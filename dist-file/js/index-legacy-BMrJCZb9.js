;
(function () {
  var _excluded = ["eventFilter"],
    _excluded2 = ["eventFilter"],
    _excluded3 = ["window"];
  function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
  function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
  function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
  function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
  function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
  function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
  function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
  function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
  function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
  function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof2(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof2(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
  function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
  function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
  function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty2(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
  function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof2(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
  function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
  function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
  function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
  function _classCallCheck2(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
  function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
  function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
  function _defineProperty2(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
  function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof2(i) ? i : i + ""; }
  function _toPrimitive(t, r) { if ("object" != _typeof2(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof2(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
  function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
  function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
  function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
  function _typeof2(o) { "@babel/helpers - typeof"; return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof2(o); }
  function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n3 = 0, F = function F() {}; return { s: F, n: function n() { return _n3 >= r.length ? { done: !0 } : { done: !1, value: r[_n3++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
  function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
  function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
  System.register([], function (exports, module) {
    'use strict';

    return {
      execute: function execute() {
        var _arrayInstrumentation, _ErrorTypeStrings$;
        var __vite_style__ = document.createElement('style');
        __vite_style__.textContent = "\n.svg-icon[data-v-3636cbfa] {\r\n  width: 24px;\r\n  height: 24px;\r\n  fill: currentColor;\n}\r\n/*end*/\n.label[data-v-055549ac] {\n  width: 120px;\n}\n.prize-list-enter-active[data-v-055549ac] {\n  animation: slide-right-055549ac 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;\n}\n.prize-list-leave-active[data-v-055549ac] {\n  animation: slide-left-055549ac 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;\n}\n.prize-operate-enter-active[data-v-055549ac] {\n  animation: show-operate-055549ac 0.6s;\n  -webkit-animation: show-operate-055549ac 0.6s;\n}\n.current-prize[data-v-055549ac] {\n  position: relative;\n  display: block;\n  overflow: hidden;\n  isolation: isolate;\n  border-radius: 20px;\n  padding: 3px;\n}\n.current-prize[data-v-055549ac]::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 400%;\n  height: 100%;\n  background: linear-gradient(115deg, #4fcf70, #fad648, #a767e5, #12bcfe, #44ce7b);\n  background-size: 25% 100%;\n  animation: an-at-keyframe-css-at-rule-that-translates-via-the-transform-property-the-background-by-negative-25-percent-of-its-width-so-that-it-gives-a-nice-border-animation_-We-use-the-translate-property-to-have-a-nice-transition-so-it_s-not-a-jerk-of-a-start-or-stop-055549ac 0.75s linear infinite;\n  translate: -5% 0%;\n  transition: translate 0.25s ease-out;\n  animation-play-state: running;\n  transition-duration: 0.75s;\n  translate: 0% 0%;\n}\n.current-prize[data-v-055549ac]::after {\n  content: \"\";\n  position: absolute;\n  inset: 4px;\n  border-top-left-radius: 20px;\n  border-bottom-right-radius: 20px;\n  z-index: -1;\n}\n@keyframes an-at-keyframe-css-at-rule-that-translates-via-the-transform-property-the-background-by-negative-25-percent-of-its-width-so-that-it-gives-a-nice-border-animation_-We-use-the-translate-property-to-have-a-nice-transition-so-it_s-not-a-jerk-of-a-start-or-stop-055549ac {\nto {\n    transform: translateX(-25%);\n}\n}\n@keyframes slide-right-055549ac {\n0% {\n    transform: translateX(-200px);\n}\n100% {\n    transform: translateX(0);\n}\n}\n@keyframes slide-left-055549ac {\n0% {\n    transform: translateX(0);\n}\n100% {\n    transform: translateX(-400px);\n}\n}\n@keyframes show-operate-055549ac {\n0% {\n    opacity: 0;\n}\n99% {\n    opacity: 0;\n}\n100% {\n    opacity: 1;\n}\n}@keyframes fadeOut{from{opacity:1}to{opacity:0}}.v-toast--fade-out{animation-name:fadeOut}@keyframes fadeInDown{from{opacity:0;transform:translate3d(0, -100%, 0)}to{opacity:1;transform:none}}.v-toast--fade-in-down{animation-name:fadeInDown}@keyframes fadeInUp{from{opacity:0;transform:translate3d(0, 100%, 0)}to{opacity:1;transform:none}}.v-toast--fade-in-up{animation-name:fadeInUp}.fade-enter-active,.fade-leave-active{transition:opacity 150ms ease-out}.fade-enter,.fade-leave-to{opacity:0}.v-toast{position:fixed;display:flex;top:0;bottom:0;left:0;right:0;padding:2em;overflow:hidden;z-index:1090;pointer-events:none}.v-toast__item{display:inline-flex;align-items:center;animation-duration:150ms;margin:.5em 0;box-shadow:0 1px 4px rgba(0,0,0,.12),0 0 6px rgba(0,0,0,.04);border-radius:.25em;pointer-events:auto;opacity:.92;color:#fff;min-height:3em;cursor:pointer}.v-toast__item--success{background-color:#47d78a}.v-toast__item--info{background-color:#1c85d5}.v-toast__item--warning{background-color:#febc22}.v-toast__item--error{background-color:#f7471c}.v-toast__item--default{background-color:#343a40}.v-toast__item--warning{color:#000}.v-toast__item.v-toast__item--top,.v-toast__item.v-toast__item--bottom{align-self:center}.v-toast__item.v-toast__item--top-right,.v-toast__item.v-toast__item--bottom-right{align-self:flex-end}.v-toast__item.v-toast__item--top-left,.v-toast__item.v-toast__item--bottom-left{align-self:flex-start}.v-toast__text{margin:0;padding:.5em 1em;word-break:break-word}.v-toast__icon{display:none}.v-toast.v-toast--top{flex-direction:column}.v-toast.v-toast--bottom{flex-direction:column-reverse}.v-toast.v-toast--custom-parent{position:absolute}@media screen and (max-width: 768px){.v-toast{padding:0;position:fixed !important}}.v-toast__item{opacity:1;min-height:4em}.v-toast__item .v-toast__text{padding:1.5em 1em}.v-toast__item .v-toast__icon{display:block;width:27px;min-width:27px;height:27px;margin-left:1em;background:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 45.999 45.999'%3e %3cpath fill='%23fff' d='M39.264 6.736c-8.982-8.981-23.545-8.982-32.528 0-8.982 8.982-8.981 23.545 0 32.528 8.982 8.98 23.545 8.981 32.528 0 8.981-8.983 8.98-23.545 0-32.528zM25.999 33a3 3 0 11-6 0V21a3 3 0 116 0v12zm-3.053-17.128c-1.728 0-2.88-1.224-2.844-2.735-.036-1.584 1.116-2.771 2.879-2.771 1.764 0 2.88 1.188 2.917 2.771-.001 1.511-1.152 2.735-2.952 2.735z'/%3e %3c/svg%3e\") no-repeat}[dir=rtl] .v-toast__item .v-toast__icon{margin-left:unset;margin-right:1em}.v-toast__item.v-toast__item--success .v-toast__icon{background:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 52 52'%3e %3cpath fill='%23fff' d='M26 0C11.664 0 0 11.663 0 26s11.664 26 26 26 26-11.663 26-26S40.336 0 26 0zm14.495 17.329l-16 18a1.997 1.997 0 01-2.745.233l-10-8a2 2 0 012.499-3.124l8.517 6.813L37.505 14.67a2.001 2.001 0 012.99 2.659z'/%3e %3c/svg%3e\") no-repeat}.v-toast__item.v-toast__item--error .v-toast__icon{background:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 51.976 51.976'%3e %3cpath fill='%23fff' d='M44.373 7.603c-10.137-10.137-26.632-10.138-36.77 0-10.138 10.138-10.137 26.632 0 36.77s26.632 10.138 36.77 0c10.137-10.138 10.137-26.633 0-36.77zm-8.132 28.638a2 2 0 01-2.828 0l-7.425-7.425-7.778 7.778a2 2 0 11-2.828-2.828l7.778-7.778-7.425-7.425a2 2 0 112.828-2.828l7.425 7.425 7.071-7.071a2 2 0 112.828 2.828l-7.071 7.071 7.425 7.425a2 2 0 010 2.828z'/%3e %3c/svg%3e\") no-repeat}.v-toast__item.v-toast__item--warning .v-toast__icon{background:url(\"data:image/svg+xml,%3csvg viewBox='0 0 52 52' xmlns='http://www.w3.org/2000/svg'%3e %3cpath fill='%23000' d='M49.466 41.26L29.216 6.85c-.69-1.16-1.89-1.85-3.22-1.85-1.32 0-2.53.69-3.21 1.85L2.536 41.26c-.71 1.2-.72 2.64-.03 3.85.68 1.18 1.89 1.89 3.24 1.89h40.51c1.35 0 2.56-.71 3.23-1.89.7-1.21.69-2.65-.02-3.85zm-25.53-21.405h3.381v3.187l-.724 8.92H24.66l-.725-8.92v-3.187zm2.97 17.344a1.712 1.712 0 01-1.267.543c-.491 0-.914-.181-1.268-.543a1.788 1.788 0 01-.531-1.297c0-.502.176-.935.53-1.297a1.712 1.712 0 011.269-.544c.49 0 .914.181 1.268.544s.53.795.53 1.297c0 .503-.176.934-.53 1.297z'/%3e %3c/svg%3e\") no-repeat}\n/*end*/\n#menu[data-v-29bbe6aa] {\n  position: absolute;\n  z-index: 100;\n  width: 100%;\n  bottom: 50px;\n  text-align: center;\n  margin: 0 auto;\n  font-size: 32px;\n}\n.header-title[data-v-29bbe6aa] {\n  animation: tracking-in-expand-fwd-29bbe6aa 0.8s cubic-bezier(0.215, 0.61, 0.355, 1) both;\n}\n.start[data-v-29bbe6aa] {\n  display: flex;\n  justify-content: center;\n}\n.btn-start[data-v-29bbe6aa] {\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 13rem;\n  overflow: hidden;\n  height: 3rem;\n  background-size: 300% 300%;\n  -webkit-backdrop-filter: blur(1rem);\n          backdrop-filter: blur(1rem);\n  border-radius: 5rem;\n  transition: 0.5s;\n  animation: gradient_301-29bbe6aa 5s ease infinite;\n  border: double 4px transparent;\n  background-image: linear-gradient(#212121, #212121), linear-gradient(137.48deg, #ffdb3b 10%, #FE53BB 45%, #8F51EA 67%, #0044ff 87%);\n  background-origin: border-box;\n  background-clip: content-box, border-box;\n  animation: pulsate-fwd-29bbe6aa 1.2s ease-in-out infinite both;\n}\n.btn-cancel[data-v-29bbe6aa] {\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 13rem;\n  overflow: hidden;\n  height: 3rem;\n  background-size: 300% 300%;\n  -webkit-backdrop-filter: blur(1rem);\n          backdrop-filter: blur(1rem);\n  border-radius: 5rem;\n  transition: 0.5s;\n  animation: gradient_301-29bbe6aa 5s ease infinite;\n  border: double 4px transparent;\n  background-image: linear-gradient(#212121, #212121), linear-gradient(137.48deg, #ffdb3b 10%, #FE53BB 45%, #8F51EA 67%, #0044ff 87%);\n  background-origin: border-box;\n  background-clip: content-box, border-box;\n}\n#container-stars[data-v-29bbe6aa] {\n  position: absolute;\n  z-index: -1;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  transition: 0.5s;\n  -webkit-backdrop-filter: blur(1rem);\n          backdrop-filter: blur(1rem);\n  border-radius: 5rem;\n}\nstrong[data-v-29bbe6aa] {\n  z-index: 2;\n  font-family: \"Avalors Personal Use\";\n  font-size: 12px;\n  letter-spacing: 5px;\n  color: #FFFFFF;\n  text-shadow: 0 0 4px white;\n}\n#glow[data-v-29bbe6aa] {\n  position: absolute;\n  display: flex;\n  width: 12rem;\n}\n.circle[data-v-29bbe6aa] {\n  width: 100%;\n  height: 30px;\n  filter: blur(2rem);\n  animation: pulse_3011-29bbe6aa 4s infinite;\n  z-index: -1;\n}\n.circle[data-v-29bbe6aa]:nth-of-type(1) {\n  background: rgba(254, 83, 186, 0.636);\n}\n.circle[data-v-29bbe6aa]:nth-of-type(2) {\n  background: rgba(142, 81, 234, 0.704);\n}\n.btn-start:hover #container-stars[data-v-29bbe6aa] {\n  z-index: 1;\n  background-color: #212121;\n}\n.btn-start[data-v-29bbe6aa]:hover {\n  transform: scale(1.1);\n}\n.btn-start[data-v-29bbe6aa]:active {\n  border: double 4px #FE53BB;\n  background-origin: border-box;\n  background-clip: content-box, border-box;\n  animation: none;\n}\n.btn-start:active .circle[data-v-29bbe6aa] {\n  background: #FE53BB;\n}\n#stars[data-v-29bbe6aa] {\n  position: relative;\n  background: transparent;\n  width: 200rem;\n  height: 200rem;\n}\n#stars[data-v-29bbe6aa]::after {\n  content: \"\";\n  position: absolute;\n  top: -10rem;\n  left: -100rem;\n  width: 100%;\n  height: 100%;\n  animation: animStarRotate-29bbe6aa 90s linear infinite;\n  background-image: radial-gradient(#ffffff 1px, transparent 1%);\n  background-size: 50px 50px;\n}\n#stars[data-v-29bbe6aa]::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: -50%;\n  width: 170%;\n  height: 500%;\n  animation: animStar-29bbe6aa 60s linear infinite;\n  background-image: radial-gradient(#ffffff 1px, transparent 1%);\n  background-size: 50px 50px;\n  opacity: 0.5;\n}\n@keyframes animStar-29bbe6aa {\nfrom {\n    transform: translateY(0);\n}\nto {\n    transform: translateY(-135rem);\n}\n}\n@keyframes animStarRotate-29bbe6aa {\nfrom {\n    transform: rotate(360deg);\n}\nto {\n    transform: rotate(0);\n}\n}\n@keyframes gradient_301-29bbe6aa {\n0% {\n    background-position: 0% 50%;\n}\n50% {\n    background-position: 100% 50%;\n}\n100% {\n    background-position: 0% 50%;\n}\n}\n@keyframes pulse_3011-29bbe6aa {\n0% {\n    transform: scale(0.75);\n    box-shadow: 0 0 0 0 rgba(0, 0, 0, 0.7);\n}\n70% {\n    transform: scale(1);\n    box-shadow: 0 0 0 10px rgba(0, 0, 0, 0);\n}\n100% {\n    transform: scale(0.75);\n    box-shadow: 0 0 0 0 rgba(0, 0, 0, 0);\n}\n}\n.btn-end[data-v-29bbe6aa] {\n  animation: pulsate-fwd-29bbe6aa 0.9s ease-in-out infinite both;\n  cursor: pointer;\n  --glow-color: rgb(217, 176, 255);\n  --glow-spread-color: rgba(191, 123, 255, 0.781);\n  --enhanced-glow-color: rgb(231, 206, 255);\n  --btn-color: rgb(100, 61, 136);\n  border: 0.25em solid var(--glow-color);\n  padding: 1em 3em;\n  color: var(--glow-color);\n  font-size: 15px;\n  font-weight: bold;\n  background-color: var(--btn-color);\n  border-radius: 1em;\n  outline: none;\n  box-shadow: 0 0 1em 0.25em var(--glow-color), 0 0 4em 1em var(--glow-spread-color), inset 0 0 0.75em 0.25em var(--glow-color);\n  text-shadow: 0 0 0.5em var(--glow-color);\n  position: relative;\n  transition: all 0.3s;\n  animation: swing-in-top-fwd 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) both;\n}\n.btn-end[data-v-29bbe6aa]::after {\n  pointer-events: none;\n  content: \"\";\n  position: absolute;\n  top: 120%;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  background-color: var(--glow-spread-color);\n  filter: blur(2em);\n  opacity: 0.7;\n  transform: perspective(1.5em) rotateX(35deg) scale(1, 0.6);\n}\n.btn-end[data-v-29bbe6aa]:hover {\n  color: var(--btn-color);\n  background-color: var(--glow-color);\n  box-shadow: 0 0 1em 0.25em var(--glow-color), 0 0 4em 2em var(--glow-spread-color), inset 0 0 0.75em 0.25em var(--glow-color);\n}\n.btn-end[data-v-29bbe6aa]:active {\n  box-shadow: 0 0 0.6em 0.25em var(--glow-color), 0 0 2.5em 2em var(--glow-spread-color), inset 0 0 0.5em 0.25em var(--glow-color);\n}\n@keyframes pulsate-fwd-29bbe6aa {\n0% {\n    transform: scale(1);\n}\n50% {\n    transform: scale(1.2);\n}\n100% {\n    transform: scale(1);\n}\n}\n@keyframes tracking-in-expand-fwd-29bbe6aa {\n0% {\n    letter-spacing: -0.5em;\n    transform: translateZ(-700px);\n    opacity: 0;\n}\n40% {\n    opacity: 0.6;\n}\n100% {\n    transform: translateZ(0);\n    opacity: 1;\n}\n}/*end*/\ndetails summary[data-v-3a365d2a] {\n  display: none;\n}*, ::before, ::after {\r\n    --tw-border-spacing-x: 0;\r\n    --tw-border-spacing-y: 0;\r\n    --tw-translate-x: 0;\r\n    --tw-translate-y: 0;\r\n    --tw-rotate: 0;\r\n    --tw-skew-x: 0;\r\n    --tw-skew-y: 0;\r\n    --tw-scale-x: 1;\r\n    --tw-scale-y: 1;\r\n    --tw-pan-x:  ;\r\n    --tw-pan-y:  ;\r\n    --tw-pinch-zoom:  ;\r\n    --tw-scroll-snap-strictness: proximity;\r\n    --tw-gradient-from-position:  ;\r\n    --tw-gradient-via-position:  ;\r\n    --tw-gradient-to-position:  ;\r\n    --tw-ordinal:  ;\r\n    --tw-slashed-zero:  ;\r\n    --tw-numeric-figure:  ;\r\n    --tw-numeric-spacing:  ;\r\n    --tw-numeric-fraction:  ;\r\n    --tw-ring-inset:  ;\r\n    --tw-ring-offset-width: 0px;\r\n    --tw-ring-offset-color: #fff;\r\n    --tw-ring-color: rgb(59 130 246 / 0.5);\r\n    --tw-ring-offset-shadow: 0 0 #0000;\r\n    --tw-ring-shadow: 0 0 #0000;\r\n    --tw-shadow: 0 0 #0000;\r\n    --tw-shadow-colored: 0 0 #0000;\r\n    --tw-blur:  ;\r\n    --tw-brightness:  ;\r\n    --tw-contrast:  ;\r\n    --tw-grayscale:  ;\r\n    --tw-hue-rotate:  ;\r\n    --tw-invert:  ;\r\n    --tw-saturate:  ;\r\n    --tw-sepia:  ;\r\n    --tw-drop-shadow:  ;\r\n    --tw-backdrop-blur:  ;\r\n    --tw-backdrop-brightness:  ;\r\n    --tw-backdrop-contrast:  ;\r\n    --tw-backdrop-grayscale:  ;\r\n    --tw-backdrop-hue-rotate:  ;\r\n    --tw-backdrop-invert:  ;\r\n    --tw-backdrop-opacity:  ;\r\n    --tw-backdrop-saturate:  ;\r\n    --tw-backdrop-sepia:  ;\r\n    --tw-contain-size:  ;\r\n    --tw-contain-layout:  ;\r\n    --tw-contain-paint:  ;\r\n    --tw-contain-style:  ;\r\n}\r\n::backdrop {\r\n    --tw-border-spacing-x: 0;\r\n    --tw-border-spacing-y: 0;\r\n    --tw-translate-x: 0;\r\n    --tw-translate-y: 0;\r\n    --tw-rotate: 0;\r\n    --tw-skew-x: 0;\r\n    --tw-skew-y: 0;\r\n    --tw-scale-x: 1;\r\n    --tw-scale-y: 1;\r\n    --tw-pan-x:  ;\r\n    --tw-pan-y:  ;\r\n    --tw-pinch-zoom:  ;\r\n    --tw-scroll-snap-strictness: proximity;\r\n    --tw-gradient-from-position:  ;\r\n    --tw-gradient-via-position:  ;\r\n    --tw-gradient-to-position:  ;\r\n    --tw-ordinal:  ;\r\n    --tw-slashed-zero:  ;\r\n    --tw-numeric-figure:  ;\r\n    --tw-numeric-spacing:  ;\r\n    --tw-numeric-fraction:  ;\r\n    --tw-ring-inset:  ;\r\n    --tw-ring-offset-width: 0px;\r\n    --tw-ring-offset-color: #fff;\r\n    --tw-ring-color: rgb(59 130 246 / 0.5);\r\n    --tw-ring-offset-shadow: 0 0 #0000;\r\n    --tw-ring-shadow: 0 0 #0000;\r\n    --tw-shadow: 0 0 #0000;\r\n    --tw-shadow-colored: 0 0 #0000;\r\n    --tw-blur:  ;\r\n    --tw-brightness:  ;\r\n    --tw-contrast:  ;\r\n    --tw-grayscale:  ;\r\n    --tw-hue-rotate:  ;\r\n    --tw-invert:  ;\r\n    --tw-saturate:  ;\r\n    --tw-sepia:  ;\r\n    --tw-drop-shadow:  ;\r\n    --tw-backdrop-blur:  ;\r\n    --tw-backdrop-brightness:  ;\r\n    --tw-backdrop-contrast:  ;\r\n    --tw-backdrop-grayscale:  ;\r\n    --tw-backdrop-hue-rotate:  ;\r\n    --tw-backdrop-invert:  ;\r\n    --tw-backdrop-opacity:  ;\r\n    --tw-backdrop-saturate:  ;\r\n    --tw-backdrop-sepia:  ;\r\n    --tw-contain-size:  ;\r\n    --tw-contain-layout:  ;\r\n    --tw-contain-paint:  ;\r\n    --tw-contain-style:  ;\r\n}\r\n:root,\n[data-theme] {\r\n    background-color: var(--fallback-b1,oklch(var(--b1)/1));\r\n    color: var(--fallback-bc,oklch(var(--bc)/1));\r\n}\r\n@supports not (color: oklch(0% 0 0)) {\r\n    :root {\r\n        color-scheme: light;\r\n        --fallback-p: #491eff;\r\n        --fallback-pc: #d4dbff;\r\n        --fallback-s: #ff41c7;\r\n        --fallback-sc: #fff9fc;\r\n        --fallback-a: #00cfbd;\r\n        --fallback-ac: #00100d;\r\n        --fallback-n: #2b3440;\r\n        --fallback-nc: #d7dde4;\r\n        --fallback-b1: #ffffff;\r\n        --fallback-b2: #e5e6e6;\r\n        --fallback-b3: #e5e6e6;\r\n        --fallback-bc: #1f2937;\r\n        --fallback-in: #00b3f0;\r\n        --fallback-inc: #000000;\r\n        --fallback-su: #00ca92;\r\n        --fallback-suc: #000000;\r\n        --fallback-wa: #ffc22d;\r\n        --fallback-wac: #000000;\r\n        --fallback-er: #ff6f70;\r\n        --fallback-erc: #000000;\r\n    }\r\n    @media (prefers-color-scheme: dark) {\r\n        :root {\r\n            color-scheme: dark;\r\n            --fallback-p: #7582ff;\r\n            --fallback-pc: #050617;\r\n            --fallback-s: #ff71cf;\r\n            --fallback-sc: #190211;\r\n            --fallback-a: #00c7b5;\r\n            --fallback-ac: #000e0c;\r\n            --fallback-n: #2a323c;\r\n            --fallback-nc: #a6adbb;\r\n            --fallback-b1: #1d232a;\r\n            --fallback-b2: #191e24;\r\n            --fallback-b3: #15191e;\r\n            --fallback-bc: #a6adbb;\r\n            --fallback-in: #00b3f0;\r\n            --fallback-inc: #000000;\r\n            --fallback-su: #00ca92;\r\n            --fallback-suc: #000000;\r\n            --fallback-wa: #ffc22d;\r\n            --fallback-wac: #000000;\r\n            --fallback-er: #ff6f70;\r\n            --fallback-erc: #000000;\r\n        }\r\n    }\r\n}\r\nhtml {\r\n    -webkit-tap-highlight-color: transparent;\r\n}\r\n* {\r\n    scrollbar-color: color-mix(in oklch, currentColor 35%, transparent) transparent;\r\n}\r\n*:hover {\r\n    scrollbar-color: color-mix(in oklch, currentColor 60%, transparent) transparent;\r\n}\r\n:root {\r\n    color-scheme: light;\r\n    --in: 72.06% 0.191 231.6;\r\n    --su: 64.8% 0.150 160;\r\n    --wa: 84.71% 0.199 83.87;\r\n    --er: 71.76% 0.221 22.18;\r\n    --pc: 89.824% 0.06192 275.75;\r\n    --ac: 15.352% 0.0368 183.61;\r\n    --inc: 0% 0 0;\r\n    --suc: 0% 0 0;\r\n    --wac: 0% 0 0;\r\n    --erc: 0% 0 0;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 49.12% 0.3096 275.75;\r\n    --s: 69.71% 0.329 342.55;\r\n    --sc: 98.71% 0.0106 342.55;\r\n    --a: 76.76% 0.184 183.61;\r\n    --n: 32.1785% 0.02476 255.701624;\r\n    --nc: 89.4994% 0.011585 252.096176;\r\n    --b1: 100% 0 0;\r\n    --b2: 96.1151% 0 0;\r\n    --b3: 92.4169% 0.00108 197.137559;\r\n    --bc: 27.8078% 0.029596 256.847952;\r\n}\r\n@media (prefers-color-scheme: dark) {\r\n    :root {\r\n        color-scheme: dark;\r\n        --in: 72.06% 0.191 231.6;\r\n        --su: 64.8% 0.150 160;\r\n        --wa: 84.71% 0.199 83.87;\r\n        --er: 71.76% 0.221 22.18;\r\n        --pc: 13.138% 0.0392 275.75;\r\n        --sc: 14.96% 0.052 342.55;\r\n        --ac: 14.902% 0.0334 183.61;\r\n        --inc: 0% 0 0;\r\n        --suc: 0% 0 0;\r\n        --wac: 0% 0 0;\r\n        --erc: 0% 0 0;\r\n        --rounded-box: 1rem;\r\n        --rounded-btn: 0.5rem;\r\n        --rounded-badge: 1.9rem;\r\n        --animation-btn: 0.25s;\r\n        --animation-input: .2s;\r\n        --btn-focus-scale: 0.95;\r\n        --border-btn: 1px;\r\n        --tab-border: 1px;\r\n        --tab-radius: 0.5rem;\r\n        --p: 65.69% 0.196 275.75;\r\n        --s: 74.8% 0.26 342.55;\r\n        --a: 74.51% 0.167 183.61;\r\n        --n: 31.3815% 0.021108 254.139175;\r\n        --nc: 74.6477% 0.0216 264.435964;\r\n        --b1: 25.3267% 0.015896 252.417568;\r\n        --b2: 23.2607% 0.013807 253.100675;\r\n        --b3: 21.1484% 0.01165 254.087939;\r\n        --bc: 74.6477% 0.0216 264.435964;\r\n    }\r\n}\r\n[data-theme=light] {\r\n    color-scheme: light;\r\n    --in: 72.06% 0.191 231.6;\r\n    --su: 64.8% 0.150 160;\r\n    --wa: 84.71% 0.199 83.87;\r\n    --er: 71.76% 0.221 22.18;\r\n    --pc: 89.824% 0.06192 275.75;\r\n    --ac: 15.352% 0.0368 183.61;\r\n    --inc: 0% 0 0;\r\n    --suc: 0% 0 0;\r\n    --wac: 0% 0 0;\r\n    --erc: 0% 0 0;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 49.12% 0.3096 275.75;\r\n    --s: 69.71% 0.329 342.55;\r\n    --sc: 98.71% 0.0106 342.55;\r\n    --a: 76.76% 0.184 183.61;\r\n    --n: 32.1785% 0.02476 255.701624;\r\n    --nc: 89.4994% 0.011585 252.096176;\r\n    --b1: 100% 0 0;\r\n    --b2: 96.1151% 0 0;\r\n    --b3: 92.4169% 0.00108 197.137559;\r\n    --bc: 27.8078% 0.029596 256.847952;\r\n}\r\n[data-theme=dark] {\r\n    color-scheme: dark;\r\n    --in: 72.06% 0.191 231.6;\r\n    --su: 64.8% 0.150 160;\r\n    --wa: 84.71% 0.199 83.87;\r\n    --er: 71.76% 0.221 22.18;\r\n    --pc: 13.138% 0.0392 275.75;\r\n    --sc: 14.96% 0.052 342.55;\r\n    --ac: 14.902% 0.0334 183.61;\r\n    --inc: 0% 0 0;\r\n    --suc: 0% 0 0;\r\n    --wac: 0% 0 0;\r\n    --erc: 0% 0 0;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 65.69% 0.196 275.75;\r\n    --s: 74.8% 0.26 342.55;\r\n    --a: 74.51% 0.167 183.61;\r\n    --n: 31.3815% 0.021108 254.139175;\r\n    --nc: 74.6477% 0.0216 264.435964;\r\n    --b1: 25.3267% 0.015896 252.417568;\r\n    --b2: 23.2607% 0.013807 253.100675;\r\n    --b3: 21.1484% 0.01165 254.087939;\r\n    --bc: 74.6477% 0.0216 264.435964;\r\n}\r\n[data-theme=cupcake] {\r\n    color-scheme: light;\r\n    --in: 72.06% 0.191 231.6;\r\n    --su: 64.8% 0.150 160;\r\n    --wa: 84.71% 0.199 83.87;\r\n    --er: 71.76% 0.221 22.18;\r\n    --pc: 15.2344% 0.017892 200.026556;\r\n    --sc: 15.787% 0.020249 356.29965;\r\n    --ac: 15.8762% 0.029206 78.618794;\r\n    --nc: 84.7148% 0.013247 313.189598;\r\n    --inc: 0% 0 0;\r\n    --suc: 0% 0 0;\r\n    --wac: 0% 0 0;\r\n    --erc: 0% 0 0;\r\n    --rounded-box: 1rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --p: 76.172% 0.089459 200.026556;\r\n    --s: 78.9351% 0.101246 356.29965;\r\n    --a: 79.3811% 0.146032 78.618794;\r\n    --n: 23.5742% 0.066235 313.189598;\r\n    --b1: 97.7882% 0.00418 56.375637;\r\n    --b2: 93.9822% 0.007638 61.449292;\r\n    --b3: 91.5861% 0.006811 53.440502;\r\n    --bc: 23.5742% 0.066235 313.189598;\r\n    --rounded-btn: 1.9rem;\r\n    --tab-border: 2px;\r\n    --tab-radius: 0.7rem;\r\n}\r\n[data-theme=bumblebee] {\r\n    color-scheme: light;\r\n    --b2: 93% 0 0;\r\n    --b3: 86% 0 0;\r\n    --in: 72.06% 0.191 231.6;\r\n    --su: 64.8% 0.150 160;\r\n    --wa: 84.71% 0.199 83.87;\r\n    --er: 71.76% 0.221 22.18;\r\n    --bc: 20% 0 0;\r\n    --ac: 16.254% 0.0314 56.52;\r\n    --nc: 82.55% 0.015 281.99;\r\n    --inc: 0% 0 0;\r\n    --suc: 0% 0 0;\r\n    --wac: 0% 0 0;\r\n    --erc: 0% 0 0;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 89.51% 0.2132 96.61;\r\n    --pc: 38.92% 0.046 96.61;\r\n    --s: 80.39% 0.194 70.76;\r\n    --sc: 39.38% 0.068 70.76;\r\n    --a: 81.27% 0.157 56.52;\r\n    --n: 12.75% 0.075 281.99;\r\n    --b1: 100% 0 0;\r\n}\r\n[data-theme=emerald] {\r\n    color-scheme: light;\r\n    --b2: 93% 0 0;\r\n    --b3: 86% 0 0;\r\n    --in: 72.06% 0.191 231.6;\r\n    --su: 64.8% 0.150 160;\r\n    --wa: 84.71% 0.199 83.87;\r\n    --er: 71.76% 0.221 22.18;\r\n    --inc: 0% 0 0;\r\n    --suc: 0% 0 0;\r\n    --wac: 0% 0 0;\r\n    --erc: 0% 0 0;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 76.6626% 0.135433 153.450024;\r\n    --pc: 33.3872% 0.040618 162.240129;\r\n    --s: 61.3028% 0.202368 261.294233;\r\n    --sc: 100% 0 0;\r\n    --a: 72.7725% 0.149783 33.200363;\r\n    --ac: 0% 0 0;\r\n    --n: 35.5192% 0.032071 262.988584;\r\n    --nc: 98.4625% 0.001706 247.838921;\r\n    --b1: 100% 0 0;\r\n    --bc: 35.5192% 0.032071 262.988584;\r\n    --animation-btn: 0;\r\n    --animation-input: 0;\r\n    --btn-focus-scale: 1;\r\n}\r\n[data-theme=corporate] {\r\n    color-scheme: light;\r\n    --b2: 93% 0 0;\r\n    --b3: 86% 0 0;\r\n    --in: 72.06% 0.191 231.6;\r\n    --su: 64.8% 0.150 160;\r\n    --wa: 84.71% 0.199 83.87;\r\n    --er: 71.76% 0.221 22.18;\r\n    --pc: 12.078% 0.0456 269.1;\r\n    --sc: 13.0739% 0.010951 256.688055;\r\n    --ac: 15.3934% 0.022799 163.57888;\r\n    --inc: 0% 0 0;\r\n    --suc: 0% 0 0;\r\n    --wac: 0% 0 0;\r\n    --erc: 0% 0 0;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --p: 60.39% 0.228 269.1;\r\n    --s: 65.3694% 0.054756 256.688055;\r\n    --a: 76.9669% 0.113994 163.57888;\r\n    --n: 22.3899% 0.031305 278.07229;\r\n    --nc: 95.8796% 0.008588 247.915135;\r\n    --b1: 100% 0 0;\r\n    --bc: 22.3899% 0.031305 278.07229;\r\n    --rounded-box: 0.25rem;\r\n    --rounded-btn: .125rem;\r\n    --rounded-badge: .125rem;\r\n    --tab-radius: 0.25rem;\r\n    --animation-btn: 0;\r\n    --animation-input: 0;\r\n    --btn-focus-scale: 1;\r\n}\r\n[data-theme=synthwave] {\r\n    color-scheme: dark;\r\n    --b2: 20.2941% 0.076211 287.835609;\r\n    --b3: 18.7665% 0.070475 287.835609;\r\n    --pc: 14.4421% 0.031903 342.009383;\r\n    --sc: 15.6543% 0.02362 227.382405;\r\n    --ac: 17.608% 0.0412 93.72;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 72.2105% 0.159514 342.009383;\r\n    --s: 78.2714% 0.118101 227.382405;\r\n    --a: 88.04% 0.206 93.72;\r\n    --n: 25.5554% 0.103537 286.507967;\r\n    --nc: 97.9365% 0.00819 301.358346;\r\n    --b1: 21.8216% 0.081948 287.835609;\r\n    --bc: 97.9365% 0.00819 301.358346;\r\n    --in: 76.5197% 0.12273 231.831603;\r\n    --inc: 23.5017% 0.096418 290.329844;\r\n    --su: 86.0572% 0.115038 178.624677;\r\n    --suc: 23.5017% 0.096418 290.329844;\r\n    --wa: 85.531% 0.122117 93.722227;\r\n    --wac: 23.5017% 0.096418 290.329844;\r\n    --er: 73.7005% 0.121339 32.639257;\r\n    --erc: 23.5017% 0.096418 290.329844;\r\n}\r\n[data-theme=retro] {\r\n    color-scheme: light;\r\n    --inc: 90.923% 0.043042 262.880917;\r\n    --suc: 12.541% 0.033982 149.213788;\r\n    --wac: 13.3168% 0.031484 58.31834;\r\n    --erc: 13.144% 0.0398 27.33;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --p: 76.8664% 0.104092 22.664655;\r\n    --pc: 26.5104% 0.006243 0.522862;\r\n    --s: 80.7415% 0.052534 159.094608;\r\n    --sc: 26.5104% 0.006243 0.522862;\r\n    --a: 70.3919% 0.125455 52.953428;\r\n    --ac: 26.5104% 0.006243 0.522862;\r\n    --n: 28.4181% 0.009519 355.534017;\r\n    --nc: 92.5604% 0.025113 89.217311;\r\n    --b1: 91.6374% 0.034554 90.51575;\r\n    --b2: 88.2722% 0.049418 91.774344;\r\n    --b3: 84.133% 0.065952 90.856665;\r\n    --bc: 26.5104% 0.006243 0.522862;\r\n    --in: 54.615% 0.215208 262.880917;\r\n    --su: 62.7052% 0.169912 149.213788;\r\n    --wa: 66.584% 0.157422 58.31834;\r\n    --er: 65.72% 0.199 27.33;\r\n    --rounded-box: 0.4rem;\r\n    --rounded-btn: 0.4rem;\r\n    --rounded-badge: 0.4rem;\r\n    --tab-radius: 0.4rem;\r\n}\r\n[data-theme=cyberpunk] {\r\n    color-scheme: light;\r\n    --b2: 87.8943% 0.16647 104.32;\r\n    --b3: 81.2786% 0.15394 104.32;\r\n    --in: 72.06% 0.191 231.6;\r\n    --su: 64.8% 0.150 160;\r\n    --wa: 84.71% 0.199 83.87;\r\n    --er: 71.76% 0.221 22.18;\r\n    --bc: 18.902% 0.0358 104.32;\r\n    --pc: 14.844% 0.0418 6.35;\r\n    --sc: 16.666% 0.0368 204.72;\r\n    --ac: 14.372% 0.04352 310.43;\r\n    --inc: 0% 0 0;\r\n    --suc: 0% 0 0;\r\n    --wac: 0% 0 0;\r\n    --erc: 0% 0 0;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;\r\n    --p: 74.22% 0.209 6.35;\r\n    --s: 83.33% 0.184 204.72;\r\n    --a: 71.86% 0.2176 310.43;\r\n    --n: 23.04% 0.065 269.31;\r\n    --nc: 94.51% 0.179 104.32;\r\n    --b1: 94.51% 0.179 104.32;\r\n    --rounded-box: 0;\r\n    --rounded-btn: 0;\r\n    --rounded-badge: 0;\r\n    --tab-radius: 0;\r\n}\r\n[data-theme=valentine] {\r\n    color-scheme: light;\r\n    --b2: 88.0567% 0.024834 337.06289;\r\n    --b3: 81.4288% 0.022964 337.06289;\r\n    --pc: 13.7239% 0.030755 15.066527;\r\n    --sc: 14.3942% 0.029258 293.189609;\r\n    --ac: 14.2537% 0.014961 197.828857;\r\n    --inc: 90.923% 0.043042 262.880917;\r\n    --suc: 12.541% 0.033982 149.213788;\r\n    --wac: 13.3168% 0.031484 58.31834;\r\n    --erc: 14.614% 0.0414 27.33;\r\n    --rounded-box: 1rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --p: 68.6197% 0.153774 15.066527;\r\n    --s: 71.971% 0.14629 293.189609;\r\n    --a: 71.2685% 0.074804 197.828857;\r\n    --n: 54.6053% 0.143342 358.004839;\r\n    --nc: 90.2701% 0.037202 336.955191;\r\n    --b1: 94.6846% 0.026703 337.06289;\r\n    --bc: 37.3085% 0.081131 4.606426;\r\n    --in: 54.615% 0.215208 262.880917;\r\n    --su: 62.7052% 0.169912 149.213788;\r\n    --wa: 66.584% 0.157422 58.31834;\r\n    --er: 73.07% 0.207 27.33;\r\n    --rounded-btn: 1.9rem;\r\n    --tab-radius: 0.7rem;\r\n}\r\n[data-theme=halloween] {\r\n    color-scheme: dark;\r\n    --b2: 23.0416% 0 0;\r\n    --b3: 21.3072% 0 0;\r\n    --bc: 84.9552% 0 0;\r\n    --sc: 89.196% 0.0496 305.03;\r\n    --nc: 84.8742% 0.009322 65.681484;\r\n    --inc: 90.923% 0.043042 262.880917;\r\n    --suc: 12.541% 0.033982 149.213788;\r\n    --wac: 13.3168% 0.031484 58.31834;\r\n    --erc: 13.144% 0.0398 27.33;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 77.48% 0.204 60.62;\r\n    --pc: 19.6935% 0.004671 196.779412;\r\n    --s: 45.98% 0.248 305.03;\r\n    --a: 64.8% 0.223 136.073479;\r\n    --ac: 0% 0 0;\r\n    --n: 24.371% 0.046608 65.681484;\r\n    --b1: 24.7759% 0 0;\r\n    --in: 54.615% 0.215208 262.880917;\r\n    --su: 62.7052% 0.169912 149.213788;\r\n    --wa: 66.584% 0.157422 58.31834;\r\n    --er: 65.72% 0.199 27.33;\r\n}\r\n[data-theme=garden] {\r\n    color-scheme: light;\r\n    --b2: 86.4453% 0.002011 17.197414;\r\n    --b3: 79.9386% 0.00186 17.197414;\r\n    --in: 72.06% 0.191 231.6;\r\n    --su: 64.8% 0.150 160;\r\n    --wa: 84.71% 0.199 83.87;\r\n    --er: 71.76% 0.221 22.18;\r\n    --sc: 89.699% 0.022197 355.095988;\r\n    --ac: 11.2547% 0.010859 154.390187;\r\n    --inc: 0% 0 0;\r\n    --suc: 0% 0 0;\r\n    --wac: 0% 0 0;\r\n    --erc: 0% 0 0;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 62.45% 0.278 3.83636;\r\n    --pc: 100% 0 0;\r\n    --s: 48.4952% 0.110985 355.095988;\r\n    --a: 56.2735% 0.054297 154.390187;\r\n    --n: 24.1559% 0.049362 89.070594;\r\n    --nc: 92.9519% 0.002163 17.197414;\r\n    --b1: 92.9519% 0.002163 17.197414;\r\n    --bc: 16.9617% 0.001664 17.32068;\r\n}\r\n[data-theme=forest] {\r\n    color-scheme: dark;\r\n    --b2: 17.522% 0.007709 17.911578;\r\n    --b3: 16.2032% 0.007129 17.911578;\r\n    --in: 72.06% 0.191 231.6;\r\n    --su: 64.8% 0.150 160;\r\n    --wa: 84.71% 0.199 83.87;\r\n    --er: 71.76% 0.221 22.18;\r\n    --bc: 83.7682% 0.001658 17.911578;\r\n    --sc: 13.9553% 0.027077 168.327128;\r\n    --ac: 14.1257% 0.02389 185.713193;\r\n    --nc: 86.1397% 0.007806 171.364646;\r\n    --inc: 0% 0 0;\r\n    --suc: 0% 0 0;\r\n    --wac: 0% 0 0;\r\n    --erc: 0% 0 0;\r\n    --rounded-box: 1rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 68.6283% 0.185567 148.958922;\r\n    --pc: 0% 0 0;\r\n    --s: 69.7764% 0.135385 168.327128;\r\n    --a: 70.6285% 0.119451 185.713193;\r\n    --n: 30.6985% 0.039032 171.364646;\r\n    --b1: 18.8409% 0.00829 17.911578;\r\n    --rounded-btn: 1.9rem;\r\n}\r\n[data-theme=aqua] {\r\n    color-scheme: dark;\r\n    --b2: 45.3464% 0.118611 261.181672;\r\n    --b3: 41.9333% 0.109683 261.181672;\r\n    --bc: 89.7519% 0.025508 261.181672;\r\n    --sc: 12.1365% 0.02175 309.782946;\r\n    --ac: 18.6854% 0.020445 94.555431;\r\n    --nc: 12.2124% 0.023402 243.760661;\r\n    --inc: 90.923% 0.043042 262.880917;\r\n    --suc: 12.541% 0.033982 149.213788;\r\n    --wac: 13.3168% 0.031484 58.31834;\r\n    --erc: 14.79% 0.038 27.33;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 85.6617% 0.14498 198.6458;\r\n    --pc: 40.1249% 0.068266 197.603872;\r\n    --s: 60.6827% 0.108752 309.782946;\r\n    --a: 93.4269% 0.102225 94.555431;\r\n    --n: 61.0622% 0.117009 243.760661;\r\n    --b1: 48.7596% 0.127539 261.181672;\r\n    --in: 54.615% 0.215208 262.880917;\r\n    --su: 62.7052% 0.169912 149.213788;\r\n    --wa: 66.584% 0.157422 58.31834;\r\n    --er: 73.95% 0.19 27.33;\r\n}\r\n[data-theme=lofi] {\r\n    color-scheme: light;\r\n    --inc: 15.908% 0.0206 205.9;\r\n    --suc: 18.026% 0.0306 164.14;\r\n    --wac: 17.674% 0.027 79.94;\r\n    --erc: 15.732% 0.03 28.47;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --p: 15.9066% 0 0;\r\n    --pc: 100% 0 0;\r\n    --s: 21.455% 0.001566 17.278957;\r\n    --sc: 100% 0 0;\r\n    --a: 26.8618% 0 0;\r\n    --ac: 100% 0 0;\r\n    --n: 0% 0 0;\r\n    --nc: 100% 0 0;\r\n    --b1: 100% 0 0;\r\n    --b2: 96.1151% 0 0;\r\n    --b3: 92.268% 0.001082 17.17934;\r\n    --bc: 0% 0 0;\r\n    --in: 79.54% 0.103 205.9;\r\n    --su: 90.13% 0.153 164.14;\r\n    --wa: 88.37% 0.135 79.94;\r\n    --er: 78.66% 0.15 28.47;\r\n    --rounded-box: 0.25rem;\r\n    --rounded-btn: 0.125rem;\r\n    --rounded-badge: 0.125rem;\r\n    --tab-radius: 0.125rem;\r\n    --animation-btn: 0;\r\n    --animation-input: 0;\r\n    --btn-focus-scale: 1;\r\n}\r\n[data-theme=pastel] {\r\n    color-scheme: light;\r\n    --in: 72.06% 0.191 231.6;\r\n    --su: 64.8% 0.150 160;\r\n    --wa: 84.71% 0.199 83.87;\r\n    --er: 71.76% 0.221 22.18;\r\n    --bc: 20% 0 0;\r\n    --pc: 16.6166% 0.006979 316.8737;\r\n    --sc: 17.6153% 0.009839 8.688364;\r\n    --ac: 17.8419% 0.012056 170.923263;\r\n    --nc: 14.2681% 0.014702 228.183906;\r\n    --inc: 0% 0 0;\r\n    --suc: 0% 0 0;\r\n    --wac: 0% 0 0;\r\n    --erc: 0% 0 0;\r\n    --rounded-box: 1rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --p: 83.0828% 0.034896 316.8737;\r\n    --s: 88.0763% 0.049197 8.688364;\r\n    --a: 89.2096% 0.06028 170.923263;\r\n    --n: 71.3406% 0.07351 228.183906;\r\n    --b1: 100% 0 0;\r\n    --b2: 98.4625% 0.001706 247.838921;\r\n    --b3: 87.1681% 0.009339 258.338227;\r\n    --rounded-btn: 1.9rem;\r\n    --tab-radius: 0.7rem;\r\n}\r\n[data-theme=fantasy] {\r\n    color-scheme: light;\r\n    --b2: 93% 0 0;\r\n    --b3: 86% 0 0;\r\n    --in: 72.06% 0.191 231.6;\r\n    --su: 64.8% 0.150 160;\r\n    --wa: 84.71% 0.199 83.87;\r\n    --er: 71.76% 0.221 22.18;\r\n    --pc: 87.49% 0.0378 325.02;\r\n    --sc: 90.784% 0.0324 241.36;\r\n    --ac: 15.196% 0.0408 56.72;\r\n    --nc: 85.5616% 0.005919 256.847952;\r\n    --inc: 0% 0 0;\r\n    --suc: 0% 0 0;\r\n    --wac: 0% 0 0;\r\n    --erc: 0% 0 0;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 37.45% 0.189 325.02;\r\n    --s: 53.92% 0.162 241.36;\r\n    --a: 75.98% 0.204 56.72;\r\n    --n: 27.8078% 0.029596 256.847952;\r\n    --b1: 100% 0 0;\r\n    --bc: 27.8078% 0.029596 256.847952;\r\n}\r\n[data-theme=wireframe] {\r\n    color-scheme: light;\r\n    --bc: 20% 0 0;\r\n    --pc: 15.6521% 0 0;\r\n    --sc: 15.6521% 0 0;\r\n    --ac: 15.6521% 0 0;\r\n    --nc: 18.8014% 0 0;\r\n    --inc: 89.0403% 0.062643 264.052021;\r\n    --suc: 90.395% 0.035372 142.495339;\r\n    --wac: 14.1626% 0.019994 108.702381;\r\n    --erc: 12.5591% 0.051537 29.233885;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    font-family: Chalkboard,comic sans ms,'sans-serif';\r\n    --p: 78.2604% 0 0;\r\n    --s: 78.2604% 0 0;\r\n    --a: 78.2604% 0 0;\r\n    --n: 94.007% 0 0;\r\n    --b1: 100% 0 0;\r\n    --b2: 94.9119% 0 0;\r\n    --b3: 89.7547% 0 0;\r\n    --in: 45.2014% 0.313214 264.052021;\r\n    --su: 51.9752% 0.176858 142.495339;\r\n    --wa: 70.8131% 0.099969 108.702381;\r\n    --er: 62.7955% 0.257683 29.233885;\r\n    --rounded-box: 0.2rem;\r\n    --rounded-btn: 0.2rem;\r\n    --rounded-badge: 0.2rem;\r\n    --tab-radius: 0.2rem;\r\n}\r\n[data-theme=black] {\r\n    color-scheme: dark;\r\n    --pc: 86.736% 0 0;\r\n    --sc: 86.736% 0 0;\r\n    --ac: 86.736% 0 0;\r\n    --nc: 86.736% 0 0;\r\n    --inc: 89.0403% 0.062643 264.052021;\r\n    --suc: 90.395% 0.035372 142.495339;\r\n    --wac: 19.3597% 0.042201 109.769232;\r\n    --erc: 12.5591% 0.051537 29.233885;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --p: 33.6799% 0 0;\r\n    --s: 33.6799% 0 0;\r\n    --a: 33.6799% 0 0;\r\n    --b1: 0% 0 0;\r\n    --b2: 19.1251% 0 0;\r\n    --b3: 26.8618% 0 0;\r\n    --bc: 87.6096% 0 0;\r\n    --n: 33.6799% 0 0;\r\n    --in: 45.2014% 0.313214 264.052021;\r\n    --su: 51.9752% 0.176858 142.495339;\r\n    --wa: 96.7983% 0.211006 109.769232;\r\n    --er: 62.7955% 0.257683 29.233885;\r\n    --rounded-box: 0;\r\n    --rounded-btn: 0;\r\n    --rounded-badge: 0;\r\n    --animation-btn: 0;\r\n    --animation-input: 0;\r\n    --btn-focus-scale: 1;\r\n    --tab-radius: 0;\r\n}\r\n[data-theme=luxury] {\r\n    color-scheme: dark;\r\n    --pc: 20% 0 0;\r\n    --sc: 85.5163% 0.012821 261.069149;\r\n    --ac: 87.3349% 0.010348 338.82597;\r\n    --inc: 15.8122% 0.024356 237.133883;\r\n    --suc: 15.6239% 0.038579 132.154381;\r\n    --wac: 17.2255% 0.027305 102.89115;\r\n    --erc: 14.3506% 0.035271 22.568916;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 100% 0 0;\r\n    --s: 27.5815% 0.064106 261.069149;\r\n    --a: 36.6744% 0.051741 338.82597;\r\n    --n: 24.27% 0.057015 59.825019;\r\n    --nc: 93.2033% 0.089631 90.861683;\r\n    --b1: 14.0765% 0.004386 285.822869;\r\n    --b2: 20.2191% 0.004211 308.22937;\r\n    --b3: 29.8961% 0.003818 308.318612;\r\n    --bc: 75.6879% 0.123666 76.890484;\r\n    --in: 79.0612% 0.121778 237.133883;\r\n    --su: 78.1197% 0.192894 132.154381;\r\n    --wa: 86.1274% 0.136524 102.89115;\r\n    --er: 71.7531% 0.176357 22.568916;\r\n}\r\n[data-theme=dracula] {\r\n    color-scheme: dark;\r\n    --b2: 26.8053% 0.020556 277.508664;\r\n    --b3: 24.7877% 0.019009 277.508664;\r\n    --pc: 15.0922% 0.036614 346.812432;\r\n    --sc: 14.8405% 0.029709 301.883095;\r\n    --ac: 16.6785% 0.024826 66.558491;\r\n    --nc: 87.8891% 0.006515 275.524078;\r\n    --inc: 17.6526% 0.018676 212.846491;\r\n    --suc: 17.4199% 0.043903 148.024881;\r\n    --wac: 19.1068% 0.026849 112.757109;\r\n    --erc: 13.6441% 0.041266 24.430965;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 75.4611% 0.18307 346.812432;\r\n    --s: 74.2023% 0.148546 301.883095;\r\n    --a: 83.3927% 0.124132 66.558491;\r\n    --n: 39.4456% 0.032576 275.524078;\r\n    --b1: 28.8229% 0.022103 277.508664;\r\n    --bc: 97.7477% 0.007913 106.545019;\r\n    --in: 88.263% 0.09338 212.846491;\r\n    --su: 87.0995% 0.219516 148.024881;\r\n    --wa: 95.5338% 0.134246 112.757109;\r\n    --er: 68.2204% 0.206328 24.430965;\r\n}\r\n[data-theme=cmyk] {\r\n    color-scheme: light;\r\n    --b2: 93% 0 0;\r\n    --b3: 86% 0 0;\r\n    --bc: 20% 0 0;\r\n    --pc: 14.3544% 0.02666 239.443325;\r\n    --sc: 12.8953% 0.040552 359.339283;\r\n    --ac: 18.8458% 0.037948 105.306968;\r\n    --nc: 84.3557% 0 0;\r\n    --inc: 13.6952% 0.0189 217.284104;\r\n    --suc: 89.3898% 0.032505 321.406278;\r\n    --wac: 14.2473% 0.031969 52.023412;\r\n    --erc: 12.4027% 0.041677 28.717543;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 71.7722% 0.133298 239.443325;\r\n    --s: 64.4766% 0.202758 359.339283;\r\n    --a: 94.2289% 0.189741 105.306968;\r\n    --n: 21.7787% 0 0;\r\n    --b1: 100% 0 0;\r\n    --in: 68.4759% 0.094499 217.284104;\r\n    --su: 46.949% 0.162524 321.406278;\r\n    --wa: 71.2364% 0.159843 52.023412;\r\n    --er: 62.0133% 0.208385 28.717543;\r\n}\r\n[data-theme=autumn] {\r\n    color-scheme: light;\r\n    --b2: 89.1077% 0 0;\r\n    --b3: 82.4006% 0 0;\r\n    --bc: 19.1629% 0 0;\r\n    --pc: 88.1446% 0.032232 17.530175;\r\n    --sc: 12.3353% 0.033821 23.865865;\r\n    --ac: 14.6851% 0.018999 60.729616;\r\n    --nc: 90.8734% 0.007475 51.902819;\r\n    --inc: 13.8449% 0.019596 207.284192;\r\n    --suc: 12.199% 0.016032 174.616213;\r\n    --wac: 14.0163% 0.032982 56.844303;\r\n    --erc: 90.614% 0.0482 24.16;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 40.7232% 0.16116 17.530175;\r\n    --s: 61.6763% 0.169105 23.865865;\r\n    --a: 73.4253% 0.094994 60.729616;\r\n    --n: 54.3672% 0.037374 51.902819;\r\n    --b1: 95.8147% 0 0;\r\n    --in: 69.2245% 0.097979 207.284192;\r\n    --su: 60.9951% 0.080159 174.616213;\r\n    --wa: 70.0817% 0.164909 56.844303;\r\n    --er: 53.07% 0.241 24.16;\r\n}\r\n[data-theme=business] {\r\n    color-scheme: dark;\r\n    --b2: 22.6487% 0 0;\r\n    --b3: 20.944% 0 0;\r\n    --bc: 84.8707% 0 0;\r\n    --pc: 88.3407% 0.019811 251.473931;\r\n    --sc: 12.8185% 0.005481 229.389418;\r\n    --ac: 13.4542% 0.033545 35.791525;\r\n    --nc: 85.4882% 0.00265 253.041249;\r\n    --inc: 12.5233% 0.028702 240.033697;\r\n    --suc: 14.0454% 0.018919 156.59611;\r\n    --wac: 15.4965% 0.023141 81.519177;\r\n    --erc: 90.3221% 0.029356 29.674507;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 41.7036% 0.099057 251.473931;\r\n    --s: 64.0924% 0.027405 229.389418;\r\n    --a: 67.271% 0.167726 35.791525;\r\n    --n: 27.441% 0.01325 253.041249;\r\n    --b1: 24.3535% 0 0;\r\n    --in: 62.6163% 0.143511 240.033697;\r\n    --su: 70.2268% 0.094594 156.59611;\r\n    --wa: 77.4824% 0.115704 81.519177;\r\n    --er: 51.6105% 0.14678 29.674507;\r\n    --rounded-box: 0.25rem;\r\n    --rounded-btn: .125rem;\r\n    --rounded-badge: .125rem;\r\n}\r\n[data-theme=acid] {\r\n    color-scheme: light;\r\n    --b2: 91.6146% 0 0;\r\n    --b3: 84.7189% 0 0;\r\n    --bc: 19.7021% 0 0;\r\n    --pc: 14.38% 0.0714 330.759573;\r\n    --sc: 14.674% 0.0448 48.250878;\r\n    --ac: 18.556% 0.0528 122.962951;\r\n    --nc: 84.262% 0.0256 278.68;\r\n    --inc: 12.144% 0.0454 252.05;\r\n    --suc: 17.144% 0.0532 158.53;\r\n    --wac: 18.202% 0.0424 100.5;\r\n    --erc: 12.968% 0.0586 29.349188;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --p: 71.9% 0.357 330.759573;\r\n    --s: 73.37% 0.224 48.250878;\r\n    --a: 92.78% 0.264 122.962951;\r\n    --n: 21.31% 0.128 278.68;\r\n    --b1: 98.5104% 0 0;\r\n    --in: 60.72% 0.227 252.05;\r\n    --su: 85.72% 0.266 158.53;\r\n    --wa: 91.01% 0.212 100.5;\r\n    --er: 64.84% 0.293 29.349188;\r\n    --rounded-box: 1.25rem;\r\n    --rounded-btn: 1rem;\r\n    --rounded-badge: 1rem;\r\n    --tab-radius: 0.7rem;\r\n}\r\n[data-theme=lemonade] {\r\n    color-scheme: light;\r\n    --b2: 91.8003% 0.0186 123.72;\r\n    --b3: 84.8906% 0.0172 123.72;\r\n    --bc: 19.742% 0.004 123.72;\r\n    --pc: 11.784% 0.0398 134.6;\r\n    --sc: 15.55% 0.0392 111.09;\r\n    --ac: 17.078% 0.0402 100.73;\r\n    --nc: 86.196% 0.015 108.6;\r\n    --inc: 17.238% 0.0094 224.14;\r\n    --suc: 17.238% 0.0094 157.85;\r\n    --wac: 17.238% 0.0094 102.15;\r\n    --erc: 17.238% 0.0094 25.85;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 58.92% 0.199 134.6;\r\n    --s: 77.75% 0.196 111.09;\r\n    --a: 85.39% 0.201 100.73;\r\n    --n: 30.98% 0.075 108.6;\r\n    --b1: 98.71% 0.02 123.72;\r\n    --in: 86.19% 0.047 224.14;\r\n    --su: 86.19% 0.047 157.85;\r\n    --wa: 86.19% 0.047 102.15;\r\n    --er: 86.19% 0.047 25.85;\r\n}\r\n[data-theme=night] {\r\n    color-scheme: dark;\r\n    --b2: 19.3144% 0.037037 265.754874;\r\n    --b3: 17.8606% 0.034249 265.754874;\r\n    --bc: 84.1536% 0.007965 265.754874;\r\n    --pc: 15.0703% 0.027798 232.66148;\r\n    --sc: 13.6023% 0.031661 276.934902;\r\n    --ac: 14.4721% 0.035244 350.048739;\r\n    --nc: 85.5899% 0.00737 260.030984;\r\n    --suc: 15.6904% 0.026506 181.911977;\r\n    --wac: 16.6486% 0.027912 82.95003;\r\n    --erc: 14.3572% 0.034051 13.11834;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 75.3513% 0.138989 232.66148;\r\n    --s: 68.0113% 0.158303 276.934902;\r\n    --a: 72.3603% 0.176218 350.048739;\r\n    --n: 27.9495% 0.036848 260.030984;\r\n    --b1: 20.7682% 0.039824 265.754874;\r\n    --in: 68.4553% 0.148062 237.25135;\r\n    --inc: 0% 0 0;\r\n    --su: 78.452% 0.132529 181.911977;\r\n    --wa: 83.2428% 0.139558 82.95003;\r\n    --er: 71.7858% 0.170255 13.11834;\r\n}\r\n[data-theme=coffee] {\r\n    color-scheme: dark;\r\n    --b2: 20.1585% 0.021457 329.708637;\r\n    --b3: 18.6412% 0.019842 329.708637;\r\n    --pc: 14.3993% 0.024765 62.756393;\r\n    --sc: 86.893% 0.00597 199.19444;\r\n    --ac: 88.5243% 0.014881 224.389184;\r\n    --nc: 83.3022% 0.003149 326.261446;\r\n    --inc: 15.898% 0.012774 184.558367;\r\n    --suc: 14.9445% 0.014491 131.116276;\r\n    --wac: 17.6301% 0.028162 87.722413;\r\n    --erc: 15.4637% 0.025644 31.871922;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 71.9967% 0.123825 62.756393;\r\n    --s: 34.465% 0.029849 199.19444;\r\n    --a: 42.6213% 0.074405 224.389184;\r\n    --n: 16.5109% 0.015743 326.261446;\r\n    --b1: 21.6758% 0.023072 329.708637;\r\n    --bc: 72.3547% 0.092794 79.129387;\r\n    --in: 79.4902% 0.063869 184.558367;\r\n    --su: 74.7224% 0.072456 131.116276;\r\n    --wa: 88.1503% 0.140812 87.722413;\r\n    --er: 77.3187% 0.12822 31.871922;\r\n}\r\n[data-theme=winter] {\r\n    color-scheme: light;\r\n    --pc: 91.372% 0.051 257.57;\r\n    --sc: 88.5103% 0.03222 282.339433;\r\n    --ac: 11.988% 0.038303 335.171434;\r\n    --nc: 83.9233% 0.012704 257.651965;\r\n    --inc: 17.6255% 0.017178 214.515264;\r\n    --suc: 16.0988% 0.015404 197.823719;\r\n    --wac: 17.8345% 0.009167 71.47031;\r\n    --erc: 14.6185% 0.022037 20.076293;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 56.86% 0.255 257.57;\r\n    --s: 42.5516% 0.161098 282.339433;\r\n    --a: 59.9398% 0.191515 335.171434;\r\n    --n: 19.6166% 0.063518 257.651965;\r\n    --b1: 100% 0 0;\r\n    --b2: 97.4663% 0.011947 259.822565;\r\n    --b3: 93.2686% 0.016223 262.751375;\r\n    --bc: 41.8869% 0.053885 255.824911;\r\n    --in: 88.1275% 0.085888 214.515264;\r\n    --su: 80.4941% 0.077019 197.823719;\r\n    --wa: 89.1725% 0.045833 71.47031;\r\n    --er: 73.0926% 0.110185 20.076293;\r\n}\r\n[data-theme=dim] {\r\n    color-scheme: dark;\r\n    --pc: 17.2267% 0.028331 139.549991;\r\n    --sc: 14.6752% 0.033181 35.353059;\r\n    --ac: 14.8459% 0.026728 311.37924;\r\n    --inc: 17.2157% 0.028409 206.182959;\r\n    --suc: 17.2343% 0.028437 166.534048;\r\n    --wac: 17.2327% 0.028447 94.818679;\r\n    --erc: 16.4838% 0.019914 33.756357;\r\n    --rounded-box: 1rem;\r\n    --rounded-btn: 0.5rem;\r\n    --rounded-badge: 1.9rem;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --tab-radius: 0.5rem;\r\n    --p: 86.1335% 0.141656 139.549991;\r\n    --s: 73.3759% 0.165904 35.353059;\r\n    --a: 74.2296% 0.133641 311.37924;\r\n    --n: 24.7311% 0.020483 264.094728;\r\n    --nc: 82.9011% 0.031335 222.959324;\r\n    --b1: 30.8577% 0.023243 264.149498;\r\n    --b2: 28.0368% 0.01983 264.182074;\r\n    --b3: 26.3469% 0.018403 262.177739;\r\n    --bc: 82.9011% 0.031335 222.959324;\r\n    --in: 86.0785% 0.142046 206.182959;\r\n    --su: 86.1717% 0.142187 166.534048;\r\n    --wa: 86.1634% 0.142236 94.818679;\r\n    --er: 82.4189% 0.09957 33.756357;\r\n}\r\n[data-theme=nord] {\r\n    color-scheme: light;\r\n    --pc: 11.8872% 0.015449 254.027774;\r\n    --sc: 13.9303% 0.011822 248.687186;\r\n    --ac: 15.4929% 0.01245 217.469017;\r\n    --inc: 13.8414% 0.012499 332.664922;\r\n    --suc: 15.3654% 0.01498 131.063061;\r\n    --wac: 17.0972% 0.017847 84.093335;\r\n    --erc: 12.122% 0.024119 15.341883;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --p: 59.4359% 0.077246 254.027774;\r\n    --s: 69.6516% 0.059108 248.687186;\r\n    --a: 77.4643% 0.062249 217.469017;\r\n    --n: 45.229% 0.035214 264.1312;\r\n    --nc: 89.9258% 0.016374 262.749256;\r\n    --b1: 95.1276% 0.007445 260.731539;\r\n    --b2: 93.2996% 0.010389 261.788485;\r\n    --b3: 89.9258% 0.016374 262.749256;\r\n    --bc: 32.4374% 0.022945 264.182036;\r\n    --in: 69.2072% 0.062496 332.664922;\r\n    --su: 76.827% 0.074899 131.063061;\r\n    --wa: 85.4862% 0.089234 84.093335;\r\n    --er: 60.61% 0.120594 15.341883;\r\n    --rounded-box: 0.4rem;\r\n    --rounded-btn: 0.2rem;\r\n    --rounded-badge: 0.4rem;\r\n    --tab-radius: 0.2rem;\r\n}\r\n[data-theme=sunset] {\r\n    color-scheme: dark;\r\n    --pc: 14.9408% 0.031656 39.94703;\r\n    --sc: 14.5075% 0.035531 2.72034;\r\n    --ac: 14.2589% 0.033336 299.844533;\r\n    --inc: 17.1119% 0.017054 206.015183;\r\n    --suc: 17.1122% 0.017172 144.77874;\r\n    --wac: 17.1139% 0.016961 74.427797;\r\n    --erc: 17.1023% 0.015778 16.886379;\r\n    --animation-btn: 0.25s;\r\n    --animation-input: .2s;\r\n    --btn-focus-scale: 0.95;\r\n    --border-btn: 1px;\r\n    --tab-border: 1px;\r\n    --p: 74.7039% 0.158278 39.94703;\r\n    --s: 72.5375% 0.177654 2.72034;\r\n    --a: 71.2947% 0.166678 299.844533;\r\n    --n: 26% 0.019 237.69;\r\n    --nc: 70% 0.019 237.69;\r\n    --b1: 22% 0.019 237.69;\r\n    --b2: 20% 0.019 237.69;\r\n    --b3: 18% 0.019 237.69;\r\n    --bc: 77.3835% 0.043586 245.096534;\r\n    --in: 85.5596% 0.085271 206.015183;\r\n    --su: 85.5609% 0.08586 144.77874;\r\n    --wa: 85.5695% 0.084806 74.427797;\r\n    --er: 85.5116% 0.07889 16.886379;\r\n    --rounded-box: 1.2rem;\r\n    --rounded-btn: 0.8rem;\r\n    --rounded-badge: 0.4rem;\r\n    --tab-radius: 0.7rem;\r\n}\r\n.container {\r\n    width: 100%;\r\n}\r\n@media (min-width: 640px) {\r\n    .container {\r\n        max-width: 640px;\r\n    }\r\n}\r\n@media (min-width: 768px) {\r\n    .container {\r\n        max-width: 768px;\r\n    }\r\n}\r\n@media (min-width: 1024px) {\r\n    .container {\r\n        max-width: 1024px;\r\n    }\r\n}\r\n@media (min-width: 1280px) {\r\n    .container {\r\n        max-width: 1280px;\r\n    }\r\n}\r\n@media (min-width: 1536px) {\r\n    .container {\r\n        max-width: 1536px;\r\n    }\r\n}\r\n.alert {\r\n    display: grid;\r\n    width: 100%;\r\n    grid-auto-flow: row;\r\n    align-content: flex-start;\r\n    align-items: center;\r\n    justify-items: center;\r\n    gap: 1rem;\r\n    text-align: center;\r\n    border-radius: var(--rounded-box, 1rem);\r\n    border-width: 1px;\r\n    --tw-border-opacity: 1;\r\n    border-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-border-opacity)));\r\n    padding: 1rem;\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\r\n    --alert-bg: var(--fallback-b2,oklch(var(--b2)/1));\r\n    --alert-bg-mix: var(--fallback-b1,oklch(var(--b1)/1));\r\n    background-color: var(--alert-bg);\r\n}\r\n@media (min-width: 640px) {\r\n    .alert {\r\n        grid-auto-flow: column;\r\n        grid-template-columns: auto minmax(auto,1fr);\r\n        justify-items: start;\r\n        text-align: start;\r\n    }\r\n}\r\n.avatar {\r\n    position: relative;\r\n    display: inline-flex;\r\n}\r\n.avatar > div {\r\n    display: block;\r\n    aspect-ratio: 1 / 1;\r\n    overflow: hidden;\r\n}\r\n.avatar img {\r\n    height: 100%;\r\n    width: 100%;\r\n    -o-object-fit: cover;\r\n       object-fit: cover;\r\n}\r\n.avatar.placeholder > div {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n}\r\n@media (hover:hover) {\r\n    .checkbox-secondary:hover {\r\n        --tw-border-opacity: 1;\r\n        border-color: var(--fallback-s,oklch(var(--s)/var(--tw-border-opacity)));\r\n    }\r\n    .label a:hover {\r\n        --tw-text-opacity: 1;\r\n        color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\r\n    }\r\n    .menu li > *:not(ul, .menu-title, details, .btn):active,\n.menu li > *:not(ul, .menu-title, details, .btn).active,\n.menu li > details > summary:active {\r\n        --tw-bg-opacity: 1;\r\n        background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\r\n        --tw-text-opacity: 1;\r\n        color: var(--fallback-nc,oklch(var(--nc)/var(--tw-text-opacity)));\r\n    }\r\n    .table tr.hover:hover,\n  .table tr.hover:nth-child(even):hover {\r\n        --tw-bg-opacity: 1;\r\n        background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity)));\r\n    }\r\n    .table-zebra tr.hover:hover,\n  .table-zebra tr.hover:nth-child(even):hover {\r\n        --tw-bg-opacity: 1;\r\n        background-color: var(--fallback-b3,oklch(var(--b3)/var(--tw-bg-opacity)));\r\n    }\r\n}\r\n.btn {\r\n    display: inline-flex;\r\n    height: 3rem;\r\n    min-height: 3rem;\r\n    flex-shrink: 0;\r\n    cursor: pointer;\r\n    -webkit-user-select: none;\r\n       -moz-user-select: none;\r\n            user-select: none;\r\n    flex-wrap: wrap;\r\n    align-items: center;\r\n    justify-content: center;\r\n    border-radius: var(--rounded-btn, 0.5rem);\r\n    border-color: transparent;\r\n    border-color: oklch(var(--btn-color, var(--b2)) / var(--tw-border-opacity));\r\n    padding-left: 1rem;\r\n    padding-right: 1rem;\r\n    text-align: center;\r\n    font-size: 0.875rem;\r\n    line-height: 1em;\r\n    gap: 0.5rem;\r\n    font-weight: 600;\r\n    text-decoration-line: none;\r\n    transition-duration: 200ms;\r\n    transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\r\n    border-width: var(--border-btn, 1px);\r\n    transition-property: color, background-color, border-color, opacity, box-shadow, transform;\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\r\n    --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);\r\n    --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);\r\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\r\n    outline-color: var(--fallback-bc,oklch(var(--bc)/1));\r\n    background-color: oklch(var(--btn-color, var(--b2)) / var(--tw-bg-opacity));\r\n    --tw-bg-opacity: 1;\r\n    --tw-border-opacity: 1;\r\n}\r\n.btn-disabled,\n  .btn[disabled],\n  .btn:disabled {\r\n    pointer-events: none;\r\n}\r\n:where(.btn:is(input[type=\"checkbox\"])),\n:where(.btn:is(input[type=\"radio\"])) {\r\n    width: auto;\r\n    -webkit-appearance: none;\r\n       -moz-appearance: none;\r\n            appearance: none;\r\n}\r\n.btn:is(input[type=\"checkbox\"]):after,\n.btn:is(input[type=\"radio\"]):after {\r\n    --tw-content: attr(aria-label);\r\n    content: var(--tw-content);\r\n}\r\n.card {\r\n    position: relative;\r\n    display: flex;\r\n    flex-direction: column;\r\n    border-radius: var(--rounded-box, 1rem);\r\n}\r\n.card:focus {\r\n    outline: 2px solid transparent;\r\n    outline-offset: 2px;\r\n}\r\n.card-body {\r\n    display: flex;\r\n    flex: 1 1 auto;\r\n    flex-direction: column;\r\n    padding: var(--padding-card, 2rem);\r\n    gap: 0.5rem;\r\n}\r\n.card-body :where(p) {\r\n    flex-grow: 1;\r\n}\r\n.card figure {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n}\r\n.card.image-full {\r\n    display: grid;\r\n}\r\n.card.image-full:before {\r\n    position: relative;\r\n    content: \"\";\r\n    z-index: 10;\r\n    border-radius: var(--rounded-box, 1rem);\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\r\n    opacity: 0.75;\r\n}\r\n.card.image-full:before,\n    .card.image-full > * {\r\n    grid-column-start: 1;\r\n    grid-row-start: 1;\r\n}\r\n.card.image-full > figure img {\r\n    height: 100%;\r\n    -o-object-fit: cover;\r\n       object-fit: cover;\r\n}\r\n.card.image-full > .card-body {\r\n    position: relative;\r\n    z-index: 20;\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-nc,oklch(var(--nc)/var(--tw-text-opacity)));\r\n}\r\n.checkbox {\r\n    flex-shrink: 0;\r\n    --chkbg: var(--fallback-bc,oklch(var(--bc)/1));\r\n    --chkfg: var(--fallback-b1,oklch(var(--b1)/1));\r\n    height: 1.5rem;\r\n    width: 1.5rem;\r\n    cursor: pointer;\r\n    -webkit-appearance: none;\r\n       -moz-appearance: none;\r\n            appearance: none;\r\n    border-radius: var(--rounded-btn, 0.5rem);\r\n    border-width: 1px;\r\n    border-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-border-opacity)));\r\n    --tw-border-opacity: 0.2;\r\n}\r\n.dropdown {\r\n    position: relative;\r\n    display: inline-block;\r\n}\r\n.dropdown > *:not(summary):focus {\r\n    outline: 2px solid transparent;\r\n    outline-offset: 2px;\r\n}\r\n.dropdown .dropdown-content {\r\n    position: absolute;\r\n}\r\n.dropdown:is(:not(details)) .dropdown-content {\r\n    visibility: hidden;\r\n    opacity: 0;\r\n    transform-origin: top;\r\n    --tw-scale-x: .95;\r\n    --tw-scale-y: .95;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\r\n    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\r\n    transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\r\n    transition-duration: 200ms;\r\n}\r\n.dropdown-end .dropdown-content {\r\n    inset-inline-end: 0px;\r\n}\r\n.dropdown-left .dropdown-content {\r\n    bottom: auto;\r\n    inset-inline-end: 100%;\r\n    top: 0px;\r\n    transform-origin: right;\r\n}\r\n.dropdown-right .dropdown-content {\r\n    bottom: auto;\r\n    inset-inline-start: 100%;\r\n    top: 0px;\r\n    transform-origin: left;\r\n}\r\n.dropdown-bottom .dropdown-content {\r\n    bottom: auto;\r\n    top: 100%;\r\n    transform-origin: top;\r\n}\r\n.dropdown-top .dropdown-content {\r\n    bottom: 100%;\r\n    top: auto;\r\n    transform-origin: bottom;\r\n}\r\n.dropdown-end.dropdown-right .dropdown-content {\r\n    bottom: 0px;\r\n    top: auto;\r\n}\r\n.dropdown-end.dropdown-left .dropdown-content {\r\n    bottom: 0px;\r\n    top: auto;\r\n}\r\n.dropdown.dropdown-open .dropdown-content,\n.dropdown:not(.dropdown-hover):focus .dropdown-content,\n.dropdown:focus-within .dropdown-content {\r\n    visibility: visible;\r\n    opacity: 1;\r\n}\r\n@media (hover: hover) {\r\n    .dropdown.dropdown-hover:hover .dropdown-content {\r\n        visibility: visible;\r\n        opacity: 1;\r\n    }\r\n    .btm-nav > *.disabled:hover,\n      .btm-nav > *[disabled]:hover {\r\n        pointer-events: none;\r\n        --tw-border-opacity: 0;\r\n        background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\r\n        --tw-bg-opacity: 0.1;\r\n        color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\r\n        --tw-text-opacity: 0.2;\r\n    }\r\n    .btn:hover {\r\n        --tw-border-opacity: 1;\r\n        border-color: var(--fallback-b3,oklch(var(--b3)/var(--tw-border-opacity)));\r\n        --tw-bg-opacity: 1;\r\n        background-color: var(--fallback-b3,oklch(var(--b3)/var(--tw-bg-opacity)));\r\n    }\r\n    @supports (color: color-mix(in oklab, black, black)) {\r\n        .btn:hover {\r\n            background-color: color-mix(\n            in oklab,\n            oklch(var(--btn-color, var(--b2)) / var(--tw-bg-opacity, 1)) 90%,\n            black\n          );\r\n            border-color: color-mix(\n            in oklab,\n            oklch(var(--btn-color, var(--b2)) / var(--tw-border-opacity, 1)) 90%,\n            black\n          );\r\n        }\r\n    }\r\n    @supports not (color: oklch(0% 0 0)) {\r\n        .btn:hover {\r\n            background-color: var(--btn-color, var(--fallback-b2));\r\n            border-color: var(--btn-color, var(--fallback-b2));\r\n        }\r\n    }\r\n    .btn.glass:hover {\r\n        --glass-opacity: 25%;\r\n        --glass-border-opacity: 15%;\r\n    }\r\n    .btn-ghost:hover {\r\n        border-color: transparent;\r\n    }\r\n    @supports (color: oklch(0% 0 0)) {\r\n        .btn-ghost:hover {\r\n            background-color: var(--fallback-bc,oklch(var(--bc)/0.2));\r\n        }\r\n    }\r\n    .btn-outline:hover {\r\n        --tw-border-opacity: 1;\r\n        border-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-border-opacity)));\r\n        --tw-bg-opacity: 1;\r\n        background-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-bg-opacity)));\r\n        --tw-text-opacity: 1;\r\n        color: var(--fallback-b1,oklch(var(--b1)/var(--tw-text-opacity)));\r\n    }\r\n    .btn-outline.btn-primary:hover {\r\n        --tw-text-opacity: 1;\r\n        color: var(--fallback-pc,oklch(var(--pc)/var(--tw-text-opacity)));\r\n    }\r\n    @supports (color: color-mix(in oklab, black, black)) {\r\n        .btn-outline.btn-primary:hover {\r\n            background-color: color-mix(in oklab, var(--fallback-p,oklch(var(--p)/1)) 90%, black);\r\n            border-color: color-mix(in oklab, var(--fallback-p,oklch(var(--p)/1)) 90%, black);\r\n        }\r\n    }\r\n    .btn-outline.btn-secondary:hover {\r\n        --tw-text-opacity: 1;\r\n        color: var(--fallback-sc,oklch(var(--sc)/var(--tw-text-opacity)));\r\n    }\r\n    @supports (color: color-mix(in oklab, black, black)) {\r\n        .btn-outline.btn-secondary:hover {\r\n            background-color: color-mix(in oklab, var(--fallback-s,oklch(var(--s)/1)) 90%, black);\r\n            border-color: color-mix(in oklab, var(--fallback-s,oklch(var(--s)/1)) 90%, black);\r\n        }\r\n    }\r\n    .btn-outline.btn-accent:hover {\r\n        --tw-text-opacity: 1;\r\n        color: var(--fallback-ac,oklch(var(--ac)/var(--tw-text-opacity)));\r\n    }\r\n    @supports (color: color-mix(in oklab, black, black)) {\r\n        .btn-outline.btn-accent:hover {\r\n            background-color: color-mix(in oklab, var(--fallback-a,oklch(var(--a)/1)) 90%, black);\r\n            border-color: color-mix(in oklab, var(--fallback-a,oklch(var(--a)/1)) 90%, black);\r\n        }\r\n    }\r\n    .btn-outline.btn-success:hover {\r\n        --tw-text-opacity: 1;\r\n        color: var(--fallback-suc,oklch(var(--suc)/var(--tw-text-opacity)));\r\n    }\r\n    @supports (color: color-mix(in oklab, black, black)) {\r\n        .btn-outline.btn-success:hover {\r\n            background-color: color-mix(in oklab, var(--fallback-su,oklch(var(--su)/1)) 90%, black);\r\n            border-color: color-mix(in oklab, var(--fallback-su,oklch(var(--su)/1)) 90%, black);\r\n        }\r\n    }\r\n    .btn-outline.btn-info:hover {\r\n        --tw-text-opacity: 1;\r\n        color: var(--fallback-inc,oklch(var(--inc)/var(--tw-text-opacity)));\r\n    }\r\n    @supports (color: color-mix(in oklab, black, black)) {\r\n        .btn-outline.btn-info:hover {\r\n            background-color: color-mix(in oklab, var(--fallback-in,oklch(var(--in)/1)) 90%, black);\r\n            border-color: color-mix(in oklab, var(--fallback-in,oklch(var(--in)/1)) 90%, black);\r\n        }\r\n    }\r\n    .btn-outline.btn-warning:hover {\r\n        --tw-text-opacity: 1;\r\n        color: var(--fallback-wac,oklch(var(--wac)/var(--tw-text-opacity)));\r\n    }\r\n    @supports (color: color-mix(in oklab, black, black)) {\r\n        .btn-outline.btn-warning:hover {\r\n            background-color: color-mix(in oklab, var(--fallback-wa,oklch(var(--wa)/1)) 90%, black);\r\n            border-color: color-mix(in oklab, var(--fallback-wa,oklch(var(--wa)/1)) 90%, black);\r\n        }\r\n    }\r\n    .btn-outline.btn-error:hover {\r\n        --tw-text-opacity: 1;\r\n        color: var(--fallback-erc,oklch(var(--erc)/var(--tw-text-opacity)));\r\n    }\r\n    @supports (color: color-mix(in oklab, black, black)) {\r\n        .btn-outline.btn-error:hover {\r\n            background-color: color-mix(in oklab, var(--fallback-er,oklch(var(--er)/1)) 90%, black);\r\n            border-color: color-mix(in oklab, var(--fallback-er,oklch(var(--er)/1)) 90%, black);\r\n        }\r\n    }\r\n    .btn-disabled:hover,\n    .btn[disabled]:hover,\n    .btn:disabled:hover {\r\n        --tw-border-opacity: 0;\r\n        background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\r\n        --tw-bg-opacity: 0.2;\r\n        color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\r\n        --tw-text-opacity: 0.2;\r\n    }\r\n    @supports (color: color-mix(in oklab, black, black)) {\r\n        .btn:is(input[type=\"checkbox\"]:checked):hover, .btn:is(input[type=\"radio\"]:checked):hover {\r\n            background-color: color-mix(in oklab, var(--fallback-p,oklch(var(--p)/1)) 90%, black);\r\n            border-color: color-mix(in oklab, var(--fallback-p,oklch(var(--p)/1)) 90%, black);\r\n        }\r\n    }\r\n    .dropdown.dropdown-hover:hover .dropdown-content {\r\n        --tw-scale-x: 1;\r\n        --tw-scale-y: 1;\r\n        transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n    }\r\n    :where(.menu li:not(.menu-title, .disabled) > *:not(ul, details, .menu-title)):not(.active, .btn):hover, :where(.menu li:not(.menu-title, .disabled) > details > summary:not(.menu-title)):not(.active, .btn):hover {\r\n        cursor: pointer;\r\n        outline: 2px solid transparent;\r\n        outline-offset: 2px;\r\n    }\r\n    @supports (color: oklch(0% 0 0)) {\r\n        :where(.menu li:not(.menu-title, .disabled) > *:not(ul, details, .menu-title)):not(.active, .btn):hover, :where(.menu li:not(.menu-title, .disabled) > details > summary:not(.menu-title)):not(.active, .btn):hover {\r\n            background-color: var(--fallback-bc,oklch(var(--bc)/0.1));\r\n        }\r\n    }\r\n}\r\n.dropdown:is(details) summary::-webkit-details-marker {\r\n    display: none;\r\n}\r\n.footer {\r\n    display: grid;\r\n    width: 100%;\r\n    grid-auto-flow: row;\r\n    place-items: start;\r\n    -moz-column-gap: 1rem;\r\n         column-gap: 1rem;\r\n    row-gap: 2.5rem;\r\n    font-size: 0.875rem;\r\n    line-height: 1.25rem;\r\n}\r\n.footer > * {\r\n    display: grid;\r\n    place-items: start;\r\n    gap: 0.5rem;\r\n}\r\n.footer-center {\r\n    place-items: center;\r\n    text-align: center;\r\n}\r\n.footer-center > * {\r\n    place-items: center;\r\n}\r\n@media (min-width: 48rem) {\r\n    .footer {\r\n        grid-auto-flow: column;\r\n    }\r\n    .footer-center {\r\n        grid-auto-flow: row dense;\r\n    }\r\n}\r\n.form-control {\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n.label {\r\n    display: flex;\r\n    -webkit-user-select: none;\r\n       -moz-user-select: none;\r\n            user-select: none;\r\n    align-items: center;\r\n    justify-content: space-between;\r\n    padding-left: 0.25rem;\r\n    padding-right: 0.25rem;\r\n    padding-top: 0.5rem;\r\n    padding-bottom: 0.5rem;\r\n}\r\n.input {\r\n    flex-shrink: 1;\r\n    -webkit-appearance: none;\r\n       -moz-appearance: none;\r\n            appearance: none;\r\n    height: 3rem;\r\n    padding-left: 1rem;\r\n    padding-right: 1rem;\r\n    font-size: 1rem;\r\n    line-height: 2;\r\n    line-height: 1.5rem;\r\n    border-radius: var(--rounded-btn, 0.5rem);\r\n    border-width: 1px;\r\n    border-color: transparent;\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\r\n}\r\n.input[type=\"number\"]::-webkit-inner-spin-button,\n.input-md[type=\"number\"]::-webkit-inner-spin-button {\r\n    margin-top: -1rem;\r\n    margin-bottom: -1rem;\r\n    margin-inline-end: -1rem;\r\n}\r\n.input-sm[type=\"number\"]::-webkit-inner-spin-button {\r\n    margin-top: 0px;\r\n    margin-bottom: 0px;\r\n    margin-inline-end: -0px;\r\n}\r\n.join {\r\n    display: inline-flex;\r\n    align-items: stretch;\r\n    border-radius: var(--rounded-btn, 0.5rem);\r\n}\r\n.join :where(.join-item) {\r\n    border-start-end-radius: 0;\r\n    border-end-end-radius: 0;\r\n    border-end-start-radius: 0;\r\n    border-start-start-radius: 0;\r\n}\r\n.join .join-item:not(:first-child):not(:last-child),\n  .join *:not(:first-child):not(:last-child) .join-item {\r\n    border-start-end-radius: 0;\r\n    border-end-end-radius: 0;\r\n    border-end-start-radius: 0;\r\n    border-start-start-radius: 0;\r\n}\r\n.join .join-item:first-child:not(:last-child),\n  .join *:first-child:not(:last-child) .join-item {\r\n    border-start-end-radius: 0;\r\n    border-end-end-radius: 0;\r\n}\r\n.join .dropdown .join-item:first-child:not(:last-child),\n  .join *:first-child:not(:last-child) .dropdown .join-item {\r\n    border-start-end-radius: inherit;\r\n    border-end-end-radius: inherit;\r\n}\r\n.join :where(.join-item:first-child:not(:last-child)),\n  .join :where(*:first-child:not(:last-child) .join-item) {\r\n    border-end-start-radius: inherit;\r\n    border-start-start-radius: inherit;\r\n}\r\n.join .join-item:last-child:not(:first-child),\n  .join *:last-child:not(:first-child) .join-item {\r\n    border-end-start-radius: 0;\r\n    border-start-start-radius: 0;\r\n}\r\n.join :where(.join-item:last-child:not(:first-child)),\n  .join :where(*:last-child:not(:first-child) .join-item) {\r\n    border-start-end-radius: inherit;\r\n    border-end-end-radius: inherit;\r\n}\r\n@supports not selector(:has(*)) {\r\n    :where(.join *) {\r\n        border-radius: inherit;\r\n    }\r\n}\r\n@supports selector(:has(*)) {\r\n    :where(.join *:has(.join-item)) {\r\n        border-radius: inherit;\r\n    }\r\n}\r\n.link {\r\n    cursor: pointer;\r\n    text-decoration-line: underline;\r\n}\r\n.mask {\r\n    -webkit-mask-size: contain;\r\n            mask-size: contain;\r\n    -webkit-mask-repeat: no-repeat;\r\n            mask-repeat: no-repeat;\r\n    -webkit-mask-position: center;\r\n            mask-position: center;\r\n}\r\n.menu {\r\n    display: flex;\r\n    flex-direction: column;\r\n    flex-wrap: wrap;\r\n    font-size: 0.875rem;\r\n    line-height: 1.25rem;\r\n    padding: 0.5rem;\r\n}\r\n.menu :where(li ul) {\r\n    position: relative;\r\n    white-space: nowrap;\r\n    margin-inline-start: 1rem;\r\n    padding-inline-start: 0.5rem;\r\n}\r\n.menu :where(li:not(.menu-title) > *:not(ul, details, .menu-title, .btn)), .menu :where(li:not(.menu-title) > details > summary:not(.menu-title)) {\r\n    display: grid;\r\n    grid-auto-flow: column;\r\n    align-content: flex-start;\r\n    align-items: center;\r\n    gap: 0.5rem;\r\n    grid-auto-columns: minmax(auto, max-content) auto max-content;\r\n    -webkit-user-select: none;\r\n       -moz-user-select: none;\r\n            user-select: none;\r\n}\r\n.menu li.disabled {\r\n    cursor: not-allowed;\r\n    -webkit-user-select: none;\r\n       -moz-user-select: none;\r\n            user-select: none;\r\n    color: var(--fallback-bc,oklch(var(--bc)/0.3));\r\n}\r\n.menu :where(li > .menu-dropdown:not(.menu-dropdown-show)) {\r\n    display: none;\r\n}\r\n:where(.menu li) {\r\n    position: relative;\r\n    display: flex;\r\n    flex-shrink: 0;\r\n    flex-direction: column;\r\n    flex-wrap: wrap;\r\n    align-items: stretch;\r\n}\r\n:where(.menu li) .badge {\r\n    justify-self: end;\r\n}\r\n.modal {\r\n    pointer-events: none;\r\n    position: fixed;\r\n    inset: 0px;\r\n    margin: 0px;\r\n    display: grid;\r\n    height: 100%;\r\n    max-height: none;\r\n    width: 100%;\r\n    max-width: none;\r\n    justify-items: center;\r\n    padding: 0px;\r\n    opacity: 0;\r\n    overscroll-behavior: contain;\r\n    z-index: 999;\r\n    background-color: transparent;\r\n    color: inherit;\r\n    transition-duration: 200ms;\r\n    transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\r\n    transition-property: transform, opacity, visibility;\r\n    overflow-y: hidden;\r\n}\r\n:where(.modal) {\r\n    align-items: center;\r\n}\r\n.modal-box {\r\n    max-height: calc(100vh - 5em);\r\n    grid-column-start: 1;\r\n    grid-row-start: 1;\r\n    width: 91.666667%;\r\n    max-width: 32rem;\r\n    --tw-scale-x: .9;\r\n    --tw-scale-y: .9;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n    border-bottom-right-radius: var(--rounded-box, 1rem);\r\n    border-bottom-left-radius: var(--rounded-box, 1rem);\r\n    border-top-left-radius: var(--rounded-box, 1rem);\r\n    border-top-right-radius: var(--rounded-box, 1rem);\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\r\n    padding: 1.5rem;\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\r\n    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\r\n    transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\r\n    transition-duration: 200ms;\r\n    box-shadow: rgba(0, 0, 0, 0.25) 0px 25px 50px -12px;\r\n    overflow-y: auto;\r\n    overscroll-behavior: contain;\r\n}\r\n.modal-open,\n.modal:target,\n.modal-toggle:checked + .modal,\n.modal[open] {\r\n    pointer-events: auto;\r\n    visibility: visible;\r\n    opacity: 1;\r\n}\r\n.modal-action {\r\n    display: flex;\r\n    margin-top: 1.5rem;\r\n    justify-content: flex-end;\r\n}\r\n:root:has(:is(.modal-open, .modal:target, .modal-toggle:checked + .modal, .modal[open])) {\r\n    overflow: hidden;\r\n    scrollbar-gutter: stable;\r\n}\r\n.navbar {\r\n    display: flex;\r\n    align-items: center;\r\n    padding: var(--navbar-padding, 0.5rem);\r\n    min-height: 4rem;\r\n    width: 100%;\r\n}\r\n:where(.navbar > *:not(script, style)) {\r\n    display: inline-flex;\r\n    align-items: center;\r\n}\r\n.navbar-start {\r\n    width: 50%;\r\n    justify-content: flex-start;\r\n}\r\n.navbar-center {\r\n    flex-shrink: 0;\r\n}\r\n.navbar-end {\r\n    width: 50%;\r\n    justify-content: flex-end;\r\n}\r\n.progress {\r\n    position: relative;\r\n    width: 100%;\r\n    -webkit-appearance: none;\r\n       -moz-appearance: none;\r\n            appearance: none;\r\n    overflow: hidden;\r\n    height: 0.5rem;\r\n    border-radius: var(--rounded-box, 1rem);\r\n    background-color: var(--fallback-bc,oklch(var(--bc)/0.2));\r\n}\r\n.select {\r\n    display: inline-flex;\r\n    cursor: pointer;\r\n    -webkit-user-select: none;\r\n       -moz-user-select: none;\r\n            user-select: none;\r\n    -webkit-appearance: none;\r\n       -moz-appearance: none;\r\n            appearance: none;\r\n    height: 3rem;\r\n    min-height: 3rem;\r\n    padding-inline-start: 1rem;\r\n    padding-inline-end: 2.5rem;\r\n    font-size: 0.875rem;\r\n    line-height: 1.25rem;\r\n    line-height: 2;\r\n    border-radius: var(--rounded-btn, 0.5rem);\r\n    border-width: 1px;\r\n    border-color: transparent;\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\r\n    background-image: linear-gradient(45deg, transparent 50%, currentColor 50%),\n    linear-gradient(135deg, currentColor 50%, transparent 50%);\r\n    background-position: calc(100% - 20px) calc(1px + 50%),\n    calc(100% - 16.1px) calc(1px + 50%);\r\n    background-size: 4px 4px,\n    4px 4px;\r\n    background-repeat: no-repeat;\r\n}\r\n.select[multiple] {\r\n    height: auto;\r\n}\r\n.table {\r\n    position: relative;\r\n    width: 100%;\r\n    border-radius: var(--rounded-box, 1rem);\r\n    text-align: left;\r\n    font-size: 0.875rem;\r\n    line-height: 1.25rem;\r\n}\r\n.table :where(.table-pin-rows thead tr) {\r\n    position: sticky;\r\n    top: 0px;\r\n    z-index: 1;\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\r\n}\r\n.table :where(.table-pin-rows tfoot tr) {\r\n    position: sticky;\r\n    bottom: 0px;\r\n    z-index: 1;\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\r\n}\r\n.table :where(.table-pin-cols tr th) {\r\n    position: sticky;\r\n    left: 0px;\r\n    right: 0px;\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\r\n}\r\n.toast {\r\n    position: fixed;\r\n    display: flex;\r\n    min-width: -moz-fit-content;\r\n    min-width: fit-content;\r\n    flex-direction: column;\r\n    white-space: nowrap;\r\n    gap: 0.5rem;\r\n    padding: 1rem;\r\n}\r\n.toggle {\r\n    flex-shrink: 0;\r\n    --tglbg: var(--fallback-b1,oklch(var(--b1)/1));\r\n    --handleoffset: 1.5rem;\r\n    --handleoffsetcalculator: calc(var(--handleoffset) * -1);\r\n    --togglehandleborder: 0 0;\r\n    height: 1.5rem;\r\n    width: 3rem;\r\n    cursor: pointer;\r\n    -webkit-appearance: none;\r\n       -moz-appearance: none;\r\n            appearance: none;\r\n    border-radius: var(--rounded-badge, 1.9rem);\r\n    border-width: 1px;\r\n    border-color: currentColor;\r\n    background-color: currentColor;\r\n    color: var(--fallback-bc,oklch(var(--bc)/0.5));\r\n    transition: background,\n    box-shadow var(--animation-input, 0.2s) ease-out;\r\n    box-shadow: var(--handleoffsetcalculator) 0 0 2px var(--tglbg) inset,\n    0 0 0 2px var(--tglbg) inset,\n    var(--togglehandleborder);\r\n}\r\n.alert-success {\r\n    border-color: var(--fallback-su,oklch(var(--su)/0.2));\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-suc,oklch(var(--suc)/var(--tw-text-opacity)));\r\n    --alert-bg: var(--fallback-su,oklch(var(--su)/1));\r\n    --alert-bg-mix: var(--fallback-b1,oklch(var(--b1)/1));\r\n}\r\n.alert-error {\r\n    border-color: var(--fallback-er,oklch(var(--er)/0.2));\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-erc,oklch(var(--erc)/var(--tw-text-opacity)));\r\n    --alert-bg: var(--fallback-er,oklch(var(--er)/1));\r\n    --alert-bg-mix: var(--fallback-b1,oklch(var(--b1)/1));\r\n}\r\n.avatar-group :where(.avatar) {\r\n    overflow: hidden;\r\n    border-radius: 9999px;\r\n    border-width: 4px;\r\n    --tw-border-opacity: 1;\r\n    border-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-border-opacity)));\r\n}\r\n.btm-nav > *.disabled,\n    .btm-nav > *[disabled] {\r\n    pointer-events: none;\r\n    --tw-border-opacity: 0;\r\n    background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\r\n    --tw-bg-opacity: 0.1;\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\r\n    --tw-text-opacity: 0.2;\r\n}\r\n.btm-nav > * .label {\r\n    font-size: 1rem;\r\n    line-height: 1.5rem;\r\n}\r\n@media (prefers-reduced-motion: no-preference) {\r\n    .btn {\r\n        animation: button-pop var(--animation-btn, 0.25s) ease-out;\r\n    }\r\n}\r\n.btn:active:hover,\n  .btn:active:focus {\r\n    animation: button-pop 0s ease-out;\r\n    transform: scale(var(--btn-focus-scale, 0.97));\r\n}\r\n@supports not (color: oklch(0% 0 0)) {\r\n    .btn {\r\n        background-color: var(--btn-color, var(--fallback-b2));\r\n        border-color: var(--btn-color, var(--fallback-b2));\r\n    }\r\n    .btn-primary {\r\n        --btn-color: var(--fallback-p);\r\n    }\r\n    .btn-secondary {\r\n        --btn-color: var(--fallback-s);\r\n    }\r\n    .btn-accent {\r\n        --btn-color: var(--fallback-a);\r\n    }\r\n    .btn-info {\r\n        --btn-color: var(--fallback-in);\r\n    }\r\n    .btn-error {\r\n        --btn-color: var(--fallback-er);\r\n    }\r\n}\r\n@supports (color: color-mix(in oklab, black, black)) {\r\n    .btn-outline.btn-primary.btn-active {\r\n        background-color: color-mix(in oklab, var(--fallback-p,oklch(var(--p)/1)) 90%, black);\r\n        border-color: color-mix(in oklab, var(--fallback-p,oklch(var(--p)/1)) 90%, black);\r\n    }\r\n    .btn-outline.btn-secondary.btn-active {\r\n        background-color: color-mix(in oklab, var(--fallback-s,oklch(var(--s)/1)) 90%, black);\r\n        border-color: color-mix(in oklab, var(--fallback-s,oklch(var(--s)/1)) 90%, black);\r\n    }\r\n    .btn-outline.btn-accent.btn-active {\r\n        background-color: color-mix(in oklab, var(--fallback-a,oklch(var(--a)/1)) 90%, black);\r\n        border-color: color-mix(in oklab, var(--fallback-a,oklch(var(--a)/1)) 90%, black);\r\n    }\r\n    .btn-outline.btn-success.btn-active {\r\n        background-color: color-mix(in oklab, var(--fallback-su,oklch(var(--su)/1)) 90%, black);\r\n        border-color: color-mix(in oklab, var(--fallback-su,oklch(var(--su)/1)) 90%, black);\r\n    }\r\n    .btn-outline.btn-info.btn-active {\r\n        background-color: color-mix(in oklab, var(--fallback-in,oklch(var(--in)/1)) 90%, black);\r\n        border-color: color-mix(in oklab, var(--fallback-in,oklch(var(--in)/1)) 90%, black);\r\n    }\r\n    .btn-outline.btn-warning.btn-active {\r\n        background-color: color-mix(in oklab, var(--fallback-wa,oklch(var(--wa)/1)) 90%, black);\r\n        border-color: color-mix(in oklab, var(--fallback-wa,oklch(var(--wa)/1)) 90%, black);\r\n    }\r\n    .btn-outline.btn-error.btn-active {\r\n        background-color: color-mix(in oklab, var(--fallback-er,oklch(var(--er)/1)) 90%, black);\r\n        border-color: color-mix(in oklab, var(--fallback-er,oklch(var(--er)/1)) 90%, black);\r\n    }\r\n}\r\n.btn:focus-visible {\r\n    outline-style: solid;\r\n    outline-width: 2px;\r\n    outline-offset: 2px;\r\n}\r\n.btn-primary {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-pc,oklch(var(--pc)/var(--tw-text-opacity)));\r\n    outline-color: var(--fallback-p,oklch(var(--p)/1));\r\n}\r\n@supports (color: oklch(0% 0 0)) {\r\n    .btn-primary {\r\n        --btn-color: var(--p);\r\n    }\r\n    .btn-secondary {\r\n        --btn-color: var(--s);\r\n    }\r\n    .btn-accent {\r\n        --btn-color: var(--a);\r\n    }\r\n    .btn-info {\r\n        --btn-color: var(--in);\r\n    }\r\n    .btn-error {\r\n        --btn-color: var(--er);\r\n    }\r\n}\r\n.btn-secondary {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-sc,oklch(var(--sc)/var(--tw-text-opacity)));\r\n    outline-color: var(--fallback-s,oklch(var(--s)/1));\r\n}\r\n.btn-accent {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-ac,oklch(var(--ac)/var(--tw-text-opacity)));\r\n    outline-color: var(--fallback-a,oklch(var(--a)/1));\r\n}\r\n.btn-info {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-inc,oklch(var(--inc)/var(--tw-text-opacity)));\r\n    outline-color: var(--fallback-in,oklch(var(--in)/1));\r\n}\r\n.btn-error {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-erc,oklch(var(--erc)/var(--tw-text-opacity)));\r\n    outline-color: var(--fallback-er,oklch(var(--er)/1));\r\n}\r\n.btn.glass {\r\n    --tw-shadow: 0 0 #0000;\r\n    --tw-shadow-colored: 0 0 #0000;\r\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\r\n    outline-color: currentColor;\r\n}\r\n.btn.glass.btn-active {\r\n    --glass-opacity: 25%;\r\n    --glass-border-opacity: 15%;\r\n}\r\n.btn-ghost {\r\n    border-width: 1px;\r\n    border-color: transparent;\r\n    background-color: transparent;\r\n    color: currentColor;\r\n    --tw-shadow: 0 0 #0000;\r\n    --tw-shadow-colored: 0 0 #0000;\r\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\r\n    outline-color: currentColor;\r\n}\r\n.btn-ghost.btn-active {\r\n    border-color: transparent;\r\n    background-color: var(--fallback-bc,oklch(var(--bc)/0.2));\r\n}\r\n.btn-outline {\r\n    border-color: currentColor;\r\n    background-color: transparent;\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\r\n    --tw-shadow: 0 0 #0000;\r\n    --tw-shadow-colored: 0 0 #0000;\r\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\r\n}\r\n.btn-outline.btn-active {\r\n    --tw-border-opacity: 1;\r\n    border-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-border-opacity)));\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-bg-opacity)));\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-b1,oklch(var(--b1)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-primary {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-p,oklch(var(--p)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-primary.btn-active {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-pc,oklch(var(--pc)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-secondary {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-s,oklch(var(--s)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-secondary.btn-active {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-sc,oklch(var(--sc)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-accent {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-a,oklch(var(--a)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-accent.btn-active {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-ac,oklch(var(--ac)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-success {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-su,oklch(var(--su)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-success.btn-active {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-suc,oklch(var(--suc)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-info {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-in,oklch(var(--in)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-info.btn-active {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-inc,oklch(var(--inc)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-warning {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-wa,oklch(var(--wa)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-warning.btn-active {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-wac,oklch(var(--wac)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-error {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-er,oklch(var(--er)/var(--tw-text-opacity)));\r\n}\r\n.btn-outline.btn-error.btn-active {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-erc,oklch(var(--erc)/var(--tw-text-opacity)));\r\n}\r\n.btn.btn-disabled,\n  .btn[disabled],\n  .btn:disabled {\r\n    --tw-border-opacity: 0;\r\n    background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\r\n    --tw-bg-opacity: 0.2;\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\r\n    --tw-text-opacity: 0.2;\r\n}\r\n.btn:is(input[type=\"checkbox\"]:checked),\n.btn:is(input[type=\"radio\"]:checked) {\r\n    --tw-border-opacity: 1;\r\n    border-color: var(--fallback-p,oklch(var(--p)/var(--tw-border-opacity)));\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-p,oklch(var(--p)/var(--tw-bg-opacity)));\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-pc,oklch(var(--pc)/var(--tw-text-opacity)));\r\n}\r\n.btn:is(input[type=\"checkbox\"]:checked):focus-visible, .btn:is(input[type=\"radio\"]:checked):focus-visible {\r\n    outline-color: var(--fallback-p,oklch(var(--p)/1));\r\n}\r\n@keyframes button-pop {\r\n    0% {\r\n        transform: scale(var(--btn-focus-scale, 0.98));\r\n    }\r\n    40% {\r\n        transform: scale(1.02);\r\n    }\r\n    100% {\r\n        transform: scale(1);\r\n    }\r\n}\r\n.card :where(figure:first-child) {\r\n    overflow: hidden;\r\n    border-start-start-radius: inherit;\r\n    border-start-end-radius: inherit;\r\n    border-end-start-radius: unset;\r\n    border-end-end-radius: unset;\r\n}\r\n.card :where(figure:last-child) {\r\n    overflow: hidden;\r\n    border-start-start-radius: unset;\r\n    border-start-end-radius: unset;\r\n    border-end-start-radius: inherit;\r\n    border-end-end-radius: inherit;\r\n}\r\n.card:focus-visible {\r\n    outline: 2px solid currentColor;\r\n    outline-offset: 2px;\r\n}\r\n.card.bordered {\r\n    border-width: 1px;\r\n    --tw-border-opacity: 1;\r\n    border-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-border-opacity)));\r\n}\r\n.card.compact .card-body {\r\n    padding: 1rem;\r\n    font-size: 0.875rem;\r\n    line-height: 1.25rem;\r\n}\r\n.card-title {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 0.5rem;\r\n    font-size: 1.25rem;\r\n    line-height: 1.75rem;\r\n    font-weight: 600;\r\n}\r\n.card.image-full :where(figure) {\r\n    overflow: hidden;\r\n    border-radius: inherit;\r\n}\r\n.checkbox:focus {\r\n    box-shadow: none;\r\n}\r\n.checkbox:focus-visible {\r\n    outline-style: solid;\r\n    outline-width: 2px;\r\n    outline-offset: 2px;\r\n    outline-color: var(--fallback-bc,oklch(var(--bc)/1));\r\n}\r\n.checkbox:disabled {\r\n    border-width: 0px;\r\n    cursor: not-allowed;\r\n    border-color: transparent;\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-bg-opacity)));\r\n    opacity: 0.2;\r\n}\r\n.checkbox:checked,\n  .checkbox[aria-checked=\"true\"] {\r\n    background-repeat: no-repeat;\r\n    animation: checkmark var(--animation-input, 0.2s) ease-out;\r\n    background-color: var(--chkbg);\r\n    background-image: linear-gradient(-45deg, transparent 65%, var(--chkbg) 65.99%),\n      linear-gradient(45deg, transparent 75%, var(--chkbg) 75.99%),\n      linear-gradient(-45deg, var(--chkbg) 40%, transparent 40.99%),\n      linear-gradient(\n        45deg,\n        var(--chkbg) 30%,\n        var(--chkfg) 30.99%,\n        var(--chkfg) 40%,\n        transparent 40.99%\n      ),\n      linear-gradient(-45deg, var(--chkfg) 50%, var(--chkbg) 50.99%);\r\n}\r\n.checkbox:indeterminate {\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-bg-opacity)));\r\n    background-repeat: no-repeat;\r\n    animation: checkmark var(--animation-input, 0.2s) ease-out;\r\n    background-image: linear-gradient(90deg, transparent 80%, var(--chkbg) 80%),\n      linear-gradient(-90deg, transparent 80%, var(--chkbg) 80%),\n      linear-gradient(0deg, var(--chkbg) 43%, var(--chkfg) 43%, var(--chkfg) 57%, var(--chkbg) 57%);\r\n}\r\n.checkbox-secondary {\r\n    --chkbg: var(--fallback-s,oklch(var(--s)/1));\r\n    --chkfg: var(--fallback-sc,oklch(var(--sc)/1));\r\n    --tw-border-opacity: 1;\r\n    border-color: var(--fallback-s,oklch(var(--s)/var(--tw-border-opacity)));\r\n}\r\n.checkbox-secondary:focus-visible {\r\n    outline-color: var(--fallback-s,oklch(var(--s)/1));\r\n}\r\n.checkbox-secondary:checked,\n    .checkbox-secondary[aria-checked=\"true\"] {\r\n    --tw-border-opacity: 1;\r\n    border-color: var(--fallback-s,oklch(var(--s)/var(--tw-border-opacity)));\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-s,oklch(var(--s)/var(--tw-bg-opacity)));\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-sc,oklch(var(--sc)/var(--tw-text-opacity)));\r\n}\r\n@keyframes checkmark {\r\n    0% {\r\n        background-position-y: 5px;\r\n    }\r\n    50% {\r\n        background-position-y: -2px;\r\n    }\r\n    100% {\r\n        background-position-y: 0;\r\n    }\r\n}\r\n.dropdown.dropdown-open .dropdown-content,\n.dropdown:focus .dropdown-content,\n.dropdown:focus-within .dropdown-content {\r\n    --tw-scale-x: 1;\r\n    --tw-scale-y: 1;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n}\r\n.label-text {\r\n    font-size: 0.875rem;\r\n    line-height: 1.25rem;\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\r\n}\r\n.input input {\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-p,oklch(var(--p)/var(--tw-bg-opacity)));\r\n    background-color: transparent;\r\n}\r\n.input input:focus {\r\n    outline: 2px solid transparent;\r\n    outline-offset: 2px;\r\n}\r\n.input[list]::-webkit-calendar-picker-indicator {\r\n    line-height: 1em;\r\n}\r\n.input-bordered {\r\n    border-color: var(--fallback-bc,oklch(var(--bc)/0.2));\r\n}\r\n.input:focus,\n  .input:focus-within {\r\n    box-shadow: none;\r\n    border-color: var(--fallback-bc,oklch(var(--bc)/0.2));\r\n    outline-style: solid;\r\n    outline-width: 2px;\r\n    outline-offset: 2px;\r\n    outline-color: var(--fallback-bc,oklch(var(--bc)/0.2));\r\n}\r\n.input:has(> input[disabled]),\n  .input-disabled,\n  .input:disabled,\n  .input[disabled] {\r\n    cursor: not-allowed;\r\n    --tw-border-opacity: 1;\r\n    border-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-border-opacity)));\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity)));\r\n    color: var(--fallback-bc,oklch(var(--bc)/0.4));\r\n}\r\n.input:has(> input[disabled])::-moz-placeholder, .input-disabled::-moz-placeholder, .input:disabled::-moz-placeholder, .input[disabled]::-moz-placeholder {\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-placeholder-opacity)));\r\n    --tw-placeholder-opacity: 0.2;\r\n}\r\n.input:has(> input[disabled])::placeholder,\n  .input-disabled::placeholder,\n  .input:disabled::placeholder,\n  .input[disabled]::placeholder {\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-placeholder-opacity)));\r\n    --tw-placeholder-opacity: 0.2;\r\n}\r\n.input:has(> input[disabled]) > input[disabled] {\r\n    cursor: not-allowed;\r\n}\r\n.input::-webkit-date-and-time-value {\r\n    text-align: inherit;\r\n}\r\n.join > :where(*:not(:first-child)) {\r\n    margin-top: 0px;\r\n    margin-bottom: 0px;\r\n    margin-inline-start: -1px;\r\n}\r\n.join > :where(*:not(:first-child)):is(.btn) {\r\n    margin-inline-start: calc(var(--border-btn) * -1);\r\n}\r\n.link:focus {\r\n    outline: 2px solid transparent;\r\n    outline-offset: 2px;\r\n}\r\n.link:focus-visible {\r\n    outline: 2px solid currentColor;\r\n    outline-offset: 2px;\r\n}\r\n.loading {\r\n    pointer-events: none;\r\n    display: inline-block;\r\n    aspect-ratio: 1 / 1;\r\n    width: 1.5rem;\r\n    background-color: currentColor;\r\n    -webkit-mask-size: 100%;\r\n            mask-size: 100%;\r\n    -webkit-mask-repeat: no-repeat;\r\n            mask-repeat: no-repeat;\r\n    -webkit-mask-position: center;\r\n            mask-position: center;\r\n    -webkit-mask-image: url(\"data:image/svg+xml,%3Csvg width='24' height='24' stroke='%23000' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cstyle%3E.spinner_V8m1%7Btransform-origin:center;animation:spinner_zKoa 2s linear infinite%7D.spinner_V8m1 circle%7Bstroke-linecap:round;animation:spinner_YpZS 1.5s ease-out infinite%7D%40keyframes spinner_zKoa%7B100%25%7Btransform:rotate(360deg)%7D%7D%40keyframes spinner_YpZS%7B0%25%7Bstroke-dasharray:0 150;stroke-dashoffset:0%7D47.5%25%7Bstroke-dasharray:42 150;stroke-dashoffset:-16%7D95%25%2C100%25%7Bstroke-dasharray:42 150;stroke-dashoffset:-59%7D%7D%3C%2Fstyle%3E%3Cg class='spinner_V8m1'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3'%3E%3C%2Fcircle%3E%3C%2Fg%3E%3C%2Fsvg%3E\");\r\n            mask-image: url(\"data:image/svg+xml,%3Csvg width='24' height='24' stroke='%23000' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cstyle%3E.spinner_V8m1%7Btransform-origin:center;animation:spinner_zKoa 2s linear infinite%7D.spinner_V8m1 circle%7Bstroke-linecap:round;animation:spinner_YpZS 1.5s ease-out infinite%7D%40keyframes spinner_zKoa%7B100%25%7Btransform:rotate(360deg)%7D%7D%40keyframes spinner_YpZS%7B0%25%7Bstroke-dasharray:0 150;stroke-dashoffset:0%7D47.5%25%7Bstroke-dasharray:42 150;stroke-dashoffset:-16%7D95%25%2C100%25%7Bstroke-dasharray:42 150;stroke-dashoffset:-59%7D%7D%3C%2Fstyle%3E%3Cg class='spinner_V8m1'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3'%3E%3C%2Fcircle%3E%3C%2Fg%3E%3C%2Fsvg%3E\");\r\n}\r\n.loading-ring {\r\n    -webkit-mask-image: url(\"data:image/svg+xml,%3Csvg width='44' height='44' viewBox='0 0 44 44' xmlns='http://www.w3.org/2000/svg' stroke='%23fff'%3E%3Cg fill='none' fill-rule='evenodd' stroke-width='2'%3E%3Ccircle cx='22' cy='22' r='1'%3E%3Canimate attributeName='r' begin='0s' dur='1.8s' values='1; 20' calcMode='spline' keyTimes='0; 1' keySplines='0.165, 0.84, 0.44, 1' repeatCount='indefinite' /%3E%3Canimate attributeName='stroke-opacity' begin='0s' dur='1.8s' values='1; 0' calcMode='spline' keyTimes='0; 1' keySplines='0.3, 0.61, 0.355, 1' repeatCount='indefinite' /%3E%3C/circle%3E%3Ccircle cx='22' cy='22' r='1'%3E%3Canimate attributeName='r' begin='-0.9s' dur='1.8s' values='1; 20' calcMode='spline' keyTimes='0; 1' keySplines='0.165, 0.84, 0.44, 1' repeatCount='indefinite' /%3E%3Canimate attributeName='stroke-opacity' begin='-0.9s' dur='1.8s' values='1; 0' calcMode='spline' keyTimes='0; 1' keySplines='0.3, 0.61, 0.355, 1' repeatCount='indefinite' /%3E%3C/circle%3E%3C/g%3E%3C/svg%3E\");\r\n            mask-image: url(\"data:image/svg+xml,%3Csvg width='44' height='44' viewBox='0 0 44 44' xmlns='http://www.w3.org/2000/svg' stroke='%23fff'%3E%3Cg fill='none' fill-rule='evenodd' stroke-width='2'%3E%3Ccircle cx='22' cy='22' r='1'%3E%3Canimate attributeName='r' begin='0s' dur='1.8s' values='1; 20' calcMode='spline' keyTimes='0; 1' keySplines='0.165, 0.84, 0.44, 1' repeatCount='indefinite' /%3E%3Canimate attributeName='stroke-opacity' begin='0s' dur='1.8s' values='1; 0' calcMode='spline' keyTimes='0; 1' keySplines='0.3, 0.61, 0.355, 1' repeatCount='indefinite' /%3E%3C/circle%3E%3Ccircle cx='22' cy='22' r='1'%3E%3Canimate attributeName='r' begin='-0.9s' dur='1.8s' values='1; 20' calcMode='spline' keyTimes='0; 1' keySplines='0.165, 0.84, 0.44, 1' repeatCount='indefinite' /%3E%3Canimate attributeName='stroke-opacity' begin='-0.9s' dur='1.8s' values='1; 0' calcMode='spline' keyTimes='0; 1' keySplines='0.3, 0.61, 0.355, 1' repeatCount='indefinite' /%3E%3C/circle%3E%3C/g%3E%3C/svg%3E\");\r\n}\r\n.loading-md {\r\n    width: 1.5rem;\r\n}\r\n.mask-squircle {\r\n    -webkit-mask-image: url(\"data:image/svg+xml,%3csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M100 0C20 0 0 20 0 100s20 100 100 100 100-20 100-100S180 0 100 0Z'/%3e%3c/svg%3e\");\r\n            mask-image: url(\"data:image/svg+xml,%3csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M100 0C20 0 0 20 0 100s20 100 100 100 100-20 100-100S180 0 100 0Z'/%3e%3c/svg%3e\");\r\n}\r\n:where(.menu li:empty) {\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-bg-opacity)));\r\n    opacity: 0.1;\r\n    margin: 0.5rem 1rem;\r\n    height: 1px;\r\n}\r\n.menu :where(li ul):before {\r\n    position: absolute;\r\n    bottom: 0.75rem;\r\n    inset-inline-start: 0px;\r\n    top: 0.75rem;\r\n    width: 1px;\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-bg-opacity)));\r\n    opacity: 0.1;\r\n    content: \"\";\r\n}\r\n.menu :where(li:not(.menu-title) > *:not(ul, details, .menu-title, .btn)),\n.menu :where(li:not(.menu-title) > details > summary:not(.menu-title)) {\r\n    border-radius: var(--rounded-btn, 0.5rem);\r\n    padding-left: 1rem;\r\n    padding-right: 1rem;\r\n    padding-top: 0.5rem;\r\n    padding-bottom: 0.5rem;\r\n    text-align: start;\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\r\n    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\r\n    transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\r\n    transition-duration: 200ms;\r\n    text-wrap: balance;\r\n}\r\n:where(.menu li:not(.menu-title, .disabled) > *:not(ul, details, .menu-title)):not(summary, .active, .btn).focus, :where(.menu li:not(.menu-title, .disabled) > *:not(ul, details, .menu-title)):not(summary, .active, .btn):focus, :where(.menu li:not(.menu-title, .disabled) > *:not(ul, details, .menu-title)):is(summary):not(.active, .btn):focus-visible, :where(.menu li:not(.menu-title, .disabled) > details > summary:not(.menu-title)):not(summary, .active, .btn).focus, :where(.menu li:not(.menu-title, .disabled) > details > summary:not(.menu-title)):not(summary, .active, .btn):focus, :where(.menu li:not(.menu-title, .disabled) > details > summary:not(.menu-title)):is(summary):not(.active, .btn):focus-visible {\r\n    cursor: pointer;\r\n    background-color: var(--fallback-bc,oklch(var(--bc)/0.1));\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\r\n    outline: 2px solid transparent;\r\n    outline-offset: 2px;\r\n}\r\n.menu li > *:not(ul, .menu-title, details, .btn):active,\n.menu li > *:not(ul, .menu-title, details, .btn).active,\n.menu li > details > summary:active {\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-nc,oklch(var(--nc)/var(--tw-text-opacity)));\r\n}\r\n.menu :where(li > details > summary)::-webkit-details-marker {\r\n    display: none;\r\n}\r\n.menu :where(li > details > summary):after,\n.menu :where(li > .menu-dropdown-toggle):after {\r\n    justify-self: end;\r\n    display: block;\r\n    margin-top: -0.5rem;\r\n    height: 0.5rem;\r\n    width: 0.5rem;\r\n    transform: rotate(45deg);\r\n    transition-property: transform, margin-top;\r\n    transition-duration: 0.3s;\r\n    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\r\n    content: \"\";\r\n    transform-origin: 75% 75%;\r\n    box-shadow: 2px 2px;\r\n    pointer-events: none;\r\n}\r\n.menu :where(li > details[open] > summary):after,\n.menu :where(li > .menu-dropdown-toggle.menu-dropdown-show):after {\r\n    transform: rotate(225deg);\r\n    margin-top: 0;\r\n}\r\n.mockup-phone .camera {\r\n    position: relative;\r\n    top: 0px;\r\n    left: 0px;\r\n    background: #000;\r\n    height: 25px;\r\n    width: 150px;\r\n    margin: 0 auto;\r\n    border-bottom-left-radius: 17px;\r\n    border-bottom-right-radius: 17px;\r\n    z-index: 11;\r\n}\r\n.mockup-phone .camera:before {\r\n    content: \"\";\r\n    position: absolute;\r\n    top: 35%;\r\n    left: 50%;\r\n    width: 50px;\r\n    height: 4px;\r\n    border-radius: 5px;\r\n    background-color: #0c0b0e;\r\n    transform: translate(-50%, -50%);\r\n}\r\n.mockup-phone .camera:after {\r\n    content: \"\";\r\n    position: absolute;\r\n    top: 20%;\r\n    left: 70%;\r\n    width: 8px;\r\n    height: 8px;\r\n    border-radius: 5px;\r\n    background-color: #0f0b25;\r\n}\r\n.mockup-phone .display {\r\n    overflow: hidden;\r\n    border-radius: 40px;\r\n    margin-top: -25px;\r\n}\r\n.mockup-browser .mockup-browser-toolbar .input {\r\n    position: relative;\r\n    margin-left: auto;\r\n    margin-right: auto;\r\n    display: block;\r\n    height: 1.75rem;\r\n    width: 24rem;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity)));\r\n    padding-left: 2rem;\r\n    direction: ltr;\r\n}\r\n.mockup-browser .mockup-browser-toolbar .input:before {\r\n    content: \"\";\r\n    position: absolute;\r\n    left: 0.5rem;\r\n    top: 50%;\r\n    aspect-ratio: 1 / 1;\r\n    height: 0.75rem;\r\n    --tw-translate-y: -50%;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n    border-radius: 9999px;\r\n    border-width: 2px;\r\n    border-color: currentColor;\r\n    opacity: 0.6;\r\n}\r\n.mockup-browser .mockup-browser-toolbar .input:after {\r\n    content: \"\";\r\n    position: absolute;\r\n    left: 1.25rem;\r\n    top: 50%;\r\n    height: 0.5rem;\r\n    --tw-translate-y: 25%;\r\n    --tw-rotate: -45deg;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n    border-radius: 9999px;\r\n    border-width: 1px;\r\n    border-color: currentColor;\r\n    opacity: 0.6;\r\n}\r\n.modal:not(dialog:not(.modal-open)),\n  .modal::backdrop {\r\n    background-color: #0006;\r\n    animation: modal-pop 0.2s ease-out;\r\n}\r\n.modal-open .modal-box,\n.modal-toggle:checked + .modal .modal-box,\n.modal:target .modal-box,\n.modal[open] .modal-box {\r\n    --tw-translate-y: 0px;\r\n    --tw-scale-x: 1;\r\n    --tw-scale-y: 1;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n}\r\n.modal-action > :not([hidden]) ~ :not([hidden]) {\r\n    --tw-space-x-reverse: 0;\r\n    margin-right: calc(0.5rem * var(--tw-space-x-reverse));\r\n    margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));\r\n}\r\n@keyframes modal-pop {\r\n    0% {\r\n        opacity: 0;\r\n    }\r\n}\r\n.progress::-moz-progress-bar {\r\n    border-radius: var(--rounded-box, 1rem);\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-bg-opacity)));\r\n}\r\n.progress-primary::-moz-progress-bar {\r\n    border-radius: var(--rounded-box, 1rem);\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-p,oklch(var(--p)/var(--tw-bg-opacity)));\r\n}\r\n.progress:indeterminate {\r\n    --progress-color: var(--fallback-bc,oklch(var(--bc)/1));\r\n    background-image: repeating-linear-gradient(\n    90deg,\n    var(--progress-color) -1%,\n    var(--progress-color) 10%,\n    transparent 10%,\n    transparent 90%\n  );\r\n    background-size: 200%;\r\n    background-position-x: 15%;\r\n    animation: progress-loading 5s ease-in-out infinite;\r\n}\r\n.progress-primary:indeterminate {\r\n    --progress-color: var(--fallback-p,oklch(var(--p)/1));\r\n}\r\n.progress::-webkit-progress-bar {\r\n    border-radius: var(--rounded-box, 1rem);\r\n    background-color: transparent;\r\n}\r\n.progress::-webkit-progress-value {\r\n    border-radius: var(--rounded-box, 1rem);\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-bg-opacity)));\r\n}\r\n.progress-primary::-webkit-progress-value {\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-p,oklch(var(--p)/var(--tw-bg-opacity)));\r\n}\r\n.progress:indeterminate::-moz-progress-bar {\r\n    background-color: transparent;\r\n    background-image: repeating-linear-gradient(\n    90deg,\n    var(--progress-color) -1%,\n    var(--progress-color) 10%,\n    transparent 10%,\n    transparent 90%\n  );\r\n    background-size: 200%;\r\n    background-position-x: 15%;\r\n    animation: progress-loading 5s ease-in-out infinite;\r\n}\r\n@keyframes progress-loading {\r\n    50% {\r\n        background-position-x: -115%;\r\n    }\r\n}\r\n@keyframes radiomark {\r\n    0% {\r\n        box-shadow: 0 0 0 12px var(--fallback-b1,oklch(var(--b1)/1)) inset,\n      0 0 0 12px var(--fallback-b1,oklch(var(--b1)/1)) inset;\r\n    }\r\n    50% {\r\n        box-shadow: 0 0 0 3px var(--fallback-b1,oklch(var(--b1)/1)) inset,\n      0 0 0 3px var(--fallback-b1,oklch(var(--b1)/1)) inset;\r\n    }\r\n    100% {\r\n        box-shadow: 0 0 0 4px var(--fallback-b1,oklch(var(--b1)/1)) inset,\n      0 0 0 4px var(--fallback-b1,oklch(var(--b1)/1)) inset;\r\n    }\r\n}\r\n@keyframes rating-pop {\r\n    0% {\r\n        transform: translateY(-0.125em);\r\n    }\r\n    40% {\r\n        transform: translateY(-0.125em);\r\n    }\r\n    100% {\r\n        transform: translateY(0);\r\n    }\r\n}\r\n.select:focus {\r\n    box-shadow: none;\r\n    border-color: var(--fallback-bc,oklch(var(--bc)/0.2));\r\n    outline-style: solid;\r\n    outline-width: 2px;\r\n    outline-offset: 2px;\r\n    outline-color: var(--fallback-bc,oklch(var(--bc)/0.2));\r\n}\r\n.select-warning {\r\n    --tw-border-opacity: 1;\r\n    border-color: var(--fallback-wa,oklch(var(--wa)/var(--tw-border-opacity)));\r\n}\r\n.select-warning:focus {\r\n    --tw-border-opacity: 1;\r\n    border-color: var(--fallback-wa,oklch(var(--wa)/var(--tw-border-opacity)));\r\n    outline-color: var(--fallback-wa,oklch(var(--wa)/1));\r\n}\r\n.select-disabled,\n  .select:disabled,\n  .select[disabled] {\r\n    cursor: not-allowed;\r\n    --tw-border-opacity: 1;\r\n    border-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-border-opacity)));\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity)));\r\n    color: var(--fallback-bc,oklch(var(--bc)/0.4));\r\n}\r\n.select-disabled::-moz-placeholder, .select:disabled::-moz-placeholder, .select[disabled]::-moz-placeholder {\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-placeholder-opacity)));\r\n    --tw-placeholder-opacity: 0.2;\r\n}\r\n.select-disabled::placeholder,\n  .select:disabled::placeholder,\n  .select[disabled]::placeholder {\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-placeholder-opacity)));\r\n    --tw-placeholder-opacity: 0.2;\r\n}\r\n.select-multiple,\n  .select[multiple],\n  .select[size].select:not([size=\"1\"]) {\r\n    background-image: none;\r\n    padding-right: 1rem;\r\n}\r\n[dir=\"rtl\"] .select {\r\n    background-position: calc(0% + 12px) calc(1px + 50%),\n    calc(0% + 16px) calc(1px + 50%);\r\n}\r\n@keyframes skeleton {\r\n    from {\r\n        background-position: 150%;\r\n    }\r\n    to {\r\n        background-position: -50%;\r\n    }\r\n}\r\n.table:where([dir=\"rtl\"], [dir=\"rtl\"] *) {\r\n    text-align: right;\r\n}\r\n.table :where(th, td) {\r\n    padding-left: 1rem;\r\n    padding-right: 1rem;\r\n    padding-top: 0.75rem;\r\n    padding-bottom: 0.75rem;\r\n    vertical-align: middle;\r\n}\r\n.table tr.active,\n  .table tr.active:nth-child(even),\n  .table-zebra tbody tr:nth-child(even) {\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity)));\r\n}\r\n.table :where(thead tr, tbody tr:not(:last-child), tbody tr:first-child:last-child) {\r\n    border-bottom-width: 1px;\r\n    --tw-border-opacity: 1;\r\n    border-bottom-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-border-opacity)));\r\n}\r\n.table :where(thead, tfoot) {\r\n    white-space: nowrap;\r\n    font-size: 0.75rem;\r\n    line-height: 1rem;\r\n    font-weight: 700;\r\n    color: var(--fallback-bc,oklch(var(--bc)/0.6));\r\n}\r\n.table :where(tfoot) {\r\n    border-top-width: 1px;\r\n    --tw-border-opacity: 1;\r\n    border-top-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-border-opacity)));\r\n}\r\n.toast > * {\r\n    animation: toast-pop 0.25s ease-out;\r\n}\r\n@keyframes toast-pop {\r\n    0% {\r\n        transform: scale(0.9);\r\n        opacity: 0;\r\n    }\r\n    100% {\r\n        transform: scale(1);\r\n        opacity: 1;\r\n    }\r\n}\r\n[dir=\"rtl\"] .toggle {\r\n    --handleoffsetcalculator: calc(var(--handleoffset) * 1);\r\n}\r\n.toggle:focus-visible {\r\n    outline-style: solid;\r\n    outline-width: 2px;\r\n    outline-offset: 2px;\r\n    outline-color: var(--fallback-bc,oklch(var(--bc)/0.2));\r\n}\r\n.toggle:hover {\r\n    background-color: currentColor;\r\n}\r\n.toggle:checked,\n  .toggle[aria-checked=\"true\"] {\r\n    background-image: none;\r\n    --handleoffsetcalculator: var(--handleoffset);\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\r\n}\r\n[dir=\"rtl\"] .toggle:checked, [dir=\"rtl\"] .toggle[aria-checked=\"true\"] {\r\n    --handleoffsetcalculator: calc(var(--handleoffset) * -1);\r\n}\r\n.toggle:indeterminate {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\r\n    box-shadow: calc(var(--handleoffset) / 2) 0 0 2px var(--tglbg) inset,\n      calc(var(--handleoffset) / -2) 0 0 2px var(--tglbg) inset,\n      0 0 0 2px var(--tglbg) inset;\r\n}\r\n[dir=\"rtl\"] .toggle:indeterminate {\r\n    box-shadow: calc(var(--handleoffset) / 2) 0 0 2px var(--tglbg) inset,\n        calc(var(--handleoffset) / -2) 0 0 2px var(--tglbg) inset,\n        0 0 0 2px var(--tglbg) inset;\r\n}\r\n.toggle-primary:focus-visible {\r\n    outline-color: var(--fallback-p,oklch(var(--p)/1));\r\n}\r\n.toggle-primary:checked,\n    .toggle-primary[aria-checked=\"true\"] {\r\n    border-color: var(--fallback-p,oklch(var(--p)/var(--tw-border-opacity)));\r\n    --tw-border-opacity: 0.1;\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-p,oklch(var(--p)/var(--tw-bg-opacity)));\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-pc,oklch(var(--pc)/var(--tw-text-opacity)));\r\n}\r\n.toggle:disabled {\r\n    cursor: not-allowed;\r\n    --tw-border-opacity: 1;\r\n    border-color: var(--fallback-bc,oklch(var(--bc)/var(--tw-border-opacity)));\r\n    background-color: transparent;\r\n    opacity: 0.3;\r\n    --togglehandleborder: 0 0 0 3px var(--fallback-bc,oklch(var(--bc)/1)) inset,\n      var(--handleoffsetcalculator) 0 0 3px var(--fallback-bc,oklch(var(--bc)/1)) inset;\r\n}\r\n.glass,\n  .glass.btn-active {\r\n    border: none;\r\n    -webkit-backdrop-filter: blur(var(--glass-blur, 40px));\r\n            backdrop-filter: blur(var(--glass-blur, 40px));\r\n    background-color: transparent;\r\n    background-image: linear-gradient(\n        135deg,\n        rgb(255 255 255 / var(--glass-opacity, 30%)) 0%,\n        rgb(0 0 0 / 0%) 100%\n      ),\n      linear-gradient(\n        var(--glass-reflex-degree, 100deg),\n        rgb(255 255 255 / var(--glass-reflex-opacity, 10%)) 25%,\n        rgb(0 0 0 / 0%) 25%\n      );\r\n    box-shadow: 0 0 0 1px rgb(255 255 255 / var(--glass-border-opacity, 10%)) inset,\n      0 0 0 2px rgb(0 0 0 / 5%);\r\n    text-shadow: 0 1px rgb(0 0 0 / var(--glass-text-shadow-opacity, 5%));\r\n}\r\n@media (hover: hover) {\r\n    .glass.btn-active {\r\n        border: none;\r\n        -webkit-backdrop-filter: blur(var(--glass-blur, 40px));\r\n                backdrop-filter: blur(var(--glass-blur, 40px));\r\n        background-color: transparent;\r\n        background-image: linear-gradient(\n          135deg,\n          rgb(255 255 255 / var(--glass-opacity, 30%)) 0%,\n          rgb(0 0 0 / 0%) 100%\n        ),\n        linear-gradient(\n          var(--glass-reflex-degree, 100deg),\n          rgb(255 255 255 / var(--glass-reflex-opacity, 10%)) 25%,\n          rgb(0 0 0 / 0%) 25%\n        );\r\n        box-shadow: 0 0 0 1px rgb(255 255 255 / var(--glass-border-opacity, 10%)) inset,\n        0 0 0 2px rgb(0 0 0 / 5%);\r\n        text-shadow: 0 1px rgb(0 0 0 / var(--glass-text-shadow-opacity, 5%));\r\n    }\r\n}\r\n.btn-xs {\r\n    height: 1.5rem;\r\n    min-height: 1.5rem;\r\n    padding-left: 0.5rem;\r\n    padding-right: 0.5rem;\r\n    font-size: 0.75rem;\r\n}\r\n.btn-sm {\r\n    height: 2rem;\r\n    min-height: 2rem;\r\n    padding-left: 0.75rem;\r\n    padding-right: 0.75rem;\r\n    font-size: 0.875rem;\r\n}\r\n.btn-lg {\r\n    height: 4rem;\r\n    min-height: 4rem;\r\n    padding-left: 1.5rem;\r\n    padding-right: 1.5rem;\r\n    font-size: 1.125rem;\r\n}\r\n.btn-square:where(.btn-xs) {\r\n    height: 1.5rem;\r\n    width: 1.5rem;\r\n    padding: 0px;\r\n}\r\n.btn-square:where(.btn-sm) {\r\n    height: 2rem;\r\n    width: 2rem;\r\n    padding: 0px;\r\n}\r\n.btn-square:where(.btn-lg) {\r\n    height: 4rem;\r\n    width: 4rem;\r\n    padding: 0px;\r\n}\r\n.btn-circle:where(.btn-xs) {\r\n    height: 1.5rem;\r\n    width: 1.5rem;\r\n    border-radius: 9999px;\r\n    padding: 0px;\r\n}\r\n.btn-circle:where(.btn-sm) {\r\n    height: 2rem;\r\n    width: 2rem;\r\n    border-radius: 9999px;\r\n    padding: 0px;\r\n}\r\n.btn-circle:where(.btn-lg) {\r\n    height: 4rem;\r\n    width: 4rem;\r\n    border-radius: 9999px;\r\n    padding: 0px;\r\n}\r\n.input-sm {\r\n    height: 2rem;\r\n    padding-left: 0.75rem;\r\n    padding-right: 0.75rem;\r\n    font-size: 0.875rem;\r\n    line-height: 2rem;\r\n}\r\n.join.join-vertical {\r\n    flex-direction: column;\r\n}\r\n.join.join-vertical .join-item:first-child:not(:last-child),\n  .join.join-vertical *:first-child:not(:last-child) .join-item {\r\n    border-end-start-radius: 0;\r\n    border-end-end-radius: 0;\r\n    border-start-start-radius: inherit;\r\n    border-start-end-radius: inherit;\r\n}\r\n.join.join-vertical .join-item:last-child:not(:first-child),\n  .join.join-vertical *:last-child:not(:first-child) .join-item {\r\n    border-start-start-radius: 0;\r\n    border-start-end-radius: 0;\r\n    border-end-start-radius: inherit;\r\n    border-end-end-radius: inherit;\r\n}\r\n.join.join-horizontal {\r\n    flex-direction: row;\r\n}\r\n.join.join-horizontal .join-item:first-child:not(:last-child),\n  .join.join-horizontal *:first-child:not(:last-child) .join-item {\r\n    border-end-end-radius: 0;\r\n    border-start-end-radius: 0;\r\n    border-end-start-radius: inherit;\r\n    border-start-start-radius: inherit;\r\n}\r\n.join.join-horizontal .join-item:last-child:not(:first-child),\n  .join.join-horizontal *:last-child:not(:first-child) .join-item {\r\n    border-end-start-radius: 0;\r\n    border-start-start-radius: 0;\r\n    border-end-end-radius: inherit;\r\n    border-start-end-radius: inherit;\r\n}\r\n.menu-horizontal {\r\n    display: inline-flex;\r\n    flex-direction: row;\r\n}\r\n.menu-horizontal > li:not(.menu-title) > details > ul {\r\n    position: absolute;\r\n}\r\n.select-sm {\r\n    height: 2rem;\r\n    min-height: 2rem;\r\n    padding-left: 0.75rem;\r\n    padding-right: 2rem;\r\n    font-size: 0.875rem;\r\n    line-height: 2rem;\r\n}\r\n[dir=\"rtl\"] .select-sm {\r\n    padding-left: 2rem;\r\n    padding-right: 0.75rem;\r\n}\r\n:where(.toast) {\r\n    bottom: 0px;\r\n    inset-inline-end: 0px;\r\n    inset-inline-start: auto;\r\n    top: auto;\r\n    --tw-translate-x: 0px;\r\n    --tw-translate-y: 0px;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n}\r\n.toast:where(.toast-start) {\r\n    inset-inline-end: auto;\r\n    inset-inline-start: 0px;\r\n    --tw-translate-x: 0px;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n}\r\n.toast:where(.toast-center) {\r\n    inset-inline-end: 50%;\r\n    inset-inline-start: 50%;\r\n    --tw-translate-x: -50%;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n}\r\n.toast:where(.toast-center):where([dir=\"rtl\"], [dir=\"rtl\"] *) {\r\n    --tw-translate-x: 50%;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n}\r\n.toast:where(.toast-end) {\r\n    inset-inline-end: 0px;\r\n    inset-inline-start: auto;\r\n    --tw-translate-x: 0px;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n}\r\n.toast:where(.toast-bottom) {\r\n    bottom: 0px;\r\n    top: auto;\r\n    --tw-translate-y: 0px;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n}\r\n.toast:where(.toast-middle) {\r\n    bottom: auto;\r\n    top: 50%;\r\n    --tw-translate-y: -50%;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n}\r\n.toast:where(.toast-top) {\r\n    bottom: auto;\r\n    top: 0px;\r\n    --tw-translate-y: 0px;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n}\r\n.tooltip {\r\n    position: relative;\r\n    display: inline-block;\r\n    --tooltip-offset: calc(100% + 1px + var(--tooltip-tail, 0px));\r\n}\r\n.tooltip:before {\r\n    position: absolute;\r\n    pointer-events: none;\r\n    z-index: 1;\r\n    content: var(--tw-content);\r\n    --tw-content: attr(data-tip);\r\n}\r\n.tooltip:before, .tooltip-top:before {\r\n    transform: translateX(-50%);\r\n    top: auto;\r\n    left: 50%;\r\n    right: auto;\r\n    bottom: var(--tooltip-offset);\r\n}\r\n.tooltip-bottom:before {\r\n    transform: translateX(-50%);\r\n    top: var(--tooltip-offset);\r\n    left: 50%;\r\n    right: auto;\r\n    bottom: auto;\r\n}\r\n.tooltip-left:before {\r\n    transform: translateY(-50%);\r\n    top: 50%;\r\n    left: auto;\r\n    right: var(--tooltip-offset);\r\n    bottom: auto;\r\n}\r\n.tooltip-right:before {\r\n    transform: translateY(-50%);\r\n    top: 50%;\r\n    left: var(--tooltip-offset);\r\n    right: auto;\r\n    bottom: auto;\r\n}\r\n.avatar.online:before {\r\n    content: \"\";\r\n    position: absolute;\r\n    z-index: 10;\r\n    display: block;\r\n    border-radius: 9999px;\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-su,oklch(var(--su)/var(--tw-bg-opacity)));\r\n    outline-style: solid;\r\n    outline-width: 2px;\r\n    outline-color: var(--fallback-b1,oklch(var(--b1)/1));\r\n    width: 15%;\r\n    height: 15%;\r\n    top: 7%;\r\n    right: 7%;\r\n}\r\n.avatar.offline:before {\r\n    content: \"\";\r\n    position: absolute;\r\n    z-index: 10;\r\n    display: block;\r\n    border-radius: 9999px;\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b3,oklch(var(--b3)/var(--tw-bg-opacity)));\r\n    outline-style: solid;\r\n    outline-width: 2px;\r\n    outline-color: var(--fallback-b1,oklch(var(--b1)/1));\r\n    width: 15%;\r\n    height: 15%;\r\n    top: 7%;\r\n    right: 7%;\r\n}\r\n.card-compact .card-body {\r\n    padding: 1rem;\r\n    font-size: 0.875rem;\r\n    line-height: 1.25rem;\r\n}\r\n.card-compact .card-title {\r\n    margin-bottom: 0.25rem;\r\n}\r\n.card-normal .card-body {\r\n    padding: var(--padding-card, 2rem);\r\n    font-size: 1rem;\r\n    line-height: 1.5rem;\r\n}\r\n.card-normal .card-title {\r\n    margin-bottom: 0.75rem;\r\n}\r\n.join.join-vertical > :where(*:not(:first-child)) {\r\n    margin-left: 0px;\r\n    margin-right: 0px;\r\n    margin-top: -1px;\r\n}\r\n.join.join-vertical > :where(*:not(:first-child)):is(.btn) {\r\n    margin-top: calc(var(--border-btn) * -1);\r\n}\r\n.join.join-horizontal > :where(*:not(:first-child)) {\r\n    margin-top: 0px;\r\n    margin-bottom: 0px;\r\n    margin-inline-start: -1px;\r\n}\r\n.join.join-horizontal > :where(*:not(:first-child)):is(.btn) {\r\n    margin-inline-start: calc(var(--border-btn) * -1);\r\n    margin-top: 0px;\r\n}\r\n.menu-horizontal > li:not(.menu-title) > details > ul {\r\n    margin-inline-start: 0px;\r\n    margin-top: 1rem;\r\n    padding-top: 0.5rem;\r\n    padding-bottom: 0.5rem;\r\n    padding-inline-end: 0.5rem;\r\n}\r\n.menu-horizontal > li > details > ul:before {\r\n    content: none;\r\n}\r\n:where(.menu-horizontal > li:not(.menu-title) > details > ul) {\r\n    border-radius: var(--rounded-box, 1rem);\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\r\n    --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);\r\n    --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);\r\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\r\n}\r\n.menu-sm :where(li:not(.menu-title) > *:not(ul, details, .menu-title)), .menu-sm :where(li:not(.menu-title) > details > summary:not(.menu-title)) {\r\n    border-radius: var(--rounded-btn, 0.5rem);\r\n    padding-left: 0.75rem;\r\n    padding-right: 0.75rem;\r\n    padding-top: 0.25rem;\r\n    padding-bottom: 0.25rem;\r\n    font-size: 0.875rem;\r\n    line-height: 1.25rem;\r\n}\r\n.menu-sm .menu-title {\r\n    padding-left: 0.75rem;\r\n    padding-right: 0.75rem;\r\n    padding-top: 0.5rem;\r\n    padding-bottom: 0.5rem;\r\n}\r\n.modal-top :where(.modal-box) {\r\n    width: 100%;\r\n    max-width: none;\r\n    --tw-translate-y: -2.5rem;\r\n    --tw-scale-x: 1;\r\n    --tw-scale-y: 1;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n    border-bottom-right-radius: var(--rounded-box, 1rem);\r\n    border-bottom-left-radius: var(--rounded-box, 1rem);\r\n    border-top-left-radius: 0px;\r\n    border-top-right-radius: 0px;\r\n}\r\n.modal-middle :where(.modal-box) {\r\n    width: 91.666667%;\r\n    max-width: 32rem;\r\n    --tw-translate-y: 0px;\r\n    --tw-scale-x: .9;\r\n    --tw-scale-y: .9;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n    border-top-left-radius: var(--rounded-box, 1rem);\r\n    border-top-right-radius: var(--rounded-box, 1rem);\r\n    border-bottom-right-radius: var(--rounded-box, 1rem);\r\n    border-bottom-left-radius: var(--rounded-box, 1rem);\r\n}\r\n.modal-bottom :where(.modal-box) {\r\n    width: 100%;\r\n    max-width: none;\r\n    --tw-translate-y: 2.5rem;\r\n    --tw-scale-x: 1;\r\n    --tw-scale-y: 1;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n    border-top-left-radius: var(--rounded-box, 1rem);\r\n    border-top-right-radius: var(--rounded-box, 1rem);\r\n    border-bottom-right-radius: 0px;\r\n    border-bottom-left-radius: 0px;\r\n}\r\n.tooltip {\r\n    position: relative;\r\n    display: inline-block;\r\n    text-align: center;\r\n    --tooltip-tail: 0.1875rem;\r\n    --tooltip-color: var(--fallback-n,oklch(var(--n)/1));\r\n    --tooltip-text-color: var(--fallback-nc,oklch(var(--nc)/1));\r\n    --tooltip-tail-offset: calc(100% + 0.0625rem - var(--tooltip-tail));\r\n}\r\n.tooltip:before,\n.tooltip:after {\r\n    opacity: 0;\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\r\n    transition-delay: 100ms;\r\n    transition-duration: 200ms;\r\n    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\r\n}\r\n.tooltip:after {\r\n    position: absolute;\r\n    content: \"\";\r\n    border-style: solid;\r\n    border-width: var(--tooltip-tail, 0);\r\n    width: 0;\r\n    height: 0;\r\n    display: block;\r\n}\r\n.tooltip:before {\r\n    max-width: 20rem;\r\n    white-space: normal;\r\n    border-radius: 0.25rem;\r\n    padding-left: 0.5rem;\r\n    padding-right: 0.5rem;\r\n    padding-top: 0.25rem;\r\n    padding-bottom: 0.25rem;\r\n    font-size: 0.875rem;\r\n    line-height: 1.25rem;\r\n    background-color: var(--tooltip-color);\r\n    color: var(--tooltip-text-color);\r\n    width: -moz-max-content;\r\n    width: max-content;\r\n}\r\n.tooltip.tooltip-open:before {\r\n    opacity: 1;\r\n    transition-delay: 75ms;\r\n}\r\n.tooltip.tooltip-open:after {\r\n    opacity: 1;\r\n    transition-delay: 75ms;\r\n}\r\n.tooltip:hover:before {\r\n    opacity: 1;\r\n    transition-delay: 75ms;\r\n}\r\n.tooltip:hover:after {\r\n    opacity: 1;\r\n    transition-delay: 75ms;\r\n}\r\n.tooltip:has(:focus-visible):after,\n.tooltip:has(:focus-visible):before {\r\n    opacity: 1;\r\n    transition-delay: 75ms;\r\n}\r\n.tooltip:not([data-tip]):hover:before,\n.tooltip:not([data-tip]):hover:after {\r\n    visibility: hidden;\r\n    opacity: 0;\r\n}\r\n.tooltip:after, .tooltip-top:after {\r\n    transform: translateX(-50%);\r\n    border-color: var(--tooltip-color) transparent transparent transparent;\r\n    top: auto;\r\n    left: 50%;\r\n    right: auto;\r\n    bottom: var(--tooltip-tail-offset);\r\n}\r\n.tooltip-bottom:after {\r\n    transform: translateX(-50%);\r\n    border-color: transparent transparent var(--tooltip-color) transparent;\r\n    top: var(--tooltip-tail-offset);\r\n    left: 50%;\r\n    right: auto;\r\n    bottom: auto;\r\n}\r\n.tooltip-left:after {\r\n    transform: translateY(-50%);\r\n    border-color: transparent transparent transparent var(--tooltip-color);\r\n    top: 50%;\r\n    left: auto;\r\n    right: calc(var(--tooltip-tail-offset) + 0.0625rem);\r\n    bottom: auto;\r\n}\r\n.tooltip-right:after {\r\n    transform: translateY(-50%);\r\n    border-color: transparent var(--tooltip-color) transparent transparent;\r\n    top: 50%;\r\n    left: calc(var(--tooltip-tail-offset) + 0.0625rem);\r\n    right: auto;\r\n    bottom: auto;\r\n}\r\n.fixed {\r\n    position: fixed;\r\n}\r\n.absolute {\r\n    position: absolute;\r\n}\r\n.relative {\r\n    position: relative;\r\n}\r\n.-top-5 {\r\n    top: -1.25rem;\r\n}\r\n.bottom-1\\/2 {\r\n    bottom: 50%;\r\n}\r\n.bottom-12 {\r\n    bottom: 3rem;\r\n}\r\n.left-0 {\r\n    left: 0px;\r\n}\r\n.left-1\\/2 {\r\n    left: 50%;\r\n}\r\n.right-0 {\r\n    right: 0px;\r\n}\r\n.right-12 {\r\n    right: 3rem;\r\n}\r\n.top-32 {\r\n    top: 8rem;\r\n}\r\n.isolate {\r\n    isolation: isolate;\r\n}\r\n.z-10 {\r\n    z-index: 10;\r\n}\r\n.z-40 {\r\n    z-index: 40;\r\n}\r\n.z-50 {\r\n    z-index: 50;\r\n}\r\n.z-\\[1\\] {\r\n    z-index: 1;\r\n}\r\n.m-0 {\r\n    margin: 0px;\r\n}\r\n.mx-auto {\r\n    margin-left: auto;\r\n    margin-right: auto;\r\n}\r\n.my-3 {\r\n    margin-top: 0.75rem;\r\n    margin-bottom: 0.75rem;\r\n}\r\n.mb-0 {\r\n    margin-bottom: 0px;\r\n}\r\n.mb-10 {\r\n    margin-bottom: 2.5rem;\r\n}\r\n.mb-12 {\r\n    margin-bottom: 3rem;\r\n}\r\n.mb-3 {\r\n    margin-bottom: 0.75rem;\r\n}\r\n.mb-6 {\r\n    margin-bottom: 1.5rem;\r\n}\r\n.mb-8 {\r\n    margin-bottom: 2rem;\r\n}\r\n.ml-1 {\r\n    margin-left: 0.25rem;\r\n}\r\n.ml-3 {\r\n    margin-left: 0.75rem;\r\n}\r\n.mr-12 {\r\n    margin-right: 3rem;\r\n}\r\n.mr-2 {\r\n    margin-right: 0.5rem;\r\n}\r\n.mr-3 {\r\n    margin-right: 0.75rem;\r\n}\r\n.mt-2 {\r\n    margin-top: 0.5rem;\r\n}\r\n.mt-3 {\r\n    margin-top: 0.75rem;\r\n}\r\n.mt-5 {\r\n    margin-top: 1.25rem;\r\n}\r\n.mt-9 {\r\n    margin-top: 2.25rem;\r\n}\r\n.box-content {\r\n    box-sizing: content-box;\r\n}\r\n.block {\r\n    display: block;\r\n}\r\n.flex {\r\n    display: flex;\r\n}\r\n.table {\r\n    display: table;\r\n}\r\n.grid {\r\n    display: grid;\r\n}\r\n.hidden {\r\n    display: none;\r\n}\r\n.h-10 {\r\n    height: 2.5rem;\r\n}\r\n.h-12 {\r\n    height: 3rem;\r\n}\r\n.h-14 {\r\n    height: 3.5rem;\r\n}\r\n.h-20 {\r\n    height: 5rem;\r\n}\r\n.h-24 {\r\n    height: 6rem;\r\n}\r\n.h-5 {\r\n    height: 1.25rem;\r\n}\r\n.h-6 {\r\n    height: 1.5rem;\r\n}\r\n.h-8 {\r\n    height: 2rem;\r\n}\r\n.h-auto {\r\n    height: auto;\r\n}\r\n.h-full {\r\n    height: 100%;\r\n}\r\n.h-screen {\r\n    height: 100vh;\r\n}\r\n.min-h-\\[calc\\(100\\%-280px\\)\\] {\r\n    min-height: calc(100% - 280px);\r\n}\r\n.w-1\\/2 {\r\n    width: 50%;\r\n}\r\n.w-10 {\r\n    width: 2.5rem;\r\n}\r\n.w-12 {\r\n    width: 3rem;\r\n}\r\n.w-24 {\r\n    width: 6rem;\r\n}\r\n.w-28 {\r\n    width: 7rem;\r\n}\r\n.w-3\\/4 {\r\n    width: 75%;\r\n}\r\n.w-32 {\r\n    width: 8rem;\r\n}\r\n.w-5 {\r\n    width: 1.25rem;\r\n}\r\n.w-52 {\r\n    width: 13rem;\r\n}\r\n.w-56 {\r\n    width: 14rem;\r\n}\r\n.w-6 {\r\n    width: 1.5rem;\r\n}\r\n.w-64 {\r\n    width: 16rem;\r\n}\r\n.w-72 {\r\n    width: 18rem;\r\n}\r\n.w-8 {\r\n    width: 2rem;\r\n}\r\n.w-auto {\r\n    width: auto;\r\n}\r\n.w-full {\r\n    width: 100%;\r\n}\r\n.w-screen {\r\n    width: 100vw;\r\n}\r\n.min-w-56 {\r\n    min-width: 14rem;\r\n}\r\n.min-w-\\[600px\\] {\r\n    min-width: 600px;\r\n}\r\n.max-w-xs {\r\n    max-width: 20rem;\r\n}\r\n.flex-1 {\r\n    flex: 1 1 0%;\r\n}\r\n.-translate-x-1\\/2 {\r\n    --tw-translate-x: -50%;\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n}\r\n.transform {\r\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\r\n}\r\n.cursor-default {\r\n    cursor: default;\r\n}\r\n.cursor-pointer {\r\n    cursor: pointer;\r\n}\r\n.resize {\r\n    resize: both;\r\n}\r\n.flex-row {\r\n    flex-direction: row;\r\n}\r\n.flex-col {\r\n    flex-direction: column;\r\n}\r\n.flex-wrap {\r\n    flex-wrap: wrap;\r\n}\r\n.items-center {\r\n    align-items: center;\r\n}\r\n.justify-start {\r\n    justify-content: flex-start;\r\n}\r\n.justify-center {\r\n    justify-content: center;\r\n}\r\n.justify-between {\r\n    justify-content: space-between;\r\n}\r\n.gap-1 {\r\n    gap: 0.25rem;\r\n}\r\n.gap-10 {\r\n    gap: 2.5rem;\r\n}\r\n.gap-2 {\r\n    gap: 0.5rem;\r\n}\r\n.gap-24 {\r\n    gap: 6rem;\r\n}\r\n.gap-3 {\r\n    gap: 0.75rem;\r\n}\r\n.gap-6 {\r\n    gap: 1.5rem;\r\n}\r\n.gap-8 {\r\n    gap: 2rem;\r\n}\r\n.divide-y > :not([hidden]) ~ :not([hidden]) {\r\n    --tw-divide-y-reverse: 0;\r\n    border-top-width: calc(1px * calc(1 - var(--tw-divide-y-reverse)));\r\n    border-bottom-width: calc(1px * var(--tw-divide-y-reverse));\r\n}\r\n.overflow-hidden {\r\n    overflow: hidden;\r\n}\r\n.overflow-x-auto {\r\n    overflow-x: auto;\r\n}\r\n.overflow-y-auto {\r\n    overflow-y: auto;\r\n}\r\n.overflow-x-hidden {\r\n    overflow-x: hidden;\r\n}\r\n.text-ellipsis {\r\n    text-overflow: ellipsis;\r\n}\r\n.whitespace-nowrap {\r\n    white-space: nowrap;\r\n}\r\n.rounded {\r\n    border-radius: 0.25rem;\r\n}\r\n.rounded-box {\r\n    border-radius: var(--rounded-box, 1rem);\r\n}\r\n.rounded-full {\r\n    border-radius: 9999px;\r\n}\r\n.rounded-lg {\r\n    border-radius: 0.5rem;\r\n}\r\n.rounded-xl {\r\n    border-radius: 0.75rem;\r\n}\r\n.rounded-l-xl {\r\n    border-top-left-radius: 0.75rem;\r\n    border-bottom-left-radius: 0.75rem;\r\n}\r\n.rounded-r-lg {\r\n    border-top-right-radius: 0.5rem;\r\n    border-bottom-right-radius: 0.5rem;\r\n}\r\n.border {\r\n    border-width: 1px;\r\n}\r\n.border-solid {\r\n    border-style: solid;\r\n}\r\n.border-dotted {\r\n    border-style: dotted;\r\n}\r\n.border-none {\r\n    border-style: none;\r\n}\r\n.bg-base-100 {\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity, 1)));\r\n}\r\n.bg-base-200 {\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity, 1)));\r\n}\r\n.bg-blue-300\\/80 {\r\n    background-color: rgb(147 197 253 / 0.8);\r\n}\r\n.bg-gray-800\\/70 {\r\n    background-color: rgb(31 41 55 / 0.7);\r\n}\r\n.bg-slate-500\\/50 {\r\n    background-color: rgb(100 116 139 / 0.5);\r\n}\r\n.bg-slate-600\\/60 {\r\n    background-color: rgb(71 85 105 / 0.6);\r\n}\r\n.bg-slate-700 {\r\n    --tw-bg-opacity: 1;\r\n    background-color: rgb(51 65 85 / var(--tw-bg-opacity, 1));\r\n}\r\n.object-cover {\r\n    -o-object-fit: cover;\r\n       object-fit: cover;\r\n}\r\n.p-0 {\r\n    padding: 0px;\r\n}\r\n.p-10 {\r\n    padding: 2.5rem;\r\n}\r\n.p-2 {\r\n    padding: 0.5rem;\r\n}\r\n.p-6 {\r\n    padding: 1.5rem;\r\n}\r\n.px-1 {\r\n    padding-left: 0.25rem;\r\n    padding-right: 0.25rem;\r\n}\r\n.px-3 {\r\n    padding-left: 0.75rem;\r\n    padding-right: 0.75rem;\r\n}\r\n.py-2 {\r\n    padding-top: 0.5rem;\r\n    padding-bottom: 0.5rem;\r\n}\r\n.py-4 {\r\n    padding-top: 1rem;\r\n    padding-bottom: 1rem;\r\n}\r\n.py-6 {\r\n    padding-top: 1.5rem;\r\n    padding-bottom: 1.5rem;\r\n}\r\n.pb-2 {\r\n    padding-bottom: 0.5rem;\r\n}\r\n.pb-6 {\r\n    padding-bottom: 1.5rem;\r\n}\r\n.pb-8 {\r\n    padding-bottom: 2rem;\r\n}\r\n.pt-1 {\r\n    padding-top: 0.25rem;\r\n}\r\n.pt-12 {\r\n    padding-top: 3rem;\r\n}\r\n.pt-14 {\r\n    padding-top: 3.5rem;\r\n}\r\n.pt-5 {\r\n    padding-top: 1.25rem;\r\n}\r\n.text-center {\r\n    text-align: center;\r\n}\r\n.font-mono {\r\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\r\n}\r\n.text-4xl {\r\n    font-size: 2.25rem;\r\n    line-height: 2.5rem;\r\n}\r\n.text-lg {\r\n    font-size: 1.125rem;\r\n    line-height: 1.75rem;\r\n}\r\n.text-sm {\r\n    font-size: 0.875rem;\r\n    line-height: 1.25rem;\r\n}\r\n.text-xl {\r\n    font-size: 1.25rem;\r\n    line-height: 1.75rem;\r\n}\r\n.font-bold {\r\n    font-weight: 700;\r\n}\r\n.font-extrabold {\r\n    font-weight: 800;\r\n}\r\n.font-normal {\r\n    font-weight: 400;\r\n}\r\n.tracking-wide {\r\n    letter-spacing: 0.025em;\r\n}\r\n.text-base-content {\r\n    --tw-text-opacity: 1;\r\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity, 1)));\r\n}\r\n.text-gray-300\\/80 {\r\n    color: rgb(209 213 219 / 0.8);\r\n}\r\n.text-inherit {\r\n    color: inherit;\r\n}\r\n.text-red-400 {\r\n    --tw-text-opacity: 1;\r\n    color: rgb(248 113 113 / var(--tw-text-opacity, 1));\r\n}\r\n.text-red-500 {\r\n    --tw-text-opacity: 1;\r\n    color: rgb(239 68 68 / var(--tw-text-opacity, 1));\r\n}\r\n.no-underline {\r\n    text-decoration-line: none;\r\n}\r\n.opacity-0 {\r\n    opacity: 0;\r\n}\r\n.shadow {\r\n    --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\r\n    --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);\r\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\r\n}\r\n.shadow-2xl {\r\n    --tw-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);\r\n    --tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);\r\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\r\n}\r\n.shadow-lg {\r\n    --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\r\n    --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);\r\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\r\n}\r\n.shadow-xl {\r\n    --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);\r\n    --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);\r\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\r\n}\r\n.outline {\r\n    outline-style: solid;\r\n}\r\n.blur {\r\n    --tw-blur: blur(8px);\r\n    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\r\n}\r\n.filter {\r\n    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\r\n}\r\n.backdrop-filter {\r\n    -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\r\n    backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\r\n}\r\n.transition {\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\r\n    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\r\n    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\r\n    transition-duration: 150ms;\r\n}\r\n.transition-opacity {\r\n    transition-property: opacity;\r\n    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\r\n    transition-duration: 150ms;\r\n}\r\n.ease-in-out {\r\n    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\r\n}\r\n\r\nbody,\r\nhtml {\r\n    margin: 0;\r\n    padding: 0;\r\n    overflow-y: overlay;\r\n    overflow-y: hidden;\r\n    overflow-x: hidden;\r\n}\r\n\r\nul {\r\n    list-style: none;\r\n}\r\n\r\n/*  */\r\n::-webkit-scrollbar {\r\n    /**/\r\n    height: 10px;\r\n    width: 10px;\r\n    background: rgba(12, 9, 9, 0.1);\r\n    float: right;\r\n}\r\n\r\n::-webkit-scrollbar:hover {\r\n    background: rgba(0, 0, 0, 0.2);\r\n}\r\n\r\n/* .tables::-webkit-scrollbar-track {\r\n    background: rgb(239, 239, 239);\r\n    border-radius: 2px;\r\n  } */\r\n::-webkit-scrollbar-thumb {\r\n    /*  */\r\n    background: #909399;\r\n    border-radius: 6px;\r\n}\r\n\r\n::-webkit-scrollbar-thumb:hover {\r\n    /* Webkit browsers */\r\n    /* Firefox */\r\n    -ms-box-shadow: inset 1px 1px 1px rgba(0, 0, 0, 0.25);\r\n    /* IE9 */\r\n    -o-box-shadow: inset 1px 1px 1px rgba(0, 0, 0, 0.25);\r\n    /* Opera(Old) */\r\n    box-shadow: inset 1px 1px 1px rgba(0, 0, 0, 0.25);\r\n    /* IE9+, News */\r\n}\r\n\r\n.hover\\:h-14:hover {\r\n    height: 3.5rem;\r\n}\r\n\r\n.hover\\:w-14:hover {\r\n    width: 3.5rem;\r\n}\r\n\r\n.hover\\:bg-base-200:hover {\r\n    --tw-bg-opacity: 1;\r\n    background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity, 1)));\r\n}\r\n\r\n.hover\\:bg-slate-500\\/80:hover {\r\n    background-color: rgb(100 116 139 / 0.8);\r\n}\r\n\r\n.hover\\:bg-slate-600:hover {\r\n    --tw-bg-opacity: 1;\r\n    background-color: rgb(71 85 105 / var(--tw-bg-opacity, 1));\r\n}\r\n\r\n.hover\\:text-lg:hover {\r\n    font-size: 1.125rem;\r\n    line-height: 1.75rem;\r\n}\r\n\r\n.hover\\:text-blue-400:hover {\r\n    --tw-text-opacity: 1;\r\n    color: rgb(96 165 250 / var(--tw-text-opacity, 1));\r\n}\r\n\r\n.hover\\:text-blue-400\\/90:hover {\r\n    color: rgb(96 165 250 / 0.9);\r\n}\r\n\r\n.hover\\:text-gray-100:hover {\r\n    --tw-text-opacity: 1;\r\n    color: rgb(243 244 246 / var(--tw-text-opacity, 1));\r\n}\r\n\r\n.hover\\:opacity-80:hover {\r\n    opacity: 0.8;\r\n}\r\n\r\n@media not all and (min-width: 1024px) {\r\n    .max-lg\\:mx-auto {\r\n        margin-left: auto;\r\n        margin-right: auto;\r\n    }\r\n    .max-lg\\:w-0 {\r\n        width: 0px;\r\n    }\r\n    .max-lg\\:w-full {\r\n        width: 100%;\r\n    }\r\n}\r\n\r\n@media (min-width: 1024px) {\r\n    .lg\\:flex {\r\n        display: flex;\r\n    }\r\n    .lg\\:hidden {\r\n        display: none;\r\n    }\r\n    .lg\\:pl-12 {\r\n        padding-left: 3rem;\r\n    }\r\n}@media (prefers-color-scheme: dark) {\r\n\r\n    .markdown-body,\r\n    [data-theme=\"dark\"],\r\n    [data-theme=\"dracula\"] {\r\n        /*dark*/\r\n        color-scheme: dark;\r\n        --color-prettylights-syntax-comment: #8b949e;\r\n        --color-prettylights-syntax-constant: #79c0ff;\r\n        --color-prettylights-syntax-entity: #d2a8ff;\r\n        --color-prettylights-syntax-storage-modifier-import: #c9d1d9;\r\n        --color-prettylights-syntax-entity-tag: #7ee787;\r\n        --color-prettylights-syntax-keyword: #ff7b72;\r\n        --color-prettylights-syntax-string: #a5d6ff;\r\n        --color-prettylights-syntax-variable: #ffa657;\r\n        --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;\r\n        --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;\r\n        --color-prettylights-syntax-invalid-illegal-bg: #8e1519;\r\n        --color-prettylights-syntax-carriage-return-text: #f0f6fc;\r\n        --color-prettylights-syntax-carriage-return-bg: #b62324;\r\n        --color-prettylights-syntax-string-regexp: #7ee787;\r\n        --color-prettylights-syntax-markup-list: #f2cc60;\r\n        --color-prettylights-syntax-markup-heading: #1f6feb;\r\n        --color-prettylights-syntax-markup-italic: #c9d1d9;\r\n        --color-prettylights-syntax-markup-bold: #c9d1d9;\r\n        --color-prettylights-syntax-markup-deleted-text: #ffdcd7;\r\n        --color-prettylights-syntax-markup-deleted-bg: #67060c;\r\n        --color-prettylights-syntax-markup-inserted-text: #aff5b4;\r\n        --color-prettylights-syntax-markup-inserted-bg: #033a16;\r\n        --color-prettylights-syntax-markup-changed-text: #ffdfb6;\r\n        --color-prettylights-syntax-markup-changed-bg: #5a1e02;\r\n        --color-prettylights-syntax-markup-ignored-text: #c9d1d9;\r\n        --color-prettylights-syntax-markup-ignored-bg: #1158c7;\r\n        --color-prettylights-syntax-meta-diff-range: #d2a8ff;\r\n        --color-prettylights-syntax-brackethighlighter-angle: #8b949e;\r\n        --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;\r\n        --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;\r\n        --color-fg-default: #e6edf3;\r\n        --color-fg-muted: #848d97;\r\n        --color-fg-subtle: #6e7681;\r\n        --color-canvas-default: #0d1117;\r\n        --color-canvas-subtle: #161b22;\r\n        --color-border-default: #30363d;\r\n        --color-border-muted: #21262d;\r\n        --color-neutral-muted: rgba(110, 118, 129, 0.4);\r\n        --color-accent-fg: #2f81f7;\r\n        --color-accent-emphasis: #1f6feb;\r\n        --color-success-fg: #3fb950;\r\n        --color-success-emphasis: #238636;\r\n        --color-attention-fg: #d29922;\r\n        --color-attention-emphasis: #9e6a03;\r\n        --color-attention-subtle: rgba(187, 128, 9, 0.15);\r\n        --color-danger-fg: #f85149;\r\n        --color-danger-emphasis: #da3633;\r\n        --color-done-fg: #a371f7;\r\n        --color-done-emphasis: #8957e5;\r\n    }\r\n}\r\n\r\n@media (prefers-color-scheme: light) {\r\n\r\n    .markdown-body,\r\n    [data-theme=\"light\"] {\r\n        /*light*/\r\n        color-scheme: light;\r\n        --color-prettylights-syntax-comment: #57606a;\r\n        --color-prettylights-syntax-constant: #0550ae;\r\n        --color-prettylights-syntax-entity: #6639ba;\r\n        --color-prettylights-syntax-storage-modifier-import: #24292f;\r\n        --color-prettylights-syntax-entity-tag: #116329;\r\n        --color-prettylights-syntax-keyword: #cf222e;\r\n        --color-prettylights-syntax-string: #0a3069;\r\n        --color-prettylights-syntax-variable: #953800;\r\n        --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;\r\n        --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;\r\n        --color-prettylights-syntax-invalid-illegal-bg: #82071e;\r\n        --color-prettylights-syntax-carriage-return-text: #f6f8fa;\r\n        --color-prettylights-syntax-carriage-return-bg: #cf222e;\r\n        --color-prettylights-syntax-string-regexp: #116329;\r\n        --color-prettylights-syntax-markup-list: #3b2300;\r\n        --color-prettylights-syntax-markup-heading: #0550ae;\r\n        --color-prettylights-syntax-markup-italic: #24292f;\r\n        --color-prettylights-syntax-markup-bold: #24292f;\r\n        --color-prettylights-syntax-markup-deleted-text: #82071e;\r\n        --color-prettylights-syntax-markup-deleted-bg: #ffebe9;\r\n        --color-prettylights-syntax-markup-inserted-text: #116329;\r\n        --color-prettylights-syntax-markup-inserted-bg: #dafbe1;\r\n        --color-prettylights-syntax-markup-changed-text: #953800;\r\n        --color-prettylights-syntax-markup-changed-bg: #ffd8b5;\r\n        --color-prettylights-syntax-markup-ignored-text: #eaeef2;\r\n        --color-prettylights-syntax-markup-ignored-bg: #0550ae;\r\n        --color-prettylights-syntax-meta-diff-range: #8250df;\r\n        --color-prettylights-syntax-brackethighlighter-angle: #57606a;\r\n        --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;\r\n        --color-prettylights-syntax-constant-other-reference-link: #0a3069;\r\n        --color-fg-default: #1F2328;\r\n        --color-fg-muted: #656d76;\r\n        --color-fg-subtle: #6e7781;\r\n        --color-canvas-default: #ffffff;\r\n        --color-canvas-subtle: #f6f8fa;\r\n        --color-border-default: #d0d7de;\r\n        --color-border-muted: hsla(210, 18%, 87%, 1);\r\n        --color-neutral-muted: rgba(175, 184, 193, 0.2);\r\n        --color-accent-fg: #0969da;\r\n        --color-accent-emphasis: #0969da;\r\n        --color-success-fg: #1a7f37;\r\n        --color-success-emphasis: #1f883d;\r\n        --color-attention-fg: #9a6700;\r\n        --color-attention-emphasis: #9a6700;\r\n        --color-attention-subtle: #fff8c5;\r\n        --color-danger-fg: #d1242f;\r\n        --color-danger-emphasis: #cf222e;\r\n        --color-done-fg: #8250df;\r\n        --color-done-emphasis: #8250df;\r\n    }\r\n}\r\n\r\n.markdown-body {\r\n    -ms-text-size-adjust: 100%;\r\n    -webkit-text-size-adjust: 100%;\r\n    margin: 0;\r\n    color: var(--color-fg-default);\r\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Noto Sans\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\";\r\n    font-size: 16px;\r\n    line-height: 1.5;\r\n    word-wrap: break-word;\r\n}\r\n\r\n/*  dracula  */\r\nhtml[data-theme=\"dracula\"] .markdown-body {\r\n    color: #e6edf3 !important;\r\n}\r\n\r\nhtml[data-theme=\"dracula\"] .markdown-body p,\r\nhtml[data-theme=\"dracula\"] .markdown-body li,\r\nhtml[data-theme=\"dracula\"] .markdown-body td,\r\nhtml[data-theme=\"dracula\"] .markdown-body th,\r\nhtml[data-theme=\"dracula\"] .markdown-body div,\r\nhtml[data-theme=\"dracula\"] .markdown-body span {\r\n    color: #e6edf3 !important;\r\n}\r\n\r\nhtml[data-theme=\"dracula\"] .markdown-body h1,\r\nhtml[data-theme=\"dracula\"] .markdown-body h2,\r\nhtml[data-theme=\"dracula\"] .markdown-body h3,\r\nhtml[data-theme=\"dracula\"] .markdown-body h4,\r\nhtml[data-theme=\"dracula\"] .markdown-body h5,\r\nhtml[data-theme=\"dracula\"] .markdown-body h6 {\r\n    color: #e6edf3 !important;\r\n}\r\n\r\nhtml[data-theme=\"dracula\"] .markdown-body a {\r\n    color: #2f81f7 !important;\r\n}\r\n\r\nhtml[data-theme=\"dracula\"] .markdown-body code {\r\n    color: #e6edf3 !important;\r\n    background-color: rgba(110, 118, 129, 0.4) !important;\r\n}\r\n\r\n/*  dracula  */\r\nhtml[data-theme=\"dracula\"] .markdown-body table {\r\n    background-color: transparent !important;\r\n}\r\n\r\nhtml[data-theme=\"dracula\"] .markdown-body table tr {\r\n    background-color: #161b22 !important;\r\n    border-top: 1px solid #30363d !important;\r\n}\r\n\r\nhtml[data-theme=\"dracula\"] .markdown-body table tr:nth-child(2n) {\r\n    background-color: #0d1117 !important;\r\n}\r\n\r\nhtml[data-theme=\"dracula\"] .markdown-body table th,\r\nhtml[data-theme=\"dracula\"] .markdown-body table td {\r\n    color: #e6edf3 !important;\r\n    background-color: transparent !important;\r\n    border: 1px solid #30363d !important;\r\n}\r\n\r\nhtml[data-theme=\"dracula\"] .markdown-body table th {\r\n    background-color: #21262d !important;\r\n    color: #e6edf3 !important;\r\n    font-weight: 600 !important;\r\n}\r\n\r\n.markdown-body .octicon {\r\n    display: inline-block;\r\n    fill: currentColor;\r\n    vertical-align: text-bottom;\r\n}\r\n\r\n.markdown-body h1:hover .anchor .octicon-link:before,\r\n.markdown-body h2:hover .anchor .octicon-link:before,\r\n.markdown-body h3:hover .anchor .octicon-link:before,\r\n.markdown-body h4:hover .anchor .octicon-link:before,\r\n.markdown-body h5:hover .anchor .octicon-link:before,\r\n.markdown-body h6:hover .anchor .octicon-link:before {\r\n    width: 16px;\r\n    height: 16px;\r\n    content: ' ';\r\n    display: inline-block;\r\n    background-color: currentColor;\r\n    -webkit-mask-image: url(\"data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>\");\r\n    mask-image: url(\"data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>\");\r\n}\r\n\r\n.markdown-body details,\r\n.markdown-body figcaption,\r\n.markdown-body figure {\r\n    display: block;\r\n}\r\n\r\n.markdown-body summary {\r\n    display: list-item;\r\n}\r\n\r\n.markdown-body [hidden] {\r\n    display: none !important;\r\n}\r\n\r\n.markdown-body a {\r\n    background-color: transparent;\r\n    color: var(--color-accent-fg);\r\n    text-decoration: none;\r\n}\r\n\r\n.markdown-body abbr[title] {\r\n    border-bottom: none;\r\n    -webkit-text-decoration: underline dotted;\r\n    text-decoration: underline dotted;\r\n}\r\n\r\n.markdown-body b,\r\n.markdown-body strong {\r\n    font-weight: var(--base-text-weight-semibold, 600);\r\n}\r\n\r\n.markdown-body dfn {\r\n    font-style: italic;\r\n}\r\n\r\n.markdown-body h1 {\r\n    margin: .67em 0;\r\n    font-weight: var(--base-text-weight-semibold, 600);\r\n    padding-bottom: .3em;\r\n    font-size: 2em;\r\n    border-bottom: 1px solid var(--color-border-muted);\r\n}\r\n\r\n.markdown-body mark {\r\n    background-color: var(--color-attention-subtle);\r\n    color: var(--color-fg-default);\r\n}\r\n\r\n.markdown-body small {\r\n    font-size: 90%;\r\n}\r\n\r\n.markdown-body sub,\r\n.markdown-body sup {\r\n    font-size: 75%;\r\n    line-height: 0;\r\n    position: relative;\r\n    vertical-align: baseline;\r\n}\r\n\r\n.markdown-body sub {\r\n    bottom: -0.25em;\r\n}\r\n\r\n.markdown-body sup {\r\n    top: -0.5em;\r\n}\r\n\r\n.markdown-body img {\r\n    border-style: none;\r\n    max-width: 100%;\r\n    box-sizing: content-box;\r\n    background-color: var(--color-canvas-default);\r\n}\r\n\r\n.markdown-body code,\r\n.markdown-body kbd,\r\n.markdown-body pre,\r\n.markdown-body samp {\r\n    font-family: monospace;\r\n    font-size: 1em;\r\n}\r\n\r\n.markdown-body figure {\r\n    margin: 1em 40px;\r\n}\r\n\r\n.markdown-body hr {\r\n    box-sizing: content-box;\r\n    overflow: hidden;\r\n    background: transparent;\r\n    border-bottom: 1px solid var(--color-border-muted);\r\n    height: .25em;\r\n    padding: 0;\r\n    margin: 24px 0;\r\n    background-color: var(--color-border-default);\r\n    border: 0;\r\n}\r\n\r\n.markdown-body input {\r\n    font: inherit;\r\n    margin: 0;\r\n    overflow: visible;\r\n    font-family: inherit;\r\n    font-size: inherit;\r\n    line-height: inherit;\r\n}\r\n\r\n.markdown-body [type=button],\r\n.markdown-body [type=reset],\r\n.markdown-body [type=submit] {\r\n    -webkit-appearance: button;\r\n    -moz-appearance: button;\r\n         appearance: button;\r\n}\r\n\r\n.markdown-body [type=checkbox],\r\n.markdown-body [type=radio] {\r\n    box-sizing: border-box;\r\n    padding: 0;\r\n}\r\n\r\n.markdown-body [type=number]::-webkit-inner-spin-button,\r\n.markdown-body [type=number]::-webkit-outer-spin-button {\r\n    height: auto;\r\n}\r\n\r\n.markdown-body [type=search]::-webkit-search-cancel-button,\r\n.markdown-body [type=search]::-webkit-search-decoration {\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n}\r\n\r\n.markdown-body ::-webkit-input-placeholder {\r\n    color: inherit;\r\n    opacity: .54;\r\n}\r\n\r\n.markdown-body ::-webkit-file-upload-button {\r\n    -webkit-appearance: button;\r\n    appearance: button;\r\n    font: inherit;\r\n}\r\n\r\n.markdown-body a:hover {\r\n    text-decoration: underline;\r\n}\r\n\r\n.markdown-body ::-moz-placeholder {\r\n    color: var(--color-fg-subtle);\r\n    opacity: 1;\r\n}\r\n\r\n.markdown-body ::placeholder {\r\n    color: var(--color-fg-subtle);\r\n    opacity: 1;\r\n}\r\n\r\n.markdown-body hr::before {\r\n    display: table;\r\n    content: \"\";\r\n}\r\n\r\n.markdown-body hr::after {\r\n    display: table;\r\n    clear: both;\r\n    content: \"\";\r\n}\r\n\r\n.markdown-body table {\r\n    border-spacing: 0;\r\n    border-collapse: collapse;\r\n    display: block;\r\n    width: -moz-max-content;\r\n    width: max-content;\r\n    max-width: 100%;\r\n    overflow: auto;\r\n}\r\n\r\n.markdown-body td,\r\n.markdown-body th {\r\n    padding: 0;\r\n}\r\n\r\n.markdown-body details summary {\r\n    cursor: pointer;\r\n}\r\n\r\n.markdown-body details:not([open])>*:not(summary) {\r\n    display: none !important;\r\n}\r\n\r\n.markdown-body a:focus,\r\n.markdown-body [role=button]:focus,\r\n.markdown-body input[type=radio]:focus,\r\n.markdown-body input[type=checkbox]:focus {\r\n    outline: 2px solid var(--color-accent-fg);\r\n    outline-offset: -2px;\r\n    box-shadow: none;\r\n}\r\n\r\n.markdown-body a:focus:not(:focus-visible),\r\n.markdown-body [role=button]:focus:not(:focus-visible),\r\n.markdown-body input[type=radio]:focus:not(:focus-visible),\r\n.markdown-body input[type=checkbox]:focus:not(:focus-visible) {\r\n    outline: solid 1px transparent;\r\n}\r\n\r\n.markdown-body a:focus-visible,\r\n.markdown-body [role=button]:focus-visible,\r\n.markdown-body input[type=radio]:focus-visible,\r\n.markdown-body input[type=checkbox]:focus-visible {\r\n    outline: 2px solid var(--color-accent-fg);\r\n    outline-offset: -2px;\r\n    box-shadow: none;\r\n}\r\n\r\n.markdown-body a:not([class]):focus,\r\n.markdown-body a:not([class]):focus-visible,\r\n.markdown-body input[type=radio]:focus,\r\n.markdown-body input[type=radio]:focus-visible,\r\n.markdown-body input[type=checkbox]:focus,\r\n.markdown-body input[type=checkbox]:focus-visible {\r\n    outline-offset: 0;\r\n}\r\n\r\n.markdown-body kbd {\r\n    display: inline-block;\r\n    padding: 3px 5px;\r\n    font: 11px ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;\r\n    line-height: 10px;\r\n    color: var(--color-fg-default);\r\n    vertical-align: middle;\r\n    background-color: var(--color-canvas-subtle);\r\n    border: solid 1px var(--color-neutral-muted);\r\n    border-bottom-color: var(--color-neutral-muted);\r\n    border-radius: 6px;\r\n    box-shadow: inset 0 -1px 0 var(--color-neutral-muted);\r\n}\r\n\r\n.markdown-body h1,\r\n.markdown-body h2,\r\n.markdown-body h3,\r\n.markdown-body h4,\r\n.markdown-body h5,\r\n.markdown-body h6 {\r\n    margin-top: 24px;\r\n    margin-bottom: 16px;\r\n    font-weight: var(--base-text-weight-semibold, 600);\r\n    line-height: 1.25;\r\n}\r\n\r\n.markdown-body h2 {\r\n    font-weight: var(--base-text-weight-semibold, 600);\r\n    padding-bottom: .3em;\r\n    font-size: 1.5em;\r\n    border-bottom: 1px solid var(--color-border-muted);\r\n}\r\n\r\n.markdown-body h3 {\r\n    font-weight: var(--base-text-weight-semibold, 600);\r\n    font-size: 1.25em;\r\n}\r\n\r\n.markdown-body h4 {\r\n    font-weight: var(--base-text-weight-semibold, 600);\r\n    font-size: 1em;\r\n}\r\n\r\n.markdown-body h5 {\r\n    font-weight: var(--base-text-weight-semibold, 600);\r\n    font-size: .875em;\r\n}\r\n\r\n.markdown-body h6 {\r\n    font-weight: var(--base-text-weight-semibold, 600);\r\n    font-size: .85em;\r\n    color: var(--color-fg-muted);\r\n}\r\n\r\n.markdown-body p {\r\n    margin-top: 0;\r\n    margin-bottom: 10px;\r\n}\r\n\r\n.markdown-body blockquote {\r\n    margin: 0;\r\n    padding: 0 1em;\r\n    color: var(--color-fg-muted);\r\n    border-left: .25em solid var(--color-border-default);\r\n}\r\n\r\n.markdown-body ul,\r\n.markdown-body ol {\r\n    margin-top: 0;\r\n    margin-bottom: 0;\r\n    padding-left: 2em;\r\n}\r\n\r\n.markdown-body ol ol,\r\n.markdown-body ul ol {\r\n    list-style-type: lower-roman;\r\n}\r\n\r\n.markdown-body ul ul ol,\r\n.markdown-body ul ol ol,\r\n.markdown-body ol ul ol,\r\n.markdown-body ol ol ol {\r\n    list-style-type: lower-alpha;\r\n}\r\n\r\n.markdown-body dd {\r\n    margin-left: 0;\r\n}\r\n\r\n.markdown-body tt,\r\n.markdown-body code,\r\n.markdown-body samp {\r\n    font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;\r\n    font-size: 12px;\r\n}\r\n\r\n.markdown-body pre {\r\n    margin-top: 0;\r\n    margin-bottom: 0;\r\n    font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;\r\n    font-size: 12px;\r\n    word-wrap: normal;\r\n}\r\n\r\n.markdown-body .octicon {\r\n    display: inline-block;\r\n    overflow: visible !important;\r\n    vertical-align: text-bottom;\r\n    fill: currentColor;\r\n}\r\n\r\n.markdown-body input::-webkit-outer-spin-button,\r\n.markdown-body input::-webkit-inner-spin-button {\r\n    margin: 0;\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n}\r\n\r\n.markdown-body .mr-2 {\r\n    margin-right: var(--base-size-8, 8px) !important;\r\n}\r\n\r\n.markdown-body::before {\r\n    display: table;\r\n    content: \"\";\r\n}\r\n\r\n.markdown-body::after {\r\n    display: table;\r\n    clear: both;\r\n    content: \"\";\r\n}\r\n\r\n.markdown-body>*:first-child {\r\n    margin-top: 0 !important;\r\n}\r\n\r\n.markdown-body>*:last-child {\r\n    margin-bottom: 0 !important;\r\n}\r\n\r\n.markdown-body a:not([href]) {\r\n    color: inherit;\r\n    text-decoration: none;\r\n}\r\n\r\n.markdown-body .absent {\r\n    color: var(--color-danger-fg);\r\n}\r\n\r\n.markdown-body .anchor {\r\n    float: left;\r\n    padding-right: 4px;\r\n    margin-left: -20px;\r\n    line-height: 1;\r\n}\r\n\r\n.markdown-body .anchor:focus {\r\n    outline: none;\r\n}\r\n\r\n.markdown-body p,\r\n.markdown-body blockquote,\r\n.markdown-body ul,\r\n.markdown-body ol,\r\n.markdown-body dl,\r\n.markdown-body table,\r\n.markdown-body pre,\r\n.markdown-body details {\r\n    margin-top: 0;\r\n    margin-bottom: 16px;\r\n}\r\n\r\n.markdown-body blockquote>:first-child {\r\n    margin-top: 0;\r\n}\r\n\r\n.markdown-body blockquote>:last-child {\r\n    margin-bottom: 0;\r\n}\r\n\r\n.markdown-body h1 .octicon-link,\r\n.markdown-body h2 .octicon-link,\r\n.markdown-body h3 .octicon-link,\r\n.markdown-body h4 .octicon-link,\r\n.markdown-body h5 .octicon-link,\r\n.markdown-body h6 .octicon-link {\r\n    color: var(--color-fg-default);\r\n    vertical-align: middle;\r\n    visibility: hidden;\r\n}\r\n\r\n.markdown-body h1:hover .anchor,\r\n.markdown-body h2:hover .anchor,\r\n.markdown-body h3:hover .anchor,\r\n.markdown-body h4:hover .anchor,\r\n.markdown-body h5:hover .anchor,\r\n.markdown-body h6:hover .anchor {\r\n    text-decoration: none;\r\n}\r\n\r\n.markdown-body h1:hover .anchor .octicon-link,\r\n.markdown-body h2:hover .anchor .octicon-link,\r\n.markdown-body h3:hover .anchor .octicon-link,\r\n.markdown-body h4:hover .anchor .octicon-link,\r\n.markdown-body h5:hover .anchor .octicon-link,\r\n.markdown-body h6:hover .anchor .octicon-link {\r\n    visibility: visible;\r\n}\r\n\r\n.markdown-body h1 tt,\r\n.markdown-body h1 code,\r\n.markdown-body h2 tt,\r\n.markdown-body h2 code,\r\n.markdown-body h3 tt,\r\n.markdown-body h3 code,\r\n.markdown-body h4 tt,\r\n.markdown-body h4 code,\r\n.markdown-body h5 tt,\r\n.markdown-body h5 code,\r\n.markdown-body h6 tt,\r\n.markdown-body h6 code {\r\n    padding: 0 .2em;\r\n    font-size: inherit;\r\n}\r\n\r\n.markdown-body summary h1,\r\n.markdown-body summary h2,\r\n.markdown-body summary h3,\r\n.markdown-body summary h4,\r\n.markdown-body summary h5,\r\n.markdown-body summary h6 {\r\n    display: inline-block;\r\n}\r\n\r\n.markdown-body summary h1 .anchor,\r\n.markdown-body summary h2 .anchor,\r\n.markdown-body summary h3 .anchor,\r\n.markdown-body summary h4 .anchor,\r\n.markdown-body summary h5 .anchor,\r\n.markdown-body summary h6 .anchor {\r\n    margin-left: -40px;\r\n}\r\n\r\n.markdown-body summary h1,\r\n.markdown-body summary h2 {\r\n    padding-bottom: 0;\r\n    border-bottom: 0;\r\n}\r\n\r\n.markdown-body ul.no-list,\r\n.markdown-body ol.no-list {\r\n    padding: 0;\r\n    list-style-type: none;\r\n}\r\n\r\n.markdown-body ol[type=\"a s\"] {\r\n    list-style-type: lower-alpha;\r\n}\r\n\r\n.markdown-body ol[type=\"A s\"] {\r\n    list-style-type: upper-alpha;\r\n}\r\n\r\n.markdown-body ol[type=\"i s\"] {\r\n    list-style-type: lower-roman;\r\n}\r\n\r\n.markdown-body ol[type=\"I s\"] {\r\n    list-style-type: upper-roman;\r\n}\r\n\r\n.markdown-body ol[type=\"1\"] {\r\n    list-style-type: decimal;\r\n}\r\n\r\n.markdown-body div>ol:not([type]) {\r\n    list-style-type: decimal;\r\n}\r\n\r\n.markdown-body ul ul,\r\n.markdown-body ul ol,\r\n.markdown-body ol ol,\r\n.markdown-body ol ul {\r\n    margin-top: 0;\r\n    margin-bottom: 0;\r\n}\r\n\r\n.markdown-body li>p {\r\n    margin-top: 16px;\r\n}\r\n\r\n.markdown-body li+li {\r\n    margin-top: .25em;\r\n}\r\n\r\n.markdown-body dl {\r\n    padding: 0;\r\n}\r\n\r\n.markdown-body dl dt {\r\n    padding: 0;\r\n    margin-top: 16px;\r\n    font-size: 1em;\r\n    font-style: italic;\r\n    font-weight: var(--base-text-weight-semibold, 600);\r\n}\r\n\r\n.markdown-body dl dd {\r\n    padding: 0 16px;\r\n    margin-bottom: 16px;\r\n}\r\n\r\n.markdown-body table th {\r\n    font-weight: var(--base-text-weight-semibold, 600);\r\n}\r\n\r\n.markdown-body table th,\r\n.markdown-body table td {\r\n    padding: 6px 13px;\r\n    border: 1px solid var(--color-border-default);\r\n}\r\n\r\n.markdown-body table td>:last-child {\r\n    margin-bottom: 0;\r\n}\r\n\r\n.markdown-body table tr {\r\n    background-color: var(--color-canvas-default);\r\n    border-top: 1px solid var(--color-border-muted);\r\n}\r\n\r\n.markdown-body table tr:nth-child(2n) {\r\n    background-color: var(--color-canvas-subtle);\r\n}\r\n\r\n.markdown-body table img {\r\n    background-color: transparent;\r\n}\r\n\r\n.markdown-body img[align=right] {\r\n    padding-left: 20px;\r\n}\r\n\r\n.markdown-body img[align=left] {\r\n    padding-right: 20px;\r\n}\r\n\r\n.markdown-body .emoji {\r\n    max-width: none;\r\n    vertical-align: text-top;\r\n    background-color: transparent;\r\n}\r\n\r\n.markdown-body span.frame {\r\n    display: block;\r\n    overflow: hidden;\r\n}\r\n\r\n.markdown-body span.frame>span {\r\n    display: block;\r\n    float: left;\r\n    width: auto;\r\n    padding: 7px;\r\n    margin: 13px 0 0;\r\n    overflow: hidden;\r\n    border: 1px solid var(--color-border-default);\r\n}\r\n\r\n.markdown-body span.frame span img {\r\n    display: block;\r\n    float: left;\r\n}\r\n\r\n.markdown-body span.frame span span {\r\n    display: block;\r\n    padding: 5px 0 0;\r\n    clear: both;\r\n    color: var(--color-fg-default);\r\n}\r\n\r\n.markdown-body span.align-center {\r\n    display: block;\r\n    overflow: hidden;\r\n    clear: both;\r\n}\r\n\r\n.markdown-body span.align-center>span {\r\n    display: block;\r\n    margin: 13px auto 0;\r\n    overflow: hidden;\r\n    text-align: center;\r\n}\r\n\r\n.markdown-body span.align-center span img {\r\n    margin: 0 auto;\r\n    text-align: center;\r\n}\r\n\r\n.markdown-body span.align-right {\r\n    display: block;\r\n    overflow: hidden;\r\n    clear: both;\r\n}\r\n\r\n.markdown-body span.align-right>span {\r\n    display: block;\r\n    margin: 13px 0 0;\r\n    overflow: hidden;\r\n    text-align: right;\r\n}\r\n\r\n.markdown-body span.align-right span img {\r\n    margin: 0;\r\n    text-align: right;\r\n}\r\n\r\n.markdown-body span.float-left {\r\n    display: block;\r\n    float: left;\r\n    margin-right: 13px;\r\n    overflow: hidden;\r\n}\r\n\r\n.markdown-body span.float-left span {\r\n    margin: 13px 0 0;\r\n}\r\n\r\n.markdown-body span.float-right {\r\n    display: block;\r\n    float: right;\r\n    margin-left: 13px;\r\n    overflow: hidden;\r\n}\r\n\r\n.markdown-body span.float-right>span {\r\n    display: block;\r\n    margin: 13px auto 0;\r\n    overflow: hidden;\r\n    text-align: right;\r\n}\r\n\r\n.markdown-body code,\r\n.markdown-body tt {\r\n    padding: .2em .4em;\r\n    margin: 0;\r\n    font-size: 85%;\r\n    white-space: break-spaces;\r\n    background-color: var(--color-neutral-muted);\r\n    border-radius: 6px;\r\n}\r\n\r\n.markdown-body code br,\r\n.markdown-body tt br {\r\n    display: none;\r\n}\r\n\r\n.markdown-body del code {\r\n    text-decoration: inherit;\r\n}\r\n\r\n.markdown-body samp {\r\n    font-size: 85%;\r\n}\r\n\r\n.markdown-body pre code {\r\n    font-size: 100%;\r\n}\r\n\r\n.markdown-body pre>code {\r\n    padding: 0;\r\n    margin: 0;\r\n    word-break: normal;\r\n    white-space: pre;\r\n    background: transparent;\r\n    border: 0;\r\n}\r\n\r\n.markdown-body .highlight {\r\n    margin-bottom: 16px;\r\n}\r\n\r\n.markdown-body .highlight pre {\r\n    margin-bottom: 0;\r\n    word-break: normal;\r\n}\r\n\r\n.markdown-body .highlight pre,\r\n.markdown-body pre {\r\n    padding: 16px;\r\n    overflow: auto;\r\n    font-size: 85%;\r\n    line-height: 1.45;\r\n    color: var(--color-fg-default);\r\n    background-color: var(--color-canvas-subtle);\r\n    border-radius: 6px;\r\n}\r\n\r\n.markdown-body pre code,\r\n.markdown-body pre tt {\r\n    display: inline;\r\n    max-width: auto;\r\n    padding: 0;\r\n    margin: 0;\r\n    overflow: visible;\r\n    line-height: inherit;\r\n    word-wrap: normal;\r\n    background-color: transparent;\r\n    border: 0;\r\n}\r\n\r\n.markdown-body .csv-data td,\r\n.markdown-body .csv-data th {\r\n    padding: 5px;\r\n    overflow: hidden;\r\n    font-size: 12px;\r\n    line-height: 1;\r\n    text-align: left;\r\n    white-space: nowrap;\r\n}\r\n\r\n.markdown-body .csv-data .blob-num {\r\n    padding: 10px 8px 9px;\r\n    text-align: right;\r\n    background: var(--color-canvas-default);\r\n    border: 0;\r\n}\r\n\r\n.markdown-body .csv-data tr {\r\n    border-top: 0;\r\n}\r\n\r\n.markdown-body .csv-data th {\r\n    font-weight: var(--base-text-weight-semibold, 600);\r\n    background: var(--color-canvas-subtle);\r\n    border-top: 0;\r\n}\r\n\r\n.markdown-body [data-footnote-ref]::before {\r\n    content: \"[\";\r\n}\r\n\r\n.markdown-body [data-footnote-ref]::after {\r\n    content: \"]\";\r\n}\r\n\r\n.markdown-body .footnotes {\r\n    font-size: 12px;\r\n    color: var(--color-fg-muted);\r\n    border-top: 1px solid var(--color-border-default);\r\n}\r\n\r\n.markdown-body .footnotes ol {\r\n    padding-left: 16px;\r\n}\r\n\r\n.markdown-body .footnotes ol ul {\r\n    display: inline-block;\r\n    padding-left: 16px;\r\n    margin-top: 16px;\r\n}\r\n\r\n.markdown-body .footnotes li {\r\n    position: relative;\r\n}\r\n\r\n.markdown-body .footnotes li:target::before {\r\n    position: absolute;\r\n    top: -8px;\r\n    right: -8px;\r\n    bottom: -8px;\r\n    left: -24px;\r\n    pointer-events: none;\r\n    content: \"\";\r\n    border: 2px solid var(--color-accent-emphasis);\r\n    border-radius: 6px;\r\n}\r\n\r\n.markdown-body .footnotes li:target {\r\n    color: var(--color-fg-default);\r\n}\r\n\r\n.markdown-body .footnotes .data-footnote-backref g-emoji {\r\n    font-family: monospace;\r\n}\r\n\r\n.markdown-body .pl-c {\r\n    color: var(--color-prettylights-syntax-comment);\r\n}\r\n\r\n.markdown-body .pl-c1,\r\n.markdown-body .pl-s .pl-v {\r\n    color: var(--color-prettylights-syntax-constant);\r\n}\r\n\r\n.markdown-body .pl-e,\r\n.markdown-body .pl-en {\r\n    color: var(--color-prettylights-syntax-entity);\r\n}\r\n\r\n.markdown-body .pl-smi,\r\n.markdown-body .pl-s .pl-s1 {\r\n    color: var(--color-prettylights-syntax-storage-modifier-import);\r\n}\r\n\r\n.markdown-body .pl-ent {\r\n    color: var(--color-prettylights-syntax-entity-tag);\r\n}\r\n\r\n.markdown-body .pl-k {\r\n    color: var(--color-prettylights-syntax-keyword);\r\n}\r\n\r\n.markdown-body .pl-s,\r\n.markdown-body .pl-pds,\r\n.markdown-body .pl-s .pl-pse .pl-s1,\r\n.markdown-body .pl-sr,\r\n.markdown-body .pl-sr .pl-cce,\r\n.markdown-body .pl-sr .pl-sre,\r\n.markdown-body .pl-sr .pl-sra {\r\n    color: var(--color-prettylights-syntax-string);\r\n}\r\n\r\n.markdown-body .pl-v,\r\n.markdown-body .pl-smw {\r\n    color: var(--color-prettylights-syntax-variable);\r\n}\r\n\r\n.markdown-body .pl-bu {\r\n    color: var(--color-prettylights-syntax-brackethighlighter-unmatched);\r\n}\r\n\r\n.markdown-body .pl-ii {\r\n    color: var(--color-prettylights-syntax-invalid-illegal-text);\r\n    background-color: var(--color-prettylights-syntax-invalid-illegal-bg);\r\n}\r\n\r\n.markdown-body .pl-c2 {\r\n    color: var(--color-prettylights-syntax-carriage-return-text);\r\n    background-color: var(--color-prettylights-syntax-carriage-return-bg);\r\n}\r\n\r\n.markdown-body .pl-sr .pl-cce {\r\n    font-weight: bold;\r\n    color: var(--color-prettylights-syntax-string-regexp);\r\n}\r\n\r\n.markdown-body .pl-ml {\r\n    color: var(--color-prettylights-syntax-markup-list);\r\n}\r\n\r\n.markdown-body .pl-mh,\r\n.markdown-body .pl-mh .pl-en,\r\n.markdown-body .pl-ms {\r\n    font-weight: bold;\r\n    color: var(--color-prettylights-syntax-markup-heading);\r\n}\r\n\r\n.markdown-body .pl-mi {\r\n    font-style: italic;\r\n    color: var(--color-prettylights-syntax-markup-italic);\r\n}\r\n\r\n.markdown-body .pl-mb {\r\n    font-weight: bold;\r\n    color: var(--color-prettylights-syntax-markup-bold);\r\n}\r\n\r\n.markdown-body .pl-md {\r\n    color: var(--color-prettylights-syntax-markup-deleted-text);\r\n    background-color: var(--color-prettylights-syntax-markup-deleted-bg);\r\n}\r\n\r\n.markdown-body .pl-mi1 {\r\n    color: var(--color-prettylights-syntax-markup-inserted-text);\r\n    background-color: var(--color-prettylights-syntax-markup-inserted-bg);\r\n}\r\n\r\n.markdown-body .pl-mc {\r\n    color: var(--color-prettylights-syntax-markup-changed-text);\r\n    background-color: var(--color-prettylights-syntax-markup-changed-bg);\r\n}\r\n\r\n.markdown-body .pl-mi2 {\r\n    color: var(--color-prettylights-syntax-markup-ignored-text);\r\n    background-color: var(--color-prettylights-syntax-markup-ignored-bg);\r\n}\r\n\r\n.markdown-body .pl-mdr {\r\n    font-weight: bold;\r\n    color: var(--color-prettylights-syntax-meta-diff-range);\r\n}\r\n\r\n.markdown-body .pl-ba {\r\n    color: var(--color-prettylights-syntax-brackethighlighter-angle);\r\n}\r\n\r\n.markdown-body .pl-sg {\r\n    color: var(--color-prettylights-syntax-sublimelinter-gutter-mark);\r\n}\r\n\r\n.markdown-body .pl-corl {\r\n    text-decoration: underline;\r\n    color: var(--color-prettylights-syntax-constant-other-reference-link);\r\n}\r\n\r\n.markdown-body g-emoji {\r\n    display: inline-block;\r\n    min-width: 1ch;\r\n    font-family: \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\r\n    font-size: 1em;\r\n    font-style: normal !important;\r\n    font-weight: var(--base-text-weight-normal, 400);\r\n    line-height: 1;\r\n    vertical-align: -0.075em;\r\n}\r\n\r\n.markdown-body g-emoji img {\r\n    width: 1em;\r\n    height: 1em;\r\n}\r\n\r\n.markdown-body .task-list-item {\r\n    list-style-type: none;\r\n}\r\n\r\n.markdown-body .task-list-item label {\r\n    font-weight: var(--base-text-weight-normal, 400);\r\n}\r\n\r\n.markdown-body .task-list-item.enabled label {\r\n    cursor: pointer;\r\n}\r\n\r\n.markdown-body .task-list-item+.task-list-item {\r\n    margin-top: 4px;\r\n}\r\n\r\n.markdown-body .task-list-item .handle {\r\n    display: none;\r\n}\r\n\r\n.markdown-body .task-list-item-checkbox {\r\n    margin: 0 .2em .25em -1.4em;\r\n    vertical-align: middle;\r\n}\r\n\r\n.markdown-body .contains-task-list:dir(rtl) .task-list-item-checkbox {\r\n    margin: 0 -1.6em .25em .2em;\r\n}\r\n\r\n.markdown-body .contains-task-list {\r\n    position: relative;\r\n}\r\n\r\n.markdown-body .contains-task-list:hover .task-list-item-convert-container,\r\n.markdown-body .contains-task-list:focus-within .task-list-item-convert-container {\r\n    display: block;\r\n    width: auto;\r\n    height: 24px;\r\n    overflow: visible;\r\n    clip: auto;\r\n}\r\n\r\n.markdown-body ::-webkit-calendar-picker-indicator {\r\n    filter: invert(50%);\r\n}\r\n\r\n.markdown-body .markdown-alert {\r\n    padding: var(--base-size-8) var(--base-size-16);\r\n    margin-bottom: 16px;\r\n    color: inherit;\r\n    border-left: .25em solid var(--color-border-default);\r\n}\r\n\r\n.markdown-body .markdown-alert>:first-child {\r\n    margin-top: 0;\r\n}\r\n\r\n.markdown-body .markdown-alert>:last-child {\r\n    margin-bottom: 0;\r\n}\r\n\r\n.markdown-body .markdown-alert .markdown-alert-title {\r\n    display: flex;\r\n    font-weight: var(--base-text-weight-medium, 500);\r\n    align-items: center;\r\n    line-height: 1;\r\n}\r\n\r\n.markdown-body .markdown-alert.markdown-alert-note {\r\n    border-left-color: var(--color-accent-emphasis);\r\n}\r\n\r\n.markdown-body .markdown-alert.markdown-alert-note .markdown-alert-title {\r\n    color: var(--color-accent-fg);\r\n}\r\n\r\n.markdown-body .markdown-alert.markdown-alert-important {\r\n    border-left-color: var(--color-done-emphasis);\r\n}\r\n\r\n.markdown-body .markdown-alert.markdown-alert-important .markdown-alert-title {\r\n    color: var(--color-done-fg);\r\n}\r\n\r\n.markdown-body .markdown-alert.markdown-alert-warning {\r\n    border-left-color: var(--color-attention-emphasis);\r\n}\r\n\r\n.markdown-body .markdown-alert.markdown-alert-warning .markdown-alert-title {\r\n    color: var(--color-attention-fg);\r\n}\r\n\r\n.markdown-body .markdown-alert.markdown-alert-tip {\r\n    border-left-color: var(--color-success-emphasis);\r\n}\r\n\r\n.markdown-body .markdown-alert.markdown-alert-tip .markdown-alert-title {\r\n    color: var(--color-success-fg);\r\n}\r\n\r\n.markdown-body .markdown-alert.markdown-alert-caution {\r\n    border-left-color: var(--color-danger-emphasis);\r\n}\r\n\r\n.markdown-body .markdown-alert.markdown-alert-caution .markdown-alert-title {\r\n    color: var(--color-danger-fg);\r\n}/*end*/\n.element-card {\n  cursor: default;\n  text-align: center;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.element-card .card-id {\n  position: absolute;\n  top: 10px;\n  left: 0;\n  right: 0;\n  text-align: center;\n  z-index: 2;\n}\n.element-card .card-name {\n  position: absolute;\n  top: 40px;\n  left: 0px;\n  right: 0;\n  font-weight: bold;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  z-index: 2;\n}\n.element-card .card-avatar-name {\n  top: auto;\n  bottom: 0;\n  left: 0px;\n  right: 0;\n  line-height: 2 !important;\n}\n.element-card .card-detail {\n  position: absolute;\n  left: 0;\n  right: 0;\n  bottom: 15px;\n  z-index: 2;\n}\n.element-card .card-avatar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 1;\n  width: 140px !important;\n  height: 120px !important;\n  -o-object-fit: cover;\n     object-fit: cover;\n}\n\n.lucky-element-card {\n  cursor: default;\n}\n.lucky-element-card::before {\n  background-color: linear-gradient(-45deg, #e81cff 0%, #40c9ff 100%);\n  border: 1px solid linear-gradient(-45deg, #e81cff 0%, #40c9ff 100%);\n}\n.lucky-element-card .card-id {\n  position: absolute;\n  top: 20px;\n  left: 0;\n  right: 0;\n  text-align: center;\n  z-index: 2;\n}\n.lucky-element-card .card-name {\n  text-align: center;\n  z-index: 2;\n  position: absolute;\n  top: 40px;\n  left: 0px;\n  right: 0;\n  font-weight: bold;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.lucky-element-card .card-avatar-name {\n  top: auto;\n  bottom: 0;\n  left: 0px;\n  right: 0;\n  line-height: 2 !important;\n}\n.lucky-element-card .card-detail {\n  position: absolute;\n  left: 0;\n  right: 0;\n  text-align: center;\n  z-index: 2;\n  bottom: 15px;\n}\n.lucky-element-card .card-avatar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 1;\n  width: 280px !important;\n  height: 240px !important;\n  -o-object-fit: cover;\n     object-fit: cover;\n}/*$vite$:1*/";
        document.head.appendChild(__vite_style__);
        exports({
          B: normalizeClass,
          D: watch,
          I: getDefaultExportFromCjs,
          J: reactive,
          K: tryOnMounted,
          L: whenever,
          M: useClipboard,
          N: useLocalStorage,
          O: useDebounceFn,
          P: inject,
          Q: nextTick,
          S: provide,
          T: useSlots,
          U: onClickOutside,
          V: withCtx,
          W: resolveDynamicComponent,
          X: mergeProps,
          Y: renderSlot,
          a: createBaseVNode,
          a0: pushScopeId,
          a1: popScopeId,
          a3: themeChange,
          a4: isHex,
          a5: isRgbOrRgba,
          a8: resolveDirective,
          b: renderList,
          c: createElementBlock,
          d: defineComponent,
          f: createTextVNode,
          g: useRoute,
          i: resolveComponent,
          j: unref,
          l: createBlock,
          m: useI18n,
          n: normalizeStyle,
          o: openBlock,
          p: useStore,
          r: ref,
          s: storeToRefs,
          u: useRouter,
          w: addOtherInfo,
          x: withDirectives,
          z: createCommentVNode
        });
        false && function polyfill() {
          var relList = document.createElement("link").relList;
          if (relList && relList.supports && relList.supports("modulepreload")) {
            return;
          }
          var _iterator = _createForOfIteratorHelper(document.querySelectorAll('link[rel="modulepreload"]')),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var link = _step.value;
              processPreload(link);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          new MutationObserver(function (mutations) {
            var _iterator2 = _createForOfIteratorHelper(mutations),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var mutation = _step2.value;
                if (mutation.type !== "childList") {
                  continue;
                }
                var _iterator3 = _createForOfIteratorHelper(mutation.addedNodes),
                  _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var node = _step3.value;
                    if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }).observe(document, {
            childList: true,
            subtree: true
          });
          function getFetchOpts(link) {
            var fetchOpts = {};
            if (link.integrity) fetchOpts.integrity = link.integrity;
            if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
            if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";else fetchOpts.credentials = "same-origin";
            return fetchOpts;
          }
          function processPreload(link) {
            if (link.ep) return;
            link.ep = true;
            var fetchOpts = getFetchOpts(link);
            fetch(link.href, fetchOpts);
          }
        }();

        /**
        * @vue/shared v3.5.13
        * (c) 2018-present Yuxi (Evan) You and Vue contributors
        * @license MIT
        **/
        /*! #__NO_SIDE_EFFECTS__ */
        // @__NO_SIDE_EFFECTS__
        function makeMap(str) {
          var map = /* @__PURE__ */Object.create(null);
          var _iterator4 = _createForOfIteratorHelper(str.split(",")),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var key = _step4.value;
              map[key] = 1;
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          return function (val) {
            return val in map;
          };
        }
        var EMPTY_OBJ = {};
        var EMPTY_ARR = [];
        var NOOP = function NOOP() {};
        var NO = function NO() {
          return false;
        };
        var isOn = function isOn(key) {
          return key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && (
          // uppercase letter
          key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
        };
        var isModelListener = function isModelListener(key) {
          return key.startsWith("onUpdate:");
        };
        var extend = Object.assign;
        var remove = function remove(arr, el) {
          var i = arr.indexOf(el);
          if (i > -1) {
            arr.splice(i, 1);
          }
        };
        var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        var hasOwn$1 = function hasOwn$1(val, key) {
          return hasOwnProperty$2.call(val, key);
        };
        var isArray$2 = Array.isArray;
        var isMap = function isMap(val) {
          return toTypeString$1(val) === "[object Map]";
        };
        var isSet = function isSet(val) {
          return toTypeString$1(val) === "[object Set]";
        };
        var isDate$1 = function isDate$1(val) {
          return toTypeString$1(val) === "[object Date]";
        };
        var isRegExp$1 = function isRegExp$1(val) {
          return toTypeString$1(val) === "[object RegExp]";
        };
        var isFunction$1 = function isFunction$1(val) {
          return typeof val === "function";
        };
        var isString$1 = function isString$1(val) {
          return typeof val === "string";
        };
        var isSymbol = function isSymbol(val) {
          return _typeof2(val) === "symbol";
        };
        var isObject$2 = function isObject$2(val) {
          return val !== null && _typeof2(val) === "object";
        };
        var isPromise$1 = function isPromise$1(val) {
          return (isObject$2(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
        };
        var objectToString$1 = Object.prototype.toString;
        var toTypeString$1 = function toTypeString$1(value) {
          return objectToString$1.call(value);
        };
        var toRawType = function toRawType(value) {
          return toTypeString$1(value).slice(8, -1);
        };
        var isPlainObject$2 = function isPlainObject$2(val) {
          return toTypeString$1(val) === "[object Object]";
        };
        var isIntegerKey = function isIntegerKey(key) {
          return isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
        };
        var isReservedProp = /* @__PURE__ */makeMap(
        // the leading comma is intentional so empty string "" is also included
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
        var cacheStringFunction = function cacheStringFunction(fn) {
          var cache = /* @__PURE__ */Object.create(null);
          return function (str) {
            var hit = cache[str];
            return hit || (cache[str] = fn(str));
          };
        };
        var camelizeRE = /-(\w)/g;
        var camelize = cacheStringFunction(function (str) {
          return str.replace(camelizeRE, function (_, c) {
            return c ? c.toUpperCase() : "";
          });
        });
        var hyphenateRE = /\B([A-Z])/g;
        var hyphenate = cacheStringFunction(function (str) {
          return str.replace(hyphenateRE, "-$1").toLowerCase();
        });
        var capitalize$1 = cacheStringFunction(function (str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        });
        var toHandlerKey = cacheStringFunction(function (str) {
          var s = str ? "on".concat(capitalize$1(str)) : "";
          return s;
        });
        var hasChanged = function hasChanged(value, oldValue) {
          return !Object.is(value, oldValue);
        };
        var invokeArrayFns = function invokeArrayFns(fns) {
          for (var _len3 = arguments.length, arg = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            arg[_key3 - 1] = arguments[_key3];
          }
          for (var i = 0; i < fns.length; i++) {
            fns[i].apply(fns, arg);
          }
        };
        var def = function def(obj, key, value) {
          var writable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          Object.defineProperty(obj, key, {
            configurable: true,
            enumerable: false,
            writable: writable,
            value: value
          });
        };
        var looseToNumber = function looseToNumber(val) {
          var n = parseFloat(val);
          return isNaN(n) ? val : n;
        };
        var toNumber = function toNumber(val) {
          var n = isString$1(val) ? Number(val) : NaN;
          return isNaN(n) ? val : n;
        };
        var _globalThis$1;
        var getGlobalThis$1 = function getGlobalThis$1() {
          return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
        };
        var GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
        var isGloballyAllowed = /* @__PURE__ */makeMap(GLOBALS_ALLOWED);
        function normalizeStyle(value) {
          if (isArray$2(value)) {
            var res = {};
            for (var i = 0; i < value.length; i++) {
              var item = value[i];
              var normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
              if (normalized) {
                for (var key in normalized) {
                  res[key] = normalized[key];
                }
              }
            }
            return res;
          } else if (isString$1(value) || isObject$2(value)) {
            return value;
          }
        }
        var listDelimiterRE = /;(?![^(]*\))/g;
        var propertyDelimiterRE = /:([^]+)/;
        var styleCommentRE = /\/\*[^]*?\*\//g;
        function parseStringStyle(cssText) {
          var ret = {};
          cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach(function (item) {
            if (item) {
              var _tmp = item.split(propertyDelimiterRE);
              _tmp.length > 1 && (ret[_tmp[0].trim()] = _tmp[1].trim());
            }
          });
          return ret;
        }
        function normalizeClass(value) {
          var res = "";
          if (isString$1(value)) {
            res = value;
          } else if (isArray$2(value)) {
            for (var i = 0; i < value.length; i++) {
              var normalized = normalizeClass(value[i]);
              if (normalized) {
                res += normalized + " ";
              }
            }
          } else if (isObject$2(value)) {
            for (var name in value) {
              if (value[name]) {
                res += name + " ";
              }
            }
          }
          return res.trim();
        }
        function normalizeProps(props) {
          if (!props) return null;
          var klass = props.class,
            style = props.style;
          if (klass && !isString$1(klass)) {
            props.class = normalizeClass(klass);
          }
          if (style) {
            props.style = normalizeStyle(style);
          }
          return props;
        }
        var specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";
        var isSpecialBooleanAttr = /* @__PURE__ */makeMap(specialBooleanAttrs);
        function includeBooleanAttr(value) {
          return !!value || value === "";
        }
        function looseCompareArrays(a, b) {
          if (a.length !== b.length) return false;
          var equal = true;
          for (var i = 0; equal && i < a.length; i++) {
            equal = looseEqual(a[i], b[i]);
          }
          return equal;
        }
        function looseEqual(a, b) {
          if (a === b) return true;
          var aValidType = isDate$1(a);
          var bValidType = isDate$1(b);
          if (aValidType || bValidType) {
            return aValidType && bValidType ? a.getTime() === b.getTime() : false;
          }
          aValidType = isSymbol(a);
          bValidType = isSymbol(b);
          if (aValidType || bValidType) {
            return a === b;
          }
          aValidType = isArray$2(a);
          bValidType = isArray$2(b);
          if (aValidType || bValidType) {
            return aValidType && bValidType ? looseCompareArrays(a, b) : false;
          }
          aValidType = isObject$2(a);
          bValidType = isObject$2(b);
          if (aValidType || bValidType) {
            if (!aValidType || !bValidType) {
              return false;
            }
            var aKeysCount = Object.keys(a).length;
            var bKeysCount = Object.keys(b).length;
            if (aKeysCount !== bKeysCount) {
              return false;
            }
            for (var key in a) {
              var aHasKey = a.hasOwnProperty(key);
              var bHasKey = b.hasOwnProperty(key);
              if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
                return false;
              }
            }
          }
          return String(a) === String(b);
        }
        function looseIndexOf(arr, val) {
          return arr.findIndex(function (item) {
            return looseEqual(item, val);
          });
        }
        var isRef$1 = function isRef$1(val) {
          return !!(val && val["__v_isRef"] === true);
        };
        var toDisplayString$1 = exports("t", function (val) {
          return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$2(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString$1(val.value) : JSON.stringify(val, _replacer, 2) : String(val);
        });
        var _replacer = function replacer(_key, val) {
          if (isRef$1(val)) {
            return _replacer(_key, val.value);
          } else if (isMap(val)) {
            return _defineProperty2({}, "Map(".concat(val.size, ")"), _toConsumableArray(val.entries()).reduce(function (entries, _ref2, i) {
              var _ref3 = _slicedToArray(_ref2, 2),
                key = _ref3[0],
                val2 = _ref3[1];
              entries[stringifySymbol(key, i) + " =>"] = val2;
              return entries;
            }, {}));
          } else if (isSet(val)) {
            return _defineProperty2({}, "Set(".concat(val.size, ")"), _toConsumableArray(val.values()).map(function (v) {
              return stringifySymbol(v);
            }));
          } else if (isSymbol(val)) {
            return stringifySymbol(val);
          } else if (isObject$2(val) && !isArray$2(val) && !isPlainObject$2(val)) {
            return String(val);
          }
          return val;
        };
        var stringifySymbol = function stringifySymbol(v) {
          var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          var _a;
          return (
            // Symbol.description in es2019+ so we need to cast here to pass
            // the lib: es2016 check
            isSymbol(v) ? "Symbol(".concat((_a = v.description) != null ? _a : i, ")") : v
          );
        };

        /**
        * @vue/reactivity v3.5.13
        * (c) 2018-present Yuxi (Evan) You and Vue contributors
        * @license MIT
        **/
        var activeEffectScope;
        var EffectScope = /*#__PURE__*/function () {
          function EffectScope() {
            var detached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            _classCallCheck2(this, EffectScope);
            this.detached = detached;
            this._active = true;
            this.effects = [];
            this.cleanups = [];
            this._isPaused = false;
            this.parent = activeEffectScope;
            if (!detached && activeEffectScope) {
              this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
            }
          }
          return _createClass(EffectScope, [{
            key: "active",
            get: function get() {
              return this._active;
            }
          }, {
            key: "pause",
            value: function pause() {
              if (this._active) {
                this._isPaused = true;
                var i, l;
                if (this.scopes) {
                  for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].pause();
                  }
                }
                for (i = 0, l = this.effects.length; i < l; i++) {
                  this.effects[i].pause();
                }
              }
            }
            /**
             * Resumes the effect scope, including all child scopes and effects.
             */
          }, {
            key: "resume",
            value: function resume() {
              if (this._active) {
                if (this._isPaused) {
                  this._isPaused = false;
                  var i, l;
                  if (this.scopes) {
                    for (i = 0, l = this.scopes.length; i < l; i++) {
                      this.scopes[i].resume();
                    }
                  }
                  for (i = 0, l = this.effects.length; i < l; i++) {
                    this.effects[i].resume();
                  }
                }
              }
            }
          }, {
            key: "run",
            value: function run(fn) {
              if (this._active) {
                var currentEffectScope = activeEffectScope;
                try {
                  activeEffectScope = this;
                  return fn();
                } finally {
                  activeEffectScope = currentEffectScope;
                }
              }
            }
            /**
             * This should only be called on non-detached scopes
             * @internal
             */
          }, {
            key: "on",
            value: function on() {
              activeEffectScope = this;
            }
            /**
             * This should only be called on non-detached scopes
             * @internal
             */
          }, {
            key: "off",
            value: function off() {
              activeEffectScope = this.parent;
            }
          }, {
            key: "stop",
            value: function stop(fromParent) {
              if (this._active) {
                this._active = false;
                var i, l;
                for (i = 0, l = this.effects.length; i < l; i++) {
                  this.effects[i].stop();
                }
                this.effects.length = 0;
                for (i = 0, l = this.cleanups.length; i < l; i++) {
                  this.cleanups[i]();
                }
                this.cleanups.length = 0;
                if (this.scopes) {
                  for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].stop(true);
                  }
                  this.scopes.length = 0;
                }
                if (!this.detached && this.parent && !fromParent) {
                  var last = this.parent.scopes.pop();
                  if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                  }
                }
                this.parent = void 0;
              }
            }
          }]);
        }();
        function effectScope(detached) {
          return new EffectScope(detached);
        }
        function getCurrentScope() {
          return activeEffectScope;
        }
        function onScopeDispose(fn) {
          var failSilently = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          if (activeEffectScope) {
            activeEffectScope.cleanups.push(fn);
          }
        }
        var activeSub;
        var pausedQueueEffects = /* @__PURE__ */new WeakSet();
        var ReactiveEffect = /*#__PURE__*/function () {
          function ReactiveEffect(fn) {
            _classCallCheck2(this, ReactiveEffect);
            this.fn = fn;
            this.deps = void 0;
            this.depsTail = void 0;
            this.flags = 1 | 4;
            this.next = void 0;
            this.cleanup = void 0;
            this.scheduler = void 0;
            if (activeEffectScope && activeEffectScope.active) {
              activeEffectScope.effects.push(this);
            }
          }
          return _createClass(ReactiveEffect, [{
            key: "pause",
            value: function pause() {
              this.flags |= 64;
            }
          }, {
            key: "resume",
            value: function resume() {
              if (this.flags & 64) {
                this.flags &= ~64;
                if (pausedQueueEffects.has(this)) {
                  pausedQueueEffects.delete(this);
                  this.trigger();
                }
              }
            }
            /**
             * @internal
             */
          }, {
            key: "notify",
            value: function notify() {
              if (this.flags & 2 && !(this.flags & 32)) {
                return;
              }
              if (!(this.flags & 8)) {
                batch(this);
              }
            }
          }, {
            key: "run",
            value: function run() {
              if (!(this.flags & 1)) {
                return this.fn();
              }
              this.flags |= 2;
              cleanupEffect(this);
              prepareDeps(this);
              var prevEffect = activeSub;
              var prevShouldTrack = shouldTrack;
              activeSub = this;
              shouldTrack = true;
              try {
                return this.fn();
              } finally {
                cleanupDeps(this);
                activeSub = prevEffect;
                shouldTrack = prevShouldTrack;
                this.flags &= ~2;
              }
            }
          }, {
            key: "stop",
            value: function stop() {
              if (this.flags & 1) {
                for (var link = this.deps; link; link = link.nextDep) {
                  removeSub(link);
                }
                this.deps = this.depsTail = void 0;
                cleanupEffect(this);
                this.onStop && this.onStop();
                this.flags &= ~1;
              }
            }
          }, {
            key: "trigger",
            value: function trigger() {
              if (this.flags & 64) {
                pausedQueueEffects.add(this);
              } else if (this.scheduler) {
                this.scheduler();
              } else {
                this.runIfDirty();
              }
            }
            /**
             * @internal
             */
          }, {
            key: "runIfDirty",
            value: function runIfDirty() {
              if (isDirty(this)) {
                this.run();
              }
            }
          }, {
            key: "dirty",
            get: function get() {
              return isDirty(this);
            }
          }]);
        }();
        var batchDepth = 0;
        var batchedSub;
        var batchedComputed;
        function batch(sub) {
          var isComputed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          sub.flags |= 8;
          if (isComputed) {
            sub.next = batchedComputed;
            batchedComputed = sub;
            return;
          }
          sub.next = batchedSub;
          batchedSub = sub;
        }
        function startBatch() {
          batchDepth++;
        }
        function endBatch() {
          if (--batchDepth > 0) {
            return;
          }
          if (batchedComputed) {
            var e = batchedComputed;
            batchedComputed = void 0;
            while (e) {
              var next = e.next;
              e.next = void 0;
              e.flags &= ~8;
              e = next;
            }
          }
          var error;
          while (batchedSub) {
            var _e = batchedSub;
            batchedSub = void 0;
            while (_e) {
              var _next = _e.next;
              _e.next = void 0;
              _e.flags &= ~8;
              if (_e.flags & 1) {
                try {
                  ;
                  _e.trigger();
                } catch (err) {
                  if (!error) error = err;
                }
              }
              _e = _next;
            }
          }
          if (error) throw error;
        }
        function prepareDeps(sub) {
          for (var link = sub.deps; link; link = link.nextDep) {
            link.version = -1;
            link.prevActiveLink = link.dep.activeLink;
            link.dep.activeLink = link;
          }
        }
        function cleanupDeps(sub) {
          var head;
          var tail = sub.depsTail;
          var link = tail;
          while (link) {
            var prev = link.prevDep;
            if (link.version === -1) {
              if (link === tail) tail = prev;
              removeSub(link);
              removeDep(link);
            } else {
              head = link;
            }
            link.dep.activeLink = link.prevActiveLink;
            link.prevActiveLink = void 0;
            link = prev;
          }
          sub.deps = head;
          sub.depsTail = tail;
        }
        function isDirty(sub) {
          for (var link = sub.deps; link; link = link.nextDep) {
            if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
              return true;
            }
          }
          if (sub._dirty) {
            return true;
          }
          return false;
        }
        function refreshComputed(computed2) {
          if (computed2.flags & 4 && !(computed2.flags & 16)) {
            return;
          }
          computed2.flags &= ~16;
          if (computed2.globalVersion === globalVersion) {
            return;
          }
          computed2.globalVersion = globalVersion;
          var dep = computed2.dep;
          computed2.flags |= 2;
          if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
            computed2.flags &= ~2;
            return;
          }
          var prevSub = activeSub;
          var prevShouldTrack = shouldTrack;
          activeSub = computed2;
          shouldTrack = true;
          try {
            prepareDeps(computed2);
            var value = computed2.fn(computed2._value);
            if (dep.version === 0 || hasChanged(value, computed2._value)) {
              computed2._value = value;
              dep.version++;
            }
          } catch (err) {
            dep.version++;
            throw err;
          } finally {
            activeSub = prevSub;
            shouldTrack = prevShouldTrack;
            cleanupDeps(computed2);
            computed2.flags &= ~2;
          }
        }
        function removeSub(link) {
          var soft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var dep = link.dep,
            prevSub = link.prevSub,
            nextSub = link.nextSub;
          if (prevSub) {
            prevSub.nextSub = nextSub;
            link.prevSub = void 0;
          }
          if (nextSub) {
            nextSub.prevSub = prevSub;
            link.nextSub = void 0;
          }
          if (dep.subs === link) {
            dep.subs = prevSub;
            if (!prevSub && dep.computed) {
              dep.computed.flags &= ~4;
              for (var l = dep.computed.deps; l; l = l.nextDep) {
                removeSub(l, true);
              }
            }
          }
          if (!soft && ! --dep.sc && dep.map) {
            dep.map.delete(dep.key);
          }
        }
        function removeDep(link) {
          var prevDep = link.prevDep,
            nextDep = link.nextDep;
          if (prevDep) {
            prevDep.nextDep = nextDep;
            link.prevDep = void 0;
          }
          if (nextDep) {
            nextDep.prevDep = prevDep;
            link.nextDep = void 0;
          }
        }
        function effect(fn, options) {
          if (fn.effect instanceof ReactiveEffect) {
            fn = fn.effect.fn;
          }
          var e = new ReactiveEffect(fn);
          if (options) {
            extend(e, options);
          }
          try {
            e.run();
          } catch (err) {
            e.stop();
            throw err;
          }
          var runner = e.run.bind(e);
          runner.effect = e;
          return runner;
        }
        function stop(runner) {
          runner.effect.stop();
        }
        var shouldTrack = true;
        var trackStack = [];
        function pauseTracking() {
          trackStack.push(shouldTrack);
          shouldTrack = false;
        }
        function resetTracking() {
          var last = trackStack.pop();
          shouldTrack = last === void 0 ? true : last;
        }
        function cleanupEffect(e) {
          var cleanup = e.cleanup;
          e.cleanup = void 0;
          if (cleanup) {
            var prevSub = activeSub;
            activeSub = void 0;
            try {
              cleanup();
            } finally {
              activeSub = prevSub;
            }
          }
        }
        var globalVersion = 0;
        var Link = /*#__PURE__*/_createClass(function Link(sub, dep) {
          _classCallCheck2(this, Link);
          this.sub = sub;
          this.dep = dep;
          this.version = dep.version;
          this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
        });
        var Dep = /*#__PURE__*/function () {
          function Dep(computed2) {
            _classCallCheck2(this, Dep);
            this.computed = computed2;
            this.version = 0;
            this.activeLink = void 0;
            this.subs = void 0;
            this.map = void 0;
            this.key = void 0;
            this.sc = 0;
          }
          return _createClass(Dep, [{
            key: "track",
            value: function track(debugInfo) {
              if (!activeSub || !shouldTrack || activeSub === this.computed) {
                return;
              }
              var link = this.activeLink;
              if (link === void 0 || link.sub !== activeSub) {
                link = this.activeLink = new Link(activeSub, this);
                if (!activeSub.deps) {
                  activeSub.deps = activeSub.depsTail = link;
                } else {
                  link.prevDep = activeSub.depsTail;
                  activeSub.depsTail.nextDep = link;
                  activeSub.depsTail = link;
                }
                addSub(link);
              } else if (link.version === -1) {
                link.version = this.version;
                if (link.nextDep) {
                  var next = link.nextDep;
                  next.prevDep = link.prevDep;
                  if (link.prevDep) {
                    link.prevDep.nextDep = next;
                  }
                  link.prevDep = activeSub.depsTail;
                  link.nextDep = void 0;
                  activeSub.depsTail.nextDep = link;
                  activeSub.depsTail = link;
                  if (activeSub.deps === link) {
                    activeSub.deps = next;
                  }
                }
              }
              return link;
            }
          }, {
            key: "trigger",
            value: function trigger(debugInfo) {
              this.version++;
              globalVersion++;
              this.notify(debugInfo);
            }
          }, {
            key: "notify",
            value: function notify(debugInfo) {
              startBatch();
              try {
                if (false) ;
                for (var link = this.subs; link; link = link.prevSub) {
                  if (link.sub.notify()) {
                    ;
                    link.sub.dep.notify();
                  }
                }
              } finally {
                endBatch();
              }
            }
          }]);
        }();
        function addSub(link) {
          link.dep.sc++;
          if (link.sub.flags & 4) {
            var computed2 = link.dep.computed;
            if (computed2 && !link.dep.subs) {
              computed2.flags |= 4 | 16;
              for (var l = computed2.deps; l; l = l.nextDep) {
                addSub(l);
              }
            }
            var currentTail = link.dep.subs;
            if (currentTail !== link) {
              link.prevSub = currentTail;
              if (currentTail) currentTail.nextSub = link;
            }
            link.dep.subs = link;
          }
        }
        var targetMap = /* @__PURE__ */new WeakMap();
        var ITERATE_KEY = Symbol("");
        var MAP_KEY_ITERATE_KEY = Symbol("");
        var ARRAY_ITERATE_KEY = Symbol("");
        function track(target, type, key) {
          if (shouldTrack && activeSub) {
            var depsMap = targetMap.get(target);
            if (!depsMap) {
              targetMap.set(target, depsMap = /* @__PURE__ */new Map());
            }
            var dep = depsMap.get(key);
            if (!dep) {
              depsMap.set(key, dep = new Dep());
              dep.map = depsMap;
              dep.key = key;
            }
            {
              dep.track();
            }
          }
        }
        function trigger(target, type, key, newValue, oldValue, oldTarget) {
          var depsMap = targetMap.get(target);
          if (!depsMap) {
            globalVersion++;
            return;
          }
          var run = function run(dep) {
            if (dep) {
              {
                dep.trigger();
              }
            }
          };
          startBatch();
          if (type === "clear") {
            depsMap.forEach(run);
          } else {
            var targetIsArray = isArray$2(target);
            var isArrayIndex = targetIsArray && isIntegerKey(key);
            if (targetIsArray && key === "length") {
              var newLength = Number(newValue);
              depsMap.forEach(function (dep, key2) {
                if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
                  run(dep);
                }
              });
            } else {
              if (key !== void 0 || depsMap.has(void 0)) {
                run(depsMap.get(key));
              }
              if (isArrayIndex) {
                run(depsMap.get(ARRAY_ITERATE_KEY));
              }
              switch (type) {
                case "add":
                  if (!targetIsArray) {
                    run(depsMap.get(ITERATE_KEY));
                    if (isMap(target)) {
                      run(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                  } else if (isArrayIndex) {
                    run(depsMap.get("length"));
                  }
                  break;
                case "delete":
                  if (!targetIsArray) {
                    run(depsMap.get(ITERATE_KEY));
                    if (isMap(target)) {
                      run(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                  }
                  break;
                case "set":
                  if (isMap(target)) {
                    run(depsMap.get(ITERATE_KEY));
                  }
                  break;
              }
            }
          }
          endBatch();
        }
        function getDepFromReactive(object, key) {
          var depMap = targetMap.get(object);
          return depMap && depMap.get(key);
        }
        function reactiveReadArray(array) {
          var raw = toRaw(array);
          if (raw === array) return raw;
          track(raw, "iterate", ARRAY_ITERATE_KEY);
          return isShallow(array) ? raw : raw.map(toReactive);
        }
        function shallowReadArray(arr) {
          track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
          return arr;
        }
        var arrayInstrumentations = (_arrayInstrumentation = {
          __proto__: null
        }, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_arrayInstrumentation, Symbol.iterator, function () {
          return iterator(this, Symbol.iterator, toReactive);
        }), "concat", function concat() {
          var _reactiveReadArray;
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          return (_reactiveReadArray = reactiveReadArray(this)).concat.apply(_reactiveReadArray, _toConsumableArray(args.map(function (x) {
            return isArray$2(x) ? reactiveReadArray(x) : x;
          })));
        }), "entries", function entries() {
          return iterator(this, "entries", function (value) {
            value[1] = toReactive(value[1]);
            return value;
          });
        }), "every", function every(fn, thisArg) {
          return apply$2(this, "every", fn, thisArg, void 0, arguments);
        }), "filter", function filter(fn, thisArg) {
          return apply$2(this, "filter", fn, thisArg, function (v) {
            return v.map(toReactive);
          }, arguments);
        }), "find", function find(fn, thisArg) {
          return apply$2(this, "find", fn, thisArg, toReactive, arguments);
        }), "findIndex", function findIndex(fn, thisArg) {
          return apply$2(this, "findIndex", fn, thisArg, void 0, arguments);
        }), "findLast", function findLast(fn, thisArg) {
          return apply$2(this, "findLast", fn, thisArg, toReactive, arguments);
        }), "findLastIndex", function findLastIndex(fn, thisArg) {
          return apply$2(this, "findLastIndex", fn, thisArg, void 0, arguments);
        }), "forEach", function forEach(fn, thisArg) {
          return apply$2(this, "forEach", fn, thisArg, void 0, arguments);
        }), _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_arrayInstrumentation, "includes", function includes() {
          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }
          return searchProxy(this, "includes", args);
        }), "indexOf", function indexOf() {
          for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
          }
          return searchProxy(this, "indexOf", args);
        }), "join", function join(separator) {
          return reactiveReadArray(this).join(separator);
        }), "lastIndexOf", function lastIndexOf() {
          for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            args[_key7] = arguments[_key7];
          }
          return searchProxy(this, "lastIndexOf", args);
        }), "map", function map(fn, thisArg) {
          return apply$2(this, "map", fn, thisArg, void 0, arguments);
        }), "pop", function pop() {
          return noTracking(this, "pop");
        }), "push", function push() {
          for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
            args[_key8] = arguments[_key8];
          }
          return noTracking(this, "push", args);
        }), "reduce", function reduce(fn) {
          for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
            args[_key9 - 1] = arguments[_key9];
          }
          return _reduce(this, "reduce", fn, args);
        }), "reduceRight", function reduceRight(fn) {
          for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
            args[_key10 - 1] = arguments[_key10];
          }
          return _reduce(this, "reduceRight", fn, args);
        }), "shift", function shift() {
          return noTracking(this, "shift");
        }), _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_arrayInstrumentation, "some", function some(fn, thisArg) {
          return apply$2(this, "some", fn, thisArg, void 0, arguments);
        }), "splice", function splice() {
          for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
            args[_key11] = arguments[_key11];
          }
          return noTracking(this, "splice", args);
        }), "toReversed", function toReversed() {
          return reactiveReadArray(this).toReversed();
        }), "toSorted", function toSorted(comparer) {
          return reactiveReadArray(this).toSorted(comparer);
        }), "toSpliced", function toSpliced() {
          var _reactiveReadArray2;
          return (_reactiveReadArray2 = reactiveReadArray(this)).toSpliced.apply(_reactiveReadArray2, arguments);
        }), "unshift", function unshift() {
          for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
            args[_key12] = arguments[_key12];
          }
          return noTracking(this, "unshift", args);
        }), "values", function values() {
          return iterator(this, "values", toReactive);
        }));
        function iterator(self, method, wrapValue) {
          var arr = shallowReadArray(self);
          var iter = arr[method]();
          if (arr !== self && !isShallow(self)) {
            iter._next = iter.next;
            iter.next = function () {
              var result = iter._next();
              if (result.value) {
                result.value = wrapValue(result.value);
              }
              return result;
            };
          }
          return iter;
        }
        var arrayProto = Array.prototype;
        function apply$2(self, method, fn, thisArg, wrappedRetFn, args) {
          var arr = shallowReadArray(self);
          var needsWrap = arr !== self && !isShallow(self);
          var methodFn = arr[method];
          if (methodFn !== arrayProto[method]) {
            var result2 = methodFn.apply(self, args);
            return needsWrap ? toReactive(result2) : result2;
          }
          var wrappedFn = fn;
          if (arr !== self) {
            if (needsWrap) {
              wrappedFn = function wrappedFn(item, index) {
                return fn.call(this, toReactive(item), index, self);
              };
            } else if (fn.length > 2) {
              wrappedFn = function wrappedFn(item, index) {
                return fn.call(this, item, index, self);
              };
            }
          }
          var result = methodFn.call(arr, wrappedFn, thisArg);
          return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
        }
        function _reduce(self, method, fn, args) {
          var arr = shallowReadArray(self);
          var wrappedFn = fn;
          if (arr !== self) {
            if (!isShallow(self)) {
              wrappedFn = function wrappedFn(acc, item, index) {
                return fn.call(this, acc, toReactive(item), index, self);
              };
            } else if (fn.length > 3) {
              wrappedFn = function wrappedFn(acc, item, index) {
                return fn.call(this, acc, item, index, self);
              };
            }
          }
          return arr[method].apply(arr, [wrappedFn].concat(_toConsumableArray(args)));
        }
        function searchProxy(self, method, args) {
          var arr = toRaw(self);
          track(arr, "iterate", ARRAY_ITERATE_KEY);
          var res = arr[method].apply(arr, _toConsumableArray(args));
          if ((res === -1 || res === false) && isProxy(args[0])) {
            args[0] = toRaw(args[0]);
            return arr[method].apply(arr, _toConsumableArray(args));
          }
          return res;
        }
        function noTracking(self, method) {
          var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          pauseTracking();
          startBatch();
          var res = toRaw(self)[method].apply(self, args);
          endBatch();
          resetTracking();
          return res;
        }
        var isNonTrackableKeys = /* @__PURE__ */makeMap("__proto__,__v_isRef,__isVue");
        var builtInSymbols = new Set(/* @__PURE__ */Object.getOwnPropertyNames(Symbol).filter(function (key) {
          return key !== "arguments" && key !== "caller";
        }).map(function (key) {
          return Symbol[key];
        }).filter(isSymbol));
        function hasOwnProperty$1(key) {
          if (!isSymbol(key)) key = String(key);
          var obj = toRaw(this);
          track(obj, "has", key);
          return obj.hasOwnProperty(key);
        }
        var BaseReactiveHandler = /*#__PURE__*/function () {
          function BaseReactiveHandler() {
            var _isReadonly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var _isShallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            _classCallCheck2(this, BaseReactiveHandler);
            this._isReadonly = _isReadonly;
            this._isShallow = _isShallow;
          }
          return _createClass(BaseReactiveHandler, [{
            key: "get",
            value: function get(target, key, receiver) {
              if (key === "__v_skip") return target["__v_skip"];
              var isReadonly2 = this._isReadonly,
                isShallow2 = this._isShallow;
              if (key === "__v_isReactive") {
                return !isReadonly2;
              } else if (key === "__v_isReadonly") {
                return isReadonly2;
              } else if (key === "__v_isShallow") {
                return isShallow2;
              } else if (key === "__v_raw") {
                if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) ||
                // receiver is not the reactive proxy, but has the same prototype
                // this means the receiver is a user proxy of the reactive proxy
                Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
                  return target;
                }
                return;
              }
              var targetIsArray = isArray$2(target);
              if (!isReadonly2) {
                var fn;
                if (targetIsArray && (fn = arrayInstrumentations[key])) {
                  return fn;
                }
                if (key === "hasOwnProperty") {
                  return hasOwnProperty$1;
                }
              }
              var res = Reflect.get(target, key,
              // if this is a proxy wrapping a ref, return methods using the raw ref
              // as receiver so that we don't have to call `toRaw` on the ref in all
              // its class methods
              isRef(target) ? target : receiver);
              if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
                return res;
              }
              if (!isReadonly2) {
                track(target, "get", key);
              }
              if (isShallow2) {
                return res;
              }
              if (isRef(res)) {
                return targetIsArray && isIntegerKey(key) ? res : res.value;
              }
              if (isObject$2(res)) {
                return isReadonly2 ? readonly(res) : reactive(res);
              }
              return res;
            }
          }]);
        }();
        var MutableReactiveHandler = /*#__PURE__*/function (_BaseReactiveHandler) {
          function MutableReactiveHandler() {
            var isShallow2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            _classCallCheck2(this, MutableReactiveHandler);
            return _callSuper(this, MutableReactiveHandler, [false, isShallow2]);
          }
          _inherits(MutableReactiveHandler, _BaseReactiveHandler);
          return _createClass(MutableReactiveHandler, [{
            key: "set",
            value: function set(target, key, value, receiver) {
              var oldValue = target[key];
              if (!this._isShallow) {
                var isOldValueReadonly = isReadonly(oldValue);
                if (!isShallow(value) && !isReadonly(value)) {
                  oldValue = toRaw(oldValue);
                  value = toRaw(value);
                }
                if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
                  if (isOldValueReadonly) {
                    return false;
                  } else {
                    oldValue.value = value;
                    return true;
                  }
                }
              }
              var hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
              var result = Reflect.set(target, key, value, isRef(target) ? target : receiver);
              if (target === toRaw(receiver)) {
                if (!hadKey) {
                  trigger(target, "add", key, value);
                } else if (hasChanged(value, oldValue)) {
                  trigger(target, "set", key, value);
                }
              }
              return result;
            }
          }, {
            key: "deleteProperty",
            value: function deleteProperty(target, key) {
              var hadKey = hasOwn$1(target, key);
              target[key];
              var result = Reflect.deleteProperty(target, key);
              if (result && hadKey) {
                trigger(target, "delete", key, void 0);
              }
              return result;
            }
          }, {
            key: "has",
            value: function has(target, key) {
              var result = Reflect.has(target, key);
              if (!isSymbol(key) || !builtInSymbols.has(key)) {
                track(target, "has", key);
              }
              return result;
            }
          }, {
            key: "ownKeys",
            value: function ownKeys(target) {
              track(target, "iterate", isArray$2(target) ? "length" : ITERATE_KEY);
              return Reflect.ownKeys(target);
            }
          }]);
        }(BaseReactiveHandler);
        var ReadonlyReactiveHandler = /*#__PURE__*/function (_BaseReactiveHandler2) {
          function ReadonlyReactiveHandler() {
            var isShallow2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            _classCallCheck2(this, ReadonlyReactiveHandler);
            return _callSuper(this, ReadonlyReactiveHandler, [true, isShallow2]);
          }
          _inherits(ReadonlyReactiveHandler, _BaseReactiveHandler2);
          return _createClass(ReadonlyReactiveHandler, [{
            key: "set",
            value: function set(target, key) {
              return true;
            }
          }, {
            key: "deleteProperty",
            value: function deleteProperty(target, key) {
              return true;
            }
          }]);
        }(BaseReactiveHandler);
        var mutableHandlers = /* @__PURE__ */new MutableReactiveHandler();
        var readonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler();
        var shallowReactiveHandlers = /* @__PURE__ */new MutableReactiveHandler(true);
        var shallowReadonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler(true);
        var toShallow = function toShallow(value) {
          return value;
        };
        var getProto = function getProto(v) {
          return Reflect.getPrototypeOf(v);
        };
        function createIterableMethod(method, isReadonly2, isShallow2) {
          return function () {
            var target = this["__v_raw"];
            var rawTarget = toRaw(target);
            var targetIsMap = isMap(rawTarget);
            var isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
            var isKeyOnly = method === "keys" && targetIsMap;
            var innerIterator = target[method].apply(target, arguments);
            var wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
            !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
            return _defineProperty2({
              // iterator protocol
              next: function next() {
                var _innerIterator$next = innerIterator.next(),
                  value = _innerIterator$next.value,
                  done = _innerIterator$next.done;
                return done ? {
                  value: value,
                  done: done
                } : {
                  value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                  done: done
                };
              }
            }, Symbol.iterator, function () {
              return this;
            });
          };
        }
        function createReadonlyMethod(type) {
          return function () {
            return type === "delete" ? false : type === "clear" ? void 0 : this;
          };
        }
        function createInstrumentations(readonly2, shallow) {
          var instrumentations = {
            get: function get(key) {
              var target = this["__v_raw"];
              var rawTarget = toRaw(target);
              var rawKey = toRaw(key);
              if (!readonly2) {
                if (hasChanged(key, rawKey)) {
                  track(rawTarget, "get", key);
                }
                track(rawTarget, "get", rawKey);
              }
              var _getProto = getProto(rawTarget),
                has = _getProto.has;
              var wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
              if (has.call(rawTarget, key)) {
                return wrap(target.get(key));
              } else if (has.call(rawTarget, rawKey)) {
                return wrap(target.get(rawKey));
              } else if (target !== rawTarget) {
                target.get(key);
              }
            },
            get size() {
              var target = this["__v_raw"];
              !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
              return Reflect.get(target, "size", target);
            },
            has: function has(key) {
              var target = this["__v_raw"];
              var rawTarget = toRaw(target);
              var rawKey = toRaw(key);
              if (!readonly2) {
                if (hasChanged(key, rawKey)) {
                  track(rawTarget, "has", key);
                }
                track(rawTarget, "has", rawKey);
              }
              return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
            },
            forEach: function forEach(callback, thisArg) {
              var observed = this;
              var target = observed["__v_raw"];
              var rawTarget = toRaw(target);
              var wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
              !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
              return target.forEach(function (value, key) {
                return callback.call(thisArg, wrap(value), wrap(key), observed);
              });
            }
          };
          extend(instrumentations, readonly2 ? {
            add: createReadonlyMethod("add"),
            set: createReadonlyMethod("set"),
            delete: createReadonlyMethod("delete"),
            clear: createReadonlyMethod("clear")
          } : {
            add: function add(value) {
              if (!shallow && !isShallow(value) && !isReadonly(value)) {
                value = toRaw(value);
              }
              var target = toRaw(this);
              var proto = getProto(target);
              var hadKey = proto.has.call(target, value);
              if (!hadKey) {
                target.add(value);
                trigger(target, "add", value, value);
              }
              return this;
            },
            set: function set(key, value) {
              if (!shallow && !isShallow(value) && !isReadonly(value)) {
                value = toRaw(value);
              }
              var target = toRaw(this);
              var _getProto2 = getProto(target),
                has = _getProto2.has,
                get = _getProto2.get;
              var hadKey = has.call(target, key);
              if (!hadKey) {
                key = toRaw(key);
                hadKey = has.call(target, key);
              }
              var oldValue = get.call(target, key);
              target.set(key, value);
              if (!hadKey) {
                trigger(target, "add", key, value);
              } else if (hasChanged(value, oldValue)) {
                trigger(target, "set", key, value);
              }
              return this;
            },
            delete: function _delete(key) {
              var target = toRaw(this);
              var _getProto3 = getProto(target),
                has = _getProto3.has,
                get = _getProto3.get;
              var hadKey = has.call(target, key);
              if (!hadKey) {
                key = toRaw(key);
                hadKey = has.call(target, key);
              }
              get ? get.call(target, key) : void 0;
              var result = target.delete(key);
              if (hadKey) {
                trigger(target, "delete", key, void 0);
              }
              return result;
            },
            clear: function clear() {
              var target = toRaw(this);
              var hadItems = target.size !== 0;
              var result = target.clear();
              if (hadItems) {
                trigger(target, "clear", void 0, void 0);
              }
              return result;
            }
          });
          var iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
          iteratorMethods.forEach(function (method) {
            instrumentations[method] = createIterableMethod(method, readonly2, shallow);
          });
          return instrumentations;
        }
        function createInstrumentationGetter(isReadonly2, shallow) {
          var instrumentations = createInstrumentations(isReadonly2, shallow);
          return function (target, key, receiver) {
            if (key === "__v_isReactive") {
              return !isReadonly2;
            } else if (key === "__v_isReadonly") {
              return isReadonly2;
            } else if (key === "__v_raw") {
              return target;
            }
            return Reflect.get(hasOwn$1(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
          };
        }
        var mutableCollectionHandlers = {
          get: /* @__PURE__ */createInstrumentationGetter(false, false)
        };
        var shallowCollectionHandlers = {
          get: /* @__PURE__ */createInstrumentationGetter(false, true)
        };
        var readonlyCollectionHandlers = {
          get: /* @__PURE__ */createInstrumentationGetter(true, false)
        };
        var shallowReadonlyCollectionHandlers = {
          get: /* @__PURE__ */createInstrumentationGetter(true, true)
        };
        var reactiveMap = /* @__PURE__ */new WeakMap();
        var shallowReactiveMap = /* @__PURE__ */new WeakMap();
        var readonlyMap = /* @__PURE__ */new WeakMap();
        var shallowReadonlyMap = /* @__PURE__ */new WeakMap();
        function targetTypeMap(rawType) {
          switch (rawType) {
            case "Object":
            case "Array":
              return 1;
            case "Map":
            case "Set":
            case "WeakMap":
            case "WeakSet":
              return 2;
            default:
              return 0;
          }
        }
        function getTargetType(value) {
          return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
        }
        function reactive(target) {
          if (isReadonly(target)) {
            return target;
          }
          return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
        }
        function shallowReactive(target) {
          return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
        }
        function readonly(target) {
          return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
        }
        function shallowReadonly(target) {
          return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
        }
        function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
          if (!isObject$2(target)) {
            return target;
          }
          if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
            return target;
          }
          var existingProxy = proxyMap.get(target);
          if (existingProxy) {
            return existingProxy;
          }
          var targetType = getTargetType(target);
          if (targetType === 0) {
            return target;
          }
          var proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
          proxyMap.set(target, proxy);
          return proxy;
        }
        function isReactive(value) {
          if (isReadonly(value)) {
            return isReactive(value["__v_raw"]);
          }
          return !!(value && value["__v_isReactive"]);
        }
        function isReadonly(value) {
          return !!(value && value["__v_isReadonly"]);
        }
        function isShallow(value) {
          return !!(value && value["__v_isShallow"]);
        }
        function isProxy(value) {
          return value ? !!value["__v_raw"] : false;
        }
        function toRaw(observed) {
          var raw = observed && observed["__v_raw"];
          return raw ? toRaw(raw) : observed;
        }
        function markRaw(value) {
          if (!hasOwn$1(value, "__v_skip") && Object.isExtensible(value)) {
            def(value, "__v_skip", true);
          }
          return value;
        }
        var toReactive = function toReactive(value) {
          return isObject$2(value) ? reactive(value) : value;
        };
        var toReadonly = function toReadonly(value) {
          return isObject$2(value) ? readonly(value) : value;
        };
        function isRef(r) {
          return r ? r["__v_isRef"] === true : false;
        }
        function ref(value) {
          return createRef(value, false);
        }
        function shallowRef(value) {
          return createRef(value, true);
        }
        function createRef(rawValue, shallow) {
          if (isRef(rawValue)) {
            return rawValue;
          }
          return new RefImpl(rawValue, shallow);
        }
        var RefImpl = /*#__PURE__*/function () {
          function RefImpl(value, isShallow2) {
            _classCallCheck2(this, RefImpl);
            this.dep = new Dep();
            this["__v_isRef"] = true;
            this["__v_isShallow"] = false;
            this._rawValue = isShallow2 ? value : toRaw(value);
            this._value = isShallow2 ? value : toReactive(value);
            this["__v_isShallow"] = isShallow2;
          }
          return _createClass(RefImpl, [{
            key: "value",
            get: function get() {
              {
                this.dep.track();
              }
              return this._value;
            },
            set: function set(newValue) {
              var oldValue = this._rawValue;
              var useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
              newValue = useDirectValue ? newValue : toRaw(newValue);
              if (hasChanged(newValue, oldValue)) {
                this._rawValue = newValue;
                this._value = useDirectValue ? newValue : toReactive(newValue);
                {
                  this.dep.trigger();
                }
              }
            }
          }]);
        }();
        function triggerRef(ref2) {
          if (ref2.dep) {
            {
              ref2.dep.trigger();
            }
          }
        }
        function unref(ref2) {
          return isRef(ref2) ? ref2.value : ref2;
        }
        function toValue$1(source) {
          return isFunction$1(source) ? source() : unref(source);
        }
        var shallowUnwrapHandlers = {
          get: function get(target, key, receiver) {
            return key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver));
          },
          set: function set(target, key, value, receiver) {
            var oldValue = target[key];
            if (isRef(oldValue) && !isRef(value)) {
              oldValue.value = value;
              return true;
            } else {
              return Reflect.set(target, key, value, receiver);
            }
          }
        };
        function proxyRefs(objectWithRefs) {
          return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
        }
        var CustomRefImpl = /*#__PURE__*/function () {
          function CustomRefImpl(factory) {
            _classCallCheck2(this, CustomRefImpl);
            this["__v_isRef"] = true;
            this._value = void 0;
            var dep = this.dep = new Dep();
            var _factory = factory(dep.track.bind(dep), dep.trigger.bind(dep)),
              get = _factory.get,
              set = _factory.set;
            this._get = get;
            this._set = set;
          }
          return _createClass(CustomRefImpl, [{
            key: "value",
            get: function get() {
              return this._value = this._get();
            },
            set: function set(newVal) {
              this._set(newVal);
            }
          }]);
        }();
        function customRef(factory) {
          return new CustomRefImpl(factory);
        }
        function toRefs(object) {
          var ret = isArray$2(object) ? new Array(object.length) : {};
          for (var key in object) {
            ret[key] = propertyToRef(object, key);
          }
          return ret;
        }
        var ObjectRefImpl = /*#__PURE__*/function () {
          function ObjectRefImpl(_object, _key, _defaultValue) {
            _classCallCheck2(this, ObjectRefImpl);
            this._object = _object;
            this._key = _key;
            this._defaultValue = _defaultValue;
            this["__v_isRef"] = true;
            this._value = void 0;
          }
          return _createClass(ObjectRefImpl, [{
            key: "value",
            get: function get() {
              var val = this._object[this._key];
              return this._value = val === void 0 ? this._defaultValue : val;
            },
            set: function set(newVal) {
              this._object[this._key] = newVal;
            }
          }, {
            key: "dep",
            get: function get() {
              return getDepFromReactive(toRaw(this._object), this._key);
            }
          }]);
        }();
        var GetterRefImpl = /*#__PURE__*/function () {
          function GetterRefImpl(_getter) {
            _classCallCheck2(this, GetterRefImpl);
            this._getter = _getter;
            this["__v_isRef"] = true;
            this["__v_isReadonly"] = true;
            this._value = void 0;
          }
          return _createClass(GetterRefImpl, [{
            key: "value",
            get: function get() {
              return this._value = this._getter();
            }
          }]);
        }();
        function toRef(source, key, defaultValue) {
          if (isRef(source)) {
            return source;
          } else if (isFunction$1(source)) {
            return new GetterRefImpl(source);
          } else if (isObject$2(source) && arguments.length > 1) {
            return propertyToRef(source, key, defaultValue);
          } else {
            return ref(source);
          }
        }
        function propertyToRef(source, key, defaultValue) {
          var val = source[key];
          return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
        }
        var ComputedRefImpl = /*#__PURE__*/function () {
          function ComputedRefImpl(fn, setter, isSSR) {
            _classCallCheck2(this, ComputedRefImpl);
            this.fn = fn;
            this.setter = setter;
            this._value = void 0;
            this.dep = new Dep(this);
            this.__v_isRef = true;
            this.deps = void 0;
            this.depsTail = void 0;
            this.flags = 16;
            this.globalVersion = globalVersion - 1;
            this.next = void 0;
            this.effect = this;
            this["__v_isReadonly"] = !setter;
            this.isSSR = isSSR;
          }
          /**
           * @internal
           */
          return _createClass(ComputedRefImpl, [{
            key: "notify",
            value: function notify() {
              this.flags |= 16;
              if (!(this.flags & 8) &&
              // avoid infinite self recursion
              activeSub !== this) {
                batch(this, true);
                return true;
              }
            }
          }, {
            key: "value",
            get: function get() {
              var link = this.dep.track();
              refreshComputed(this);
              if (link) {
                link.version = this.dep.version;
              }
              return this._value;
            },
            set: function set(newValue) {
              if (this.setter) {
                this.setter(newValue);
              }
            }
          }]);
        }();
        function computed$1(getterOrOptions, debugOptions) {
          var isSSR = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var getter;
          var setter;
          if (isFunction$1(getterOrOptions)) {
            getter = getterOrOptions;
          } else {
            getter = getterOrOptions.get;
            setter = getterOrOptions.set;
          }
          var cRef = new ComputedRefImpl(getter, setter, isSSR);
          return cRef;
        }
        var TrackOpTypes = {
          "GET": "get",
          "HAS": "has",
          "ITERATE": "iterate"
        };
        var TriggerOpTypes = {
          "SET": "set",
          "ADD": "add",
          "DELETE": "delete",
          "CLEAR": "clear"
        };
        var INITIAL_WATCHER_VALUE = {};
        var cleanupMap = /* @__PURE__ */new WeakMap();
        var activeWatcher = void 0;
        function getCurrentWatcher() {
          return activeWatcher;
        }
        function onWatcherCleanup(cleanupFn) {
          var failSilently = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var owner = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : activeWatcher;
          if (owner) {
            var cleanups = cleanupMap.get(owner);
            if (!cleanups) cleanupMap.set(owner, cleanups = []);
            cleanups.push(cleanupFn);
          }
        }
        function watch$1(source, cb) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJ;
          var immediate = options.immediate,
            deep = options.deep,
            once = options.once,
            scheduler = options.scheduler,
            augmentJob = options.augmentJob,
            call = options.call;
          var reactiveGetter = function reactiveGetter(source2) {
            if (deep) return source2;
            if (isShallow(source2) || deep === false || deep === 0) return traverse(source2, 1);
            return traverse(source2);
          };
          var effect2;
          var getter;
          var cleanup;
          var boundCleanup;
          var forceTrigger = false;
          var isMultiSource = false;
          if (isRef(source)) {
            getter = function getter() {
              return source.value;
            };
            forceTrigger = isShallow(source);
          } else if (isReactive(source)) {
            getter = function getter() {
              return reactiveGetter(source);
            };
            forceTrigger = true;
          } else if (isArray$2(source)) {
            isMultiSource = true;
            forceTrigger = source.some(function (s) {
              return isReactive(s) || isShallow(s);
            });
            getter = function getter() {
              return source.map(function (s) {
                if (isRef(s)) {
                  return s.value;
                } else if (isReactive(s)) {
                  return reactiveGetter(s);
                } else if (isFunction$1(s)) {
                  return call ? call(s, 2) : s();
                } else ;
              });
            };
          } else if (isFunction$1(source)) {
            if (cb) {
              getter = call ? function () {
                return call(source, 2);
              } : source;
            } else {
              getter = function getter() {
                if (cleanup) {
                  pauseTracking();
                  try {
                    cleanup();
                  } finally {
                    resetTracking();
                  }
                }
                var currentEffect = activeWatcher;
                activeWatcher = effect2;
                try {
                  return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
                } finally {
                  activeWatcher = currentEffect;
                }
              };
            }
          } else {
            getter = NOOP;
          }
          if (cb && deep) {
            var baseGetter = getter;
            var depth = deep === true ? Infinity : deep;
            getter = function getter() {
              return traverse(baseGetter(), depth);
            };
          }
          var scope = getCurrentScope();
          var watchHandle = function watchHandle() {
            effect2.stop();
            if (scope && scope.active) {
              remove(scope.effects, effect2);
            }
          };
          if (once && cb) {
            var _cb = cb;
            cb = function cb() {
              _cb.apply(void 0, arguments);
              watchHandle();
            };
          }
          var oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
          var job = function job(immediateFirstRun) {
            if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
              return;
            }
            if (cb) {
              var newValue = effect2.run();
              if (deep || forceTrigger || (isMultiSource ? newValue.some(function (v, i) {
                return hasChanged(v, oldValue[i]);
              }) : hasChanged(newValue, oldValue))) {
                if (cleanup) {
                  cleanup();
                }
                var currentWatcher = activeWatcher;
                activeWatcher = effect2;
                try {
                  var args = [newValue,
                  // pass undefined as the old value when it's changed for the first time
                  oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue, boundCleanup];
                  call ? call(cb, 3, args) :
                  // @ts-expect-error
                  cb.apply(void 0, args);
                  oldValue = newValue;
                } finally {
                  activeWatcher = currentWatcher;
                }
              }
            } else {
              effect2.run();
            }
          };
          if (augmentJob) {
            augmentJob(job);
          }
          effect2 = new ReactiveEffect(getter);
          effect2.scheduler = scheduler ? function () {
            return scheduler(job, false);
          } : job;
          boundCleanup = function boundCleanup(fn) {
            return onWatcherCleanup(fn, false, effect2);
          };
          cleanup = effect2.onStop = function () {
            var cleanups = cleanupMap.get(effect2);
            if (cleanups) {
              if (call) {
                call(cleanups, 4);
              } else {
                var _iterator5 = _createForOfIteratorHelper(cleanups),
                  _step5;
                try {
                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                    var cleanup2 = _step5.value;
                    cleanup2();
                  }
                } catch (err) {
                  _iterator5.e(err);
                } finally {
                  _iterator5.f();
                }
              }
              cleanupMap.delete(effect2);
            }
          };
          if (cb) {
            if (immediate) {
              job(true);
            } else {
              oldValue = effect2.run();
            }
          } else if (scheduler) {
            scheduler(job.bind(null, true), true);
          } else {
            effect2.run();
          }
          watchHandle.pause = effect2.pause.bind(effect2);
          watchHandle.resume = effect2.resume.bind(effect2);
          watchHandle.stop = watchHandle;
          return watchHandle;
        }
        function traverse(value) {
          var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
          var seen = arguments.length > 2 ? arguments[2] : undefined;
          if (depth <= 0 || !isObject$2(value) || value["__v_skip"]) {
            return value;
          }
          seen = seen || /* @__PURE__ */new Set();
          if (seen.has(value)) {
            return value;
          }
          seen.add(value);
          depth--;
          if (isRef(value)) {
            traverse(value.value, depth, seen);
          } else if (isArray$2(value)) {
            for (var i = 0; i < value.length; i++) {
              traverse(value[i], depth, seen);
            }
          } else if (isSet(value) || isMap(value)) {
            value.forEach(function (v) {
              traverse(v, depth, seen);
            });
          } else if (isPlainObject$2(value)) {
            for (var key in value) {
              traverse(value[key], depth, seen);
            }
            var _iterator6 = _createForOfIteratorHelper(Object.getOwnPropertySymbols(value)),
              _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var _key13 = _step6.value;
                if (Object.prototype.propertyIsEnumerable.call(value, _key13)) {
                  traverse(value[_key13], depth, seen);
                }
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          }
          return value;
        }

        /**
        * @vue/runtime-core v3.5.13
        * (c) 2018-present Yuxi (Evan) You and Vue contributors
        * @license MIT
        **/
        var stack = [];
        function pushWarningContext(vnode) {
          stack.push(vnode);
        }
        function popWarningContext() {
          stack.pop();
        }
        var isWarning = false;
        function warn$1(msg) {
          if (isWarning) return;
          isWarning = true;
          pauseTracking();
          var instance = stack.length ? stack[stack.length - 1].component : null;
          var appWarnHandler = instance && instance.appContext.config.warnHandler;
          var trace = getComponentTrace();
          for (var _len13 = arguments.length, args = new Array(_len13 > 1 ? _len13 - 1 : 0), _key14 = 1; _key14 < _len13; _key14++) {
            args[_key14 - 1] = arguments[_key14];
          }
          if (appWarnHandler) {
            callWithErrorHandling(appWarnHandler, instance, 11, [
            // eslint-disable-next-line no-restricted-syntax
            msg + args.map(function (a) {
              var _a, _b;
              return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
            }).join(""), instance && instance.proxy, trace.map(function (_ref7) {
              var vnode = _ref7.vnode;
              return "at <".concat(formatComponentName(instance, vnode.type), ">");
            }).join("\n"), trace]);
          } else {
            var _console;
            var warnArgs = ["[Vue warn]: ".concat(msg)].concat(args);
            if (trace.length &&
            // avoid spamming console during tests
            true) {
              warnArgs.push.apply(warnArgs, ["\n"].concat(_toConsumableArray(formatTrace(trace))));
            }
            (_console = console).warn.apply(_console, _toConsumableArray(warnArgs));
          }
          resetTracking();
          isWarning = false;
        }
        function getComponentTrace() {
          var currentVNode = stack[stack.length - 1];
          if (!currentVNode) {
            return [];
          }
          var normalizedStack = [];
          while (currentVNode) {
            var last = normalizedStack[0];
            if (last && last.vnode === currentVNode) {
              last.recurseCount++;
            } else {
              normalizedStack.push({
                vnode: currentVNode,
                recurseCount: 0
              });
            }
            var parentInstance = currentVNode.component && currentVNode.component.parent;
            currentVNode = parentInstance && parentInstance.vnode;
          }
          return normalizedStack;
        }
        function formatTrace(trace) {
          var logs = [];
          trace.forEach(function (entry, i) {
            logs.push.apply(logs, _toConsumableArray(i === 0 ? [] : ["\n"]).concat(_toConsumableArray(formatTraceEntry(entry))));
          });
          return logs;
        }
        function formatTraceEntry(_ref8) {
          var vnode = _ref8.vnode,
            recurseCount = _ref8.recurseCount;
          var postfix = recurseCount > 0 ? "... (".concat(recurseCount, " recursive calls)") : "";
          var isRoot = vnode.component ? vnode.component.parent == null : false;
          var open = " at <".concat(formatComponentName(vnode.component, vnode.type, isRoot));
          var close = ">" + postfix;
          return vnode.props ? [open].concat(_toConsumableArray(formatProps(vnode.props)), [close]) : [open + close];
        }
        function formatProps(props) {
          var res = [];
          var keys = Object.keys(props);
          keys.slice(0, 3).forEach(function (key) {
            res.push.apply(res, _toConsumableArray(formatProp(key, props[key])));
          });
          if (keys.length > 3) {
            res.push(" ...");
          }
          return res;
        }
        function formatProp(key, value, raw) {
          if (isString$1(value)) {
            value = JSON.stringify(value);
            return raw ? value : ["".concat(key, "=").concat(value)];
          } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
            return raw ? value : ["".concat(key, "=").concat(value)];
          } else if (isRef(value)) {
            value = formatProp(key, toRaw(value.value), true);
            return raw ? value : ["".concat(key, "=Ref<"), value, ">"];
          } else if (isFunction$1(value)) {
            return ["".concat(key, "=fn").concat(value.name ? "<".concat(value.name, ">") : "")];
          } else {
            value = toRaw(value);
            return raw ? value : ["".concat(key, "="), value];
          }
        }
        function assertNumber(val, type) {
          return;
        }
        var ErrorCodes = {
          "SETUP_FUNCTION": 0,
          "0": "SETUP_FUNCTION",
          "RENDER_FUNCTION": 1,
          "1": "RENDER_FUNCTION",
          "NATIVE_EVENT_HANDLER": 5,
          "5": "NATIVE_EVENT_HANDLER",
          "COMPONENT_EVENT_HANDLER": 6,
          "6": "COMPONENT_EVENT_HANDLER",
          "VNODE_HOOK": 7,
          "7": "VNODE_HOOK",
          "DIRECTIVE_HOOK": 8,
          "8": "DIRECTIVE_HOOK",
          "TRANSITION_HOOK": 9,
          "9": "TRANSITION_HOOK",
          "APP_ERROR_HANDLER": 10,
          "10": "APP_ERROR_HANDLER",
          "APP_WARN_HANDLER": 11,
          "11": "APP_WARN_HANDLER",
          "FUNCTION_REF": 12,
          "12": "FUNCTION_REF",
          "ASYNC_COMPONENT_LOADER": 13,
          "13": "ASYNC_COMPONENT_LOADER",
          "SCHEDULER": 14,
          "14": "SCHEDULER",
          "COMPONENT_UPDATE": 15,
          "15": "COMPONENT_UPDATE",
          "APP_UNMOUNT_CLEANUP": 16,
          "16": "APP_UNMOUNT_CLEANUP"
        };
        var ErrorTypeStrings$1 = (_ErrorTypeStrings$ = {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_ErrorTypeStrings$, "sp", "serverPrefetch hook"), "bc", "beforeCreate hook"), "c", "created hook"), "bm", "beforeMount hook"), "m", "mounted hook"), "bu", "beforeUpdate hook"), "u", "updated"), "bum", "beforeUnmount hook"), "um", "unmounted hook"), "a", "activated hook"), _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_ErrorTypeStrings$, "da", "deactivated hook"), "ec", "errorCaptured hook"), "rtc", "renderTracked hook"), "rtg", "renderTriggered hook"), 0, "setup function"), 1, "render function"), 2, "watcher getter"), 3, "watcher callback"), 4, "watcher cleanup function"), 5, "native event handler"), _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_ErrorTypeStrings$, 6, "component event handler"), 7, "vnode hook"), 8, "directive hook"), 9, "transition hook"), 10, "app errorHandler"), 11, "app warnHandler"), 12, "ref function"), 13, "async component loader"), 14, "scheduler flush"), 15, "component update"), _defineProperty2(_ErrorTypeStrings$, 16, "app unmount cleanup function"));
        function callWithErrorHandling(fn, instance, type, args) {
          try {
            return args ? fn.apply(void 0, _toConsumableArray(args)) : fn();
          } catch (err) {
            handleError(err, instance, type);
          }
        }
        function callWithAsyncErrorHandling(fn, instance, type, args) {
          if (isFunction$1(fn)) {
            var res = callWithErrorHandling(fn, instance, type, args);
            if (res && isPromise$1(res)) {
              res.catch(function (err) {
                handleError(err, instance, type);
              });
            }
            return res;
          }
          if (isArray$2(fn)) {
            var values = [];
            for (var i = 0; i < fn.length; i++) {
              values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
            }
            return values;
          }
        }
        function handleError(err, instance, type) {
          var throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
          var contextVNode = instance ? instance.vnode : null;
          var _ref9 = instance && instance.appContext.config || EMPTY_OBJ,
            errorHandler = _ref9.errorHandler,
            throwUnhandledErrorInProduction = _ref9.throwUnhandledErrorInProduction;
          if (instance) {
            var cur = instance.parent;
            var exposedInstance = instance.proxy;
            var errorInfo = "https://vuejs.org/error-reference/#runtime-".concat(type);
            while (cur) {
              var errorCapturedHooks = cur.ec;
              if (errorCapturedHooks) {
                for (var i = 0; i < errorCapturedHooks.length; i++) {
                  if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                    return;
                  }
                }
              }
              cur = cur.parent;
            }
            if (errorHandler) {
              pauseTracking();
              callWithErrorHandling(errorHandler, null, 10, [err, exposedInstance, errorInfo]);
              resetTracking();
              return;
            }
          }
          logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
        }
        function logError(err, type, contextVNode) {
          var throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
          var throwInProd = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          if (throwInProd) {
            throw err;
          } else {
            console.error(err);
          }
        }
        var queue = [];
        var flushIndex = -1;
        var pendingPostFlushCbs = [];
        var activePostFlushCbs = null;
        var postFlushIndex = 0;
        var resolvedPromise = /* @__PURE__ */Promise.resolve();
        var currentFlushPromise = null;
        function nextTick(fn) {
          var p = currentFlushPromise || resolvedPromise;
          return fn ? p.then(this ? fn.bind(this) : fn) : p;
        }
        function findInsertionIndex$1(id) {
          var start = flushIndex + 1;
          var end = queue.length;
          while (start < end) {
            var middle = start + end >>> 1;
            var middleJob = queue[middle];
            var middleJobId = getId(middleJob);
            if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
              start = middle + 1;
            } else {
              end = middle;
            }
          }
          return start;
        }
        function queueJob(job) {
          if (!(job.flags & 1)) {
            var jobId = getId(job);
            var lastJob = queue[queue.length - 1];
            if (!lastJob ||
            // fast path when the job id is larger than the tail
            !(job.flags & 2) && jobId >= getId(lastJob)) {
              queue.push(job);
            } else {
              queue.splice(findInsertionIndex$1(jobId), 0, job);
            }
            job.flags |= 1;
            queueFlush();
          }
        }
        function queueFlush() {
          if (!currentFlushPromise) {
            currentFlushPromise = resolvedPromise.then(flushJobs);
          }
        }
        function queuePostFlushCb(cb) {
          if (!isArray$2(cb)) {
            if (activePostFlushCbs && cb.id === -1) {
              activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
            } else if (!(cb.flags & 1)) {
              pendingPostFlushCbs.push(cb);
              cb.flags |= 1;
            }
          } else {
            pendingPostFlushCbs.push.apply(pendingPostFlushCbs, _toConsumableArray(cb));
          }
          queueFlush();
        }
        function flushPreFlushCbs(instance, seen) {
          var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : flushIndex + 1;
          for (; i < queue.length; i++) {
            var cb = queue[i];
            if (cb && cb.flags & 2) {
              if (instance && cb.id !== instance.uid) {
                continue;
              }
              queue.splice(i, 1);
              i--;
              if (cb.flags & 4) {
                cb.flags &= ~1;
              }
              cb();
              if (!(cb.flags & 4)) {
                cb.flags &= ~1;
              }
            }
          }
        }
        function flushPostFlushCbs(seen) {
          if (pendingPostFlushCbs.length) {
            var deduped = _toConsumableArray(new Set(pendingPostFlushCbs)).sort(function (a, b) {
              return getId(a) - getId(b);
            });
            pendingPostFlushCbs.length = 0;
            if (activePostFlushCbs) {
              var _activePostFlushCbs;
              (_activePostFlushCbs = activePostFlushCbs).push.apply(_activePostFlushCbs, _toConsumableArray(deduped));
              return;
            }
            activePostFlushCbs = deduped;
            for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
              var cb = activePostFlushCbs[postFlushIndex];
              if (cb.flags & 4) {
                cb.flags &= ~1;
              }
              if (!(cb.flags & 8)) cb();
              cb.flags &= ~1;
            }
            activePostFlushCbs = null;
            postFlushIndex = 0;
          }
        }
        var getId = function getId(job) {
          return job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
        };
        function flushJobs(seen) {
          try {
            for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
              var job = queue[flushIndex];
              if (job && !(job.flags & 8)) {
                if (false) ;
                if (job.flags & 4) {
                  job.flags &= ~1;
                }
                callWithErrorHandling(job, job.i, job.i ? 15 : 14);
                if (!(job.flags & 4)) {
                  job.flags &= ~1;
                }
              }
            }
          } finally {
            for (; flushIndex < queue.length; flushIndex++) {
              var _job = queue[flushIndex];
              if (_job) {
                _job.flags &= ~1;
              }
            }
            flushIndex = -1;
            queue.length = 0;
            flushPostFlushCbs();
            currentFlushPromise = null;
            if (queue.length || pendingPostFlushCbs.length) {
              flushJobs();
            }
          }
        }
        var devtools$1;
        var buffer = [];
        function setDevtoolsHook$1(hook, target) {
          var _a, _b;
          devtools$1 = hook;
          if (devtools$1) {
            devtools$1.enabled = true;
            buffer.forEach(function (_ref10) {
              var _devtools$;
              var event = _ref10.event,
                args = _ref10.args;
              return (_devtools$ = devtools$1).emit.apply(_devtools$, [event].concat(_toConsumableArray(args)));
            });
            buffer = [];
          } else if (
          // handle late devtools injection - only do this if we are in an actual
          // browser environment to avoid the timer handle stalling test runner exit
          // (#4815)
          typeof window !== "undefined" &&
          // some envs mock window but not fully
          window.HTMLElement &&
          // also exclude jsdom
          // eslint-disable-next-line no-restricted-syntax
          !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
            var replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
            replay.push(function (newHook) {
              setDevtoolsHook$1(newHook, target);
            });
            setTimeout(function () {
              if (!devtools$1) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                buffer = [];
              }
            }, 3e3);
          } else {
            buffer = [];
          }
        }
        var currentRenderingInstance = null;
        var currentScopeId = null;
        function setCurrentRenderingInstance(instance) {
          var prev = currentRenderingInstance;
          currentRenderingInstance = instance;
          currentScopeId = instance && instance.type.__scopeId || null;
          return prev;
        }
        function pushScopeId(id) {
          currentScopeId = id;
        }
        function popScopeId() {
          currentScopeId = null;
        }
        var withScopeId = function withScopeId(_id) {
          return withCtx;
        };
        function withCtx(fn) {
          var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentRenderingInstance;
          var isNonScopedSlot = arguments.length > 2 ? arguments[2] : undefined;
          if (!ctx) return fn;
          if (fn._n) {
            return fn;
          }
          var _renderFnWithContext = function renderFnWithContext() {
            if (_renderFnWithContext._d) {
              setBlockTracking(-1);
            }
            var prevInstance = setCurrentRenderingInstance(ctx);
            var res;
            try {
              res = fn.apply(void 0, arguments);
            } finally {
              setCurrentRenderingInstance(prevInstance);
              if (_renderFnWithContext._d) {
                setBlockTracking(1);
              }
            }
            return res;
          };
          _renderFnWithContext._n = true;
          _renderFnWithContext._c = true;
          _renderFnWithContext._d = true;
          return _renderFnWithContext;
        }
        function withDirectives(vnode, directives) {
          if (currentRenderingInstance === null) {
            return vnode;
          }
          var instance = getComponentPublicInstance(currentRenderingInstance);
          var bindings = vnode.dirs || (vnode.dirs = []);
          for (var i = 0; i < directives.length; i++) {
            var _directives$i = _slicedToArray(directives[i], 4),
              dir = _directives$i[0],
              value = _directives$i[1],
              arg = _directives$i[2],
              _directives$i$ = _directives$i[3],
              modifiers = _directives$i$ === void 0 ? EMPTY_OBJ : _directives$i$;
            if (dir) {
              if (isFunction$1(dir)) {
                dir = {
                  mounted: dir,
                  updated: dir
                };
              }
              if (dir.deep) {
                traverse(value);
              }
              bindings.push({
                dir: dir,
                instance: instance,
                value: value,
                oldValue: void 0,
                arg: arg,
                modifiers: modifiers
              });
            }
          }
          return vnode;
        }
        function invokeDirectiveHook(vnode, prevVNode, instance, name) {
          var bindings = vnode.dirs;
          var oldBindings = prevVNode && prevVNode.dirs;
          for (var i = 0; i < bindings.length; i++) {
            var binding = bindings[i];
            if (oldBindings) {
              binding.oldValue = oldBindings[i].value;
            }
            var hook = binding.dir[name];
            if (hook) {
              pauseTracking();
              callWithAsyncErrorHandling(hook, instance, 8, [vnode.el, binding, vnode, prevVNode]);
              resetTracking();
            }
          }
        }
        var TeleportEndKey = Symbol("_vte");
        var isTeleport = function isTeleport(type) {
          return type.__isTeleport;
        };
        var isTeleportDisabled = function isTeleportDisabled(props) {
          return props && (props.disabled || props.disabled === "");
        };
        var isTeleportDeferred = function isTeleportDeferred(props) {
          return props && (props.defer || props.defer === "");
        };
        var isTargetSVG = function isTargetSVG(target) {
          return typeof SVGElement !== "undefined" && target instanceof SVGElement;
        };
        var isTargetMathML = function isTargetMathML(target) {
          return typeof MathMLElement === "function" && target instanceof MathMLElement;
        };
        var resolveTarget = function resolveTarget(props, select) {
          var targetSelector = props && props.to;
          if (isString$1(targetSelector)) {
            if (!select) {
              return null;
            } else {
              var target = select(targetSelector);
              return target;
            }
          } else {
            return targetSelector;
          }
        };
        var TeleportImpl = {
          name: "Teleport",
          __isTeleport: true,
          process: function process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
            var mountChildren = internals.mc,
              patchChildren = internals.pc,
              patchBlockChildren = internals.pbc,
              _internals$o = internals.o,
              insert = _internals$o.insert,
              querySelector = _internals$o.querySelector,
              createText = _internals$o.createText,
              createComment = _internals$o.createComment;
            var disabled = isTeleportDisabled(n2.props);
            var shapeFlag = n2.shapeFlag,
              children = n2.children,
              dynamicChildren = n2.dynamicChildren;
            if (n1 == null) {
              var placeholder = n2.el = createText("");
              var mainAnchor = n2.anchor = createText("");
              insert(placeholder, container, anchor);
              insert(mainAnchor, container, anchor);
              var mount = function mount(container2, anchor2) {
                if (shapeFlag & 16) {
                  if (parentComponent && parentComponent.isCE) {
                    parentComponent.ce._teleportTarget = container2;
                  }
                  mountChildren(children, container2, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                }
              };
              var mountToTarget = function mountToTarget() {
                var target = n2.target = resolveTarget(n2.props, querySelector);
                var targetAnchor = prepareAnchor(target, n2, createText, insert);
                if (target) {
                  if (namespace !== "svg" && isTargetSVG(target)) {
                    namespace = "svg";
                  } else if (namespace !== "mathml" && isTargetMathML(target)) {
                    namespace = "mathml";
                  }
                  if (!disabled) {
                    mount(target, targetAnchor);
                    updateCssVars(n2, false);
                  }
                }
              };
              if (disabled) {
                mount(container, mainAnchor);
                updateCssVars(n2, true);
              }
              if (isTeleportDeferred(n2.props)) {
                queuePostRenderEffect(function () {
                  mountToTarget();
                  n2.el.__isMounted = true;
                }, parentSuspense);
              } else {
                mountToTarget();
              }
            } else {
              if (isTeleportDeferred(n2.props) && !n1.el.__isMounted) {
                queuePostRenderEffect(function () {
                  TeleportImpl.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
                  delete n1.el.__isMounted;
                }, parentSuspense);
                return;
              }
              n2.el = n1.el;
              n2.targetStart = n1.targetStart;
              var _mainAnchor = n2.anchor = n1.anchor;
              var target = n2.target = n1.target;
              var targetAnchor = n2.targetAnchor = n1.targetAnchor;
              var wasDisabled = isTeleportDisabled(n1.props);
              var currentContainer = wasDisabled ? container : target;
              var currentAnchor = wasDisabled ? _mainAnchor : targetAnchor;
              if (namespace === "svg" || isTargetSVG(target)) {
                namespace = "svg";
              } else if (namespace === "mathml" || isTargetMathML(target)) {
                namespace = "mathml";
              }
              if (dynamicChildren) {
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, namespace, slotScopeIds);
                traverseStaticChildren(n1, n2, true);
              } else if (!optimized) {
                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, false);
              }
              if (disabled) {
                if (!wasDisabled) {
                  moveTeleport(n2, container, _mainAnchor, internals, 1);
                } else {
                  if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                    n2.props.to = n1.props.to;
                  }
                }
              } else {
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                  var nextTarget = n2.target = resolveTarget(n2.props, querySelector);
                  if (nextTarget) {
                    moveTeleport(n2, nextTarget, null, internals, 0);
                  }
                } else if (wasDisabled) {
                  moveTeleport(n2, target, targetAnchor, internals, 1);
                }
              }
              updateCssVars(n2, disabled);
            }
          },
          remove: function remove(vnode, parentComponent, parentSuspense, _ref11, doRemove) {
            var unmount = _ref11.um,
              hostRemove = _ref11.o.remove;
            var shapeFlag = vnode.shapeFlag,
              children = vnode.children,
              anchor = vnode.anchor,
              targetStart = vnode.targetStart,
              targetAnchor = vnode.targetAnchor,
              target = vnode.target,
              props = vnode.props;
            if (target) {
              hostRemove(targetStart);
              hostRemove(targetAnchor);
            }
            doRemove && hostRemove(anchor);
            if (shapeFlag & 16) {
              var shouldRemove = doRemove || !isTeleportDisabled(props);
              for (var i = 0; i < children.length; i++) {
                var child = children[i];
                unmount(child, parentComponent, parentSuspense, shouldRemove, !!child.dynamicChildren);
              }
            }
          },
          move: moveTeleport,
          hydrate: hydrateTeleport
        };
        function moveTeleport(vnode, container, parentAnchor, _ref12) {
          var insert = _ref12.o.insert,
            move = _ref12.m;
          var moveType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;
          if (moveType === 0) {
            insert(vnode.targetAnchor, container, parentAnchor);
          }
          var el = vnode.el,
            anchor = vnode.anchor,
            shapeFlag = vnode.shapeFlag,
            children = vnode.children,
            props = vnode.props;
          var isReorder = moveType === 2;
          if (isReorder) {
            insert(el, container, parentAnchor);
          }
          if (!isReorder || isTeleportDisabled(props)) {
            if (shapeFlag & 16) {
              for (var i = 0; i < children.length; i++) {
                move(children[i], container, parentAnchor, 2);
              }
            }
          }
          if (isReorder) {
            insert(anchor, container, parentAnchor);
          }
        }
        function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, _ref13, hydrateChildren) {
          var _ref13$o = _ref13.o,
            nextSibling = _ref13$o.nextSibling,
            parentNode = _ref13$o.parentNode,
            querySelector = _ref13$o.querySelector,
            insert = _ref13$o.insert,
            createText = _ref13$o.createText;
          var target = vnode.target = resolveTarget(vnode.props, querySelector);
          if (target) {
            var disabled = isTeleportDisabled(vnode.props);
            var targetNode = target._lpa || target.firstChild;
            if (vnode.shapeFlag & 16) {
              if (disabled) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetStart = targetNode;
                vnode.targetAnchor = targetNode && nextSibling(targetNode);
              } else {
                vnode.anchor = nextSibling(node);
                var targetAnchor = targetNode;
                while (targetAnchor) {
                  if (targetAnchor && targetAnchor.nodeType === 8) {
                    if (targetAnchor.data === "teleport start anchor") {
                      vnode.targetStart = targetAnchor;
                    } else if (targetAnchor.data === "teleport anchor") {
                      vnode.targetAnchor = targetAnchor;
                      target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                      break;
                    }
                  }
                  targetAnchor = nextSibling(targetAnchor);
                }
                if (!vnode.targetAnchor) {
                  prepareAnchor(target, vnode, createText, insert);
                }
                hydrateChildren(targetNode && nextSibling(targetNode), vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
              }
            }
            updateCssVars(vnode, disabled);
          }
          return vnode.anchor && nextSibling(vnode.anchor);
        }
        var Teleport = exports("$", TeleportImpl);
        function updateCssVars(vnode, isDisabled) {
          var ctx = vnode.ctx;
          if (ctx && ctx.ut) {
            var node, anchor;
            if (isDisabled) {
              node = vnode.el;
              anchor = vnode.anchor;
            } else {
              node = vnode.targetStart;
              anchor = vnode.targetAnchor;
            }
            while (node && node !== anchor) {
              if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
              node = node.nextSibling;
            }
            ctx.ut();
          }
        }
        function prepareAnchor(target, vnode, createText, insert) {
          var targetStart = vnode.targetStart = createText("");
          var targetAnchor = vnode.targetAnchor = createText("");
          targetStart[TeleportEndKey] = targetAnchor;
          if (target) {
            insert(targetStart, target);
            insert(targetAnchor, target);
          }
          return targetAnchor;
        }
        var leaveCbKey = Symbol("_leaveCb");
        var enterCbKey$1 = Symbol("_enterCb");
        function useTransitionState() {
          var state = {
            isMounted: false,
            isLeaving: false,
            isUnmounting: false,
            leavingVNodes: /* @__PURE__ */new Map()
          };
          onMounted(function () {
            state.isMounted = true;
          });
          onBeforeUnmount(function () {
            state.isUnmounting = true;
          });
          return state;
        }
        var TransitionHookValidator = [Function, Array];
        var BaseTransitionPropsValidators = {
          mode: String,
          appear: Boolean,
          persisted: Boolean,
          // enter
          onBeforeEnter: TransitionHookValidator,
          onEnter: TransitionHookValidator,
          onAfterEnter: TransitionHookValidator,
          onEnterCancelled: TransitionHookValidator,
          // leave
          onBeforeLeave: TransitionHookValidator,
          onLeave: TransitionHookValidator,
          onAfterLeave: TransitionHookValidator,
          onLeaveCancelled: TransitionHookValidator,
          // appear
          onBeforeAppear: TransitionHookValidator,
          onAppear: TransitionHookValidator,
          onAfterAppear: TransitionHookValidator,
          onAppearCancelled: TransitionHookValidator
        };
        var _recursiveGetSubtree = function recursiveGetSubtree(instance) {
          var subTree = instance.subTree;
          return subTree.component ? _recursiveGetSubtree(subTree.component) : subTree;
        };
        var BaseTransitionImpl = {
          name: "BaseTransition",
          props: BaseTransitionPropsValidators,
          setup: function setup(props, _ref14) {
            var slots = _ref14.slots;
            var instance = getCurrentInstance();
            var state = useTransitionState();
            return function () {
              var children = slots.default && getTransitionRawChildren(slots.default(), true);
              if (!children || !children.length) {
                return;
              }
              var child = findNonCommentChild(children);
              var rawProps = toRaw(props);
              var mode = rawProps.mode;
              if (state.isLeaving) {
                return emptyPlaceholder(child);
              }
              var innerChild = getInnerChild$1(child);
              if (!innerChild) {
                return emptyPlaceholder(child);
              }
              var enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance,
              // #11061, ensure enterHooks is fresh after clone
              function (hooks) {
                return enterHooks = hooks;
              });
              if (innerChild.type !== Comment) {
                setTransitionHooks(innerChild, enterHooks);
              }
              var oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
              if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && _recursiveGetSubtree(instance).type !== Comment) {
                var leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                setTransitionHooks(oldInnerChild, leavingHooks);
                if (mode === "out-in" && innerChild.type !== Comment) {
                  state.isLeaving = true;
                  leavingHooks.afterLeave = function () {
                    state.isLeaving = false;
                    if (!(instance.job.flags & 8)) {
                      instance.update();
                    }
                    delete leavingHooks.afterLeave;
                    oldInnerChild = void 0;
                  };
                  return emptyPlaceholder(child);
                } else if (mode === "in-out" && innerChild.type !== Comment) {
                  leavingHooks.delayLeave = function (el, earlyRemove, delayedLeave) {
                    var leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                    leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                    el[leaveCbKey] = function () {
                      earlyRemove();
                      el[leaveCbKey] = void 0;
                      delete enterHooks.delayedLeave;
                      oldInnerChild = void 0;
                    };
                    enterHooks.delayedLeave = function () {
                      delayedLeave();
                      delete enterHooks.delayedLeave;
                      oldInnerChild = void 0;
                    };
                  };
                } else {
                  oldInnerChild = void 0;
                }
              } else if (oldInnerChild) {
                oldInnerChild = void 0;
              }
              return child;
            };
          }
        };
        function findNonCommentChild(children) {
          var child = children[0];
          if (children.length > 1) {
            var _iterator7 = _createForOfIteratorHelper(children),
              _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var _c2 = _step7.value;
                if (_c2.type !== Comment) {
                  child = _c2;
                  break;
                }
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
          }
          return child;
        }
        var BaseTransition = BaseTransitionImpl;
        function getLeavingNodesForType(state, vnode) {
          var leavingVNodes = state.leavingVNodes;
          var leavingVNodesCache = leavingVNodes.get(vnode.type);
          if (!leavingVNodesCache) {
            leavingVNodesCache = /* @__PURE__ */Object.create(null);
            leavingVNodes.set(vnode.type, leavingVNodesCache);
          }
          return leavingVNodesCache;
        }
        function resolveTransitionHooks(vnode, props, state, instance, postClone) {
          var appear = props.appear,
            mode = props.mode,
            _props$persisted = props.persisted,
            persisted = _props$persisted === void 0 ? false : _props$persisted,
            onBeforeEnter = props.onBeforeEnter,
            onEnter = props.onEnter,
            onAfterEnter = props.onAfterEnter,
            onEnterCancelled = props.onEnterCancelled,
            onBeforeLeave = props.onBeforeLeave,
            onLeave = props.onLeave,
            onAfterLeave = props.onAfterLeave,
            onLeaveCancelled = props.onLeaveCancelled,
            onBeforeAppear = props.onBeforeAppear,
            onAppear = props.onAppear,
            onAfterAppear = props.onAfterAppear,
            onAppearCancelled = props.onAppearCancelled;
          var key = String(vnode.key);
          var leavingVNodesCache = getLeavingNodesForType(state, vnode);
          var callHook2 = function callHook2(hook, args) {
            hook && callWithAsyncErrorHandling(hook, instance, 9, args);
          };
          var callAsyncHook = function callAsyncHook(hook, args) {
            var done = args[1];
            callHook2(hook, args);
            if (isArray$2(hook)) {
              if (hook.every(function (hook2) {
                return hook2.length <= 1;
              })) done();
            } else if (hook.length <= 1) {
              done();
            }
          };
          var hooks = {
            mode: mode,
            persisted: persisted,
            beforeEnter: function beforeEnter(el) {
              var hook = onBeforeEnter;
              if (!state.isMounted) {
                if (appear) {
                  hook = onBeforeAppear || onBeforeEnter;
                } else {
                  return;
                }
              }
              if (el[leaveCbKey]) {
                el[leaveCbKey](true
                /* cancelled */);
              }
              var leavingVNode = leavingVNodesCache[key];
              if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
                leavingVNode.el[leaveCbKey]();
              }
              callHook2(hook, [el]);
            },
            enter: function enter(el) {
              var hook = onEnter;
              var afterHook = onAfterEnter;
              var cancelHook = onEnterCancelled;
              if (!state.isMounted) {
                if (appear) {
                  hook = onAppear || onEnter;
                  afterHook = onAfterAppear || onAfterEnter;
                  cancelHook = onAppearCancelled || onEnterCancelled;
                } else {
                  return;
                }
              }
              var called = false;
              var done = el[enterCbKey$1] = function (cancelled) {
                if (called) return;
                called = true;
                if (cancelled) {
                  callHook2(cancelHook, [el]);
                } else {
                  callHook2(afterHook, [el]);
                }
                if (hooks.delayedLeave) {
                  hooks.delayedLeave();
                }
                el[enterCbKey$1] = void 0;
              };
              if (hook) {
                callAsyncHook(hook, [el, done]);
              } else {
                done();
              }
            },
            leave: function leave(el, remove2) {
              var key2 = String(vnode.key);
              if (el[enterCbKey$1]) {
                el[enterCbKey$1](true
                /* cancelled */);
              }
              if (state.isUnmounting) {
                return remove2();
              }
              callHook2(onBeforeLeave, [el]);
              var called = false;
              var done = el[leaveCbKey] = function (cancelled) {
                if (called) return;
                called = true;
                remove2();
                if (cancelled) {
                  callHook2(onLeaveCancelled, [el]);
                } else {
                  callHook2(onAfterLeave, [el]);
                }
                el[leaveCbKey] = void 0;
                if (leavingVNodesCache[key2] === vnode) {
                  delete leavingVNodesCache[key2];
                }
              };
              leavingVNodesCache[key2] = vnode;
              if (onLeave) {
                callAsyncHook(onLeave, [el, done]);
              } else {
                done();
              }
            },
            clone: function clone(vnode2) {
              var hooks2 = resolveTransitionHooks(vnode2, props, state, instance, postClone);
              if (postClone) postClone(hooks2);
              return hooks2;
            }
          };
          return hooks;
        }
        function emptyPlaceholder(vnode) {
          if (isKeepAlive(vnode)) {
            vnode = cloneVNode(vnode);
            vnode.children = null;
            return vnode;
          }
        }
        function getInnerChild$1(vnode) {
          if (!isKeepAlive(vnode)) {
            if (isTeleport(vnode.type) && vnode.children) {
              return findNonCommentChild(vnode.children);
            }
            return vnode;
          }
          var shapeFlag = vnode.shapeFlag,
            children = vnode.children;
          if (children) {
            if (shapeFlag & 16) {
              return children[0];
            }
            if (shapeFlag & 32 && isFunction$1(children.default)) {
              return children.default();
            }
          }
        }
        function setTransitionHooks(vnode, hooks) {
          if (vnode.shapeFlag & 6 && vnode.component) {
            vnode.transition = hooks;
            setTransitionHooks(vnode.component.subTree, hooks);
          } else if (vnode.shapeFlag & 128) {
            vnode.ssContent.transition = hooks.clone(vnode.ssContent);
            vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
          } else {
            vnode.transition = hooks;
          }
        }
        function getTransitionRawChildren(children) {
          var keepComment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var parentKey = arguments.length > 2 ? arguments[2] : undefined;
          var ret = [];
          var keyedFragmentCount = 0;
          for (var i = 0; i < children.length; i++) {
            var child = children[i];
            var key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
            if (child.type === Fragment) {
              if (child.patchFlag & 128) keyedFragmentCount++;
              ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
            } else if (keepComment || child.type !== Comment) {
              ret.push(key != null ? cloneVNode(child, {
                key: key
              }) : child);
            }
          }
          if (keyedFragmentCount > 1) {
            for (var _i2 = 0; _i2 < ret.length; _i2++) {
              ret[_i2].patchFlag = -2;
            }
          }
          return ret;
        }
        /*! #__NO_SIDE_EFFECTS__ */
        // @__NO_SIDE_EFFECTS__
        function defineComponent(options, extraOptions) {
          return isFunction$1(options) ?
          // #8236: extend call and options.name access are considered side-effects
          // by Rollup, so we have to wrap it in a pure-annotated IIFE.
          /* @__PURE__ */
          function () {
            return extend({
              name: options.name
            }, extraOptions, {
              setup: options
            });
          }() : options;
        }
        function useId() {
          var i = getCurrentInstance();
          if (i) {
            return (i.appContext.config.idPrefix || "v") + "-" + i.ids[0] + i.ids[1]++;
          }
          return "";
        }
        function markAsyncBoundary(instance) {
          instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
        }
        function useTemplateRef(key) {
          var i = getCurrentInstance();
          var r = shallowRef(null);
          if (i) {
            var refs = i.refs === EMPTY_OBJ ? i.refs = {} : i.refs;
            {
              Object.defineProperty(refs, key, {
                enumerable: true,
                get: function get() {
                  return r.value;
                },
                set: function set(val) {
                  return r.value = val;
                }
              });
            }
          }
          var ret = r;
          return ret;
        }
        function setRef(rawRef, oldRawRef, parentSuspense, vnode) {
          var isUnmount = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          if (isArray$2(rawRef)) {
            rawRef.forEach(function (r, i) {
              return setRef(r, oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount);
            });
            return;
          }
          if (isAsyncWrapper(vnode) && !isUnmount) {
            if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
              setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
            }
            return;
          }
          var refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
          var value = isUnmount ? null : refValue;
          var owner = rawRef.i,
            ref3 = rawRef.r;
          var oldRef = oldRawRef && oldRawRef.r;
          var refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
          var setupState = owner.setupState;
          var rawSetupState = toRaw(setupState);
          var canSetSetupRef = setupState === EMPTY_OBJ ? function () {
            return false;
          } : function (key) {
            return hasOwn$1(rawSetupState, key);
          };
          if (oldRef != null && oldRef !== ref3) {
            if (isString$1(oldRef)) {
              refs[oldRef] = null;
              if (canSetSetupRef(oldRef)) {
                setupState[oldRef] = null;
              }
            } else if (isRef(oldRef)) {
              oldRef.value = null;
            }
          }
          if (isFunction$1(ref3)) {
            callWithErrorHandling(ref3, owner, 12, [value, refs]);
          } else {
            var _isString = isString$1(ref3);
            var _isRef = isRef(ref3);
            if (_isString || _isRef) {
              var doSet = function doSet() {
                if (rawRef.f) {
                  var existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
                  if (isUnmount) {
                    isArray$2(existing) && remove(existing, refValue);
                  } else {
                    if (!isArray$2(existing)) {
                      if (_isString) {
                        refs[ref3] = [refValue];
                        if (canSetSetupRef(ref3)) {
                          setupState[ref3] = refs[ref3];
                        }
                      } else {
                        ref3.value = [refValue];
                        if (rawRef.k) refs[rawRef.k] = ref3.value;
                      }
                    } else if (!existing.includes(refValue)) {
                      existing.push(refValue);
                    }
                  }
                } else if (_isString) {
                  refs[ref3] = value;
                  if (canSetSetupRef(ref3)) {
                    setupState[ref3] = value;
                  }
                } else if (_isRef) {
                  ref3.value = value;
                  if (rawRef.k) refs[rawRef.k] = value;
                } else ;
              };
              if (value) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
              } else {
                doSet();
              }
            }
          }
        }
        var hasLoggedMismatchError = false;
        var logMismatchError = function logMismatchError() {
          if (hasLoggedMismatchError) {
            return;
          }
          console.error("Hydration completed but contains mismatches.");
          hasLoggedMismatchError = true;
        };
        var isSVGContainer = function isSVGContainer(container) {
          return container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
        };
        var isMathMLContainer = function isMathMLContainer(container) {
          return container.namespaceURI.includes("MathML");
        };
        var getContainerType = function getContainerType(container) {
          if (container.nodeType !== 1) return void 0;
          if (isSVGContainer(container)) return "svg";
          if (isMathMLContainer(container)) return "mathml";
          return void 0;
        };
        var isComment = function isComment(node) {
          return node.nodeType === 8;
        };
        function createHydrationFunctions(rendererInternals) {
          var mountComponent = rendererInternals.mt,
            patch = rendererInternals.p,
            _rendererInternals$o = rendererInternals.o,
            patchProp = _rendererInternals$o.patchProp,
            createText = _rendererInternals$o.createText,
            nextSibling = _rendererInternals$o.nextSibling,
            parentNode = _rendererInternals$o.parentNode,
            remove2 = _rendererInternals$o.remove,
            insert = _rendererInternals$o.insert,
            createComment = _rendererInternals$o.createComment;
          var hydrate = function hydrate(vnode, container) {
            if (!container.hasChildNodes()) {
              patch(null, vnode, container);
              flushPostFlushCbs();
              container._vnode = vnode;
              return;
            }
            _hydrateNode(container.firstChild, vnode, null, null, null);
            flushPostFlushCbs();
            container._vnode = vnode;
          };
          var _hydrateNode = function hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds) {
            var optimized = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
            optimized = optimized || !!vnode.dynamicChildren;
            var isFragmentStart = isComment(node) && node.data === "[";
            var onMismatch = function onMismatch() {
              return handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
            };
            var type = vnode.type,
              ref3 = vnode.ref,
              shapeFlag = vnode.shapeFlag,
              patchFlag = vnode.patchFlag;
            var domType = node.nodeType;
            vnode.el = node;
            if (patchFlag === -2) {
              optimized = false;
              vnode.dynamicChildren = null;
            }
            var nextNode = null;
            switch (type) {
              case Text:
                if (domType !== 3) {
                  if (vnode.children === "") {
                    insert(vnode.el = createText(""), parentNode(node), node);
                    nextNode = node;
                  } else {
                    nextNode = onMismatch();
                  }
                } else {
                  if (node.data !== vnode.children) {
                    logMismatchError();
                    node.data = vnode.children;
                  }
                  nextNode = nextSibling(node);
                }
                break;
              case Comment:
                if (isTemplateNode(node)) {
                  nextNode = nextSibling(node);
                  replaceNode(vnode.el = node.content.firstChild, node, parentComponent);
                } else if (domType !== 8 || isFragmentStart) {
                  nextNode = onMismatch();
                } else {
                  nextNode = nextSibling(node);
                }
                break;
              case Static:
                if (isFragmentStart) {
                  node = nextSibling(node);
                  domType = node.nodeType;
                }
                if (domType === 1 || domType === 3) {
                  nextNode = node;
                  var needToAdoptContent = !vnode.children.length;
                  for (var i = 0; i < vnode.staticCount; i++) {
                    if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
                    if (i === vnode.staticCount - 1) {
                      vnode.anchor = nextNode;
                    }
                    nextNode = nextSibling(nextNode);
                  }
                  return isFragmentStart ? nextSibling(nextNode) : nextNode;
                } else {
                  onMismatch();
                }
                break;
              case Fragment:
                if (!isFragmentStart) {
                  nextNode = onMismatch();
                } else {
                  nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                }
                break;
              default:
                if (shapeFlag & 1) {
                  if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
                    nextNode = onMismatch();
                  } else {
                    nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                  }
                } else if (shapeFlag & 6) {
                  vnode.slotScopeIds = slotScopeIds;
                  var container = parentNode(node);
                  if (isFragmentStart) {
                    nextNode = locateClosingAnchor(node);
                  } else if (isComment(node) && node.data === "teleport start") {
                    nextNode = locateClosingAnchor(node, node.data, "teleport end");
                  } else {
                    nextNode = nextSibling(node);
                  }
                  mountComponent(vnode, container, null, parentComponent, parentSuspense, getContainerType(container), optimized);
                  if (isAsyncWrapper(vnode) && !vnode.type.__asyncResolved) {
                    var subTree;
                    if (isFragmentStart) {
                      subTree = createVNode(Fragment);
                      subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                    } else {
                      subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                    }
                    subTree.el = node;
                    vnode.component.subTree = subTree;
                  }
                } else if (shapeFlag & 64) {
                  if (domType !== 8) {
                    nextNode = onMismatch();
                  } else {
                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                  }
                } else if (shapeFlag & 128) {
                  nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, getContainerType(parentNode(node)), slotScopeIds, optimized, rendererInternals, _hydrateNode);
                } else ;
            }
            if (ref3 != null) {
              setRef(ref3, null, parentSuspense, vnode);
            }
            return nextNode;
          };
          var hydrateElement = function hydrateElement(el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) {
            optimized = optimized || !!vnode.dynamicChildren;
            var type = vnode.type,
              props = vnode.props,
              patchFlag = vnode.patchFlag,
              shapeFlag = vnode.shapeFlag,
              dirs = vnode.dirs,
              transition = vnode.transition;
            var forcePatch = type === "input" || type === "option";
            if (forcePatch || patchFlag !== -1) {
              if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, "created");
              }
              var needCallTransitionHooks = false;
              if (isTemplateNode(el)) {
                needCallTransitionHooks = needTransition(null,
                // no need check parentSuspense in hydration
                transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
                var content = el.content.firstChild;
                if (needCallTransitionHooks) {
                  transition.beforeEnter(content);
                }
                replaceNode(content, el, parentComponent);
                vnode.el = el = content;
              }
              if (shapeFlag & 16 &&
              // skip if element has innerHTML / textContent
              !(props && (props.innerHTML || props.textContent))) {
                var next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                while (next) {
                  if (!isMismatchAllowed(el, 1
                  /* CHILDREN */)) {
                    logMismatchError();
                  }
                  var cur = next;
                  next = next.nextSibling;
                  remove2(cur);
                }
              } else if (shapeFlag & 8) {
                var clientText = vnode.children;
                if (clientText[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) {
                  clientText = clientText.slice(1);
                }
                if (el.textContent !== clientText) {
                  if (!isMismatchAllowed(el, 0
                  /* TEXT */)) {
                    logMismatchError();
                  }
                  el.textContent = vnode.children;
                }
              }
              if (props) {
                if (forcePatch || !optimized || patchFlag & (16 | 32)) {
                  var isCustomElement = el.tagName.includes("-");
                  for (var key in props) {
                    if (forcePatch && (key.endsWith("value") || key === "indeterminate") || isOn(key) && !isReservedProp(key) ||
                    // force hydrate v-bind with .prop modifiers
                    key[0] === "." || isCustomElement) {
                      patchProp(el, key, null, props[key], void 0, parentComponent);
                    }
                  }
                } else if (props.onClick) {
                  patchProp(el, "onClick", null, props.onClick, void 0, parentComponent);
                } else if (patchFlag & 4 && isReactive(props.style)) {
                  for (var _key15 in props.style) props.style[_key15];
                }
              }
              var vnodeHooks;
              if (vnodeHooks = props && props.onVnodeBeforeMount) {
                invokeVNodeHook(vnodeHooks, parentComponent, vnode);
              }
              if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
              }
              if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
                queueEffectWithSuspense(function () {
                  vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                  needCallTransitionHooks && transition.enter(el);
                  dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
                }, parentSuspense);
              }
            }
            return el.nextSibling;
          };
          var hydrateChildren = function hydrateChildren(node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) {
            optimized = optimized || !!parentVNode.dynamicChildren;
            var children = parentVNode.children;
            var l = children.length;
            for (var i = 0; i < l; i++) {
              var vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
              var isText = vnode.type === Text;
              if (node) {
                if (isText && !optimized) {
                  if (i + 1 < l && normalizeVNode(children[i + 1]).type === Text) {
                    insert(createText(node.data.slice(vnode.children.length)), container, nextSibling(node));
                    node.data = vnode.children;
                  }
                }
                node = _hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
              } else if (isText && !vnode.children) {
                insert(vnode.el = createText(""), container);
              } else {
                if (!isMismatchAllowed(container, 1
                /* CHILDREN */)) {
                  logMismatchError();
                }
                patch(null, vnode, container, null, parentComponent, parentSuspense, getContainerType(container), slotScopeIds);
              }
            }
            return node;
          };
          var hydrateFragment = function hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) {
            var fragmentSlotScopeIds = vnode.slotScopeIds;
            if (fragmentSlotScopeIds) {
              slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
            }
            var container = parentNode(node);
            var next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
            if (next && isComment(next) && next.data === "]") {
              return nextSibling(vnode.anchor = next);
            } else {
              logMismatchError();
              insert(vnode.anchor = createComment("]"), container, next);
              return next;
            }
          };
          var handleMismatch = function handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) {
            if (!isMismatchAllowed(node.parentElement, 1
            /* CHILDREN */)) {
              logMismatchError();
            }
            vnode.el = null;
            if (isFragment) {
              var end = locateClosingAnchor(node);
              while (true) {
                var next2 = nextSibling(node);
                if (next2 && next2 !== end) {
                  remove2(next2);
                } else {
                  break;
                }
              }
            }
            var next = nextSibling(node);
            var container = parentNode(node);
            remove2(node);
            patch(null, vnode, container, next, parentComponent, parentSuspense, getContainerType(container), slotScopeIds);
            if (parentComponent) {
              parentComponent.vnode.el = vnode.el;
              updateHOCHostEl(parentComponent, vnode.el);
            }
            return next;
          };
          var locateClosingAnchor = function locateClosingAnchor(node) {
            var open = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "[";
            var close = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "]";
            var match = 0;
            while (node) {
              node = nextSibling(node);
              if (node && isComment(node)) {
                if (node.data === open) match++;
                if (node.data === close) {
                  if (match === 0) {
                    return nextSibling(node);
                  } else {
                    match--;
                  }
                }
              }
            }
            return node;
          };
          var replaceNode = function replaceNode(newNode, oldNode, parentComponent) {
            var parentNode2 = oldNode.parentNode;
            if (parentNode2) {
              parentNode2.replaceChild(newNode, oldNode);
            }
            var parent = parentComponent;
            while (parent) {
              if (parent.vnode.el === oldNode) {
                parent.vnode.el = parent.subTree.el = newNode;
              }
              parent = parent.parent;
            }
          };
          var isTemplateNode = function isTemplateNode(node) {
            return node.nodeType === 1 && node.tagName === "TEMPLATE";
          };
          return [hydrate, _hydrateNode];
        }
        var allowMismatchAttr = "data-allow-mismatch";
        var MismatchTypeString = _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, 0
        /* TEXT */, "text"), 1
        /* CHILDREN */, "children"), 2
        /* CLASS */, "class"), 3
        /* STYLE */, "style"), 4
        /* ATTRIBUTE */, "attribute");
        function isMismatchAllowed(el, allowedType) {
          if (allowedType === 0 || allowedType === 1) {
            while (el && !el.hasAttribute(allowMismatchAttr)) {
              el = el.parentElement;
            }
          }
          var allowedAttr = el && el.getAttribute(allowMismatchAttr);
          if (allowedAttr == null) {
            return false;
          } else if (allowedAttr === "") {
            return true;
          } else {
            var list = allowedAttr.split(",");
            if (allowedType === 0 && list.includes("children")) {
              return true;
            }
            return allowedAttr.split(",").includes(MismatchTypeString[allowedType]);
          }
        }
        var requestIdleCallback = getGlobalThis$1().requestIdleCallback || function (cb) {
          return setTimeout(cb, 1);
        };
        var cancelIdleCallback = getGlobalThis$1().cancelIdleCallback || function (id) {
          return clearTimeout(id);
        };
        var hydrateOnIdle = function hydrateOnIdle() {
          var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1e4;
          return function (hydrate) {
            var id = requestIdleCallback(hydrate, {
              timeout: timeout
            });
            return function () {
              return cancelIdleCallback(id);
            };
          };
        };
        function elementIsVisibleInViewport(el) {
          var _el$getBoundingClient = el.getBoundingClientRect(),
            top = _el$getBoundingClient.top,
            left = _el$getBoundingClient.left,
            bottom = _el$getBoundingClient.bottom,
            right = _el$getBoundingClient.right;
          var _window = window,
            innerHeight = _window.innerHeight,
            innerWidth = _window.innerWidth;
          return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);
        }
        var hydrateOnVisible = function hydrateOnVisible(opts) {
          return function (hydrate, forEach) {
            var ob = new IntersectionObserver(function (entries) {
              var _iterator8 = _createForOfIteratorHelper(entries),
                _step8;
              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                  var e = _step8.value;
                  if (!e.isIntersecting) continue;
                  ob.disconnect();
                  hydrate();
                  break;
                }
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
            }, opts);
            forEach(function (el) {
              if (!(el instanceof Element)) return;
              if (elementIsVisibleInViewport(el)) {
                hydrate();
                ob.disconnect();
                return false;
              }
              ob.observe(el);
            });
            return function () {
              return ob.disconnect();
            };
          };
        };
        var hydrateOnMediaQuery = function hydrateOnMediaQuery(query) {
          return function (hydrate) {
            if (query) {
              var mql = matchMedia(query);
              if (mql.matches) {
                hydrate();
              } else {
                mql.addEventListener("change", hydrate, {
                  once: true
                });
                return function () {
                  return mql.removeEventListener("change", hydrate);
                };
              }
            }
          };
        };
        var hydrateOnInteraction = function hydrateOnInteraction() {
          var interactions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          return function (hydrate, forEach) {
            if (isString$1(interactions)) interactions = [interactions];
            var hasHydrated = false;
            var doHydrate = function doHydrate(e) {
              if (!hasHydrated) {
                hasHydrated = true;
                teardown();
                hydrate();
                e.target.dispatchEvent(new e.constructor(e.type, e));
              }
            };
            var teardown = function teardown() {
              forEach(function (el) {
                var _iterator9 = _createForOfIteratorHelper(interactions),
                  _step9;
                try {
                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                    var i = _step9.value;
                    el.removeEventListener(i, doHydrate);
                  }
                } catch (err) {
                  _iterator9.e(err);
                } finally {
                  _iterator9.f();
                }
              });
            };
            forEach(function (el) {
              var _iterator10 = _createForOfIteratorHelper(interactions),
                _step10;
              try {
                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                  var i = _step10.value;
                  el.addEventListener(i, doHydrate, {
                    once: true
                  });
                }
              } catch (err) {
                _iterator10.e(err);
              } finally {
                _iterator10.f();
              }
            });
            return teardown;
          };
        };
        function forEachElement(node, cb) {
          if (isComment(node) && node.data === "[") {
            var depth = 1;
            var next = node.nextSibling;
            while (next) {
              if (next.nodeType === 1) {
                var result = cb(next);
                if (result === false) {
                  break;
                }
              } else if (isComment(next)) {
                if (next.data === "]") {
                  if (--depth === 0) break;
                } else if (next.data === "[") {
                  depth++;
                }
              }
              next = next.nextSibling;
            }
          } else {
            cb(node);
          }
        }
        var isAsyncWrapper = function isAsyncWrapper(i) {
          return !!i.type.__asyncLoader;
        };
        /*! #__NO_SIDE_EFFECTS__ */
        // @__NO_SIDE_EFFECTS__
        function defineAsyncComponent(source) {
          if (isFunction$1(source)) {
            source = {
              loader: source
            };
          }
          var _source = source,
            loader = _source.loader,
            loadingComponent = _source.loadingComponent,
            errorComponent = _source.errorComponent,
            _source$delay = _source.delay,
            delay = _source$delay === void 0 ? 200 : _source$delay,
            hydrateStrategy = _source.hydrate,
            timeout = _source.timeout,
            _source$suspensible = _source.suspensible,
            suspensible = _source$suspensible === void 0 ? true : _source$suspensible,
            userOnError = _source.onError;
          var pendingRequest = null;
          var resolvedComp;
          var retries = 0;
          var retry = function retry() {
            retries++;
            pendingRequest = null;
            return load();
          };
          var load = function load() {
            var thisRequest;
            return pendingRequest || (thisRequest = pendingRequest = loader().catch(function (err) {
              err = err instanceof Error ? err : new Error(String(err));
              if (userOnError) {
                return new Promise(function (resolve2, reject) {
                  var userRetry = function userRetry() {
                    return resolve2(retry());
                  };
                  var userFail = function userFail() {
                    return reject(err);
                  };
                  userOnError(err, userRetry, userFail, retries + 1);
                });
              } else {
                throw err;
              }
            }).then(function (comp) {
              if (thisRequest !== pendingRequest && pendingRequest) {
                return pendingRequest;
              }
              if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
                comp = comp.default;
              }
              resolvedComp = comp;
              return comp;
            }));
          };
          return /* @__PURE__ */defineComponent({
            name: "AsyncComponentWrapper",
            __asyncLoader: load,
            __asyncHydrate: function __asyncHydrate(el, instance, hydrate) {
              var doHydrate = hydrateStrategy ? function () {
                var teardown = hydrateStrategy(hydrate, function (cb) {
                  return forEachElement(el, cb);
                });
                if (teardown) {
                  (instance.bum || (instance.bum = [])).push(teardown);
                }
              } : hydrate;
              if (resolvedComp) {
                doHydrate();
              } else {
                load().then(function () {
                  return !instance.isUnmounted && doHydrate();
                });
              }
            },
            get __asyncResolved() {
              return resolvedComp;
            },
            setup: function setup() {
              var instance = currentInstance;
              markAsyncBoundary(instance);
              if (resolvedComp) {
                return function () {
                  return createInnerComp(resolvedComp, instance);
                };
              }
              var onError = function onError(err) {
                pendingRequest = null;
                handleError(err, instance, 13, !errorComponent);
              };
              if (suspensible && instance.suspense || isInSSRComponentSetup) {
                return load().then(function (comp) {
                  return function () {
                    return createInnerComp(comp, instance);
                  };
                }).catch(function (err) {
                  onError(err);
                  return function () {
                    return errorComponent ? createVNode(errorComponent, {
                      error: err
                    }) : null;
                  };
                });
              }
              var loaded = ref(false);
              var error = ref();
              var delayed = ref(!!delay);
              if (delay) {
                setTimeout(function () {
                  delayed.value = false;
                }, delay);
              }
              if (timeout != null) {
                setTimeout(function () {
                  if (!loaded.value && !error.value) {
                    var err = new Error("Async component timed out after ".concat(timeout, "ms."));
                    onError(err);
                    error.value = err;
                  }
                }, timeout);
              }
              load().then(function () {
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                  instance.parent.update();
                }
              }).catch(function (err) {
                onError(err);
                error.value = err;
              });
              return function () {
                if (loaded.value && resolvedComp) {
                  return createInnerComp(resolvedComp, instance);
                } else if (error.value && errorComponent) {
                  return createVNode(errorComponent, {
                    error: error.value
                  });
                } else if (loadingComponent && !delayed.value) {
                  return createVNode(loadingComponent);
                }
              };
            }
          });
        }
        function createInnerComp(comp, parent) {
          var _parent$vnode = parent.vnode,
            ref22 = _parent$vnode.ref,
            props = _parent$vnode.props,
            children = _parent$vnode.children,
            ce = _parent$vnode.ce;
          var vnode = createVNode(comp, props, children);
          vnode.ref = ref22;
          vnode.ce = ce;
          delete parent.vnode.ce;
          return vnode;
        }
        var isKeepAlive = function isKeepAlive(vnode) {
          return vnode.type.__isKeepAlive;
        };
        var KeepAliveImpl = {
          name: "KeepAlive",
          // Marker for special handling inside the renderer. We are not using a ===
          // check directly on KeepAlive in the renderer, because importing it directly
          // would prevent it from being tree-shaken.
          __isKeepAlive: true,
          props: {
            include: [String, RegExp, Array],
            exclude: [String, RegExp, Array],
            max: [String, Number]
          },
          setup: function setup(props, _ref15) {
            var slots = _ref15.slots;
            var instance = getCurrentInstance();
            var sharedContext = instance.ctx;
            if (!sharedContext.renderer) {
              return function () {
                var children = slots.default && slots.default();
                return children && children.length === 1 ? children[0] : children;
              };
            }
            var cache = /* @__PURE__ */new Map();
            var keys = /* @__PURE__ */new Set();
            var current = null;
            var parentSuspense = instance.suspense;
            var _sharedContext$render = sharedContext.renderer,
              patch = _sharedContext$render.p,
              move = _sharedContext$render.m,
              _unmount = _sharedContext$render.um,
              createElement = _sharedContext$render.o.createElement;
            var storageContainer = createElement("div");
            sharedContext.activate = function (vnode, container, anchor, namespace, optimized) {
              var instance2 = vnode.component;
              move(vnode, container, anchor, 0, parentSuspense);
              patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, namespace, vnode.slotScopeIds, optimized);
              queuePostRenderEffect(function () {
                instance2.isDeactivated = false;
                if (instance2.a) {
                  invokeArrayFns(instance2.a);
                }
                var vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) {
                  invokeVNodeHook(vnodeHook, instance2.parent, vnode);
                }
              }, parentSuspense);
            };
            sharedContext.deactivate = function (vnode) {
              var instance2 = vnode.component;
              invalidateMount(instance2.m);
              invalidateMount(instance2.a);
              move(vnode, storageContainer, null, 1, parentSuspense);
              queuePostRenderEffect(function () {
                if (instance2.da) {
                  invokeArrayFns(instance2.da);
                }
                var vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) {
                  invokeVNodeHook(vnodeHook, instance2.parent, vnode);
                }
                instance2.isDeactivated = true;
              }, parentSuspense);
            };
            function unmount(vnode) {
              resetShapeFlag(vnode);
              _unmount(vnode, instance, parentSuspense, true);
            }
            function pruneCache(filter) {
              cache.forEach(function (vnode, key) {
                var name = getComponentName(vnode.type);
                if (name && !filter(name)) {
                  pruneCacheEntry(key);
                }
              });
            }
            function pruneCacheEntry(key) {
              var cached = cache.get(key);
              if (cached && (!current || !isSameVNodeType(cached, current))) {
                unmount(cached);
              } else if (current) {
                resetShapeFlag(current);
              }
              cache.delete(key);
              keys.delete(key);
            }
            watch(function () {
              return [props.include, props.exclude];
            }, function (_ref16) {
              var _ref17 = _slicedToArray(_ref16, 2),
                include = _ref17[0],
                exclude = _ref17[1];
              include && pruneCache(function (name) {
                return matches(include, name);
              });
              exclude && pruneCache(function (name) {
                return !matches(exclude, name);
              });
            },
            // prune post-render after `current` has been updated
            {
              flush: "post",
              deep: true
            });
            var pendingCacheKey = null;
            var cacheSubtree = function cacheSubtree() {
              if (pendingCacheKey != null) {
                if (isSuspense(instance.subTree.type)) {
                  queuePostRenderEffect(function () {
                    cache.set(pendingCacheKey, getInnerChild(instance.subTree));
                  }, instance.subTree.suspense);
                } else {
                  cache.set(pendingCacheKey, getInnerChild(instance.subTree));
                }
              }
            };
            onMounted(cacheSubtree);
            onUpdated(cacheSubtree);
            onBeforeUnmount(function () {
              cache.forEach(function (cached) {
                var subTree = instance.subTree,
                  suspense = instance.suspense;
                var vnode = getInnerChild(subTree);
                if (cached.type === vnode.type && cached.key === vnode.key) {
                  resetShapeFlag(vnode);
                  var da = vnode.component.da;
                  da && queuePostRenderEffect(da, suspense);
                  return;
                }
                unmount(cached);
              });
            });
            return function () {
              pendingCacheKey = null;
              if (!slots.default) {
                return current = null;
              }
              var children = slots.default();
              var rawVNode = children[0];
              if (children.length > 1) {
                current = null;
                return children;
              } else if (!isVNode$1(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
                current = null;
                return rawVNode;
              }
              var vnode = getInnerChild(rawVNode);
              if (vnode.type === Comment) {
                current = null;
                return vnode;
              }
              var comp = vnode.type;
              var name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
              var include = props.include,
                exclude = props.exclude,
                max = props.max;
              if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
                vnode.shapeFlag &= ~256;
                current = vnode;
                return rawVNode;
              }
              var key = vnode.key == null ? comp : vnode.key;
              var cachedVNode = cache.get(key);
              if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128) {
                  rawVNode.ssContent = vnode;
                }
              }
              pendingCacheKey = key;
              if (cachedVNode) {
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) {
                  setTransitionHooks(vnode, vnode.transition);
                }
                vnode.shapeFlag |= 512;
                keys.delete(key);
                keys.add(key);
              } else {
                keys.add(key);
                if (max && keys.size > parseInt(max, 10)) {
                  pruneCacheEntry(keys.values().next().value);
                }
              }
              vnode.shapeFlag |= 256;
              current = vnode;
              return isSuspense(rawVNode.type) ? rawVNode : vnode;
            };
          }
        };
        var KeepAlive = KeepAliveImpl;
        function matches(pattern, name) {
          if (isArray$2(pattern)) {
            return pattern.some(function (p) {
              return matches(p, name);
            });
          } else if (isString$1(pattern)) {
            return pattern.split(",").includes(name);
          } else if (isRegExp$1(pattern)) {
            pattern.lastIndex = 0;
            return pattern.test(name);
          }
          return false;
        }
        function onActivated(hook, target) {
          registerKeepAliveHook(hook, "a", target);
        }
        function onDeactivated(hook, target) {
          registerKeepAliveHook(hook, "da", target);
        }
        function registerKeepAliveHook(hook, type) {
          var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;
          var wrappedHook = hook.__wdc || (hook.__wdc = function () {
            var current = target;
            while (current) {
              if (current.isDeactivated) {
                return;
              }
              current = current.parent;
            }
            return hook();
          });
          injectHook(type, wrappedHook, target);
          if (target) {
            var current = target.parent;
            while (current && current.parent) {
              if (isKeepAlive(current.parent.vnode)) {
                injectToKeepAliveRoot(wrappedHook, type, target, current);
              }
              current = current.parent;
            }
          }
        }
        function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
          var injected = injectHook(type, hook, keepAliveRoot, true
          /* prepend */);
          onUnmounted(function () {
            remove(keepAliveRoot[type], injected);
          }, target);
        }
        function resetShapeFlag(vnode) {
          vnode.shapeFlag &= ~256;
          vnode.shapeFlag &= ~512;
        }
        function getInnerChild(vnode) {
          return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
        }
        function injectHook(type, hook) {
          var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;
          var prepend = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          if (target) {
            var hooks = target[type] || (target[type] = []);
            var wrappedHook = hook.__weh || (hook.__weh = function () {
              pauseTracking();
              var reset = setCurrentInstance(target);
              for (var _len14 = arguments.length, args = new Array(_len14), _key16 = 0; _key16 < _len14; _key16++) {
                args[_key16] = arguments[_key16];
              }
              var res = callWithAsyncErrorHandling(hook, target, type, args);
              reset();
              resetTracking();
              return res;
            });
            if (prepend) {
              hooks.unshift(wrappedHook);
            } else {
              hooks.push(wrappedHook);
            }
            return wrappedHook;
          }
        }
        var createHook = function createHook(lifecycle) {
          return function (hook) {
            var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;
            if (!isInSSRComponentSetup || lifecycle === "sp") {
              injectHook(lifecycle, function () {
                return hook.apply(void 0, arguments);
              }, target);
            }
          };
        };
        var onBeforeMount = createHook("bm");
        var onMounted = exports("v", createHook("m"));
        var onBeforeUpdate = createHook("bu");
        var onUpdated = createHook("u");
        var onBeforeUnmount = createHook("bum");
        var onUnmounted = createHook("um");
        var onServerPrefetch = createHook("sp");
        var onRenderTriggered = createHook("rtg");
        var onRenderTracked = createHook("rtc");
        function onErrorCaptured(hook) {
          var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;
          injectHook("ec", hook, target);
        }
        var COMPONENTS = "components";
        var DIRECTIVES = "directives";
        function resolveComponent(name, maybeSelfReference) {
          return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
        }
        var NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
        function resolveDynamicComponent(component) {
          if (isString$1(component)) {
            return resolveAsset(COMPONENTS, component, false) || component;
          } else {
            return component || NULL_DYNAMIC_COMPONENT;
          }
        }
        function resolveDirective(name) {
          return resolveAsset(DIRECTIVES, name);
        }
        function resolveAsset(type, name) {
          var warnMissing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          var maybeSelfReference = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var instance = currentRenderingInstance || currentInstance;
          if (instance) {
            var Component = instance.type;
            if (type === COMPONENTS) {
              var selfName = getComponentName(Component, false);
              if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
                return Component;
              }
            }
            var res =
            // local registration
            // check instance[type] first which is resolved for options API
            resolve(instance[type] || Component[type], name) ||
            // global registration
            resolve(instance.appContext[type], name);
            if (!res && maybeSelfReference) {
              return Component;
            }
            return res;
          }
        }
        function resolve(registry, name) {
          return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
        }
        function renderList(source, renderItem, cache, index) {
          var ret;
          var cached = cache && cache[index];
          var sourceIsArray = isArray$2(source);
          if (sourceIsArray || isString$1(source)) {
            var sourceIsReactiveArray = sourceIsArray && isReactive(source);
            var needsWrap = false;
            if (sourceIsReactiveArray) {
              needsWrap = !isShallow(source);
              source = shallowReadArray(source);
            }
            ret = new Array(source.length);
            for (var i = 0, l = source.length; i < l; i++) {
              ret[i] = renderItem(needsWrap ? toReactive(source[i]) : source[i], i, void 0, cached && cached[i]);
            }
          } else if (typeof source === "number") {
            ret = new Array(source);
            for (var _i3 = 0; _i3 < source; _i3++) {
              ret[_i3] = renderItem(_i3 + 1, _i3, void 0, cached && cached[_i3]);
            }
          } else if (isObject$2(source)) {
            if (source[Symbol.iterator]) {
              ret = Array.from(source, function (item, i) {
                return renderItem(item, i, void 0, cached && cached[i]);
              });
            } else {
              var keys = Object.keys(source);
              ret = new Array(keys.length);
              for (var _i4 = 0, _l = keys.length; _i4 < _l; _i4++) {
                var key = keys[_i4];
                ret[_i4] = renderItem(source[key], key, _i4, cached && cached[_i4]);
              }
            }
          } else {
            ret = [];
          }
          if (cache) {
            cache[index] = ret;
          }
          return ret;
        }
        function createSlots(slots, dynamicSlots) {
          var _loop = function _loop() {
            var slot = dynamicSlots[i];
            if (isArray$2(slot)) {
              for (var j = 0; j < slot.length; j++) {
                slots[slot[j].name] = slot[j].fn;
              }
            } else if (slot) {
              slots[slot.name] = slot.key ? function () {
                var res = slot.fn.apply(slot, arguments);
                if (res) res.key = slot.key;
                return res;
              } : slot.fn;
            }
          };
          for (var i = 0; i < dynamicSlots.length; i++) {
            _loop();
          }
          return slots;
        }
        function renderSlot(slots, name) {
          var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var fallback = arguments.length > 3 ? arguments[3] : undefined;
          var noSlotted = arguments.length > 4 ? arguments[4] : undefined;
          if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
            if (name !== "default") props.name = name;
            return openBlock(), createBlock(Fragment, null, [createVNode("slot", props, fallback && fallback())], 64);
          }
          var slot = slots[name];
          if (slot && slot._c) {
            slot._d = false;
          }
          openBlock();
          var validSlotContent = slot && ensureValidVNode(slot(props));
          var slotKey = props.key ||
          // slot content array of a dynamic conditional slot may have a branch
          // key attached in the `createSlots` helper, respect that
          validSlotContent && validSlotContent.key;
          var rendered = createBlock(Fragment, {
            key: (slotKey && !isSymbol(slotKey) ? slotKey : "_".concat(name)) + (
            // #7256 force differentiate fallback content from actual content
            !validSlotContent && fallback ? "_fb" : "")
          }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
          if (!noSlotted && rendered.scopeId) {
            rendered.slotScopeIds = [rendered.scopeId + "-s"];
          }
          if (slot && slot._c) {
            slot._d = true;
          }
          return rendered;
        }
        function ensureValidVNode(vnodes) {
          return vnodes.some(function (child) {
            if (!isVNode$1(child)) return true;
            if (child.type === Comment) return false;
            if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
            return true;
          }) ? vnodes : null;
        }
        function toHandlers(obj, preserveCaseIfNecessary) {
          var ret = {};
          for (var key in obj) {
            ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? "on:".concat(key) : toHandlerKey(key)] = obj[key];
          }
          return ret;
        }
        var _getPublicInstance = function getPublicInstance(i) {
          if (!i) return null;
          if (isStatefulComponent(i)) return getComponentPublicInstance(i);
          return _getPublicInstance(i.parent);
        };
        var publicPropertiesMap =
        // Move PURE marker to new line to workaround compiler discarding it
        // due to type annotation
        /* @__PURE__ */
        extend(/* @__PURE__ */Object.create(null), {
          $: function $(i) {
            return i;
          },
          $el: function $el(i) {
            return i.vnode.el;
          },
          $data: function $data(i) {
            return i.data;
          },
          $props: function $props(i) {
            return i.props;
          },
          $attrs: function $attrs(i) {
            return i.attrs;
          },
          $slots: function $slots(i) {
            return i.slots;
          },
          $refs: function $refs(i) {
            return i.refs;
          },
          $parent: function $parent(i) {
            return _getPublicInstance(i.parent);
          },
          $root: function $root(i) {
            return _getPublicInstance(i.root);
          },
          $host: function $host(i) {
            return i.ce;
          },
          $emit: function $emit(i) {
            return i.emit;
          },
          $options: function $options(i) {
            return resolveMergedOptions(i);
          },
          $forceUpdate: function $forceUpdate(i) {
            return i.f || (i.f = function () {
              queueJob(i.update);
            });
          },
          $nextTick: function $nextTick(i) {
            return i.n || (i.n = nextTick.bind(i.proxy));
          },
          $watch: function $watch(i) {
            return instanceWatch.bind(i);
          }
        });
        var hasSetupBinding = function hasSetupBinding(state, key) {
          return state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
        };
        var PublicInstanceProxyHandlers = {
          get: function get(_ref18, key) {
            var instance = _ref18._;
            if (key === "__v_skip") {
              return true;
            }
            var ctx = instance.ctx,
              setupState = instance.setupState,
              data = instance.data,
              props = instance.props,
              accessCache = instance.accessCache,
              type = instance.type,
              appContext = instance.appContext;
            var normalizedProps;
            if (key[0] !== "$") {
              var n = accessCache[key];
              if (n !== void 0) {
                switch (n) {
                  case 1:
                    return setupState[key];
                  case 2:
                    return data[key];
                  case 4:
                    return ctx[key];
                  case 3:
                    return props[key];
                }
              } else if (hasSetupBinding(setupState, key)) {
                accessCache[key] = 1;
                return setupState[key];
              } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
                accessCache[key] = 2;
                return data[key];
              } else if (
              // only cache other properties when instance has declared (thus stable)
              // props
              (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)) {
                accessCache[key] = 3;
                return props[key];
              } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
                accessCache[key] = 4;
                return ctx[key];
              } else if (shouldCacheAccess) {
                accessCache[key] = 0;
              }
            }
            var publicGetter = publicPropertiesMap[key];
            var cssModule, globalProperties;
            if (publicGetter) {
              if (key === "$attrs") {
                track(instance.attrs, "get", "");
              }
              return publicGetter(instance);
            } else if (
            // css module (injected by vue-loader)
            (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
              return cssModule;
            } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
              accessCache[key] = 4;
              return ctx[key];
            } else if (
            // global properties
            globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)) {
              {
                return globalProperties[key];
              }
            } else ;
          },
          set: function set(_ref19, key, value) {
            var instance = _ref19._;
            var data = instance.data,
              setupState = instance.setupState,
              ctx = instance.ctx;
            if (hasSetupBinding(setupState, key)) {
              setupState[key] = value;
              return true;
            } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
              data[key] = value;
              return true;
            } else if (hasOwn$1(instance.props, key)) {
              return false;
            }
            if (key[0] === "$" && key.slice(1) in instance) {
              return false;
            } else {
              {
                ctx[key] = value;
              }
            }
            return true;
          },
          has: function has(_ref20, key) {
            var _ref20$_ = _ref20._,
              data = _ref20$_.data,
              setupState = _ref20$_.setupState,
              accessCache = _ref20$_.accessCache,
              ctx = _ref20$_.ctx,
              appContext = _ref20$_.appContext,
              propsOptions = _ref20$_.propsOptions;
            var normalizedProps;
            return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$1(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
          },
          defineProperty: function defineProperty(target, key, descriptor) {
            if (descriptor.get != null) {
              target._.accessCache[key] = 0;
            } else if (hasOwn$1(descriptor, "value")) {
              this.set(target, key, descriptor.value, null);
            }
            return Reflect.defineProperty(target, key, descriptor);
          }
        };
        var RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */extend({}, PublicInstanceProxyHandlers, {
          get: function get(target, key) {
            if (key === Symbol.unscopables) {
              return;
            }
            return PublicInstanceProxyHandlers.get(target, key, target);
          },
          has: function has(_, key) {
            var has = key[0] !== "_" && !isGloballyAllowed(key);
            return has;
          }
        });
        function defineProps() {
          return null;
        }
        function defineEmits() {
          return null;
        }
        function defineExpose(exposed) {}
        function defineOptions(options) {}
        function defineSlots() {
          return null;
        }
        function defineModel() {}
        function withDefaults(props, defaults) {
          return null;
        }
        function useSlots() {
          return getContext().slots;
        }
        function useAttrs() {
          return getContext().attrs;
        }
        function getContext() {
          var i = getCurrentInstance();
          return i.setupContext || (i.setupContext = createSetupContext(i));
        }
        function normalizePropsOrEmits(props) {
          return isArray$2(props) ? props.reduce(function (normalized, p) {
            return normalized[p] = null, normalized;
          }, {}) : props;
        }
        function mergeDefaults(raw, defaults) {
          var props = normalizePropsOrEmits(raw);
          for (var key in defaults) {
            if (key.startsWith("__skip")) continue;
            var opt = props[key];
            if (opt) {
              if (isArray$2(opt) || isFunction$1(opt)) {
                opt = props[key] = {
                  type: opt,
                  default: defaults[key]
                };
              } else {
                opt.default = defaults[key];
              }
            } else if (opt === null) {
              opt = props[key] = {
                default: defaults[key]
              };
            } else ;
            if (opt && defaults["__skip_".concat(key)]) {
              opt.skipFactory = true;
            }
          }
          return props;
        }
        function mergeModels(a, b) {
          if (!a || !b) return a || b;
          if (isArray$2(a) && isArray$2(b)) return a.concat(b);
          return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
        }
        function createPropsRestProxy(props, excludedKeys) {
          var ret = {};
          var _loop2 = function _loop2(key) {
            if (!excludedKeys.includes(key)) {
              Object.defineProperty(ret, key, {
                enumerable: true,
                get: function get() {
                  return props[key];
                }
              });
            }
          };
          for (var key in props) {
            _loop2(key);
          }
          return ret;
        }
        function withAsyncContext(getAwaitable) {
          var ctx = getCurrentInstance();
          var awaitable = getAwaitable();
          unsetCurrentInstance();
          if (isPromise$1(awaitable)) {
            awaitable = awaitable.catch(function (e) {
              setCurrentInstance(ctx);
              throw e;
            });
          }
          return [awaitable, function () {
            return setCurrentInstance(ctx);
          }];
        }
        var shouldCacheAccess = true;
        function applyOptions(instance) {
          var options = resolveMergedOptions(instance);
          var publicThis = instance.proxy;
          var ctx = instance.ctx;
          shouldCacheAccess = false;
          if (options.beforeCreate) {
            callHook$1(options.beforeCreate, instance, "bc");
          }
          var dataOptions = options.data,
            computedOptions = options.computed,
            methods = options.methods,
            watchOptions = options.watch,
            provideOptions = options.provide,
            injectOptions = options.inject,
            created = options.created,
            beforeMount = options.beforeMount,
            mounted = options.mounted,
            beforeUpdate = options.beforeUpdate,
            updated = options.updated,
            activated = options.activated,
            deactivated = options.deactivated,
            beforeDestroy = options.beforeDestroy,
            beforeUnmount = options.beforeUnmount,
            destroyed = options.destroyed,
            unmounted = options.unmounted,
            render = options.render,
            renderTracked = options.renderTracked,
            renderTriggered = options.renderTriggered,
            errorCaptured = options.errorCaptured,
            serverPrefetch = options.serverPrefetch,
            expose = options.expose,
            inheritAttrs = options.inheritAttrs,
            components = options.components,
            directives = options.directives,
            filters = options.filters;
          var checkDuplicateProperties = null;
          if (injectOptions) {
            resolveInjections(injectOptions, ctx, checkDuplicateProperties);
          }
          if (methods) {
            for (var key in methods) {
              var methodHandler = methods[key];
              if (isFunction$1(methodHandler)) {
                {
                  ctx[key] = methodHandler.bind(publicThis);
                }
              }
            }
          }
          if (dataOptions) {
            var data = dataOptions.call(publicThis, publicThis);
            if (!isObject$2(data)) ;else {
              instance.data = reactive(data);
            }
          }
          shouldCacheAccess = true;
          if (computedOptions) {
            var _loop3 = function _loop3() {
              var opt = computedOptions[_key17];
              var get = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
              var set = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
              var c = computed({
                get: get,
                set: set
              });
              Object.defineProperty(ctx, _key17, {
                enumerable: true,
                configurable: true,
                get: function get() {
                  return c.value;
                },
                set: function set(v) {
                  return c.value = v;
                }
              });
            };
            for (var _key17 in computedOptions) {
              _loop3();
            }
          }
          if (watchOptions) {
            for (var _key18 in watchOptions) {
              createWatcher(watchOptions[_key18], ctx, publicThis, _key18);
            }
          }
          if (provideOptions) {
            var provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
            Reflect.ownKeys(provides).forEach(function (key) {
              provide(key, provides[key]);
            });
          }
          if (created) {
            callHook$1(created, instance, "c");
          }
          function registerLifecycleHook(register, hook) {
            if (isArray$2(hook)) {
              hook.forEach(function (_hook) {
                return register(_hook.bind(publicThis));
              });
            } else if (hook) {
              register(hook.bind(publicThis));
            }
          }
          registerLifecycleHook(onBeforeMount, beforeMount);
          registerLifecycleHook(onMounted, mounted);
          registerLifecycleHook(onBeforeUpdate, beforeUpdate);
          registerLifecycleHook(onUpdated, updated);
          registerLifecycleHook(onActivated, activated);
          registerLifecycleHook(onDeactivated, deactivated);
          registerLifecycleHook(onErrorCaptured, errorCaptured);
          registerLifecycleHook(onRenderTracked, renderTracked);
          registerLifecycleHook(onRenderTriggered, renderTriggered);
          registerLifecycleHook(onBeforeUnmount, beforeUnmount);
          registerLifecycleHook(onUnmounted, unmounted);
          registerLifecycleHook(onServerPrefetch, serverPrefetch);
          if (isArray$2(expose)) {
            if (expose.length) {
              var exposed = instance.exposed || (instance.exposed = {});
              expose.forEach(function (key) {
                Object.defineProperty(exposed, key, {
                  get: function get() {
                    return publicThis[key];
                  },
                  set: function set(val) {
                    return publicThis[key] = val;
                  }
                });
              });
            } else if (!instance.exposed) {
              instance.exposed = {};
            }
          }
          if (render && instance.render === NOOP) {
            instance.render = render;
          }
          if (inheritAttrs != null) {
            instance.inheritAttrs = inheritAttrs;
          }
          if (components) instance.components = components;
          if (directives) instance.directives = directives;
          if (serverPrefetch) {
            markAsyncBoundary(instance);
          }
        }
        function resolveInjections(injectOptions, ctx) {
          var checkDuplicateProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOOP;
          if (isArray$2(injectOptions)) {
            injectOptions = normalizeInject(injectOptions);
          }
          var _loop4 = function _loop4() {
            var opt = injectOptions[key];
            var injected;
            if (isObject$2(opt)) {
              if ("default" in opt) {
                injected = inject(opt.from || key, opt.default, true);
              } else {
                injected = inject(opt.from || key);
              }
            } else {
              injected = inject(opt);
            }
            if (isRef(injected)) {
              Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: function get() {
                  return injected.value;
                },
                set: function set(v) {
                  return injected.value = v;
                }
              });
            } else {
              ctx[key] = injected;
            }
          };
          for (var key in injectOptions) {
            _loop4();
          }
        }
        function callHook$1(hook, instance, type) {
          callWithAsyncErrorHandling(isArray$2(hook) ? hook.map(function (h2) {
            return h2.bind(instance.proxy);
          }) : hook.bind(instance.proxy), instance, type);
        }
        function createWatcher(raw, ctx, publicThis, key) {
          var getter = key.includes(".") ? createPathGetter(publicThis, key) : function () {
            return publicThis[key];
          };
          if (isString$1(raw)) {
            var handler = ctx[raw];
            if (isFunction$1(handler)) {
              {
                watch(getter, handler);
              }
            }
          } else if (isFunction$1(raw)) {
            {
              watch(getter, raw.bind(publicThis));
            }
          } else if (isObject$2(raw)) {
            if (isArray$2(raw)) {
              raw.forEach(function (r) {
                return createWatcher(r, ctx, publicThis, key);
              });
            } else {
              var _handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
              if (isFunction$1(_handler)) {
                watch(getter, _handler, raw);
              }
            }
          } else ;
        }
        function resolveMergedOptions(instance) {
          var base = instance.type;
          var mixins = base.mixins,
            extendsOptions = base.extends;
          var _instance$appContext = instance.appContext,
            globalMixins = _instance$appContext.mixins,
            cache = _instance$appContext.optionsCache,
            optionMergeStrategies = _instance$appContext.config.optionMergeStrategies;
          var cached = cache.get(base);
          var resolved;
          if (cached) {
            resolved = cached;
          } else if (!globalMixins.length && !mixins && !extendsOptions) {
            {
              resolved = base;
            }
          } else {
            resolved = {};
            if (globalMixins.length) {
              globalMixins.forEach(function (m) {
                return mergeOptions$1(resolved, m, optionMergeStrategies, true);
              });
            }
            mergeOptions$1(resolved, base, optionMergeStrategies);
          }
          if (isObject$2(base)) {
            cache.set(base, resolved);
          }
          return resolved;
        }
        function mergeOptions$1(to, from, strats) {
          var asMixin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var mixins = from.mixins,
            extendsOptions = from.extends;
          if (extendsOptions) {
            mergeOptions$1(to, extendsOptions, strats, true);
          }
          if (mixins) {
            mixins.forEach(function (m) {
              return mergeOptions$1(to, m, strats, true);
            });
          }
          for (var key in from) {
            if (asMixin && key === "expose") ;else {
              var strat = internalOptionMergeStrats[key] || strats && strats[key];
              to[key] = strat ? strat(to[key], from[key]) : from[key];
            }
          }
          return to;
        }
        var internalOptionMergeStrats = {
          data: mergeDataFn,
          props: mergeEmitsOrPropsOptions,
          emits: mergeEmitsOrPropsOptions,
          // objects
          methods: mergeObjectOptions,
          computed: mergeObjectOptions,
          // lifecycle
          beforeCreate: mergeAsArray,
          created: mergeAsArray,
          beforeMount: mergeAsArray,
          mounted: mergeAsArray,
          beforeUpdate: mergeAsArray,
          updated: mergeAsArray,
          beforeDestroy: mergeAsArray,
          beforeUnmount: mergeAsArray,
          destroyed: mergeAsArray,
          unmounted: mergeAsArray,
          activated: mergeAsArray,
          deactivated: mergeAsArray,
          errorCaptured: mergeAsArray,
          serverPrefetch: mergeAsArray,
          // assets
          components: mergeObjectOptions,
          directives: mergeObjectOptions,
          // watch
          watch: mergeWatchOptions,
          // provide / inject
          provide: mergeDataFn,
          inject: mergeInject
        };
        function mergeDataFn(to, from) {
          if (!from) {
            return to;
          }
          if (!to) {
            return from;
          }
          return function mergedDataFn() {
            return extend(isFunction$1(to) ? to.call(this, this) : to, isFunction$1(from) ? from.call(this, this) : from);
          };
        }
        function mergeInject(to, from) {
          return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
        }
        function normalizeInject(raw) {
          if (isArray$2(raw)) {
            var res = {};
            for (var i = 0; i < raw.length; i++) {
              res[raw[i]] = raw[i];
            }
            return res;
          }
          return raw;
        }
        function mergeAsArray(to, from) {
          return to ? _toConsumableArray(new Set([].concat(to, from))) : from;
        }
        function mergeObjectOptions(to, from) {
          return to ? extend(/* @__PURE__ */Object.create(null), to, from) : from;
        }
        function mergeEmitsOrPropsOptions(to, from) {
          if (to) {
            if (isArray$2(to) && isArray$2(from)) {
              return _toConsumableArray(/* @__PURE__ */new Set([].concat(_toConsumableArray(to), _toConsumableArray(from))));
            }
            return extend(/* @__PURE__ */Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
          } else {
            return from;
          }
        }
        function mergeWatchOptions(to, from) {
          if (!to) return from;
          if (!from) return to;
          var merged = extend(/* @__PURE__ */Object.create(null), to);
          for (var key in from) {
            merged[key] = mergeAsArray(to[key], from[key]);
          }
          return merged;
        }
        function createAppContext() {
          return {
            app: null,
            config: {
              isNativeTag: NO,
              performance: false,
              globalProperties: {},
              optionMergeStrategies: {},
              errorHandler: void 0,
              warnHandler: void 0,
              compilerOptions: {}
            },
            mixins: [],
            components: {},
            directives: {},
            provides: /* @__PURE__ */Object.create(null),
            optionsCache: /* @__PURE__ */new WeakMap(),
            propsCache: /* @__PURE__ */new WeakMap(),
            emitsCache: /* @__PURE__ */new WeakMap()
          };
        }
        var uid$1 = 0;
        function createAppAPI(render, hydrate) {
          return function createApp(rootComponent) {
            var rootProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            if (!isFunction$1(rootComponent)) {
              rootComponent = extend({}, rootComponent);
            }
            if (rootProps != null && !isObject$2(rootProps)) {
              rootProps = null;
            }
            var context = createAppContext();
            var installedPlugins = /* @__PURE__ */new WeakSet();
            var pluginCleanupFns = [];
            var isMounted = false;
            var app = context.app = {
              _uid: uid$1++,
              _component: rootComponent,
              _props: rootProps,
              _container: null,
              _context: context,
              _instance: null,
              version: version,
              get config() {
                return context.config;
              },
              set config(v) {},
              use: function use(plugin) {
                for (var _len15 = arguments.length, options = new Array(_len15 > 1 ? _len15 - 1 : 0), _key19 = 1; _key19 < _len15; _key19++) {
                  options[_key19 - 1] = arguments[_key19];
                }
                if (installedPlugins.has(plugin)) ;else if (plugin && isFunction$1(plugin.install)) {
                  installedPlugins.add(plugin);
                  plugin.install.apply(plugin, [app].concat(options));
                } else if (isFunction$1(plugin)) {
                  installedPlugins.add(plugin);
                  plugin.apply(void 0, [app].concat(options));
                } else ;
                return app;
              },
              mixin: function mixin(_mixin) {
                {
                  if (!context.mixins.includes(_mixin)) {
                    context.mixins.push(_mixin);
                  }
                }
                return app;
              },
              component: function component(name, _component) {
                if (!_component) {
                  return context.components[name];
                }
                context.components[name] = _component;
                return app;
              },
              directive: function directive(name, _directive) {
                if (!_directive) {
                  return context.directives[name];
                }
                context.directives[name] = _directive;
                return app;
              },
              mount: function mount(rootContainer, isHydrate, namespace) {
                if (!isMounted) {
                  var vnode = app._ceVNode || createVNode(rootComponent, rootProps);
                  vnode.appContext = context;
                  if (namespace === true) {
                    namespace = "svg";
                  } else if (namespace === false) {
                    namespace = void 0;
                  }
                  if (isHydrate && hydrate) {
                    hydrate(vnode, rootContainer);
                  } else {
                    render(vnode, rootContainer, namespace);
                  }
                  isMounted = true;
                  app._container = rootContainer;
                  rootContainer.__vue_app__ = app;
                  return getComponentPublicInstance(vnode.component);
                }
              },
              onUnmount: function onUnmount(cleanupFn) {
                pluginCleanupFns.push(cleanupFn);
              },
              unmount: function unmount() {
                if (isMounted) {
                  callWithAsyncErrorHandling(pluginCleanupFns, app._instance, 16);
                  render(null, app._container);
                  delete app._container.__vue_app__;
                }
              },
              provide: function provide(key, value) {
                context.provides[key] = value;
                return app;
              },
              runWithContext: function runWithContext(fn) {
                var lastApp = currentApp;
                currentApp = app;
                try {
                  return fn();
                } finally {
                  currentApp = lastApp;
                }
              }
            };
            return app;
          };
        }
        var currentApp = null;
        function provide(key, value) {
          if (!currentInstance) ;else {
            var provides = currentInstance.provides;
            var parentProvides = currentInstance.parent && currentInstance.parent.provides;
            if (parentProvides === provides) {
              provides = currentInstance.provides = Object.create(parentProvides);
            }
            provides[key] = value;
          }
        }
        function inject(key, defaultValue) {
          var treatDefaultAsFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var instance = currentInstance || currentRenderingInstance;
          if (instance || currentApp) {
            var provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
            if (provides && key in provides) {
              return provides[key];
            } else if (arguments.length > 1) {
              return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
            } else ;
          }
        }
        function hasInjectionContext() {
          return !!(currentInstance || currentRenderingInstance || currentApp);
        }
        var internalObjectProto = {};
        var createInternalObject = function createInternalObject() {
          return Object.create(internalObjectProto);
        };
        var isInternalObject = function isInternalObject(obj) {
          return Object.getPrototypeOf(obj) === internalObjectProto;
        };
        function initProps(instance, rawProps, isStateful) {
          var isSSR = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var props = {};
          var attrs = createInternalObject();
          instance.propsDefaults = /* @__PURE__ */Object.create(null);
          setFullProps(instance, rawProps, props, attrs);
          for (var key in instance.propsOptions[0]) {
            if (!(key in props)) {
              props[key] = void 0;
            }
          }
          if (isStateful) {
            instance.props = isSSR ? props : shallowReactive(props);
          } else {
            if (!instance.type.props) {
              instance.props = attrs;
            } else {
              instance.props = props;
            }
          }
          instance.attrs = attrs;
        }
        function updateProps(instance, rawProps, rawPrevProps, optimized) {
          var props = instance.props,
            attrs = instance.attrs,
            patchFlag = instance.vnode.patchFlag;
          var rawCurrentProps = toRaw(props);
          var _instance$propsOption = _slicedToArray(instance.propsOptions, 1),
            options = _instance$propsOption[0];
          var hasAttrsChanged = false;
          if (
          // always force full diff in dev
          // - #1942 if hmr is enabled with sfc component
          // - vite#872 non-sfc component used by sfc component
          (optimized || patchFlag > 0) && !(patchFlag & 16)) {
            if (patchFlag & 8) {
              var propsToUpdate = instance.vnode.dynamicProps;
              for (var i = 0; i < propsToUpdate.length; i++) {
                var key = propsToUpdate[i];
                if (isEmitListener(instance.emitsOptions, key)) {
                  continue;
                }
                var value = rawProps[key];
                if (options) {
                  if (hasOwn$1(attrs, key)) {
                    if (value !== attrs[key]) {
                      attrs[key] = value;
                      hasAttrsChanged = true;
                    }
                  } else {
                    var camelizedKey = camelize(key);
                    props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
                  }
                } else {
                  if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                  }
                }
              }
            }
          } else {
            if (setFullProps(instance, rawProps, props, attrs)) {
              hasAttrsChanged = true;
            }
            var kebabKey;
            for (var _key20 in rawCurrentProps) {
              if (!rawProps ||
              // for camelCase
              !hasOwn$1(rawProps, _key20) && (
              // it's possible the original props was passed in as kebab-case
              // and converted to camelCase (#955)
              (kebabKey = hyphenate(_key20)) === _key20 || !hasOwn$1(rawProps, kebabKey))) {
                if (options) {
                  if (rawPrevProps && (
                  // for camelCase
                  rawPrevProps[_key20] !== void 0 ||
                  // for kebab-case
                  rawPrevProps[kebabKey] !== void 0)) {
                    props[_key20] = resolvePropValue(options, rawCurrentProps, _key20, void 0, instance, true);
                  }
                } else {
                  delete props[_key20];
                }
              }
            }
            if (attrs !== rawCurrentProps) {
              for (var _key21 in attrs) {
                if (!rawProps || !hasOwn$1(rawProps, _key21) && true) {
                  delete attrs[_key21];
                  hasAttrsChanged = true;
                }
              }
            }
          }
          if (hasAttrsChanged) {
            trigger(instance.attrs, "set", "");
          }
        }
        function setFullProps(instance, rawProps, props, attrs) {
          var _instance$propsOption2 = _slicedToArray(instance.propsOptions, 2),
            options = _instance$propsOption2[0],
            needCastKeys = _instance$propsOption2[1];
          var hasAttrsChanged = false;
          var rawCastValues;
          if (rawProps) {
            for (var key in rawProps) {
              if (isReservedProp(key)) {
                continue;
              }
              var value = rawProps[key];
              var camelKey = void 0;
              if (options && hasOwn$1(options, camelKey = camelize(key))) {
                if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                  props[camelKey] = value;
                } else {
                  (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                }
              } else if (!isEmitListener(instance.emitsOptions, key)) {
                if (!(key in attrs) || value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              }
            }
          }
          if (needCastKeys) {
            var rawCurrentProps = toRaw(props);
            var castValues = rawCastValues || EMPTY_OBJ;
            for (var i = 0; i < needCastKeys.length; i++) {
              var _key22 = needCastKeys[i];
              props[_key22] = resolvePropValue(options, rawCurrentProps, _key22, castValues[_key22], instance, !hasOwn$1(castValues, _key22));
            }
          }
          return hasAttrsChanged;
        }
        function resolvePropValue(options, props, key, value, instance, isAbsent) {
          var opt = options[key];
          if (opt != null) {
            var hasDefault = hasOwn$1(opt, "default");
            if (hasDefault && value === void 0) {
              var defaultValue = opt.default;
              if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
                var propsDefaults = instance.propsDefaults;
                if (key in propsDefaults) {
                  value = propsDefaults[key];
                } else {
                  var reset = setCurrentInstance(instance);
                  value = propsDefaults[key] = defaultValue.call(null, props);
                  reset();
                }
              } else {
                value = defaultValue;
              }
              if (instance.ce) {
                instance.ce._setProp(key, value);
              }
            }
            if (opt[0
            /* shouldCast */]) {
              if (isAbsent && !hasDefault) {
                value = false;
              } else if (opt[1
              /* shouldCastTrue */] && (value === "" || value === hyphenate(key))) {
                value = true;
              }
            }
          }
          return value;
        }
        var mixinPropsCache = /* @__PURE__ */new WeakMap();
        function normalizePropsOptions(comp, appContext) {
          var asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var cache = asMixin ? mixinPropsCache : appContext.propsCache;
          var cached = cache.get(comp);
          if (cached) {
            return cached;
          }
          var raw = comp.props;
          var normalized = {};
          var needCastKeys = [];
          var hasExtends = false;
          if (!isFunction$1(comp)) {
            var extendProps = function extendProps(raw2) {
              hasExtends = true;
              var _normalizePropsOption = normalizePropsOptions(raw2, appContext, true),
                _normalizePropsOption2 = _slicedToArray(_normalizePropsOption, 2),
                props = _normalizePropsOption2[0],
                keys = _normalizePropsOption2[1];
              extend(normalized, props);
              if (keys) needCastKeys.push.apply(needCastKeys, _toConsumableArray(keys));
            };
            if (!asMixin && appContext.mixins.length) {
              appContext.mixins.forEach(extendProps);
            }
            if (comp.extends) {
              extendProps(comp.extends);
            }
            if (comp.mixins) {
              comp.mixins.forEach(extendProps);
            }
          }
          if (!raw && !hasExtends) {
            if (isObject$2(comp)) {
              cache.set(comp, EMPTY_ARR);
            }
            return EMPTY_ARR;
          }
          if (isArray$2(raw)) {
            for (var i = 0; i < raw.length; i++) {
              var normalizedKey = camelize(raw[i]);
              if (validatePropName(normalizedKey)) {
                normalized[normalizedKey] = EMPTY_OBJ;
              }
            }
          } else if (raw) {
            for (var key in raw) {
              var _normalizedKey = camelize(key);
              if (validatePropName(_normalizedKey)) {
                var opt = raw[key];
                var prop = normalized[_normalizedKey] = isArray$2(opt) || isFunction$1(opt) ? {
                  type: opt
                } : extend({}, opt);
                var propType = prop.type;
                var shouldCast = false;
                var shouldCastTrue = true;
                if (isArray$2(propType)) {
                  for (var _index2 = 0; _index2 < propType.length; ++_index2) {
                    var type = propType[_index2];
                    var typeName = isFunction$1(type) && type.name;
                    if (typeName === "Boolean") {
                      shouldCast = true;
                      break;
                    } else if (typeName === "String") {
                      shouldCastTrue = false;
                    }
                  }
                } else {
                  shouldCast = isFunction$1(propType) && propType.name === "Boolean";
                }
                prop[0
                /* shouldCast */] = shouldCast;
                prop[1
                /* shouldCastTrue */] = shouldCastTrue;
                if (shouldCast || hasOwn$1(prop, "default")) {
                  needCastKeys.push(_normalizedKey);
                }
              }
            }
          }
          var res = [normalized, needCastKeys];
          if (isObject$2(comp)) {
            cache.set(comp, res);
          }
          return res;
        }
        function validatePropName(key) {
          if (key[0] !== "$" && !isReservedProp(key)) {
            return true;
          }
          return false;
        }
        var isInternalKey = function isInternalKey(key) {
          return key[0] === "_" || key === "$stable";
        };
        var normalizeSlotValue = function normalizeSlotValue(value) {
          return isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
        };
        var normalizeSlot$1 = function normalizeSlot$1(key, rawSlot, ctx) {
          if (rawSlot._n) {
            return rawSlot;
          }
          var normalized = withCtx(function () {
            if (false) ;
            return normalizeSlotValue(rawSlot.apply(void 0, arguments));
          }, ctx);
          normalized._c = false;
          return normalized;
        };
        var normalizeObjectSlots = function normalizeObjectSlots(rawSlots, slots, instance) {
          var ctx = rawSlots._ctx;
          var _loop5 = function _loop5() {
            if (isInternalKey(key)) return 1; // continue
            var value = rawSlots[key];
            if (isFunction$1(value)) {
              slots[key] = normalizeSlot$1(key, value, ctx);
            } else if (value != null) {
              var normalized = normalizeSlotValue(value);
              slots[key] = function () {
                return normalized;
              };
            }
          };
          for (var key in rawSlots) {
            if (_loop5()) continue;
          }
        };
        var normalizeVNodeSlots = function normalizeVNodeSlots(instance, children) {
          var normalized = normalizeSlotValue(children);
          instance.slots.default = function () {
            return normalized;
          };
        };
        var assignSlots = function assignSlots(slots, children, optimized) {
          for (var key in children) {
            if (optimized || key !== "_") {
              slots[key] = children[key];
            }
          }
        };
        var initSlots = function initSlots(instance, children, optimized) {
          var slots = instance.slots = createInternalObject();
          if (instance.vnode.shapeFlag & 32) {
            var type = children._;
            if (type) {
              assignSlots(slots, children, optimized);
              if (optimized) {
                def(slots, "_", type, true);
              }
            } else {
              normalizeObjectSlots(children, slots);
            }
          } else if (children) {
            normalizeVNodeSlots(instance, children);
          }
        };
        var updateSlots = function updateSlots(instance, children, optimized) {
          var vnode = instance.vnode,
            slots = instance.slots;
          var needDeletionCheck = true;
          var deletionComparisonTarget = EMPTY_OBJ;
          if (vnode.shapeFlag & 32) {
            var type = children._;
            if (type) {
              if (optimized && type === 1) {
                needDeletionCheck = false;
              } else {
                assignSlots(slots, children, optimized);
              }
            } else {
              needDeletionCheck = !children.$stable;
              normalizeObjectSlots(children, slots);
            }
            deletionComparisonTarget = children;
          } else if (children) {
            normalizeVNodeSlots(instance, children);
            deletionComparisonTarget = {
              default: 1
            };
          }
          if (needDeletionCheck) {
            for (var key in slots) {
              if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
                delete slots[key];
              }
            }
          }
        };
        var queuePostRenderEffect = queueEffectWithSuspense;
        function createRenderer(options) {
          return baseCreateRenderer(options);
        }
        function createHydrationRenderer(options) {
          return baseCreateRenderer(options, createHydrationFunctions);
        }
        function baseCreateRenderer(options, createHydrationFns) {
          var target = getGlobalThis$1();
          target.__VUE__ = true;
          var hostInsert = options.insert,
            hostRemove = options.remove,
            hostPatchProp = options.patchProp,
            hostCreateElement = options.createElement,
            hostCreateText = options.createText,
            hostCreateComment = options.createComment,
            hostSetText = options.setText,
            hostSetElementText = options.setElementText,
            hostParentNode = options.parentNode,
            hostNextSibling = options.nextSibling,
            _options$setScopeId = options.setScopeId,
            hostSetScopeId = _options$setScopeId === void 0 ? NOOP : _options$setScopeId,
            hostInsertStaticContent = options.insertStaticContent;
          var patch = function patch(n1, n2, container) {
            var anchor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
            var parentComponent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
            var parentSuspense = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
            var namespace = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : void 0;
            var slotScopeIds = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
            var optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : !!n2.dynamicChildren;
            if (n1 === n2) {
              return;
            }
            if (n1 && !isSameVNodeType(n1, n2)) {
              anchor = _getNextHostNode(n1);
              unmount(n1, parentComponent, parentSuspense, true);
              n1 = null;
            }
            if (n2.patchFlag === -2) {
              optimized = false;
              n2.dynamicChildren = null;
            }
            var type = n2.type,
              ref3 = n2.ref,
              shapeFlag = n2.shapeFlag;
            switch (type) {
              case Text:
                processText(n1, n2, container, anchor);
                break;
              case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
              case Static:
                if (n1 == null) {
                  mountStaticNode(n2, container, anchor, namespace);
                }
                break;
              case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                break;
              default:
                if (shapeFlag & 1) {
                  processElement(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                } else if (shapeFlag & 6) {
                  processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                } else if (shapeFlag & 64) {
                  type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
                } else if (shapeFlag & 128) {
                  type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
                } else ;
            }
            if (ref3 != null && parentComponent) {
              setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
            }
          };
          var processText = function processText(n1, n2, container, anchor) {
            if (n1 == null) {
              hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
            } else {
              var el = n2.el = n1.el;
              if (n2.children !== n1.children) {
                hostSetText(el, n2.children);
              }
            }
          };
          var processCommentNode = function processCommentNode(n1, n2, container, anchor) {
            if (n1 == null) {
              hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
            } else {
              n2.el = n1.el;
            }
          };
          var mountStaticNode = function mountStaticNode(n2, container, anchor, namespace) {
            var _hostInsertStaticCont = hostInsertStaticContent(n2.children, container, anchor, namespace, n2.el, n2.anchor);
            var _hostInsertStaticCont2 = _slicedToArray(_hostInsertStaticCont, 2);
            n2.el = _hostInsertStaticCont2[0];
            n2.anchor = _hostInsertStaticCont2[1];
          };
          var moveStaticNode = function moveStaticNode(_ref21, container, nextSibling) {
            var el = _ref21.el,
              anchor = _ref21.anchor;
            var next;
            while (el && el !== anchor) {
              next = hostNextSibling(el);
              hostInsert(el, container, nextSibling);
              el = next;
            }
            hostInsert(anchor, container, nextSibling);
          };
          var removeStaticNode = function removeStaticNode(_ref22) {
            var el = _ref22.el,
              anchor = _ref22.anchor;
            var next;
            while (el && el !== anchor) {
              next = hostNextSibling(el);
              hostRemove(el);
              el = next;
            }
            hostRemove(anchor);
          };
          var processElement = function processElement(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
            if (n2.type === "svg") {
              namespace = "svg";
            } else if (n2.type === "math") {
              namespace = "mathml";
            }
            if (n1 == null) {
              mountElement(n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            } else {
              patchElement(n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            }
          };
          var mountElement = function mountElement(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
            var el;
            var vnodeHook;
            var props = vnode.props,
              shapeFlag = vnode.shapeFlag,
              transition = vnode.transition,
              dirs = vnode.dirs;
            el = vnode.el = hostCreateElement(vnode.type, namespace, props && props.is, props);
            if (shapeFlag & 8) {
              hostSetElementText(el, vnode.children);
            } else if (shapeFlag & 16) {
              mountChildren(vnode.children, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(vnode, namespace), slotScopeIds, optimized);
            }
            if (dirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "created");
            }
            _setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
            if (props) {
              for (var key in props) {
                if (key !== "value" && !isReservedProp(key)) {
                  hostPatchProp(el, key, null, props[key], namespace, parentComponent);
                }
              }
              if ("value" in props) {
                hostPatchProp(el, "value", null, props.value, namespace);
              }
              if (vnodeHook = props.onVnodeBeforeMount) {
                invokeVNodeHook(vnodeHook, parentComponent, vnode);
              }
            }
            if (dirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
            }
            var needCallTransitionHooks = needTransition(parentSuspense, transition);
            if (needCallTransitionHooks) {
              transition.beforeEnter(el);
            }
            hostInsert(el, container, anchor);
            if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
              queuePostRenderEffect(function () {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                needCallTransitionHooks && transition.enter(el);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
              }, parentSuspense);
            }
          };
          var _setScopeId = function setScopeId(el, vnode, scopeId, slotScopeIds, parentComponent) {
            if (scopeId) {
              hostSetScopeId(el, scopeId);
            }
            if (slotScopeIds) {
              for (var i = 0; i < slotScopeIds.length; i++) {
                hostSetScopeId(el, slotScopeIds[i]);
              }
            }
            if (parentComponent) {
              var subTree = parentComponent.subTree;
              if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
                var parentVNode = parentComponent.vnode;
                _setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
              }
            }
          };
          var mountChildren = function mountChildren(children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
            var start = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
            for (var i = start; i < children.length; i++) {
              var child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
              patch(null, child, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            }
          };
          var patchElement = function patchElement(n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
            var el = n2.el = n1.el;
            var patchFlag = n2.patchFlag,
              dynamicChildren = n2.dynamicChildren,
              dirs = n2.dirs;
            patchFlag |= n1.patchFlag & 16;
            var oldProps = n1.props || EMPTY_OBJ;
            var newProps = n2.props || EMPTY_OBJ;
            var vnodeHook;
            parentComponent && toggleRecurse(parentComponent, false);
            if (vnodeHook = newProps.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            }
            if (dirs) {
              invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
            }
            parentComponent && toggleRecurse(parentComponent, true);
            if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
              hostSetElementText(el, "");
            }
            if (dynamicChildren) {
              patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds);
            } else if (!optimized) {
              patchChildren(n1, n2, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds, false);
            }
            if (patchFlag > 0) {
              if (patchFlag & 16) {
                patchProps(el, oldProps, newProps, parentComponent, namespace);
              } else {
                if (patchFlag & 2) {
                  if (oldProps.class !== newProps.class) {
                    hostPatchProp(el, "class", null, newProps.class, namespace);
                  }
                }
                if (patchFlag & 4) {
                  hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
                }
                if (patchFlag & 8) {
                  var propsToUpdate = n2.dynamicProps;
                  for (var i = 0; i < propsToUpdate.length; i++) {
                    var key = propsToUpdate[i];
                    var prev = oldProps[key];
                    var next = newProps[key];
                    if (next !== prev || key === "value") {
                      hostPatchProp(el, key, prev, next, namespace, parentComponent);
                    }
                  }
                }
              }
              if (patchFlag & 1) {
                if (n1.children !== n2.children) {
                  hostSetElementText(el, n2.children);
                }
              }
            } else if (!optimized && dynamicChildren == null) {
              patchProps(el, oldProps, newProps, parentComponent, namespace);
            }
            if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
              queuePostRenderEffect(function () {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
              }, parentSuspense);
            }
          };
          var patchBlockChildren = function patchBlockChildren(oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) {
            for (var i = 0; i < newChildren.length; i++) {
              var oldVNode = oldChildren[i];
              var newVNode = newChildren[i];
              var container =
              // oldVNode may be an errored async setup() component inside Suspense
              // which will not have a mounted element
              oldVNode.el && (
              // - In the case of a Fragment, we need to provide the actual parent
              // of the Fragment itself so it can move its children.
              oldVNode.type === Fragment ||
              // - In the case of different nodes, there is going to be a replacement
              // which also requires the correct parent container
              !isSameVNodeType(oldVNode, newVNode) ||
              // - In the case of a component, it could contain anything.
              oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) :
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer;
              patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, true);
            }
          };
          var patchProps = function patchProps(el, oldProps, newProps, parentComponent, namespace) {
            if (oldProps !== newProps) {
              if (oldProps !== EMPTY_OBJ) {
                for (var key in oldProps) {
                  if (!isReservedProp(key) && !(key in newProps)) {
                    hostPatchProp(el, key, oldProps[key], null, namespace, parentComponent);
                  }
                }
              }
              for (var _key23 in newProps) {
                if (isReservedProp(_key23)) continue;
                var next = newProps[_key23];
                var prev = oldProps[_key23];
                if (next !== prev && _key23 !== "value") {
                  hostPatchProp(el, _key23, prev, next, namespace, parentComponent);
                }
              }
              if ("value" in newProps) {
                hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
              }
            }
          };
          var processFragment = function processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
            var fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
            var fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
            var patchFlag = n2.patchFlag,
              dynamicChildren = n2.dynamicChildren,
              fragmentSlotScopeIds = n2.slotScopeIds;
            if (fragmentSlotScopeIds) {
              slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
            }
            if (n1 == null) {
              hostInsert(fragmentStartAnchor, container, anchor);
              hostInsert(fragmentEndAnchor, container, anchor);
              mountChildren(
              // #10007
              // such fragment like `<></>` will be compiled into
              // a fragment which doesn't have a children.
              // In this case fallback to an empty array
              n2.children || [], container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            } else {
              if (patchFlag > 0 && patchFlag & 64 && dynamicChildren &&
              // #2715 the previous fragment could've been a BAILed one as a result
              // of renderSlot() with no valid children
              n1.dynamicChildren) {
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, namespace, slotScopeIds);
                if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null || parentComponent && n2 === parentComponent.subTree) {
                  traverseStaticChildren(n1, n2, true
                  /* shallow */);
                }
              } else {
                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
              }
            }
          };
          var processComponent = function processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
            n2.slotScopeIds = slotScopeIds;
            if (n1 == null) {
              if (n2.shapeFlag & 512) {
                parentComponent.ctx.activate(n2, container, anchor, namespace, optimized);
              } else {
                mountComponent(n2, container, anchor, parentComponent, parentSuspense, namespace, optimized);
              }
            } else {
              updateComponent(n1, n2, optimized);
            }
          };
          var mountComponent = function mountComponent(initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) {
            var instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
            if (isKeepAlive(initialVNode)) {
              instance.ctx.renderer = internals;
            }
            {
              setupComponent(instance, false, optimized);
            }
            if (instance.asyncDep) {
              parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
              if (!initialVNode.el) {
                var placeholder = instance.subTree = createVNode(Comment);
                processCommentNode(null, placeholder, container, anchor);
              }
            } else {
              setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, namespace, optimized);
            }
          };
          var updateComponent = function updateComponent(n1, n2, optimized) {
            var instance = n2.component = n1.component;
            if (shouldUpdateComponent(n1, n2, optimized)) {
              if (instance.asyncDep && !instance.asyncResolved) {
                updateComponentPreRender(instance, n2, optimized);
                return;
              } else {
                instance.next = n2;
                instance.update();
              }
            } else {
              n2.el = n1.el;
              instance.vnode = n2;
            }
          };
          var setupRenderEffect = function setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) {
            var _componentUpdateFn = function componentUpdateFn() {
              if (!instance.isMounted) {
                var vnodeHook;
                var _initialVNode = initialVNode,
                  el = _initialVNode.el,
                  props = _initialVNode.props;
                var bm = instance.bm,
                  _m = instance.m,
                  parent = instance.parent,
                  root = instance.root,
                  type = instance.type;
                var isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                if (bm) {
                  invokeArrayFns(bm);
                }
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                  invokeVNodeHook(vnodeHook, parent, initialVNode);
                }
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                  var hydrateSubTree = function hydrateSubTree() {
                    instance.subTree = renderComponentRoot(instance);
                    hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                  };
                  if (isAsyncWrapperVNode && type.__asyncHydrate) {
                    type.__asyncHydrate(el, instance, hydrateSubTree);
                  } else {
                    hydrateSubTree();
                  }
                } else {
                  if (root.ce) {
                    root.ce._injectChildStyle(type);
                  }
                  var subTree = instance.subTree = renderComponentRoot(instance);
                  patch(null, subTree, container, anchor, instance, parentSuspense, namespace);
                  initialVNode.el = subTree.el;
                }
                if (_m) {
                  queuePostRenderEffect(_m, parentSuspense);
                }
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                  var scopedInitialVNode = initialVNode;
                  queuePostRenderEffect(function () {
                    return invokeVNodeHook(vnodeHook, parent, scopedInitialVNode);
                  }, parentSuspense);
                }
                if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
                  instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                }
                instance.isMounted = true;
                initialVNode = container = anchor = null;
              } else {
                var next = instance.next,
                  bu = instance.bu,
                  u = instance.u,
                  _parent = instance.parent,
                  vnode = instance.vnode;
                {
                  var nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
                  if (nonHydratedAsyncRoot) {
                    if (next) {
                      next.el = vnode.el;
                      updateComponentPreRender(instance, next, optimized);
                    }
                    nonHydratedAsyncRoot.asyncDep.then(function () {
                      if (!instance.isUnmounted) {
                        _componentUpdateFn();
                      }
                    });
                    return;
                  }
                }
                var originNext = next;
                var _vnodeHook;
                toggleRecurse(instance, false);
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                } else {
                  next = vnode;
                }
                if (bu) {
                  invokeArrayFns(bu);
                }
                if (_vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
                  invokeVNodeHook(_vnodeHook, _parent, next, vnode);
                }
                toggleRecurse(instance, true);
                var nextTree = renderComponentRoot(instance);
                var prevTree = instance.subTree;
                instance.subTree = nextTree;
                patch(prevTree, nextTree,
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el),
                // anchor may have changed if it's in a fragment
                _getNextHostNode(prevTree), instance, parentSuspense, namespace);
                next.el = nextTree.el;
                if (originNext === null) {
                  updateHOCHostEl(instance, nextTree.el);
                }
                if (u) {
                  queuePostRenderEffect(u, parentSuspense);
                }
                if (_vnodeHook = next.props && next.props.onVnodeUpdated) {
                  queuePostRenderEffect(function () {
                    return invokeVNodeHook(_vnodeHook, _parent, next, vnode);
                  }, parentSuspense);
                }
              }
            };
            instance.scope.on();
            var effect2 = instance.effect = new ReactiveEffect(_componentUpdateFn);
            instance.scope.off();
            var update = instance.update = effect2.run.bind(effect2);
            var job = instance.job = effect2.runIfDirty.bind(effect2);
            job.i = instance;
            job.id = instance.uid;
            effect2.scheduler = function () {
              return queueJob(job);
            };
            toggleRecurse(instance, true);
            update();
          };
          var updateComponentPreRender = function updateComponentPreRender(instance, nextVNode, optimized) {
            nextVNode.component = instance;
            var prevProps = instance.vnode.props;
            instance.vnode = nextVNode;
            instance.next = null;
            updateProps(instance, nextVNode.props, prevProps, optimized);
            updateSlots(instance, nextVNode.children, optimized);
            pauseTracking();
            flushPreFlushCbs(instance);
            resetTracking();
          };
          var patchChildren = function patchChildren(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds) {
            var optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
            var c1 = n1 && n1.children;
            var prevShapeFlag = n1 ? n1.shapeFlag : 0;
            var c2 = n2.children;
            var patchFlag = n2.patchFlag,
              shapeFlag = n2.shapeFlag;
            if (patchFlag > 0) {
              if (patchFlag & 128) {
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                return;
              } else if (patchFlag & 256) {
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                return;
              }
            }
            if (shapeFlag & 8) {
              if (prevShapeFlag & 16) {
                unmountChildren(c1, parentComponent, parentSuspense);
              }
              if (c2 !== c1) {
                hostSetElementText(container, c2);
              }
            } else {
              if (prevShapeFlag & 16) {
                if (shapeFlag & 16) {
                  patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                } else {
                  unmountChildren(c1, parentComponent, parentSuspense, true);
                }
              } else {
                if (prevShapeFlag & 8) {
                  hostSetElementText(container, "");
                }
                if (shapeFlag & 16) {
                  mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                }
              }
            }
          };
          var patchUnkeyedChildren = function patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
            c1 = c1 || EMPTY_ARR;
            c2 = c2 || EMPTY_ARR;
            var oldLength = c1.length;
            var newLength = c2.length;
            var commonLength = Math.min(oldLength, newLength);
            var i;
            for (i = 0; i < commonLength; i++) {
              var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
              patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            }
            if (oldLength > newLength) {
              unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
            } else {
              mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, commonLength);
            }
          };
          var patchKeyedChildren = function patchKeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
            var i = 0;
            var l2 = c2.length;
            var e1 = c1.length - 1;
            var e2 = l2 - 1;
            while (i <= e1 && i <= e2) {
              var n1 = c1[i];
              var n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
              if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
              } else {
                break;
              }
              i++;
            }
            while (i <= e1 && i <= e2) {
              var _n = c1[e1];
              var _n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
              if (isSameVNodeType(_n, _n2)) {
                patch(_n, _n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
              } else {
                break;
              }
              e1--;
              e2--;
            }
            if (i > e1) {
              if (i <= e2) {
                var nextPos = e2 + 1;
                var anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while (i <= e2) {
                  patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                  i++;
                }
              }
            } else if (i > e2) {
              while (i <= e1) {
                unmount(c1[i], parentComponent, parentSuspense, true);
                i++;
              }
            } else {
              var s1 = i;
              var s2 = i;
              var keyToNewIndexMap = /* @__PURE__ */new Map();
              for (i = s2; i <= e2; i++) {
                var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                if (nextChild.key != null) {
                  keyToNewIndexMap.set(nextChild.key, i);
                }
              }
              var j;
              var patched = 0;
              var toBePatched = e2 - s2 + 1;
              var moved = false;
              var maxNewIndexSoFar = 0;
              var newIndexToOldIndexMap = new Array(toBePatched);
              for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
              for (i = s1; i <= e1; i++) {
                var prevChild = c1[i];
                if (patched >= toBePatched) {
                  unmount(prevChild, parentComponent, parentSuspense, true);
                  continue;
                }
                var newIndex = void 0;
                if (prevChild.key != null) {
                  newIndex = keyToNewIndexMap.get(prevChild.key);
                } else {
                  for (j = s2; j <= e2; j++) {
                    if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                      newIndex = j;
                      break;
                    }
                  }
                }
                if (newIndex === void 0) {
                  unmount(prevChild, parentComponent, parentSuspense, true);
                } else {
                  newIndexToOldIndexMap[newIndex - s2] = i + 1;
                  if (newIndex >= maxNewIndexSoFar) {
                    maxNewIndexSoFar = newIndex;
                  } else {
                    moved = true;
                  }
                  patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                  patched++;
                }
              }
              var increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
              j = increasingNewIndexSequence.length - 1;
              for (i = toBePatched - 1; i >= 0; i--) {
                var nextIndex = s2 + i;
                var _nextChild = c2[nextIndex];
                var _anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) {
                  patch(null, _nextChild, container, _anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                } else if (moved) {
                  if (j < 0 || i !== increasingNewIndexSequence[j]) {
                    _move(_nextChild, container, _anchor, 2);
                  } else {
                    j--;
                  }
                }
              }
            }
          };
          var _move = function move(vnode, container, anchor, moveType) {
            var parentSuspense = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
            var el = vnode.el,
              type = vnode.type,
              transition = vnode.transition,
              children = vnode.children,
              shapeFlag = vnode.shapeFlag;
            if (shapeFlag & 6) {
              _move(vnode.component.subTree, container, anchor, moveType);
              return;
            }
            if (shapeFlag & 128) {
              vnode.suspense.move(container, anchor, moveType);
              return;
            }
            if (shapeFlag & 64) {
              type.move(vnode, container, anchor, internals);
              return;
            }
            if (type === Fragment) {
              hostInsert(el, container, anchor);
              for (var i = 0; i < children.length; i++) {
                _move(children[i], container, anchor, moveType);
              }
              hostInsert(vnode.anchor, container, anchor);
              return;
            }
            if (type === Static) {
              moveStaticNode(vnode, container, anchor);
              return;
            }
            var needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
            if (needTransition2) {
              if (moveType === 0) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(function () {
                  return transition.enter(el);
                }, parentSuspense);
              } else {
                var leave = transition.leave,
                  delayLeave = transition.delayLeave,
                  afterLeave = transition.afterLeave;
                var remove22 = function remove22() {
                  return hostInsert(el, container, anchor);
                };
                var performLeave = function performLeave() {
                  leave(el, function () {
                    remove22();
                    afterLeave && afterLeave();
                  });
                };
                if (delayLeave) {
                  delayLeave(el, remove22, performLeave);
                } else {
                  performLeave();
                }
              }
            } else {
              hostInsert(el, container, anchor);
            }
          };
          var unmount = function unmount(vnode, parentComponent, parentSuspense) {
            var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            var optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
            var type = vnode.type,
              props = vnode.props,
              ref3 = vnode.ref,
              children = vnode.children,
              dynamicChildren = vnode.dynamicChildren,
              shapeFlag = vnode.shapeFlag,
              patchFlag = vnode.patchFlag,
              dirs = vnode.dirs,
              cacheIndex = vnode.cacheIndex;
            if (patchFlag === -2) {
              optimized = false;
            }
            if (ref3 != null) {
              setRef(ref3, null, parentSuspense, vnode, true);
            }
            if (cacheIndex != null) {
              parentComponent.renderCache[cacheIndex] = void 0;
            }
            if (shapeFlag & 256) {
              parentComponent.ctx.deactivate(vnode);
              return;
            }
            var shouldInvokeDirs = shapeFlag & 1 && dirs;
            var shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
            var vnodeHook;
            if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
            if (shapeFlag & 6) {
              unmountComponent(vnode.component, parentSuspense, doRemove);
            } else {
              if (shapeFlag & 128) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
              }
              if (shouldInvokeDirs) {
                invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
              }
              if (shapeFlag & 64) {
                vnode.type.remove(vnode, parentComponent, parentSuspense, internals, doRemove);
              } else if (dynamicChildren &&
              // #5154
              // when v-once is used inside a block, setBlockTracking(-1) marks the
              // parent block with hasOnce: true
              // so that it doesn't take the fast path during unmount - otherwise
              // components nested in v-once are never unmounted.
              !dynamicChildren.hasOnce && (
              // #1153: fast path should not be taken for non-stable (v-for) fragments
              type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
              } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
                unmountChildren(children, parentComponent, parentSuspense);
              }
              if (doRemove) {
                remove2(vnode);
              }
            }
            if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
              queuePostRenderEffect(function () {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
              }, parentSuspense);
            }
          };
          var remove2 = function remove2(vnode) {
            var type = vnode.type,
              el = vnode.el,
              anchor = vnode.anchor,
              transition = vnode.transition;
            if (type === Fragment) {
              {
                removeFragment(el, anchor);
              }
              return;
            }
            if (type === Static) {
              removeStaticNode(vnode);
              return;
            }
            var performRemove = function performRemove() {
              hostRemove(el);
              if (transition && !transition.persisted && transition.afterLeave) {
                transition.afterLeave();
              }
            };
            if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
              var leave = transition.leave,
                delayLeave = transition.delayLeave;
              var performLeave = function performLeave() {
                return leave(el, performRemove);
              };
              if (delayLeave) {
                delayLeave(vnode.el, performRemove, performLeave);
              } else {
                performLeave();
              }
            } else {
              performRemove();
            }
          };
          var removeFragment = function removeFragment(cur, end) {
            var next;
            while (cur !== end) {
              next = hostNextSibling(cur);
              hostRemove(cur);
              cur = next;
            }
            hostRemove(end);
          };
          var unmountComponent = function unmountComponent(instance, parentSuspense, doRemove) {
            var bum = instance.bum,
              scope = instance.scope,
              job = instance.job,
              subTree = instance.subTree,
              um = instance.um,
              m = instance.m,
              a = instance.a;
            invalidateMount(m);
            invalidateMount(a);
            if (bum) {
              invokeArrayFns(bum);
            }
            scope.stop();
            if (job) {
              job.flags |= 8;
              unmount(subTree, instance, parentSuspense, doRemove);
            }
            if (um) {
              queuePostRenderEffect(um, parentSuspense);
            }
            queuePostRenderEffect(function () {
              instance.isUnmounted = true;
            }, parentSuspense);
            if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
              parentSuspense.deps--;
              if (parentSuspense.deps === 0) {
                parentSuspense.resolve();
              }
            }
          };
          var unmountChildren = function unmountChildren(children, parentComponent, parentSuspense) {
            var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            var optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
            var start = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
            for (var i = start; i < children.length; i++) {
              unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
            }
          };
          var _getNextHostNode = function getNextHostNode(vnode) {
            if (vnode.shapeFlag & 6) {
              return _getNextHostNode(vnode.component.subTree);
            }
            if (vnode.shapeFlag & 128) {
              return vnode.suspense.next();
            }
            var el = hostNextSibling(vnode.anchor || vnode.el);
            var teleportEnd = el && el[TeleportEndKey];
            return teleportEnd ? hostNextSibling(teleportEnd) : el;
          };
          var isFlushing = false;
          var render = function render(vnode, container, namespace) {
            if (vnode == null) {
              if (container._vnode) {
                unmount(container._vnode, null, null, true);
              }
            } else {
              patch(container._vnode || null, vnode, container, null, null, null, namespace);
            }
            container._vnode = vnode;
            if (!isFlushing) {
              isFlushing = true;
              flushPreFlushCbs();
              flushPostFlushCbs();
              isFlushing = false;
            }
          };
          var internals = {
            p: patch,
            um: unmount,
            m: _move,
            r: remove2,
            mt: mountComponent,
            mc: mountChildren,
            pc: patchChildren,
            pbc: patchBlockChildren,
            n: _getNextHostNode,
            o: options
          };
          var hydrate;
          var hydrateNode;
          if (createHydrationFns) {
            var _createHydrationFns = createHydrationFns(internals);
            var _createHydrationFns2 = _slicedToArray(_createHydrationFns, 2);
            hydrate = _createHydrationFns2[0];
            hydrateNode = _createHydrationFns2[1];
          }
          return {
            render: render,
            hydrate: hydrate,
            createApp: createAppAPI(render, hydrate)
          };
        }
        function resolveChildrenNamespace(_ref23, currentNamespace) {
          var type = _ref23.type,
            props = _ref23.props;
          return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
        }
        function toggleRecurse(_ref24, allowed) {
          var effect2 = _ref24.effect,
            job = _ref24.job;
          if (allowed) {
            effect2.flags |= 32;
            job.flags |= 4;
          } else {
            effect2.flags &= ~32;
            job.flags &= ~4;
          }
        }
        function needTransition(parentSuspense, transition) {
          return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
        }
        function traverseStaticChildren(n1, n2) {
          var shallow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var ch1 = n1.children;
          var ch2 = n2.children;
          if (isArray$2(ch1) && isArray$2(ch2)) {
            for (var i = 0; i < ch1.length; i++) {
              var c1 = ch1[i];
              var c2 = ch2[i];
              if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
                if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                  c2 = ch2[i] = cloneIfMounted(ch2[i]);
                  c2.el = c1.el;
                }
                if (!shallow && c2.patchFlag !== -2) traverseStaticChildren(c1, c2);
              }
              if (c2.type === Text) {
                c2.el = c1.el;
              }
            }
          }
        }
        function getSequence(arr) {
          var p = arr.slice();
          var result = [0];
          var i, j, u, v, c;
          var len = arr.length;
          for (i = 0; i < len; i++) {
            var arrI = arr[i];
            if (arrI !== 0) {
              j = result[result.length - 1];
              if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
              }
              u = 0;
              v = result.length - 1;
              while (u < v) {
                c = u + v >> 1;
                if (arr[result[c]] < arrI) {
                  u = c + 1;
                } else {
                  v = c;
                }
              }
              if (arrI < arr[result[u]]) {
                if (u > 0) {
                  p[i] = result[u - 1];
                }
                result[u] = i;
              }
            }
          }
          u = result.length;
          v = result[u - 1];
          while (u-- > 0) {
            result[u] = v;
            v = p[v];
          }
          return result;
        }
        function locateNonHydratedAsyncRoot(instance) {
          var subComponent = instance.subTree.component;
          if (subComponent) {
            if (subComponent.asyncDep && !subComponent.asyncResolved) {
              return subComponent;
            } else {
              return locateNonHydratedAsyncRoot(subComponent);
            }
          }
        }
        function invalidateMount(hooks) {
          if (hooks) {
            for (var i = 0; i < hooks.length; i++) hooks[i].flags |= 8;
          }
        }
        var ssrContextKey = Symbol.for("v-scx");
        var useSSRContext = function useSSRContext() {
          {
            var ctx = inject(ssrContextKey);
            return ctx;
          }
        };
        function watchEffect(effect2, options) {
          return doWatch(effect2, null, options);
        }
        function watchPostEffect(effect2, options) {
          return doWatch(effect2, null, {
            flush: "post"
          });
        }
        function watchSyncEffect(effect2, options) {
          return doWatch(effect2, null, {
            flush: "sync"
          });
        }
        function watch(source, cb, options) {
          return doWatch(source, cb, options);
        }
        function doWatch(source, cb) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJ;
          var immediate = options.immediate,
            deep = options.deep,
            flush = options.flush,
            once = options.once;
          var baseWatchOptions = extend({}, options);
          var runsImmediately = cb && immediate || !cb && flush !== "post";
          var ssrCleanup;
          if (isInSSRComponentSetup) {
            if (flush === "sync") {
              var ctx = useSSRContext();
              ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
            } else if (!runsImmediately) {
              var watchStopHandle = function watchStopHandle() {};
              watchStopHandle.stop = NOOP;
              watchStopHandle.resume = NOOP;
              watchStopHandle.pause = NOOP;
              return watchStopHandle;
            }
          }
          var instance = currentInstance;
          baseWatchOptions.call = function (fn, type, args) {
            return callWithAsyncErrorHandling(fn, instance, type, args);
          };
          var isPre = false;
          if (flush === "post") {
            baseWatchOptions.scheduler = function (job) {
              queuePostRenderEffect(job, instance && instance.suspense);
            };
          } else if (flush !== "sync") {
            isPre = true;
            baseWatchOptions.scheduler = function (job, isFirstRun) {
              if (isFirstRun) {
                job();
              } else {
                queueJob(job);
              }
            };
          }
          baseWatchOptions.augmentJob = function (job) {
            if (cb) {
              job.flags |= 4;
            }
            if (isPre) {
              job.flags |= 2;
              if (instance) {
                job.id = instance.uid;
                job.i = instance;
              }
            }
          };
          var watchHandle = watch$1(source, cb, baseWatchOptions);
          if (isInSSRComponentSetup) {
            if (ssrCleanup) {
              ssrCleanup.push(watchHandle);
            } else if (runsImmediately) {
              watchHandle();
            }
          }
          return watchHandle;
        }
        function instanceWatch(source, value, options) {
          var publicThis = this.proxy;
          var getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : function () {
            return publicThis[source];
          } : source.bind(publicThis, publicThis);
          var cb;
          if (isFunction$1(value)) {
            cb = value;
          } else {
            cb = value.handler;
            options = value;
          }
          var reset = setCurrentInstance(this);
          var res = doWatch(getter, cb.bind(publicThis), options);
          reset();
          return res;
        }
        function createPathGetter(ctx, path) {
          var segments = path.split(".");
          return function () {
            var cur = ctx;
            for (var i = 0; i < segments.length && cur; i++) {
              cur = cur[segments[i]];
            }
            return cur;
          };
        }
        function useModel(props, name) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJ;
          var i = getCurrentInstance();
          var camelizedName = camelize(name);
          var hyphenatedName = hyphenate(name);
          var modifiers = getModelModifiers(props, camelizedName);
          var res = customRef(function (track2, trigger2) {
            var localValue;
            var prevSetValue = EMPTY_OBJ;
            var prevEmittedValue;
            watchSyncEffect(function () {
              var propValue = props[camelizedName];
              if (hasChanged(localValue, propValue)) {
                localValue = propValue;
                trigger2();
              }
            });
            return {
              get: function get() {
                track2();
                return options.get ? options.get(localValue) : localValue;
              },
              set: function set(value) {
                var emittedValue = options.set ? options.set(value) : value;
                if (!hasChanged(emittedValue, localValue) && !(prevSetValue !== EMPTY_OBJ && hasChanged(value, prevSetValue))) {
                  return;
                }
                var rawProps = i.vnode.props;
                if (!(rawProps && (
                // check if parent has passed v-model
                name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && ("onUpdate:".concat(name) in rawProps || "onUpdate:".concat(camelizedName) in rawProps || "onUpdate:".concat(hyphenatedName) in rawProps))) {
                  localValue = value;
                  trigger2();
                }
                i.emit("update:".concat(name), emittedValue);
                if (hasChanged(value, emittedValue) && hasChanged(value, prevSetValue) && !hasChanged(emittedValue, prevEmittedValue)) {
                  trigger2();
                }
                prevSetValue = value;
                prevEmittedValue = emittedValue;
              }
            };
          });
          res[Symbol.iterator] = function () {
            var i2 = 0;
            return {
              next: function next() {
                if (i2 < 2) {
                  return {
                    value: i2++ ? modifiers || EMPTY_OBJ : res,
                    done: false
                  };
                } else {
                  return {
                    done: true
                  };
                }
              }
            };
          };
          return res;
        }
        var getModelModifiers = function getModelModifiers(props, modelName) {
          return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props["".concat(modelName, "Modifiers")] || props["".concat(camelize(modelName), "Modifiers")] || props["".concat(hyphenate(modelName), "Modifiers")];
        };
        function emit(instance, event) {
          if (instance.isUnmounted) return;
          var props = instance.vnode.props || EMPTY_OBJ;
          for (var _len16 = arguments.length, rawArgs = new Array(_len16 > 2 ? _len16 - 2 : 0), _key24 = 2; _key24 < _len16; _key24++) {
            rawArgs[_key24 - 2] = arguments[_key24];
          }
          var args = rawArgs;
          var isModelListener2 = event.startsWith("update:");
          var modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
          if (modifiers) {
            if (modifiers.trim) {
              args = rawArgs.map(function (a) {
                return isString$1(a) ? a.trim() : a;
              });
            }
            if (modifiers.number) {
              args = rawArgs.map(looseToNumber);
            }
          }
          var handlerName;
          var handler = props[handlerName = toHandlerKey(event)] ||
          // also try camelCase event handler (#2249)
          props[handlerName = toHandlerKey(camelize(event))];
          if (!handler && isModelListener2) {
            handler = props[handlerName = toHandlerKey(hyphenate(event))];
          }
          if (handler) {
            callWithAsyncErrorHandling(handler, instance, 6, args);
          }
          var onceHandler = props[handlerName + "Once"];
          if (onceHandler) {
            if (!instance.emitted) {
              instance.emitted = {};
            } else if (instance.emitted[handlerName]) {
              return;
            }
            instance.emitted[handlerName] = true;
            callWithAsyncErrorHandling(onceHandler, instance, 6, args);
          }
        }
        function normalizeEmitsOptions(comp, appContext) {
          var asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var cache = appContext.emitsCache;
          var cached = cache.get(comp);
          if (cached !== void 0) {
            return cached;
          }
          var raw = comp.emits;
          var normalized = {};
          var hasExtends = false;
          if (!isFunction$1(comp)) {
            var extendEmits = function extendEmits(raw2) {
              var normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
              if (normalizedFromExtend) {
                hasExtends = true;
                extend(normalized, normalizedFromExtend);
              }
            };
            if (!asMixin && appContext.mixins.length) {
              appContext.mixins.forEach(extendEmits);
            }
            if (comp.extends) {
              extendEmits(comp.extends);
            }
            if (comp.mixins) {
              comp.mixins.forEach(extendEmits);
            }
          }
          if (!raw && !hasExtends) {
            if (isObject$2(comp)) {
              cache.set(comp, null);
            }
            return null;
          }
          if (isArray$2(raw)) {
            raw.forEach(function (key) {
              return normalized[key] = null;
            });
          } else {
            extend(normalized, raw);
          }
          if (isObject$2(comp)) {
            cache.set(comp, normalized);
          }
          return normalized;
        }
        function isEmitListener(options, key) {
          if (!options || !isOn(key)) {
            return false;
          }
          key = key.slice(2).replace(/Once$/, "");
          return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
        }
        function markAttrsAccessed() {}
        function renderComponentRoot(instance) {
          var Component = instance.type,
            vnode = instance.vnode,
            proxy = instance.proxy,
            withProxy = instance.withProxy,
            _instance$propsOption3 = _slicedToArray(instance.propsOptions, 1),
            propsOptions = _instance$propsOption3[0],
            slots = instance.slots,
            attrs = instance.attrs,
            emit2 = instance.emit,
            render = instance.render,
            renderCache = instance.renderCache,
            props = instance.props,
            data = instance.data,
            setupState = instance.setupState,
            ctx = instance.ctx,
            inheritAttrs = instance.inheritAttrs;
          var prev = setCurrentRenderingInstance(instance);
          var result;
          var fallthroughAttrs;
          try {
            if (vnode.shapeFlag & 4) {
              var proxyToUse = withProxy || proxy;
              var thisProxy = false ? new Proxy(proxyToUse, {
                get: function get(target, key, receiver) {
                  warn$1("Property '".concat(String(key), "' was accessed via 'this'. Avoid using 'this' in templates."));
                  return Reflect.get(target, key, receiver);
                }
              }) : proxyToUse;
              result = normalizeVNode(render.call(thisProxy, proxyToUse, renderCache, false ? shallowReadonly(props) : props, setupState, data, ctx));
              fallthroughAttrs = attrs;
            } else {
              var render2 = Component;
              if (false) ;
              result = normalizeVNode(render2.length > 1 ? render2(false ? shallowReadonly(props) : props, false ? {
                get attrs() {
                  markAttrsAccessed();
                  return shallowReadonly(attrs);
                },
                slots: slots,
                emit: emit2
              } : {
                attrs: attrs,
                slots: slots,
                emit: emit2
              }) : render2(false ? shallowReadonly(props) : props, null));
              fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
            }
          } catch (err) {
            blockStack.length = 0;
            handleError(err, instance, 1);
            result = createVNode(Comment);
          }
          var root = result;
          if (fallthroughAttrs && inheritAttrs !== false) {
            var keys = Object.keys(fallthroughAttrs);
            var _root = root,
              shapeFlag = _root.shapeFlag;
            if (keys.length) {
              if (shapeFlag & (1 | 6)) {
                if (propsOptions && keys.some(isModelListener)) {
                  fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                }
                root = cloneVNode(root, fallthroughAttrs, false, true);
              }
            }
          }
          if (vnode.dirs) {
            root = cloneVNode(root, null, false, true);
            root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
          }
          if (vnode.transition) {
            setTransitionHooks(root, vnode.transition);
          }
          {
            result = root;
          }
          setCurrentRenderingInstance(prev);
          return result;
        }
        function filterSingleRoot(children) {
          var recurse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var singleRoot;
          for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (isVNode$1(child)) {
              if (child.type !== Comment || child.children === "v-if") {
                if (singleRoot) {
                  return;
                } else {
                  singleRoot = child;
                }
              }
            } else {
              return;
            }
          }
          return singleRoot;
        }
        var getFunctionalFallthrough = function getFunctionalFallthrough(attrs) {
          var res;
          for (var key in attrs) {
            if (key === "class" || key === "style" || isOn(key)) {
              (res || (res = {}))[key] = attrs[key];
            }
          }
          return res;
        };
        var filterModelListeners = function filterModelListeners(attrs, props) {
          var res = {};
          for (var key in attrs) {
            if (!isModelListener(key) || !(key.slice(9) in props)) {
              res[key] = attrs[key];
            }
          }
          return res;
        };
        function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
          var prevProps = prevVNode.props,
            prevChildren = prevVNode.children,
            component = prevVNode.component;
          var nextProps = nextVNode.props,
            nextChildren = nextVNode.children,
            patchFlag = nextVNode.patchFlag;
          var emits = component.emitsOptions;
          if (nextVNode.dirs || nextVNode.transition) {
            return true;
          }
          if (optimized && patchFlag >= 0) {
            if (patchFlag & 1024) {
              return true;
            }
            if (patchFlag & 16) {
              if (!prevProps) {
                return !!nextProps;
              }
              return hasPropsChanged(prevProps, nextProps, emits);
            } else if (patchFlag & 8) {
              var dynamicProps = nextVNode.dynamicProps;
              for (var i = 0; i < dynamicProps.length; i++) {
                var key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                  return true;
                }
              }
            }
          } else {
            if (prevChildren || nextChildren) {
              if (!nextChildren || !nextChildren.$stable) {
                return true;
              }
            }
            if (prevProps === nextProps) {
              return false;
            }
            if (!prevProps) {
              return !!nextProps;
            }
            if (!nextProps) {
              return true;
            }
            return hasPropsChanged(prevProps, nextProps, emits);
          }
          return false;
        }
        function hasPropsChanged(prevProps, nextProps, emitsOptions) {
          var nextKeys = Object.keys(nextProps);
          if (nextKeys.length !== Object.keys(prevProps).length) {
            return true;
          }
          for (var i = 0; i < nextKeys.length; i++) {
            var key = nextKeys[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
              return true;
            }
          }
          return false;
        }
        function updateHOCHostEl(_ref25, el) {
          var vnode = _ref25.vnode,
            parent = _ref25.parent;
          while (parent) {
            var root = parent.subTree;
            if (root.suspense && root.suspense.activeBranch === vnode) {
              root.el = vnode.el;
            }
            if (root === vnode) {
              (vnode = parent.vnode).el = el;
              parent = parent.parent;
            } else {
              break;
            }
          }
        }
        var isSuspense = function isSuspense(type) {
          return type.__isSuspense;
        };
        var suspenseId = 0;
        var SuspenseImpl = {
          name: "Suspense",
          // In order to make Suspense tree-shakable, we need to avoid importing it
          // directly in the renderer. The renderer checks for the __isSuspense flag
          // on a vnode's type and calls the `process` method, passing in renderer
          // internals.
          __isSuspense: true,
          process: function process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
            if (n1 == null) {
              mountSuspense(n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals);
            } else {
              if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
                n2.suspense = n1.suspense;
                n2.suspense.vnode = n2;
                n2.el = n1.el;
                return;
              }
              patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, rendererInternals);
            }
          },
          hydrate: hydrateSuspense,
          normalize: normalizeSuspenseChildren
        };
        var Suspense = SuspenseImpl;
        function triggerEvent(vnode, name) {
          var eventListener = vnode.props && vnode.props[name];
          if (isFunction$1(eventListener)) {
            eventListener();
          }
        }
        function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
          var patch = rendererInternals.p,
            createElement = rendererInternals.o.createElement;
          var hiddenContainer = createElement("div");
          var suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals);
          patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds);
          if (suspense.deps > 0) {
            triggerEvent(vnode, "onPending");
            triggerEvent(vnode, "onFallback");
            patch(null, vnode.ssFallback, container, anchor, parentComponent, null,
            // fallback tree will not have suspense context
            namespace, slotScopeIds);
            setActiveBranch(suspense, vnode.ssFallback);
          } else {
            suspense.resolve(false, true);
          }
        }
        function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, _ref26) {
          var patch = _ref26.p,
            unmount = _ref26.um,
            createElement = _ref26.o.createElement;
          var suspense = n2.suspense = n1.suspense;
          suspense.vnode = n2;
          n2.el = n1.el;
          var newBranch = n2.ssContent;
          var newFallback = n2.ssFallback;
          var activeBranch = suspense.activeBranch,
            pendingBranch = suspense.pendingBranch,
            isInFallback = suspense.isInFallback,
            isHydrating = suspense.isHydrating;
          if (pendingBranch) {
            suspense.pendingBranch = newBranch;
            if (isSameVNodeType(newBranch, pendingBranch)) {
              patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
              if (suspense.deps <= 0) {
                suspense.resolve();
              } else if (isInFallback) {
                if (!isHydrating) {
                  patch(activeBranch, newFallback, container, anchor, parentComponent, null,
                  // fallback tree will not have suspense context
                  namespace, slotScopeIds, optimized);
                  setActiveBranch(suspense, newFallback);
                }
              }
            } else {
              suspense.pendingId = suspenseId++;
              if (isHydrating) {
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
              } else {
                unmount(pendingBranch, parentComponent, suspense);
              }
              suspense.deps = 0;
              suspense.effects.length = 0;
              suspense.hiddenContainer = createElement("div");
              if (isInFallback) {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                  suspense.resolve();
                } else {
                  patch(activeBranch, newFallback, container, anchor, parentComponent, null,
                  // fallback tree will not have suspense context
                  namespace, slotScopeIds, optimized);
                  setActiveBranch(suspense, newFallback);
                }
              } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, namespace, slotScopeIds, optimized);
                suspense.resolve(true);
              } else {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                  suspense.resolve();
                }
              }
            }
          } else {
            if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
              patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, namespace, slotScopeIds, optimized);
              setActiveBranch(suspense, newBranch);
            } else {
              triggerEvent(n2, "onPending");
              suspense.pendingBranch = newBranch;
              if (newBranch.shapeFlag & 512) {
                suspense.pendingId = newBranch.component.suspenseId;
              } else {
                suspense.pendingId = suspenseId++;
              }
              patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
              if (suspense.deps <= 0) {
                suspense.resolve();
              } else {
                var timeout = suspense.timeout,
                  pendingId = suspense.pendingId;
                if (timeout > 0) {
                  setTimeout(function () {
                    if (suspense.pendingId === pendingId) {
                      suspense.fallback(newFallback);
                    }
                  }, timeout);
                } else if (timeout === 0) {
                  suspense.fallback(newFallback);
                }
              }
            }
          }
        }
        function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals) {
          var isHydrating = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;
          var patch = rendererInternals.p,
            _move2 = rendererInternals.m,
            _unmount2 = rendererInternals.um,
            _next2 = rendererInternals.n,
            _rendererInternals$o2 = rendererInternals.o,
            parentNode = _rendererInternals$o2.parentNode,
            remove2 = _rendererInternals$o2.remove;
          var parentSuspenseId;
          var isSuspensible = isVNodeSuspensible(vnode);
          if (isSuspensible) {
            if (parentSuspense && parentSuspense.pendingBranch) {
              parentSuspenseId = parentSuspense.pendingId;
              parentSuspense.deps++;
            }
          }
          var timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
          var initialAnchor = anchor;
          var suspense = {
            vnode: vnode,
            parent: parentSuspense,
            parentComponent: parentComponent,
            namespace: namespace,
            container: container,
            hiddenContainer: hiddenContainer,
            deps: 0,
            pendingId: suspenseId++,
            timeout: typeof timeout === "number" ? timeout : -1,
            activeBranch: null,
            pendingBranch: null,
            isInFallback: !isHydrating,
            isHydrating: isHydrating,
            isUnmounted: false,
            effects: [],
            resolve: function resolve() {
              var resume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              var vnode2 = suspense.vnode,
                activeBranch = suspense.activeBranch,
                pendingBranch = suspense.pendingBranch,
                pendingId = suspense.pendingId,
                effects = suspense.effects,
                parentComponent2 = suspense.parentComponent,
                container2 = suspense.container;
              var delayEnter = false;
              if (suspense.isHydrating) {
                suspense.isHydrating = false;
              } else if (!resume) {
                delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
                if (delayEnter) {
                  activeBranch.transition.afterLeave = function () {
                    if (pendingId === suspense.pendingId) {
                      _move2(pendingBranch, container2, anchor === initialAnchor ? _next2(activeBranch) : anchor, 0);
                      queuePostFlushCb(effects);
                    }
                  };
                }
                if (activeBranch) {
                  if (parentNode(activeBranch.el) === container2) {
                    anchor = _next2(activeBranch);
                  }
                  _unmount2(activeBranch, parentComponent2, suspense, true);
                }
                if (!delayEnter) {
                  _move2(pendingBranch, container2, anchor, 0);
                }
              }
              setActiveBranch(suspense, pendingBranch);
              suspense.pendingBranch = null;
              suspense.isInFallback = false;
              var parent = suspense.parent;
              var hasUnresolvedAncestor = false;
              while (parent) {
                if (parent.pendingBranch) {
                  var _parent$effects;
                  (_parent$effects = parent.effects).push.apply(_parent$effects, _toConsumableArray(effects));
                  hasUnresolvedAncestor = true;
                  break;
                }
                parent = parent.parent;
              }
              if (!hasUnresolvedAncestor && !delayEnter) {
                queuePostFlushCb(effects);
              }
              suspense.effects = [];
              if (isSuspensible) {
                if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
                  parentSuspense.deps--;
                  if (parentSuspense.deps === 0 && !sync) {
                    parentSuspense.resolve();
                  }
                }
              }
              triggerEvent(vnode2, "onResolve");
            },
            fallback: function fallback(fallbackVNode) {
              if (!suspense.pendingBranch) {
                return;
              }
              var vnode2 = suspense.vnode,
                activeBranch = suspense.activeBranch,
                parentComponent2 = suspense.parentComponent,
                container2 = suspense.container,
                namespace2 = suspense.namespace;
              triggerEvent(vnode2, "onFallback");
              var anchor2 = _next2(activeBranch);
              var mountFallback = function mountFallback() {
                if (!suspense.isInFallback) {
                  return;
                }
                patch(null, fallbackVNode, container2, anchor2, parentComponent2, null,
                // fallback tree will not have suspense context
                namespace2, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
              };
              var delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
              if (delayEnter) {
                activeBranch.transition.afterLeave = mountFallback;
              }
              suspense.isInFallback = true;
              _unmount2(activeBranch, parentComponent2, null,
              // no suspense so unmount hooks fire now
              true
              // shouldRemove
              );
              if (!delayEnter) {
                mountFallback();
              }
            },
            move: function move(container2, anchor2, type) {
              suspense.activeBranch && _move2(suspense.activeBranch, container2, anchor2, type);
              suspense.container = container2;
            },
            next: function next() {
              return suspense.activeBranch && _next2(suspense.activeBranch);
            },
            registerDep: function registerDep(instance, setupRenderEffect, optimized2) {
              var isInPendingSuspense = !!suspense.pendingBranch;
              if (isInPendingSuspense) {
                suspense.deps++;
              }
              var hydratedEl = instance.vnode.el;
              instance.asyncDep.catch(function (err) {
                handleError(err, instance, 0);
              }).then(function (asyncSetupResult) {
                if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
                  return;
                }
                instance.asyncResolved = true;
                var vnode2 = instance.vnode;
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) {
                  vnode2.el = hydratedEl;
                }
                var placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode2,
                // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el),
                // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : _next2(instance.subTree), suspense, namespace, optimized2);
                if (placeholder) {
                  remove2(placeholder);
                }
                updateHOCHostEl(instance, vnode2.el);
                if (isInPendingSuspense && --suspense.deps === 0) {
                  suspense.resolve();
                }
              });
            },
            unmount: function unmount(parentSuspense2, doRemove) {
              suspense.isUnmounted = true;
              if (suspense.activeBranch) {
                _unmount2(suspense.activeBranch, parentComponent, parentSuspense2, doRemove);
              }
              if (suspense.pendingBranch) {
                _unmount2(suspense.pendingBranch, parentComponent, parentSuspense2, doRemove);
              }
            }
          };
          return suspense;
        }
        function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
          var suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode,
          // eslint-disable-next-line no-restricted-globals
          document.createElement("div"), null, namespace, slotScopeIds, optimized, rendererInternals, true);
          var result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
          if (suspense.deps === 0) {
            suspense.resolve(false, true);
          }
          return result;
        }
        function normalizeSuspenseChildren(vnode) {
          var shapeFlag = vnode.shapeFlag,
            children = vnode.children;
          var isSlotChildren = shapeFlag & 32;
          vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
          vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
        }
        function normalizeSuspenseSlot(s) {
          var block;
          if (isFunction$1(s)) {
            var trackBlock = isBlockTreeEnabled && s._c;
            if (trackBlock) {
              s._d = false;
              openBlock();
            }
            s = s();
            if (trackBlock) {
              s._d = true;
              block = currentBlock;
              closeBlock();
            }
          }
          if (isArray$2(s)) {
            var singleChild = filterSingleRoot(s);
            s = singleChild;
          }
          s = normalizeVNode(s);
          if (block && !s.dynamicChildren) {
            s.dynamicChildren = block.filter(function (c) {
              return c !== s;
            });
          }
          return s;
        }
        function queueEffectWithSuspense(fn, suspense) {
          if (suspense && suspense.pendingBranch) {
            if (isArray$2(fn)) {
              var _suspense$effects;
              (_suspense$effects = suspense.effects).push.apply(_suspense$effects, _toConsumableArray(fn));
            } else {
              suspense.effects.push(fn);
            }
          } else {
            queuePostFlushCb(fn);
          }
        }
        function setActiveBranch(suspense, branch) {
          suspense.activeBranch = branch;
          var vnode = suspense.vnode,
            parentComponent = suspense.parentComponent;
          var el = branch.el;
          while (!el && branch.component) {
            branch = branch.component.subTree;
            el = branch.el;
          }
          vnode.el = el;
          if (parentComponent && parentComponent.subTree === vnode) {
            parentComponent.vnode.el = el;
            updateHOCHostEl(parentComponent, el);
          }
        }
        function isVNodeSuspensible(vnode) {
          var suspensible = vnode.props && vnode.props.suspensible;
          return suspensible != null && suspensible !== false;
        }
        var Fragment = exports("F", Symbol.for("v-fgt"));
        var Text = Symbol.for("v-txt");
        var Comment = Symbol.for("v-cmt");
        var Static = Symbol.for("v-stc");
        var blockStack = [];
        var currentBlock = null;
        function openBlock() {
          var disableTracking = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          blockStack.push(currentBlock = disableTracking ? null : []);
        }
        function closeBlock() {
          blockStack.pop();
          currentBlock = blockStack[blockStack.length - 1] || null;
        }
        var isBlockTreeEnabled = 1;
        function setBlockTracking(value) {
          var inVOnce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          isBlockTreeEnabled += value;
          if (value < 0 && currentBlock && inVOnce) {
            currentBlock.hasOnce = true;
          }
        }
        function setupBlock(vnode) {
          vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
          closeBlock();
          if (isBlockTreeEnabled > 0 && currentBlock) {
            currentBlock.push(vnode);
          }
          return vnode;
        }
        function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
          return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
        }
        function createBlock(type, props, children, patchFlag, dynamicProps) {
          return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
        }
        function isVNode$1(value) {
          return value ? value.__v_isVNode === true : false;
        }
        function isSameVNodeType(n1, n2) {
          return n1.type === n2.type && n1.key === n2.key;
        }
        function transformVNodeArgs(transformer) {}
        var normalizeKey = function normalizeKey(_ref27) {
          var key = _ref27.key;
          return key != null ? key : null;
        };
        var normalizeRef = function normalizeRef(_ref28) {
          var ref3 = _ref28.ref,
            ref_key = _ref28.ref_key,
            ref_for = _ref28.ref_for;
          if (typeof ref3 === "number") {
            ref3 = "" + ref3;
          }
          return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$1(ref3) ? {
            i: currentRenderingInstance,
            r: ref3,
            k: ref_key,
            f: !!ref_for
          } : ref3 : null;
        };
        function createBaseVNode(type) {
          var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var patchFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
          var dynamicProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var shapeFlag = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : type === Fragment ? 0 : 1;
          var isBlockNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
          var needFullChildrenNormalization = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
          var vnode = {
            __v_isVNode: true,
            __v_skip: true,
            type: type,
            props: props,
            key: props && normalizeKey(props),
            ref: props && normalizeRef(props),
            scopeId: currentScopeId,
            slotScopeIds: null,
            children: children,
            component: null,
            suspense: null,
            ssContent: null,
            ssFallback: null,
            dirs: null,
            transition: null,
            el: null,
            anchor: null,
            target: null,
            targetStart: null,
            targetAnchor: null,
            staticCount: 0,
            shapeFlag: shapeFlag,
            patchFlag: patchFlag,
            dynamicProps: dynamicProps,
            dynamicChildren: null,
            appContext: null,
            ctx: currentRenderingInstance
          };
          if (needFullChildrenNormalization) {
            normalizeChildren(vnode, children);
            if (shapeFlag & 128) {
              type.normalize(vnode);
            }
          } else if (children) {
            vnode.shapeFlag |= isString$1(children) ? 8 : 16;
          }
          if (isBlockTreeEnabled > 0 &&
          // avoid a block node from tracking itself
          !isBlockNode &&
          // has current parent block
          currentBlock && (
          // presence of a patch flag indicates this node needs patching on updates.
          // component nodes also should always be patched, because even if the
          // component doesn't need to update, it needs to persist the instance on to
          // the next vnode so that it can be properly unmounted later.
          vnode.patchFlag > 0 || shapeFlag & 6) &&
          // the EVENTS flag is only for hydration and if it is the only flag, the
          // vnode should not be considered dynamic due to handler caching.
          vnode.patchFlag !== 32) {
            currentBlock.push(vnode);
          }
          return vnode;
        }
        var createVNode = exports("e", _createVNode);
        function _createVNode(type) {
          var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var patchFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
          var dynamicProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var isBlockNode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
          if (!type || type === NULL_DYNAMIC_COMPONENT) {
            type = Comment;
          }
          if (isVNode$1(type)) {
            var cloned = cloneVNode(type, props, true
            /* mergeRef: true */);
            if (children) {
              normalizeChildren(cloned, children);
            }
            if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
              if (cloned.shapeFlag & 6) {
                currentBlock[currentBlock.indexOf(type)] = cloned;
              } else {
                currentBlock.push(cloned);
              }
            }
            cloned.patchFlag = -2;
            return cloned;
          }
          if (isClassComponent(type)) {
            type = type.__vccOpts;
          }
          if (props) {
            props = guardReactiveProps(props);
            var _props2 = props,
              klass = _props2.class,
              style = _props2.style;
            if (klass && !isString$1(klass)) {
              props.class = normalizeClass(klass);
            }
            if (isObject$2(style)) {
              if (isProxy(style) && !isArray$2(style)) {
                style = extend({}, style);
              }
              props.style = normalizeStyle(style);
            }
          }
          var shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$1(type) ? 2 : 0;
          return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
        }
        function guardReactiveProps(props) {
          if (!props) return null;
          return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
        }
        function cloneVNode(vnode, extraProps) {
          var mergeRef = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var cloneTransition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var props = vnode.props,
            ref3 = vnode.ref,
            patchFlag = vnode.patchFlag,
            children = vnode.children,
            transition = vnode.transition;
          var mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
          var cloned = {
            __v_isVNode: true,
            __v_skip: true,
            type: vnode.type,
            props: mergedProps,
            key: mergedProps && normalizeKey(mergedProps),
            ref: extraProps && extraProps.ref ?
            // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref3,
            scopeId: vnode.scopeId,
            slotScopeIds: vnode.slotScopeIds,
            children: children,
            target: vnode.target,
            targetStart: vnode.targetStart,
            targetAnchor: vnode.targetAnchor,
            staticCount: vnode.staticCount,
            shapeFlag: vnode.shapeFlag,
            // if the vnode is cloned with extra props, we can no longer assume its
            // existing patch flag to be reliable and need to add the FULL_PROPS flag.
            // note: preserve flag for fragments since they use the flag for children
            // fast paths only.
            patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
            dynamicProps: vnode.dynamicProps,
            dynamicChildren: vnode.dynamicChildren,
            appContext: vnode.appContext,
            dirs: vnode.dirs,
            transition: transition,
            // These should technically only be non-null on mounted VNodes. However,
            // they *should* be copied for kept-alive vnodes. So we just always copy
            // them since them being non-null during a mount doesn't affect the logic as
            // they will simply be overwritten.
            component: vnode.component,
            suspense: vnode.suspense,
            ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
            ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
            el: vnode.el,
            anchor: vnode.anchor,
            ctx: vnode.ctx,
            ce: vnode.ce
          };
          if (transition && cloneTransition) {
            setTransitionHooks(cloned, transition.clone(cloned));
          }
          return cloned;
        }
        function createTextVNode() {
          var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : " ";
          var flag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          return createVNode(Text, null, text, flag);
        }
        function createStaticVNode(content, numberOfNodes) {
          var vnode = createVNode(Static, null, content);
          vnode.staticCount = numberOfNodes;
          return vnode;
        }
        function createCommentVNode() {
          var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
          var asBlock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
        }
        function normalizeVNode(child) {
          if (child == null || typeof child === "boolean") {
            return createVNode(Comment);
          } else if (isArray$2(child)) {
            return createVNode(Fragment, null,
            // #3666, avoid reference pollution when reusing vnode
            child.slice());
          } else if (isVNode$1(child)) {
            return cloneIfMounted(child);
          } else {
            return createVNode(Text, null, String(child));
          }
        }
        function cloneIfMounted(child) {
          return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
        }
        function normalizeChildren(vnode, children) {
          var type = 0;
          var shapeFlag = vnode.shapeFlag;
          if (children == null) {
            children = null;
          } else if (isArray$2(children)) {
            type = 16;
          } else if (_typeof2(children) === "object") {
            if (shapeFlag & (1 | 64)) {
              var slot = children.default;
              if (slot) {
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
              }
              return;
            } else {
              type = 32;
              var slotFlag = children._;
              if (!slotFlag && !isInternalObject(children)) {
                children._ctx = currentRenderingInstance;
              } else if (slotFlag === 3 && currentRenderingInstance) {
                if (currentRenderingInstance.slots._ === 1) {
                  children._ = 1;
                } else {
                  children._ = 2;
                  vnode.patchFlag |= 1024;
                }
              }
            }
          } else if (isFunction$1(children)) {
            children = {
              default: children,
              _ctx: currentRenderingInstance
            };
            type = 32;
          } else {
            children = String(children);
            if (shapeFlag & 64) {
              type = 16;
              children = [createTextVNode(children)];
            } else {
              type = 8;
            }
          }
          vnode.children = children;
          vnode.shapeFlag |= type;
        }
        function mergeProps() {
          var ret = {};
          for (var i = 0; i < arguments.length; i++) {
            var toMerge = i < 0 || arguments.length <= i ? undefined : arguments[i];
            for (var key in toMerge) {
              if (key === "class") {
                if (ret.class !== toMerge.class) {
                  ret.class = normalizeClass([ret.class, toMerge.class]);
                }
              } else if (key === "style") {
                ret.style = normalizeStyle([ret.style, toMerge.style]);
              } else if (isOn(key)) {
                var existing = ret[key];
                var incoming = toMerge[key];
                if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
                  ret[key] = existing ? [].concat(existing, incoming) : incoming;
                }
              } else if (key !== "") {
                ret[key] = toMerge[key];
              }
            }
          }
          return ret;
        }
        function invokeVNodeHook(hook, instance, vnode) {
          var prevVNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          callWithAsyncErrorHandling(hook, instance, 7, [vnode, prevVNode]);
        }
        var emptyAppContext = createAppContext();
        var uid = 0;
        function createComponentInstance(vnode, parent, suspense) {
          var type = vnode.type;
          var appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
          var instance = {
            uid: uid++,
            vnode: vnode,
            type: type,
            parent: parent,
            appContext: appContext,
            root: null,
            // to be immediately set
            next: null,
            subTree: null,
            // will be set synchronously right after creation
            effect: null,
            update: null,
            // will be set synchronously right after creation
            job: null,
            scope: new EffectScope(true
            /* detached */),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: parent ? parent.provides : Object.create(appContext.provides),
            ids: parent ? parent.ids : ["", 0, 0],
            accessCache: null,
            renderCache: [],
            // local resolved assets
            components: null,
            directives: null,
            // resolved props and emits options
            propsOptions: normalizePropsOptions(type, appContext),
            emitsOptions: normalizeEmitsOptions(type, appContext),
            // emit
            emit: null,
            // to be set immediately
            emitted: null,
            // props default value
            propsDefaults: EMPTY_OBJ,
            // inheritAttrs
            inheritAttrs: type.inheritAttrs,
            // state
            ctx: EMPTY_OBJ,
            data: EMPTY_OBJ,
            props: EMPTY_OBJ,
            attrs: EMPTY_OBJ,
            slots: EMPTY_OBJ,
            refs: EMPTY_OBJ,
            setupState: EMPTY_OBJ,
            setupContext: null,
            // suspense related
            suspense: suspense,
            suspenseId: suspense ? suspense.pendingId : 0,
            asyncDep: null,
            asyncResolved: false,
            // lifecycle hooks
            // not using enums here because it results in computed properties
            isMounted: false,
            isUnmounted: false,
            isDeactivated: false,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
          };
          {
            instance.ctx = {
              _: instance
            };
          }
          instance.root = parent ? parent.root : instance;
          instance.emit = emit.bind(null, instance);
          if (vnode.ce) {
            vnode.ce(instance);
          }
          return instance;
        }
        var currentInstance = null;
        var getCurrentInstance = exports("R", function () {
          return currentInstance || currentRenderingInstance;
        });
        var internalSetCurrentInstance;
        var setInSSRSetupState;
        {
          var g = getGlobalThis$1();
          var registerGlobalSetter = function registerGlobalSetter(key, setter) {
            var setters;
            if (!(setters = g[key])) setters = g[key] = [];
            setters.push(setter);
            return function (v) {
              if (setters.length > 1) setters.forEach(function (set) {
                return set(v);
              });else setters[0](v);
            };
          };
          internalSetCurrentInstance = registerGlobalSetter("__VUE_INSTANCE_SETTERS__", function (v) {
            return currentInstance = v;
          });
          setInSSRSetupState = registerGlobalSetter("__VUE_SSR_SETTERS__", function (v) {
            return isInSSRComponentSetup = v;
          });
        }
        var setCurrentInstance = function setCurrentInstance(instance) {
          var prev = currentInstance;
          internalSetCurrentInstance(instance);
          instance.scope.on();
          return function () {
            instance.scope.off();
            internalSetCurrentInstance(prev);
          };
        };
        var unsetCurrentInstance = function unsetCurrentInstance() {
          currentInstance && currentInstance.scope.off();
          internalSetCurrentInstance(null);
        };
        function isStatefulComponent(instance) {
          return instance.vnode.shapeFlag & 4;
        }
        var isInSSRComponentSetup = false;
        function setupComponent(instance) {
          var isSSR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var optimized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          isSSR && setInSSRSetupState(isSSR);
          var _instance$vnode = instance.vnode,
            props = _instance$vnode.props,
            children = _instance$vnode.children;
          var isStateful = isStatefulComponent(instance);
          initProps(instance, props, isStateful, isSSR);
          initSlots(instance, children, optimized);
          var setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
          isSSR && setInSSRSetupState(false);
          return setupResult;
        }
        function setupStatefulComponent(instance, isSSR) {
          var Component = instance.type;
          instance.accessCache = /* @__PURE__ */Object.create(null);
          instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
          var setup = Component.setup;
          if (setup) {
            pauseTracking();
            var setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
            var reset = setCurrentInstance(instance);
            var setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
            var isAsyncSetup = isPromise$1(setupResult);
            resetTracking();
            reset();
            if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
              markAsyncBoundary(instance);
            }
            if (isAsyncSetup) {
              setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
              if (isSSR) {
                return setupResult.then(function (resolvedResult) {
                  handleSetupResult(instance, resolvedResult, isSSR);
                }).catch(function (e) {
                  handleError(e, instance, 0);
                });
              } else {
                instance.asyncDep = setupResult;
              }
            } else {
              handleSetupResult(instance, setupResult, isSSR);
            }
          } else {
            finishComponentSetup(instance, isSSR);
          }
        }
        function handleSetupResult(instance, setupResult, isSSR) {
          if (isFunction$1(setupResult)) {
            if (instance.type.__ssrInlineRender) {
              instance.ssrRender = setupResult;
            } else {
              instance.render = setupResult;
            }
          } else if (isObject$2(setupResult)) {
            instance.setupState = proxyRefs(setupResult);
          } else ;
          finishComponentSetup(instance, isSSR);
        }
        var compile$2;
        var installWithProxy;
        function registerRuntimeCompiler(_compile) {
          compile$2 = _compile;
          installWithProxy = function installWithProxy(i) {
            if (i.render._rc) {
              i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
            }
          };
        }
        var isRuntimeOnly = function isRuntimeOnly() {
          return !compile$2;
        };
        function finishComponentSetup(instance, isSSR, skipOptions) {
          var Component = instance.type;
          if (!instance.render) {
            if (!isSSR && compile$2 && !Component.render) {
              var template = Component.template || resolveMergedOptions(instance).template;
              if (template) {
                var _instance$appContext$ = instance.appContext.config,
                  isCustomElement = _instance$appContext$.isCustomElement,
                  compilerOptions = _instance$appContext$.compilerOptions;
                var delimiters = Component.delimiters,
                  componentCompilerOptions = Component.compilerOptions;
                var finalCompilerOptions = extend(extend({
                  isCustomElement: isCustomElement,
                  delimiters: delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile$2(template, finalCompilerOptions);
              }
            }
            instance.render = Component.render || NOOP;
            if (installWithProxy) {
              installWithProxy(instance);
            }
          }
          {
            var reset = setCurrentInstance(instance);
            pauseTracking();
            try {
              applyOptions(instance);
            } finally {
              resetTracking();
              reset();
            }
          }
        }
        var attrsProxyHandlers = {
          get: function get(target, key) {
            track(target, "get", "");
            return target[key];
          }
        };
        function createSetupContext(instance) {
          var expose = function expose(exposed) {
            instance.exposed = exposed || {};
          };
          {
            return {
              attrs: new Proxy(instance.attrs, attrsProxyHandlers),
              slots: instance.slots,
              emit: instance.emit,
              expose: expose
            };
          }
        }
        function getComponentPublicInstance(instance) {
          if (instance.exposed) {
            return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
              get: function get(target, key) {
                if (key in target) {
                  return target[key];
                } else if (key in publicPropertiesMap) {
                  return publicPropertiesMap[key](instance);
                }
              },
              has: function has(target, key) {
                return key in target || key in publicPropertiesMap;
              }
            }));
          } else {
            return instance.proxy;
          }
        }
        var classifyRE = /(?:^|[-_])(\w)/g;
        var classify = function classify(str) {
          return str.replace(classifyRE, function (c) {
            return c.toUpperCase();
          }).replace(/[-_]/g, "");
        };
        function getComponentName(Component) {
          var includeInferred = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
        }
        function formatComponentName(instance, Component) {
          var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var name = getComponentName(Component);
          if (!name && Component.__file) {
            var match = Component.__file.match(/([^/\\]+)\.\w+$/);
            if (match) {
              name = match[1];
            }
          }
          if (!name && instance && instance.parent) {
            var inferFromRegistry = function inferFromRegistry(registry) {
              for (var key in registry) {
                if (registry[key] === Component) {
                  return key;
                }
              }
            };
            name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
          }
          return name ? classify(name) : isRoot ? "App" : "Anonymous";
        }
        function isClassComponent(value) {
          return isFunction$1(value) && "__vccOpts" in value;
        }
        var computed = exports("A", function (getterOrOptions, debugOptions) {
          var c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
          return c;
        });
        function h(type, propsOrChildren, children) {
          var l = arguments.length;
          if (l === 2) {
            if (isObject$2(propsOrChildren) && !isArray$2(propsOrChildren)) {
              if (isVNode$1(propsOrChildren)) {
                return createVNode(type, null, [propsOrChildren]);
              }
              return createVNode(type, propsOrChildren);
            } else {
              return createVNode(type, null, propsOrChildren);
            }
          } else {
            if (l > 3) {
              children = Array.prototype.slice.call(arguments, 2);
            } else if (l === 3 && isVNode$1(children)) {
              children = [children];
            }
            return createVNode(type, propsOrChildren, children);
          }
        }
        function initCustomFormatter() {
          {
            return;
          }
        }
        function withMemo(memo, render, cache, index) {
          var cached = cache[index];
          if (cached && isMemoSame(cached, memo)) {
            return cached;
          }
          var ret = render();
          ret.memo = memo.slice();
          ret.cacheIndex = index;
          return cache[index] = ret;
        }
        function isMemoSame(cached, memo) {
          var prev = cached.memo;
          if (prev.length != memo.length) {
            return false;
          }
          for (var i = 0; i < prev.length; i++) {
            if (hasChanged(prev[i], memo[i])) {
              return false;
            }
          }
          if (isBlockTreeEnabled > 0 && currentBlock) {
            currentBlock.push(cached);
          }
          return true;
        }
        var version = "3.5.13";
        var warn$2 = NOOP;
        var ErrorTypeStrings = ErrorTypeStrings$1;
        var devtools$2 = devtools$1;
        var setDevtoolsHook = setDevtoolsHook$1;
        var _ssrUtils = {
          createComponentInstance: createComponentInstance,
          setupComponent: setupComponent,
          renderComponentRoot: renderComponentRoot,
          setCurrentRenderingInstance: setCurrentRenderingInstance,
          isVNode: isVNode$1,
          normalizeVNode: normalizeVNode,
          getComponentPublicInstance: getComponentPublicInstance,
          ensureValidVNode: ensureValidVNode,
          pushWarningContext: pushWarningContext,
          popWarningContext: popWarningContext
        };
        var ssrUtils = _ssrUtils;
        var resolveFilter = null;
        var compatUtils = null;
        var DeprecationTypes = null;

        /**
        * @vue/runtime-dom v3.5.13
        * (c) 2018-present Yuxi (Evan) You and Vue contributors
        * @license MIT
        **/
        var policy = void 0;
        var tt = typeof window !== "undefined" && window.trustedTypes;
        if (tt) {
          try {
            policy = /* @__PURE__ */tt.createPolicy("vue", {
              createHTML: function createHTML(val) {
                return val;
              }
            });
          } catch (e) {}
        }
        var unsafeToTrustedHTML = policy ? function (val) {
          return policy.createHTML(val);
        } : function (val) {
          return val;
        };
        var svgNS = "http://www.w3.org/2000/svg";
        var mathmlNS = "http://www.w3.org/1998/Math/MathML";
        var doc = typeof document !== "undefined" ? document : null;
        var templateContainer = doc && /* @__PURE__ */doc.createElement("template");
        var nodeOps = {
          insert: function insert(child, parent, anchor) {
            parent.insertBefore(child, anchor || null);
          },
          remove: function remove(child) {
            var parent = child.parentNode;
            if (parent) {
              parent.removeChild(child);
            }
          },
          createElement: function createElement(tag, namespace, is, props) {
            var el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, {
              is: is
            }) : doc.createElement(tag);
            if (tag === "select" && props && props.multiple != null) {
              el.setAttribute("multiple", props.multiple);
            }
            return el;
          },
          createText: function createText(text) {
            return doc.createTextNode(text);
          },
          createComment: function createComment(text) {
            return doc.createComment(text);
          },
          setText: function setText(node, text) {
            node.nodeValue = text;
          },
          setElementText: function setElementText(el, text) {
            el.textContent = text;
          },
          parentNode: function parentNode(node) {
            return node.parentNode;
          },
          nextSibling: function nextSibling(node) {
            return node.nextSibling;
          },
          querySelector: function querySelector(selector) {
            return doc.querySelector(selector);
          },
          setScopeId: function setScopeId(el, id) {
            el.setAttribute(id, "");
          },
          // __UNSAFE__
          // Reason: innerHTML.
          // Static content here can only come from compiled templates.
          // As long as the user only uses trusted templates, this is safe.
          insertStaticContent: function insertStaticContent(content, parent, anchor, namespace, start, end) {
            var before = anchor ? anchor.previousSibling : parent.lastChild;
            if (start && (start === end || start.nextSibling)) {
              while (true) {
                parent.insertBefore(start.cloneNode(true), anchor);
                if (start === end || !(start = start.nextSibling)) break;
              }
            } else {
              templateContainer.innerHTML = unsafeToTrustedHTML(namespace === "svg" ? "<svg>".concat(content, "</svg>") : namespace === "mathml" ? "<math>".concat(content, "</math>") : content);
              var template = templateContainer.content;
              if (namespace === "svg" || namespace === "mathml") {
                var wrapper = template.firstChild;
                while (wrapper.firstChild) {
                  template.appendChild(wrapper.firstChild);
                }
                template.removeChild(wrapper);
              }
              parent.insertBefore(template, anchor);
            }
            return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild];
          }
        };
        var TRANSITION = "transition";
        var ANIMATION = "animation";
        var vtcKey = Symbol("_vtc");
        var DOMTransitionPropsValidators = {
          name: String,
          type: String,
          css: {
            type: Boolean,
            default: true
          },
          duration: [String, Number, Object],
          enterFromClass: String,
          enterActiveClass: String,
          enterToClass: String,
          appearFromClass: String,
          appearActiveClass: String,
          appearToClass: String,
          leaveFromClass: String,
          leaveActiveClass: String,
          leaveToClass: String
        };
        var TransitionPropsValidators = /* @__PURE__ */extend({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators);
        var decorate$1 = function decorate$1(t) {
          t.displayName = "Transition";
          t.props = TransitionPropsValidators;
          return t;
        };
        var Transition = /* @__PURE__ */decorate$1(function (props, _ref29) {
          var slots = _ref29.slots;
          return h(BaseTransition, resolveTransitionProps(props), slots);
        });
        var callHook = function callHook(hook) {
          var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          if (isArray$2(hook)) {
            hook.forEach(function (h2) {
              return h2.apply(void 0, _toConsumableArray(args));
            });
          } else if (hook) {
            hook.apply(void 0, _toConsumableArray(args));
          }
        };
        var hasExplicitCallback = function hasExplicitCallback(hook) {
          return hook ? isArray$2(hook) ? hook.some(function (h2) {
            return h2.length > 1;
          }) : hook.length > 1 : false;
        };
        function resolveTransitionProps(rawProps) {
          var baseProps = {};
          for (var key in rawProps) {
            if (!(key in DOMTransitionPropsValidators)) {
              baseProps[key] = rawProps[key];
            }
          }
          if (rawProps.css === false) {
            return baseProps;
          }
          var _rawProps$name = rawProps.name,
            name = _rawProps$name === void 0 ? "v" : _rawProps$name,
            type = rawProps.type,
            duration = rawProps.duration,
            _rawProps$enterFromCl = rawProps.enterFromClass,
            enterFromClass = _rawProps$enterFromCl === void 0 ? "".concat(name, "-enter-from") : _rawProps$enterFromCl,
            _rawProps$enterActive = rawProps.enterActiveClass,
            enterActiveClass = _rawProps$enterActive === void 0 ? "".concat(name, "-enter-active") : _rawProps$enterActive,
            _rawProps$enterToClas = rawProps.enterToClass,
            enterToClass = _rawProps$enterToClas === void 0 ? "".concat(name, "-enter-to") : _rawProps$enterToClas,
            _rawProps$appearFromC = rawProps.appearFromClass,
            appearFromClass = _rawProps$appearFromC === void 0 ? enterFromClass : _rawProps$appearFromC,
            _rawProps$appearActiv = rawProps.appearActiveClass,
            appearActiveClass = _rawProps$appearActiv === void 0 ? enterActiveClass : _rawProps$appearActiv,
            _rawProps$appearToCla = rawProps.appearToClass,
            appearToClass = _rawProps$appearToCla === void 0 ? enterToClass : _rawProps$appearToCla,
            _rawProps$leaveFromCl = rawProps.leaveFromClass,
            leaveFromClass = _rawProps$leaveFromCl === void 0 ? "".concat(name, "-leave-from") : _rawProps$leaveFromCl,
            _rawProps$leaveActive = rawProps.leaveActiveClass,
            leaveActiveClass = _rawProps$leaveActive === void 0 ? "".concat(name, "-leave-active") : _rawProps$leaveActive,
            _rawProps$leaveToClas = rawProps.leaveToClass,
            leaveToClass = _rawProps$leaveToClas === void 0 ? "".concat(name, "-leave-to") : _rawProps$leaveToClas;
          var durations = normalizeDuration(duration);
          var enterDuration = durations && durations[0];
          var leaveDuration = durations && durations[1];
          var _onBeforeEnter = baseProps.onBeforeEnter,
            onEnter = baseProps.onEnter,
            _onEnterCancelled = baseProps.onEnterCancelled,
            _onLeave = baseProps.onLeave,
            _onLeaveCancelled = baseProps.onLeaveCancelled,
            _baseProps$onBeforeAp = baseProps.onBeforeAppear,
            _onBeforeAppear = _baseProps$onBeforeAp === void 0 ? _onBeforeEnter : _baseProps$onBeforeAp,
            _baseProps$onAppear = baseProps.onAppear,
            onAppear = _baseProps$onAppear === void 0 ? onEnter : _baseProps$onAppear,
            _baseProps$onAppearCa = baseProps.onAppearCancelled,
            _onAppearCancelled = _baseProps$onAppearCa === void 0 ? _onEnterCancelled : _baseProps$onAppearCa;
          var finishEnter = function finishEnter(el, isAppear, done, isCancelled) {
            el._enterCancelled = isCancelled;
            removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
            removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
            done && done();
          };
          var finishLeave = function finishLeave(el, done) {
            el._isLeaving = false;
            removeTransitionClass(el, leaveFromClass);
            removeTransitionClass(el, leaveToClass);
            removeTransitionClass(el, leaveActiveClass);
            done && done();
          };
          var makeEnterHook = function makeEnterHook(isAppear) {
            return function (el, done) {
              var hook = isAppear ? onAppear : onEnter;
              var resolve = function resolve() {
                return finishEnter(el, isAppear, done);
              };
              callHook(hook, [el, resolve]);
              nextFrame(function () {
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) {
                  whenTransitionEnds(el, type, enterDuration, resolve);
                }
              });
            };
          };
          return extend(baseProps, {
            onBeforeEnter: function onBeforeEnter(el) {
              callHook(_onBeforeEnter, [el]);
              addTransitionClass(el, enterFromClass);
              addTransitionClass(el, enterActiveClass);
            },
            onBeforeAppear: function onBeforeAppear(el) {
              callHook(_onBeforeAppear, [el]);
              addTransitionClass(el, appearFromClass);
              addTransitionClass(el, appearActiveClass);
            },
            onEnter: makeEnterHook(false),
            onAppear: makeEnterHook(true),
            onLeave: function onLeave(el, done) {
              el._isLeaving = true;
              var resolve = function resolve() {
                return finishLeave(el, done);
              };
              addTransitionClass(el, leaveFromClass);
              if (!el._enterCancelled) {
                forceReflow();
                addTransitionClass(el, leaveActiveClass);
              } else {
                addTransitionClass(el, leaveActiveClass);
                forceReflow();
              }
              nextFrame(function () {
                if (!el._isLeaving) {
                  return;
                }
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(_onLeave)) {
                  whenTransitionEnds(el, type, leaveDuration, resolve);
                }
              });
              callHook(_onLeave, [el, resolve]);
            },
            onEnterCancelled: function onEnterCancelled(el) {
              finishEnter(el, false, void 0, true);
              callHook(_onEnterCancelled, [el]);
            },
            onAppearCancelled: function onAppearCancelled(el) {
              finishEnter(el, true, void 0, true);
              callHook(_onAppearCancelled, [el]);
            },
            onLeaveCancelled: function onLeaveCancelled(el) {
              finishLeave(el);
              callHook(_onLeaveCancelled, [el]);
            }
          });
        }
        function normalizeDuration(duration) {
          if (duration == null) {
            return null;
          } else if (isObject$2(duration)) {
            return [NumberOf(duration.enter), NumberOf(duration.leave)];
          } else {
            var n = NumberOf(duration);
            return [n, n];
          }
        }
        function NumberOf(val) {
          var res = toNumber(val);
          return res;
        }
        function addTransitionClass(el, cls) {
          cls.split(/\s+/).forEach(function (c) {
            return c && el.classList.add(c);
          });
          (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */new Set())).add(cls);
        }
        function removeTransitionClass(el, cls) {
          cls.split(/\s+/).forEach(function (c) {
            return c && el.classList.remove(c);
          });
          var _vtc = el[vtcKey];
          if (_vtc) {
            _vtc.delete(cls);
            if (!_vtc.size) {
              el[vtcKey] = void 0;
            }
          }
        }
        function nextFrame(cb) {
          requestAnimationFrame(function () {
            requestAnimationFrame(cb);
          });
        }
        var endId = 0;
        function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
          var id = el._endId = ++endId;
          var resolveIfNotStale = function resolveIfNotStale() {
            if (id === el._endId) {
              resolve();
            }
          };
          if (explicitTimeout != null) {
            return setTimeout(resolveIfNotStale, explicitTimeout);
          }
          var _getTransitionInfo = getTransitionInfo(el, expectedType),
            type = _getTransitionInfo.type,
            timeout = _getTransitionInfo.timeout,
            propCount = _getTransitionInfo.propCount;
          if (!type) {
            return resolve();
          }
          var endEvent = type + "end";
          var ended = 0;
          var end = function end() {
            el.removeEventListener(endEvent, onEnd);
            resolveIfNotStale();
          };
          var onEnd = function onEnd(e) {
            if (e.target === el && ++ended >= propCount) {
              end();
            }
          };
          setTimeout(function () {
            if (ended < propCount) {
              end();
            }
          }, timeout + 1);
          el.addEventListener(endEvent, onEnd);
        }
        function getTransitionInfo(el, expectedType) {
          var styles = window.getComputedStyle(el);
          var getStyleProperties = function getStyleProperties(key) {
            return (styles[key] || "").split(", ");
          };
          var transitionDelays = getStyleProperties("".concat(TRANSITION, "Delay"));
          var transitionDurations = getStyleProperties("".concat(TRANSITION, "Duration"));
          var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
          var animationDelays = getStyleProperties("".concat(ANIMATION, "Delay"));
          var animationDurations = getStyleProperties("".concat(ANIMATION, "Duration"));
          var animationTimeout = getTimeout(animationDelays, animationDurations);
          var type = null;
          var timeout = 0;
          var propCount = 0;
          if (expectedType === TRANSITION) {
            if (transitionTimeout > 0) {
              type = TRANSITION;
              timeout = transitionTimeout;
              propCount = transitionDurations.length;
            }
          } else if (expectedType === ANIMATION) {
            if (animationTimeout > 0) {
              type = ANIMATION;
              timeout = animationTimeout;
              propCount = animationDurations.length;
            }
          } else {
            timeout = Math.max(transitionTimeout, animationTimeout);
            type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
            propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
          }
          var hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties("".concat(TRANSITION, "Property")).toString());
          return {
            type: type,
            timeout: timeout,
            propCount: propCount,
            hasTransform: hasTransform
          };
        }
        function getTimeout(delays, durations) {
          while (delays.length < durations.length) {
            delays = delays.concat(delays);
          }
          return Math.max.apply(Math, _toConsumableArray(durations.map(function (d, i) {
            return toMs(d) + toMs(delays[i]);
          })));
        }
        function toMs(s) {
          if (s === "auto") return 0;
          return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
        }
        function forceReflow() {
          return document.body.offsetHeight;
        }
        function patchClass(el, value, isSVG) {
          var transitionClasses = el[vtcKey];
          if (transitionClasses) {
            value = (value ? [value].concat(_toConsumableArray(transitionClasses)) : _toConsumableArray(transitionClasses)).join(" ");
          }
          if (value == null) {
            el.removeAttribute("class");
          } else if (isSVG) {
            el.setAttribute("class", value);
          } else {
            el.className = value;
          }
        }
        var vShowOriginalDisplay = Symbol("_vod");
        var vShowHidden = Symbol("_vsh");
        var vShow = exports("Z", {
          beforeMount: function beforeMount(el, _ref30, _ref31) {
            var value = _ref30.value;
            var transition = _ref31.transition;
            el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
            if (transition && value) {
              transition.beforeEnter(el);
            } else {
              setDisplay(el, value);
            }
          },
          mounted: function mounted(el, _ref32, _ref33) {
            var value = _ref32.value;
            var transition = _ref33.transition;
            if (transition && value) {
              transition.enter(el);
            }
          },
          updated: function updated(el, _ref34, _ref35) {
            var value = _ref34.value,
              oldValue = _ref34.oldValue;
            var transition = _ref35.transition;
            if (!value === !oldValue) return;
            if (transition) {
              if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
              } else {
                transition.leave(el, function () {
                  setDisplay(el, false);
                });
              }
            } else {
              setDisplay(el, value);
            }
          },
          beforeUnmount: function beforeUnmount(el, _ref36) {
            var value = _ref36.value;
            setDisplay(el, value);
          }
        });
        function setDisplay(el, value) {
          el.style.display = value ? el[vShowOriginalDisplay] : "none";
          el[vShowHidden] = !value;
        }
        function initVShowForSSR() {
          vShow.getSSRProps = function (_ref37) {
            var value = _ref37.value;
            if (!value) {
              return {
                style: {
                  display: "none"
                }
              };
            }
          };
        }
        var CSS_VAR_TEXT = Symbol("");
        function useCssVars(getter) {
          var instance = getCurrentInstance();
          if (!instance) {
            return;
          }
          var updateTeleports = instance.ut = function () {
            var vars = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getter(instance.proxy);
            Array.from(document.querySelectorAll("[data-v-owner=\"".concat(instance.uid, "\"]"))).forEach(function (node) {
              return setVarsOnNode(node, vars);
            });
          };
          var setVars = function setVars() {
            var vars = getter(instance.proxy);
            if (instance.ce) {
              setVarsOnNode(instance.ce, vars);
            } else {
              setVarsOnVNode(instance.subTree, vars);
            }
            updateTeleports(vars);
          };
          onBeforeUpdate(function () {
            queuePostFlushCb(setVars);
          });
          onMounted(function () {
            watch(setVars, NOOP, {
              flush: "post"
            });
            var ob = new MutationObserver(setVars);
            ob.observe(instance.subTree.el.parentNode, {
              childList: true
            });
            onUnmounted(function () {
              return ob.disconnect();
            });
          });
        }
        function setVarsOnVNode(vnode, vars) {
          if (vnode.shapeFlag & 128) {
            var suspense = vnode.suspense;
            vnode = suspense.activeBranch;
            if (suspense.pendingBranch && !suspense.isHydrating) {
              suspense.effects.push(function () {
                setVarsOnVNode(suspense.activeBranch, vars);
              });
            }
          }
          while (vnode.component) {
            vnode = vnode.component.subTree;
          }
          if (vnode.shapeFlag & 1 && vnode.el) {
            setVarsOnNode(vnode.el, vars);
          } else if (vnode.type === Fragment) {
            vnode.children.forEach(function (c) {
              return setVarsOnVNode(c, vars);
            });
          } else if (vnode.type === Static) {
            var _vnode = vnode,
              el = _vnode.el,
              anchor = _vnode.anchor;
            while (el) {
              setVarsOnNode(el, vars);
              if (el === anchor) break;
              el = el.nextSibling;
            }
          }
        }
        function setVarsOnNode(el, vars) {
          if (el.nodeType === 1) {
            var style = el.style;
            var cssText = "";
            for (var key in vars) {
              style.setProperty("--".concat(key), vars[key]);
              cssText += "--".concat(key, ": ").concat(vars[key], ";");
            }
            style[CSS_VAR_TEXT] = cssText;
          }
        }
        var displayRE = /(^|;)\s*display\s*:/;
        function patchStyle(el, prev, next) {
          var style = el.style;
          var isCssString = isString$1(next);
          var hasControlledDisplay = false;
          if (next && !isCssString) {
            if (prev) {
              if (!isString$1(prev)) {
                for (var key in prev) {
                  if (next[key] == null) {
                    setStyle(style, key, "");
                  }
                }
              } else {
                var _iterator11 = _createForOfIteratorHelper(prev.split(";")),
                  _step11;
                try {
                  for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                    var prevStyle = _step11.value;
                    var _key25 = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
                    if (next[_key25] == null) {
                      setStyle(style, _key25, "");
                    }
                  }
                } catch (err) {
                  _iterator11.e(err);
                } finally {
                  _iterator11.f();
                }
              }
            }
            for (var _key26 in next) {
              if (_key26 === "display") {
                hasControlledDisplay = true;
              }
              setStyle(style, _key26, next[_key26]);
            }
          } else {
            if (isCssString) {
              if (prev !== next) {
                var cssVarText = style[CSS_VAR_TEXT];
                if (cssVarText) {
                  next += ";" + cssVarText;
                }
                style.cssText = next;
                hasControlledDisplay = displayRE.test(next);
              }
            } else if (prev) {
              el.removeAttribute("style");
            }
          }
          if (vShowOriginalDisplay in el) {
            el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
            if (el[vShowHidden]) {
              style.display = "none";
            }
          }
        }
        var importantRE = /\s*!important$/;
        function setStyle(style, name, val) {
          if (isArray$2(val)) {
            val.forEach(function (v) {
              return setStyle(style, name, v);
            });
          } else {
            if (val == null) val = "";
            if (name.startsWith("--")) {
              style.setProperty(name, val);
            } else {
              var prefixed = autoPrefix(style, name);
              if (importantRE.test(val)) {
                style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
              } else {
                style[prefixed] = val;
              }
            }
          }
        }
        var prefixes = ["Webkit", "Moz", "ms"];
        var prefixCache = {};
        function autoPrefix(style, rawName) {
          var cached = prefixCache[rawName];
          if (cached) {
            return cached;
          }
          var name = camelize(rawName);
          if (name !== "filter" && name in style) {
            return prefixCache[rawName] = name;
          }
          name = capitalize$1(name);
          for (var i = 0; i < prefixes.length; i++) {
            var prefixed = prefixes[i] + name;
            if (prefixed in style) {
              return prefixCache[rawName] = prefixed;
            }
          }
          return rawName;
        }
        var xlinkNS = "http://www.w3.org/1999/xlink";
        function patchAttr(el, key, value, isSVG, instance) {
          var isBoolean = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : isSpecialBooleanAttr(key);
          if (isSVG && key.startsWith("xlink:")) {
            if (value == null) {
              el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
            } else {
              el.setAttributeNS(xlinkNS, key, value);
            }
          } else {
            if (value == null || isBoolean && !includeBooleanAttr(value)) {
              el.removeAttribute(key);
            } else {
              el.setAttribute(key, isBoolean ? "" : isSymbol(value) ? String(value) : value);
            }
          }
        }
        function patchDOMProp(el, key, value, parentComponent, attrName) {
          if (key === "innerHTML" || key === "textContent") {
            if (value != null) {
              el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
            }
            return;
          }
          var tag = el.tagName;
          if (key === "value" && tag !== "PROGRESS" &&
          // custom elements may use _value internally
          !tag.includes("-")) {
            var oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
            var newValue = value == null ?
            // #11647: value should be set as empty string for null and undefined,
            // but <input type="checkbox"> should be set as 'on'.
            el.type === "checkbox" ? "on" : "" : String(value);
            if (oldValue !== newValue || !("_value" in el)) {
              el.value = newValue;
            }
            if (value == null) {
              el.removeAttribute(key);
            }
            el._value = value;
            return;
          }
          var needRemove = false;
          if (value === "" || value == null) {
            var type = _typeof2(el[key]);
            if (type === "boolean") {
              value = includeBooleanAttr(value);
            } else if (value == null && type === "string") {
              value = "";
              needRemove = true;
            } else if (type === "number") {
              value = 0;
              needRemove = true;
            }
          }
          try {
            el[key] = value;
          } catch (e) {}
          needRemove && el.removeAttribute(attrName || key);
        }
        function addEventListener(el, event, handler, options) {
          el.addEventListener(event, handler, options);
        }
        function removeEventListener(el, event, handler, options) {
          el.removeEventListener(event, handler, options);
        }
        var veiKey = Symbol("_vei");
        function patchEvent(el, rawName, prevValue, nextValue) {
          var instance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          var invokers = el[veiKey] || (el[veiKey] = {});
          var existingInvoker = invokers[rawName];
          if (nextValue && existingInvoker) {
            existingInvoker.value = nextValue;
          } else {
            var _parseName = parseName(rawName),
              _parseName2 = _slicedToArray(_parseName, 2),
              name = _parseName2[0],
              options = _parseName2[1];
            if (nextValue) {
              var invoker = invokers[rawName] = createInvoker(nextValue, instance);
              addEventListener(el, name, invoker, options);
            } else if (existingInvoker) {
              removeEventListener(el, name, existingInvoker, options);
              invokers[rawName] = void 0;
            }
          }
        }
        var optionsModifierRE = /(?:Once|Passive|Capture)$/;
        function parseName(name) {
          var options;
          if (optionsModifierRE.test(name)) {
            options = {};
            var _m2;
            while (_m2 = name.match(optionsModifierRE)) {
              name = name.slice(0, name.length - _m2[0].length);
              options[_m2[0].toLowerCase()] = true;
            }
          }
          var event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
          return [event, options];
        }
        var cachedNow = 0;
        var p$1 = /* @__PURE__ */Promise.resolve();
        var getNow = function getNow() {
          return cachedNow || (p$1.then(function () {
            return cachedNow = 0;
          }), cachedNow = Date.now());
        };
        function createInvoker(initialValue, instance) {
          var _invoker = function invoker(e) {
            if (!e._vts) {
              e._vts = Date.now();
            } else if (e._vts <= _invoker.attached) {
              return;
            }
            callWithAsyncErrorHandling(patchStopImmediatePropagation(e, _invoker.value), instance, 5, [e]);
          };
          _invoker.value = initialValue;
          _invoker.attached = getNow();
          return _invoker;
        }
        function patchStopImmediatePropagation(e, value) {
          if (isArray$2(value)) {
            var originalStop = e.stopImmediatePropagation;
            e.stopImmediatePropagation = function () {
              originalStop.call(e);
              e._stopped = true;
            };
            return value.map(function (fn) {
              return function (e2) {
                return !e2._stopped && fn && fn(e2);
              };
            });
          } else {
            return value;
          }
        }
        var isNativeOn = function isNativeOn(key) {
          return key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 &&
          // lowercase letter
          key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
        };
        var patchProp = function patchProp(el, key, prevValue, nextValue, namespace, parentComponent) {
          var isSVG = namespace === "svg";
          if (key === "class") {
            patchClass(el, nextValue, isSVG);
          } else if (key === "style") {
            patchStyle(el, prevValue, nextValue);
          } else if (isOn(key)) {
            if (!isModelListener(key)) {
              patchEvent(el, key, prevValue, nextValue, parentComponent);
            }
          } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
            patchDOMProp(el, key, nextValue);
            if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
              patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
            }
          } else if (
          // #11081 force set props for possible async custom element
          el._isVueCE && (/[A-Z]/.test(key) || !isString$1(nextValue))) {
            patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
          } else {
            if (key === "true-value") {
              el._trueValue = nextValue;
            } else if (key === "false-value") {
              el._falseValue = nextValue;
            }
            patchAttr(el, key, nextValue, isSVG);
          }
        };
        function shouldSetAsProp(el, key, value, isSVG) {
          if (isSVG) {
            if (key === "innerHTML" || key === "textContent") {
              return true;
            }
            if (key in el && isNativeOn(key) && isFunction$1(value)) {
              return true;
            }
            return false;
          }
          if (key === "spellcheck" || key === "draggable" || key === "translate") {
            return false;
          }
          if (key === "form") {
            return false;
          }
          if (key === "list" && el.tagName === "INPUT") {
            return false;
          }
          if (key === "type" && el.tagName === "TEXTAREA") {
            return false;
          }
          if (key === "width" || key === "height") {
            var tag = el.tagName;
            if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
              return false;
            }
          }
          if (isNativeOn(key) && isString$1(value)) {
            return false;
          }
          return key in el;
        }
        var REMOVAL = {};
        /*! #__NO_SIDE_EFFECTS__ */
        // @__NO_SIDE_EFFECTS__
        function defineCustomElement(options, extraOptions, _createApp) {
          var Comp = defineComponent(options, extraOptions);
          if (isPlainObject$2(Comp)) extend(Comp, extraOptions);
          var VueCustomElement = /*#__PURE__*/function (_VueElement) {
            function VueCustomElement(initialProps) {
              _classCallCheck2(this, VueCustomElement);
              return _callSuper(this, VueCustomElement, [Comp, initialProps, _createApp]);
            }
            _inherits(VueCustomElement, _VueElement);
            return _createClass(VueCustomElement);
          }(VueElement);
          VueCustomElement.def = Comp;
          return VueCustomElement;
        }
        /*! #__NO_SIDE_EFFECTS__ */
        var defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */function defineSSRCustomElement(options, extraOptions) {
          return /* @__PURE__ */defineCustomElement(options, extraOptions, createSSRApp);
        };
        var BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : /*#__PURE__*/_createClass(function _class() {
          _classCallCheck2(this, _class);
        });
        var VueElement = /*#__PURE__*/function (_BaseClass) {
          function VueElement(_def) {
            var _this4;
            var _props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var _createApp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createApp;
            _classCallCheck2(this, VueElement);
            _this4 = _callSuper(this, VueElement);
            _this4._def = _def;
            _this4._props = _props;
            _this4._createApp = _createApp;
            _this4._isVueCE = true;
            _this4._instance = null;
            _this4._app = null;
            _this4._nonce = _this4._def.nonce;
            _this4._connected = false;
            _this4._resolved = false;
            _this4._numberProps = null;
            _this4._styleChildren = /* @__PURE__ */new WeakSet();
            _this4._ob = null;
            if (_this4.shadowRoot && _createApp !== createApp) {
              _this4._root = _this4.shadowRoot;
            } else {
              if (_def.shadowRoot !== false) {
                _this4.attachShadow({
                  mode: "open"
                });
                _this4._root = _this4.shadowRoot;
              } else {
                _this4._root = _this4;
              }
            }
            if (!_this4._def.__asyncLoader) {
              _this4._resolveProps(_this4._def);
            }
            return _this4;
          }
          _inherits(VueElement, _BaseClass);
          return _createClass(VueElement, [{
            key: "connectedCallback",
            value: function connectedCallback() {
              var _this5 = this;
              if (!this.isConnected) return;
              if (!this.shadowRoot) {
                this._parseSlots();
              }
              this._connected = true;
              var parent = this;
              while (parent = parent && (parent.parentNode || parent.host)) {
                if (parent instanceof VueElement) {
                  this._parent = parent;
                  break;
                }
              }
              if (!this._instance) {
                if (this._resolved) {
                  this._setParent();
                  this._update();
                } else {
                  if (parent && parent._pendingResolve) {
                    this._pendingResolve = parent._pendingResolve.then(function () {
                      _this5._pendingResolve = void 0;
                      _this5._resolveDef();
                    });
                  } else {
                    this._resolveDef();
                  }
                }
              }
            }
          }, {
            key: "_setParent",
            value: function _setParent() {
              var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._parent;
              if (parent) {
                this._instance.parent = parent._instance;
                this._instance.provides = parent._instance.provides;
              }
            }
          }, {
            key: "disconnectedCallback",
            value: function disconnectedCallback() {
              var _this6 = this;
              this._connected = false;
              nextTick(function () {
                if (!_this6._connected) {
                  if (_this6._ob) {
                    _this6._ob.disconnect();
                    _this6._ob = null;
                  }
                  _this6._app && _this6._app.unmount();
                  if (_this6._instance) _this6._instance.ce = void 0;
                  _this6._app = _this6._instance = null;
                }
              });
            }
            /**
             * resolve inner component definition (handle possible async component)
             */
          }, {
            key: "_resolveDef",
            value: function _resolveDef() {
              var _this7 = this;
              if (this._pendingResolve) {
                return;
              }
              for (var i = 0; i < this.attributes.length; i++) {
                this._setAttr(this.attributes[i].name);
              }
              this._ob = new MutationObserver(function (mutations) {
                var _iterator12 = _createForOfIteratorHelper(mutations),
                  _step12;
                try {
                  for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                    var _m4 = _step12.value;
                    _this7._setAttr(_m4.attributeName);
                  }
                } catch (err) {
                  _iterator12.e(err);
                } finally {
                  _iterator12.f();
                }
              });
              this._ob.observe(this, {
                attributes: true
              });
              var resolve = function resolve(def) {
                var isAsync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                _this7._resolved = true;
                _this7._pendingResolve = void 0;
                var props = def.props,
                  styles = def.styles;
                var numberProps;
                if (props && !isArray$2(props)) {
                  for (var key in props) {
                    var opt = props[key];
                    if (opt === Number || opt && opt.type === Number) {
                      if (key in _this7._props) {
                        _this7._props[key] = toNumber(_this7._props[key]);
                      }
                      (numberProps || (numberProps = /* @__PURE__ */Object.create(null)))[camelize(key)] = true;
                    }
                  }
                }
                _this7._numberProps = numberProps;
                if (isAsync) {
                  _this7._resolveProps(def);
                }
                if (_this7.shadowRoot) {
                  _this7._applyStyles(styles);
                }
                _this7._mount(def);
              };
              var asyncDef = this._def.__asyncLoader;
              if (asyncDef) {
                this._pendingResolve = asyncDef().then(function (def) {
                  return resolve(_this7._def = def, true);
                });
              } else {
                resolve(this._def);
              }
            }
          }, {
            key: "_mount",
            value: function _mount(def) {
              var _this8 = this;
              this._app = this._createApp(def);
              if (def.configureApp) {
                def.configureApp(this._app);
              }
              this._app._ceVNode = this._createVNode();
              this._app.mount(this._root);
              var exposed = this._instance && this._instance.exposed;
              if (!exposed) return;
              var _loop6 = function _loop6(key) {
                if (!hasOwn$1(_this8, key)) {
                  Object.defineProperty(_this8, key, {
                    // unwrap ref to be consistent with public instance behavior
                    get: function get() {
                      return unref(exposed[key]);
                    }
                  });
                }
              };
              for (var key in exposed) {
                _loop6(key);
              }
            }
          }, {
            key: "_resolveProps",
            value: function _resolveProps(def) {
              var _this9 = this;
              var props = def.props;
              var declaredPropKeys = isArray$2(props) ? props : Object.keys(props || {});
              for (var _i5 = 0, _Object$keys = Object.keys(this); _i5 < _Object$keys.length; _i5++) {
                var key = _Object$keys[_i5];
                if (key[0] !== "_" && declaredPropKeys.includes(key)) {
                  this._setProp(key, this[key]);
                }
              }
              var _iterator13 = _createForOfIteratorHelper(declaredPropKeys.map(camelize)),
                _step13;
              try {
                var _loop7 = function _loop7() {
                  var key = _step13.value;
                  Object.defineProperty(_this9, key, {
                    get: function get() {
                      return this._getProp(key);
                    },
                    set: function set(val) {
                      this._setProp(key, val, true, true);
                    }
                  });
                };
                for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
                  _loop7();
                }
              } catch (err) {
                _iterator13.e(err);
              } finally {
                _iterator13.f();
              }
            }
          }, {
            key: "_setAttr",
            value: function _setAttr(key) {
              if (key.startsWith("data-v-")) return;
              var has = this.hasAttribute(key);
              var value = has ? this.getAttribute(key) : REMOVAL;
              var camelKey = camelize(key);
              if (has && this._numberProps && this._numberProps[camelKey]) {
                value = toNumber(value);
              }
              this._setProp(camelKey, value, false, true);
            }
            /**
             * @internal
             */
          }, {
            key: "_getProp",
            value: function _getProp(key) {
              return this._props[key];
            }
            /**
             * @internal
             */
          }, {
            key: "_setProp",
            value: function _setProp(key, val) {
              var shouldReflect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
              var shouldUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
              if (val !== this._props[key]) {
                if (val === REMOVAL) {
                  delete this._props[key];
                } else {
                  this._props[key] = val;
                  if (key === "key" && this._app) {
                    this._app._ceVNode.key = val;
                  }
                }
                if (shouldUpdate && this._instance) {
                  this._update();
                }
                if (shouldReflect) {
                  var ob = this._ob;
                  ob && ob.disconnect();
                  if (val === true) {
                    this.setAttribute(hyphenate(key), "");
                  } else if (typeof val === "string" || typeof val === "number") {
                    this.setAttribute(hyphenate(key), val + "");
                  } else if (!val) {
                    this.removeAttribute(hyphenate(key));
                  }
                  ob && ob.observe(this, {
                    attributes: true
                  });
                }
              }
            }
          }, {
            key: "_update",
            value: function _update() {
              render(this._createVNode(), this._root);
            }
          }, {
            key: "_createVNode",
            value: function _createVNode() {
              var _this10 = this;
              var baseProps = {};
              if (!this.shadowRoot) {
                baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
              }
              var vnode = createVNode(this._def, extend(baseProps, this._props));
              if (!this._instance) {
                vnode.ce = function (instance) {
                  _this10._instance = instance;
                  instance.ce = _this10;
                  instance.isCE = true;
                  var dispatch = function dispatch(event, args) {
                    _this10.dispatchEvent(new CustomEvent(event, isPlainObject$2(args[0]) ? extend({
                      detail: args
                    }, args[0]) : {
                      detail: args
                    }));
                  };
                  instance.emit = function (event) {
                    for (var _len17 = arguments.length, args = new Array(_len17 > 1 ? _len17 - 1 : 0), _key27 = 1; _key27 < _len17; _key27++) {
                      args[_key27 - 1] = arguments[_key27];
                    }
                    dispatch(event, args);
                    if (hyphenate(event) !== event) {
                      dispatch(hyphenate(event), args);
                    }
                  };
                  _this10._setParent();
                };
              }
              return vnode;
            }
          }, {
            key: "_applyStyles",
            value: function _applyStyles(styles, owner) {
              if (!styles) return;
              if (owner) {
                if (owner === this._def || this._styleChildren.has(owner)) {
                  return;
                }
                this._styleChildren.add(owner);
              }
              var nonce = this._nonce;
              for (var i = styles.length - 1; i >= 0; i--) {
                var s = document.createElement("style");
                if (nonce) s.setAttribute("nonce", nonce);
                s.textContent = styles[i];
                this.shadowRoot.prepend(s);
              }
            }
            /**
             * Only called when shadowRoot is false
             */
          }, {
            key: "_parseSlots",
            value: function _parseSlots() {
              var slots = this._slots = {};
              var n;
              while (n = this.firstChild) {
                var slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
                (slots[slotName] || (slots[slotName] = [])).push(n);
                this.removeChild(n);
              }
            }
            /**
             * Only called when shadowRoot is false
             */
          }, {
            key: "_renderSlots",
            value: function _renderSlots() {
              var outlets = (this._teleportTarget || this).querySelectorAll("slot");
              var scopeId = this._instance.type.__scopeId;
              for (var i = 0; i < outlets.length; i++) {
                var o = outlets[i];
                var slotName = o.getAttribute("name") || "default";
                var content = this._slots[slotName];
                var parent = o.parentNode;
                if (content) {
                  var _iterator14 = _createForOfIteratorHelper(content),
                    _step14;
                  try {
                    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                      var n = _step14.value;
                      if (scopeId && n.nodeType === 1) {
                        var id = scopeId + "-s";
                        var walker = document.createTreeWalker(n, 1);
                        n.setAttribute(id, "");
                        var child = void 0;
                        while (child = walker.nextNode()) {
                          child.setAttribute(id, "");
                        }
                      }
                      parent.insertBefore(n, o);
                    }
                  } catch (err) {
                    _iterator14.e(err);
                  } finally {
                    _iterator14.f();
                  }
                } else {
                  while (o.firstChild) parent.insertBefore(o.firstChild, o);
                }
                parent.removeChild(o);
              }
            }
            /**
             * @internal
             */
          }, {
            key: "_injectChildStyle",
            value: function _injectChildStyle(comp) {
              this._applyStyles(comp.styles, comp);
            }
            /**
             * @internal
             */
          }, {
            key: "_removeChildStyle",
            value: function _removeChildStyle(comp) {}
          }]);
        }(BaseClass);
        function useHost(caller) {
          var instance = getCurrentInstance();
          var el = instance && instance.ce;
          if (el) {
            return el;
          }
          return null;
        }
        function useShadowRoot() {
          var el = useHost();
          return el && el.shadowRoot;
        }
        function useCssModule() {
          var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "$style";
          {
            var instance = getCurrentInstance();
            if (!instance) {
              return EMPTY_OBJ;
            }
            var modules = instance.type.__cssModules;
            if (!modules) {
              return EMPTY_OBJ;
            }
            var mod = modules[name];
            if (!mod) {
              return EMPTY_OBJ;
            }
            return mod;
          }
        }
        var positionMap = /* @__PURE__ */new WeakMap();
        var newPositionMap = /* @__PURE__ */new WeakMap();
        var moveCbKey = Symbol("_moveCb");
        var enterCbKey = Symbol("_enterCb");
        var decorate = function decorate(t) {
          delete t.props.mode;
          return t;
        };
        var TransitionGroupImpl = /* @__PURE__ */decorate({
          name: "TransitionGroup",
          props: /* @__PURE__ */extend({}, TransitionPropsValidators, {
            tag: String,
            moveClass: String
          }),
          setup: function setup(props, _ref38) {
            var slots = _ref38.slots;
            var instance = getCurrentInstance();
            var state = useTransitionState();
            var prevChildren;
            var children;
            onUpdated(function () {
              if (!prevChildren.length) {
                return;
              }
              var moveClass = props.moveClass || "".concat(props.name || "v", "-move");
              if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
                return;
              }
              prevChildren.forEach(callPendingCbs);
              prevChildren.forEach(recordPosition);
              var movedChildren = prevChildren.filter(applyTranslation);
              forceReflow();
              movedChildren.forEach(function (c) {
                var el = c.el;
                var style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = "";
                var cb = el[moveCbKey] = function (e) {
                  if (e && e.target !== el) {
                    return;
                  }
                  if (!e || /transform$/.test(e.propertyName)) {
                    el.removeEventListener("transitionend", cb);
                    el[moveCbKey] = null;
                    removeTransitionClass(el, moveClass);
                  }
                };
                el.addEventListener("transitionend", cb);
              });
            });
            return function () {
              var rawProps = toRaw(props);
              var cssTransitionProps = resolveTransitionProps(rawProps);
              var tag = rawProps.tag || Fragment;
              prevChildren = [];
              if (children) {
                for (var i = 0; i < children.length; i++) {
                  var child = children[i];
                  if (child.el && child.el instanceof Element) {
                    prevChildren.push(child);
                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
                    positionMap.set(child, child.el.getBoundingClientRect());
                  }
                }
              }
              children = slots.default ? getTransitionRawChildren(slots.default()) : [];
              for (var _i6 = 0; _i6 < children.length; _i6++) {
                var _child = children[_i6];
                if (_child.key != null) {
                  setTransitionHooks(_child, resolveTransitionHooks(_child, cssTransitionProps, state, instance));
                }
              }
              return createVNode(tag, null, children);
            };
          }
        });
        var TransitionGroup = TransitionGroupImpl;
        function callPendingCbs(c) {
          var el = c.el;
          if (el[moveCbKey]) {
            el[moveCbKey]();
          }
          if (el[enterCbKey]) {
            el[enterCbKey]();
          }
        }
        function recordPosition(c) {
          newPositionMap.set(c, c.el.getBoundingClientRect());
        }
        function applyTranslation(c) {
          var oldPos = positionMap.get(c);
          var newPos = newPositionMap.get(c);
          var dx = oldPos.left - newPos.left;
          var dy = oldPos.top - newPos.top;
          if (dx || dy) {
            var s = c.el.style;
            s.transform = s.webkitTransform = "translate(".concat(dx, "px,").concat(dy, "px)");
            s.transitionDuration = "0s";
            return c;
          }
        }
        function hasCSSTransform(el, root, moveClass) {
          var clone = el.cloneNode();
          var _vtc = el[vtcKey];
          if (_vtc) {
            _vtc.forEach(function (cls) {
              cls.split(/\s+/).forEach(function (c) {
                return c && clone.classList.remove(c);
              });
            });
          }
          moveClass.split(/\s+/).forEach(function (c) {
            return c && clone.classList.add(c);
          });
          clone.style.display = "none";
          var container = root.nodeType === 1 ? root : root.parentNode;
          container.appendChild(clone);
          var _getTransitionInfo2 = getTransitionInfo(clone),
            hasTransform = _getTransitionInfo2.hasTransform;
          container.removeChild(clone);
          return hasTransform;
        }
        var getModelAssigner = function getModelAssigner(vnode) {
          var fn = vnode.props["onUpdate:modelValue"] || false;
          return isArray$2(fn) ? function (value) {
            return invokeArrayFns(fn, value);
          } : fn;
        };
        function onCompositionStart(e) {
          e.target.composing = true;
        }
        function onCompositionEnd(e) {
          var target = e.target;
          if (target.composing) {
            target.composing = false;
            target.dispatchEvent(new Event("input"));
          }
        }
        var assignKey = Symbol("_assign");
        var vModelText = exports("G", {
          created: function created(el, _ref39, vnode) {
            var _ref39$modifiers = _ref39.modifiers,
              lazy = _ref39$modifiers.lazy,
              trim = _ref39$modifiers.trim,
              number = _ref39$modifiers.number;
            el[assignKey] = getModelAssigner(vnode);
            var castToNumber = number || vnode.props && vnode.props.type === "number";
            addEventListener(el, lazy ? "change" : "input", function (e) {
              if (e.target.composing) return;
              var domValue = el.value;
              if (trim) {
                domValue = domValue.trim();
              }
              if (castToNumber) {
                domValue = looseToNumber(domValue);
              }
              el[assignKey](domValue);
            });
            if (trim) {
              addEventListener(el, "change", function () {
                el.value = el.value.trim();
              });
            }
            if (!lazy) {
              addEventListener(el, "compositionstart", onCompositionStart);
              addEventListener(el, "compositionend", onCompositionEnd);
              addEventListener(el, "change", onCompositionEnd);
            }
          },
          // set value on mounted so it's after min/max for type="range"
          mounted: function mounted(el, _ref40) {
            var value = _ref40.value;
            el.value = value == null ? "" : value;
          },
          beforeUpdate: function beforeUpdate(el, _ref41, vnode) {
            var value = _ref41.value,
              oldValue = _ref41.oldValue,
              _ref41$modifiers = _ref41.modifiers,
              lazy = _ref41$modifiers.lazy,
              trim = _ref41$modifiers.trim,
              number = _ref41$modifiers.number;
            el[assignKey] = getModelAssigner(vnode);
            if (el.composing) return;
            var elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
            var newValue = value == null ? "" : value;
            if (elValue === newValue) {
              return;
            }
            if (document.activeElement === el && el.type !== "range") {
              if (lazy && value === oldValue) {
                return;
              }
              if (trim && el.value.trim() === newValue) {
                return;
              }
            }
            el.value = newValue;
          }
        });
        var vModelCheckbox = exports("y", {
          // #4096 array checkboxes need to be deep traversed
          deep: true,
          created: function created(el, _, vnode) {
            el[assignKey] = getModelAssigner(vnode);
            addEventListener(el, "change", function () {
              var modelValue = el._modelValue;
              var elementValue = getValue(el);
              var checked = el.checked;
              var assign = el[assignKey];
              if (isArray$2(modelValue)) {
                var _index3 = looseIndexOf(modelValue, elementValue);
                var found = _index3 !== -1;
                if (checked && !found) {
                  assign(modelValue.concat(elementValue));
                } else if (!checked && found) {
                  var filtered = _toConsumableArray(modelValue);
                  filtered.splice(_index3, 1);
                  assign(filtered);
                }
              } else if (isSet(modelValue)) {
                var cloned = new Set(modelValue);
                if (checked) {
                  cloned.add(elementValue);
                } else {
                  cloned.delete(elementValue);
                }
                assign(cloned);
              } else {
                assign(getCheckboxValue(el, checked));
              }
            });
          },
          // set initial checked on mount to wait for true-value/false-value
          mounted: setChecked,
          beforeUpdate: function beforeUpdate(el, binding, vnode) {
            el[assignKey] = getModelAssigner(vnode);
            setChecked(el, binding, vnode);
          }
        });
        function setChecked(el, _ref42, vnode) {
          var value = _ref42.value,
            oldValue = _ref42.oldValue;
          el._modelValue = value;
          var checked;
          if (isArray$2(value)) {
            checked = looseIndexOf(value, vnode.props.value) > -1;
          } else if (isSet(value)) {
            checked = value.has(vnode.props.value);
          } else {
            if (value === oldValue) return;
            checked = looseEqual(value, getCheckboxValue(el, true));
          }
          if (el.checked !== checked) {
            el.checked = checked;
          }
        }
        var vModelRadio = {
          created: function created(el, _ref43, vnode) {
            var value = _ref43.value;
            el.checked = looseEqual(value, vnode.props.value);
            el[assignKey] = getModelAssigner(vnode);
            addEventListener(el, "change", function () {
              el[assignKey](getValue(el));
            });
          },
          beforeUpdate: function beforeUpdate(el, _ref44, vnode) {
            var value = _ref44.value,
              oldValue = _ref44.oldValue;
            el[assignKey] = getModelAssigner(vnode);
            if (value !== oldValue) {
              el.checked = looseEqual(value, vnode.props.value);
            }
          }
        };
        var vModelSelect = exports("H", {
          // <select multiple> value need to be deep traversed
          deep: true,
          created: function created(el, _ref45, vnode) {
            var value = _ref45.value,
              number = _ref45.modifiers.number;
            var isSetModel = isSet(value);
            addEventListener(el, "change", function () {
              var selectedVal = Array.prototype.filter.call(el.options, function (o) {
                return o.selected;
              }).map(function (o) {
                return number ? looseToNumber(getValue(o)) : getValue(o);
              });
              el[assignKey](el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
              el._assigning = true;
              nextTick(function () {
                el._assigning = false;
              });
            });
            el[assignKey] = getModelAssigner(vnode);
          },
          // set value in mounted & updated because <select> relies on its children
          // <option>s.
          mounted: function mounted(el, _ref46) {
            var value = _ref46.value;
            setSelected(el, value);
          },
          beforeUpdate: function beforeUpdate(el, _binding, vnode) {
            el[assignKey] = getModelAssigner(vnode);
          },
          updated: function updated(el, _ref47) {
            var value = _ref47.value;
            if (!el._assigning) {
              setSelected(el, value);
            }
          }
        });
        function setSelected(el, value) {
          var isMultiple = el.multiple;
          var isArrayValue = isArray$2(value);
          if (isMultiple && !isArrayValue && !isSet(value)) {
            return;
          }
          var _loop8 = function _loop8() {
              var option = el.options[i];
              var optionValue = getValue(option);
              if (isMultiple) {
                if (isArrayValue) {
                  var optionType = _typeof2(optionValue);
                  if (optionType === "string" || optionType === "number") {
                    option.selected = value.some(function (v) {
                      return String(v) === String(optionValue);
                    });
                  } else {
                    option.selected = looseIndexOf(value, optionValue) > -1;
                  }
                } else {
                  option.selected = value.has(optionValue);
                }
              } else if (looseEqual(getValue(option), value)) {
                if (el.selectedIndex !== i) el.selectedIndex = i;
                return {
                  v: void 0
                };
              }
            },
            _ret;
          for (var i = 0, l = el.options.length; i < l; i++) {
            _ret = _loop8();
            if (_ret) return _ret.v;
          }
          if (!isMultiple && el.selectedIndex !== -1) {
            el.selectedIndex = -1;
          }
        }
        function getValue(el) {
          return "_value" in el ? el._value : el.value;
        }
        function getCheckboxValue(el, checked) {
          var key = checked ? "_trueValue" : "_falseValue";
          return key in el ? el[key] : checked;
        }
        var vModelDynamic = {
          created: function created(el, binding, vnode) {
            callModelHook(el, binding, vnode, null, "created");
          },
          mounted: function mounted(el, binding, vnode) {
            callModelHook(el, binding, vnode, null, "mounted");
          },
          beforeUpdate: function beforeUpdate(el, binding, vnode, prevVNode) {
            callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
          },
          updated: function updated(el, binding, vnode, prevVNode) {
            callModelHook(el, binding, vnode, prevVNode, "updated");
          }
        };
        function resolveDynamicModel(tagName, type) {
          switch (tagName) {
            case "SELECT":
              return vModelSelect;
            case "TEXTAREA":
              return vModelText;
            default:
              switch (type) {
                case "checkbox":
                  return vModelCheckbox;
                case "radio":
                  return vModelRadio;
                default:
                  return vModelText;
              }
          }
        }
        function callModelHook(el, binding, vnode, prevVNode, hook) {
          var modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
          var fn = modelToUse[hook];
          fn && fn(el, binding, vnode, prevVNode);
        }
        function initVModelForSSR() {
          vModelText.getSSRProps = function (_ref48) {
            var value = _ref48.value;
            return {
              value: value
            };
          };
          vModelRadio.getSSRProps = function (_ref49, vnode) {
            var value = _ref49.value;
            if (vnode.props && looseEqual(vnode.props.value, value)) {
              return {
                checked: true
              };
            }
          };
          vModelCheckbox.getSSRProps = function (_ref50, vnode) {
            var value = _ref50.value;
            if (isArray$2(value)) {
              if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
                return {
                  checked: true
                };
              }
            } else if (isSet(value)) {
              if (vnode.props && value.has(vnode.props.value)) {
                return {
                  checked: true
                };
              }
            } else if (value) {
              return {
                checked: true
              };
            }
          };
          vModelDynamic.getSSRProps = function (binding, vnode) {
            if (typeof vnode.type !== "string") {
              return;
            }
            var modelToUse = resolveDynamicModel(
            // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
            vnode.type.toUpperCase(), vnode.props && vnode.props.type);
            if (modelToUse.getSSRProps) {
              return modelToUse.getSSRProps(binding, vnode);
            }
          };
        }
        var systemModifiers = ["ctrl", "shift", "alt", "meta"];
        var modifierGuards = {
          stop: function stop(e) {
            return e.stopPropagation();
          },
          prevent: function prevent(e) {
            return e.preventDefault();
          },
          self: function self(e) {
            return e.target !== e.currentTarget;
          },
          ctrl: function ctrl(e) {
            return !e.ctrlKey;
          },
          shift: function shift(e) {
            return !e.shiftKey;
          },
          alt: function alt(e) {
            return !e.altKey;
          },
          meta: function meta(e) {
            return !e.metaKey;
          },
          left: function left(e) {
            return "button" in e && e.button !== 0;
          },
          middle: function middle(e) {
            return "button" in e && e.button !== 1;
          },
          right: function right(e) {
            return "button" in e && e.button !== 2;
          },
          exact: function exact(e, modifiers) {
            return systemModifiers.some(function (m) {
              return e["".concat(m, "Key")] && !modifiers.includes(m);
            });
          }
        };
        var withModifiers = exports("a2", function (fn, modifiers) {
          var cache = fn._withMods || (fn._withMods = {});
          var cacheKey = modifiers.join(".");
          return cache[cacheKey] || (cache[cacheKey] = function (event) {
            for (var i = 0; i < modifiers.length; i++) {
              var guard = modifierGuards[modifiers[i]];
              if (guard && guard(event, modifiers)) return;
            }
            for (var _len18 = arguments.length, args = new Array(_len18 > 1 ? _len18 - 1 : 0), _key28 = 1; _key28 < _len18; _key28++) {
              args[_key28 - 1] = arguments[_key28];
            }
            return fn.apply(void 0, [event].concat(args));
          });
        });
        var keyNames = {
          esc: "escape",
          space: " ",
          up: "arrow-up",
          left: "arrow-left",
          right: "arrow-right",
          down: "arrow-down",
          delete: "backspace"
        };
        var withKeys = function withKeys(fn, modifiers) {
          var cache = fn._withKeys || (fn._withKeys = {});
          var cacheKey = modifiers.join(".");
          return cache[cacheKey] || (cache[cacheKey] = function (event) {
            if (!("key" in event)) {
              return;
            }
            var eventKey = hyphenate(event.key);
            if (modifiers.some(function (k) {
              return k === eventKey || keyNames[k] === eventKey;
            })) {
              return fn(event);
            }
          });
        };
        var rendererOptions = /* @__PURE__ */extend({
          patchProp: patchProp
        }, nodeOps);
        var renderer;
        var enabledHydration = false;
        function ensureRenderer() {
          return renderer || (renderer = createRenderer(rendererOptions));
        }
        function ensureHydrationRenderer() {
          renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
          enabledHydration = true;
          return renderer;
        }
        var render = function render() {
          var _ensureRenderer;
          (_ensureRenderer = ensureRenderer()).render.apply(_ensureRenderer, arguments);
        };
        var hydrate = function hydrate() {
          var _ensureHydrationRende;
          (_ensureHydrationRende = ensureHydrationRenderer()).hydrate.apply(_ensureHydrationRende, arguments);
        };
        var createApp = function createApp() {
          var _ensureRenderer2;
          var app = (_ensureRenderer2 = ensureRenderer()).createApp.apply(_ensureRenderer2, arguments);
          var mount = app.mount;
          app.mount = function (containerOrSelector) {
            var container = normalizeContainer(containerOrSelector);
            if (!container) return;
            var component = app._component;
            if (!isFunction$1(component) && !component.render && !component.template) {
              component.template = container.innerHTML;
            }
            if (container.nodeType === 1) {
              container.textContent = "";
            }
            var proxy = mount(container, false, resolveRootNamespace(container));
            if (container instanceof Element) {
              container.removeAttribute("v-cloak");
              container.setAttribute("data-v-app", "");
            }
            return proxy;
          };
          return app;
        };
        var createSSRApp = function createSSRApp() {
          var _ensureHydrationRende2;
          var app = (_ensureHydrationRende2 = ensureHydrationRenderer()).createApp.apply(_ensureHydrationRende2, arguments);
          var mount = app.mount;
          app.mount = function (containerOrSelector) {
            var container = normalizeContainer(containerOrSelector);
            if (container) {
              return mount(container, true, resolveRootNamespace(container));
            }
          };
          return app;
        };
        function resolveRootNamespace(container) {
          if (container instanceof SVGElement) {
            return "svg";
          }
          if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
            return "mathml";
          }
        }
        function normalizeContainer(container) {
          if (isString$1(container)) {
            var res = document.querySelector(container);
            return res;
          }
          return container;
        }
        var ssrDirectiveInitialized = false;
        var initDirectivesForSSR = function initDirectivesForSSR() {
          if (!ssrDirectiveInitialized) {
            ssrDirectiveInitialized = true;
            initVModelForSSR();
            initVShowForSSR();
          }
        };

        /**
        * vue v3.5.13
        * (c) 2018-present Yuxi (Evan) You and Vue contributors
        * @license MIT
        **/
        var compile$1 = function compile$1() {};
        var vue_runtime_esmBundler = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          BaseTransition: BaseTransition,
          BaseTransitionPropsValidators: BaseTransitionPropsValidators,
          Comment: Comment,
          DeprecationTypes: DeprecationTypes,
          EffectScope: EffectScope,
          ErrorCodes: ErrorCodes,
          ErrorTypeStrings: ErrorTypeStrings,
          Fragment: Fragment,
          KeepAlive: KeepAlive,
          ReactiveEffect: ReactiveEffect,
          Static: Static,
          Suspense: Suspense,
          Teleport: Teleport,
          Text: Text,
          TrackOpTypes: TrackOpTypes,
          Transition: Transition,
          TransitionGroup: TransitionGroup,
          TriggerOpTypes: TriggerOpTypes,
          VueElement: VueElement,
          assertNumber: assertNumber,
          callWithAsyncErrorHandling: callWithAsyncErrorHandling,
          callWithErrorHandling: callWithErrorHandling,
          camelize: camelize,
          capitalize: capitalize$1,
          cloneVNode: cloneVNode,
          compatUtils: compatUtils,
          compile: compile$1,
          computed: computed,
          createApp: createApp,
          createBlock: createBlock,
          createCommentVNode: createCommentVNode,
          createElementBlock: createElementBlock,
          createElementVNode: createBaseVNode,
          createHydrationRenderer: createHydrationRenderer,
          createPropsRestProxy: createPropsRestProxy,
          createRenderer: createRenderer,
          createSSRApp: createSSRApp,
          createSlots: createSlots,
          createStaticVNode: createStaticVNode,
          createTextVNode: createTextVNode,
          createVNode: createVNode,
          customRef: customRef,
          defineAsyncComponent: defineAsyncComponent,
          defineComponent: defineComponent,
          defineCustomElement: defineCustomElement,
          defineEmits: defineEmits,
          defineExpose: defineExpose,
          defineModel: defineModel,
          defineOptions: defineOptions,
          defineProps: defineProps,
          defineSSRCustomElement: defineSSRCustomElement,
          defineSlots: defineSlots,
          devtools: devtools$2,
          effect: effect,
          effectScope: effectScope,
          getCurrentInstance: getCurrentInstance,
          getCurrentScope: getCurrentScope,
          getCurrentWatcher: getCurrentWatcher,
          getTransitionRawChildren: getTransitionRawChildren,
          guardReactiveProps: guardReactiveProps,
          h: h,
          handleError: handleError,
          hasInjectionContext: hasInjectionContext,
          hydrate: hydrate,
          hydrateOnIdle: hydrateOnIdle,
          hydrateOnInteraction: hydrateOnInteraction,
          hydrateOnMediaQuery: hydrateOnMediaQuery,
          hydrateOnVisible: hydrateOnVisible,
          initCustomFormatter: initCustomFormatter,
          initDirectivesForSSR: initDirectivesForSSR,
          inject: inject,
          isMemoSame: isMemoSame,
          isProxy: isProxy,
          isReactive: isReactive,
          isReadonly: isReadonly,
          isRef: isRef,
          isRuntimeOnly: isRuntimeOnly,
          isShallow: isShallow,
          isVNode: isVNode$1,
          markRaw: markRaw,
          mergeDefaults: mergeDefaults,
          mergeModels: mergeModels,
          mergeProps: mergeProps,
          nextTick: nextTick,
          normalizeClass: normalizeClass,
          normalizeProps: normalizeProps,
          normalizeStyle: normalizeStyle,
          onActivated: onActivated,
          onBeforeMount: onBeforeMount,
          onBeforeUnmount: onBeforeUnmount,
          onBeforeUpdate: onBeforeUpdate,
          onDeactivated: onDeactivated,
          onErrorCaptured: onErrorCaptured,
          onMounted: onMounted,
          onRenderTracked: onRenderTracked,
          onRenderTriggered: onRenderTriggered,
          onScopeDispose: onScopeDispose,
          onServerPrefetch: onServerPrefetch,
          onUnmounted: onUnmounted,
          onUpdated: onUpdated,
          onWatcherCleanup: onWatcherCleanup,
          openBlock: openBlock,
          popScopeId: popScopeId,
          provide: provide,
          proxyRefs: proxyRefs,
          pushScopeId: pushScopeId,
          queuePostFlushCb: queuePostFlushCb,
          reactive: reactive,
          readonly: readonly,
          ref: ref,
          registerRuntimeCompiler: registerRuntimeCompiler,
          render: render,
          renderList: renderList,
          renderSlot: renderSlot,
          resolveComponent: resolveComponent,
          resolveDirective: resolveDirective,
          resolveDynamicComponent: resolveDynamicComponent,
          resolveFilter: resolveFilter,
          resolveTransitionHooks: resolveTransitionHooks,
          setBlockTracking: setBlockTracking,
          setDevtoolsHook: setDevtoolsHook,
          setTransitionHooks: setTransitionHooks,
          shallowReactive: shallowReactive,
          shallowReadonly: shallowReadonly,
          shallowRef: shallowRef,
          ssrContextKey: ssrContextKey,
          ssrUtils: ssrUtils,
          stop: stop,
          toDisplayString: toDisplayString$1,
          toHandlerKey: toHandlerKey,
          toHandlers: toHandlers,
          toRaw: toRaw,
          toRef: toRef,
          toRefs: toRefs,
          toValue: toValue$1,
          transformVNodeArgs: transformVNodeArgs,
          triggerRef: triggerRef,
          unref: unref,
          useAttrs: useAttrs,
          useCssModule: useCssModule,
          useCssVars: useCssVars,
          useHost: useHost,
          useId: useId,
          useModel: useModel,
          useSSRContext: useSSRContext,
          useShadowRoot: useShadowRoot,
          useSlots: useSlots,
          useTemplateRef: useTemplateRef,
          useTransitionState: useTransitionState,
          vModelCheckbox: vModelCheckbox,
          vModelDynamic: vModelDynamic,
          vModelRadio: vModelRadio,
          vModelSelect: vModelSelect,
          vModelText: vModelText,
          vShow: vShow,
          version: version,
          warn: warn$2,
          watch: watch,
          watchEffect: watchEffect,
          watchPostEffect: watchPostEffect,
          watchSyncEffect: watchSyncEffect,
          withAsyncContext: withAsyncContext,
          withCtx: withCtx,
          withDefaults: withDefaults,
          withDirectives: withDirectives,
          withKeys: withKeys,
          withMemo: withMemo,
          withModifiers: withModifiers,
          withScopeId: withScopeId
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        var _hoisted_1$9 = ["width", "height"];
        var _hoisted_2$6 = ["xlink:href"];
        var _sfc_main$9 = /* @__PURE__ */defineComponent({
          __name: "index",
          props: {
            prefix: {
              type: String,
              default: "icon"
            },
            name: {
              type: String,
              required: true
            },
            color: {
              type: String,
              default: "#242424"
            },
            size: {
              type: String,
              default: "24px"
            }
          },
          setup: function setup(__props) {
            var props = __props;
            var symbolId = computed(function () {
              return "#".concat(props.prefix, "-").concat(props.name);
            });
            return function (_ctx, _cache) {
              return openBlock(), createElementBlock("svg", {
                "aria-hidden": "true",
                class: "svg-icon",
                width: props.size,
                height: props.size
              }, [createBaseVNode("use", {
                "xlink:href": symbolId.value
              }, null, 8, _hoisted_2$6)], 8, _hoisted_1$9);
            };
          }
        });

        /* unplugin-vue-components disabled */

        var _export_sfc = exports("k", function (sfc, props) {
          var target = sfc.__vccOpts || sfc;
          var _iterator15 = _createForOfIteratorHelper(props),
            _step15;
          try {
            for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
              var _step15$value = _slicedToArray(_step15.value, 2),
                key = _step15$value[0],
                val = _step15$value[1];
              target[key] = val;
            }
          } catch (err) {
            _iterator15.e(err);
          } finally {
            _iterator15.f();
          }
          return target;
        });
        var __unplugin_components_0 = exports("_", /* @__PURE__ */_export_sfc(_sfc_main$9, [["__scopeId", "data-v-3636cbfa"]]));

        /*!
          * shared v10.0.5
          * (c) 2024 kazuya kawaguchi
          * Released under the MIT License.
          */
        var inBrowser = typeof window !== "undefined";
        var makeSymbol = function makeSymbol(name) {
          var shareable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          return !shareable ? Symbol(name) : Symbol.for(name);
        };
        var generateFormatCacheKey = function generateFormatCacheKey(locale, key, source) {
          return friendlyJSONstringify({
            l: locale,
            k: key,
            s: source
          });
        };
        var friendlyJSONstringify = function friendlyJSONstringify(json) {
          return JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
        };
        var isNumber = function isNumber(val) {
          return typeof val === "number" && isFinite(val);
        };
        var isDate = function isDate(val) {
          return toTypeString(val) === "[object Date]";
        };
        var isRegExp = function isRegExp(val) {
          return toTypeString(val) === "[object RegExp]";
        };
        var isEmptyObject = function isEmptyObject(val) {
          return isPlainObject$1(val) && Object.keys(val).length === 0;
        };
        var assign$2 = Object.assign;
        var _create = Object.create;
        var create$1 = function create$1() {
          var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          return _create(obj);
        };
        var _globalThis;
        var getGlobalThis = function getGlobalThis() {
          return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : create$1());
        };
        function escapeHtml(rawText) {
          return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function hasOwn(obj, key) {
          return hasOwnProperty.call(obj, key);
        }
        var isArray$1 = Array.isArray;
        var isFunction = function isFunction(val) {
          return typeof val === "function";
        };
        var isString = function isString(val) {
          return typeof val === "string";
        };
        var isBoolean = function isBoolean(val) {
          return typeof val === "boolean";
        };
        var isObject$1 = function isObject$1(val) {
          return val !== null && _typeof2(val) === "object";
        };
        var isPromise = function isPromise(val) {
          return isObject$1(val) && isFunction(val.then) && isFunction(val.catch);
        };
        var objectToString = Object.prototype.toString;
        var toTypeString = function toTypeString(value) {
          return objectToString.call(value);
        };
        var isPlainObject$1 = function isPlainObject$1(val) {
          return toTypeString(val) === "[object Object]";
        };
        var toDisplayString = function toDisplayString(val) {
          return val == null ? "" : isArray$1(val) || isPlainObject$1(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
        };
        function join(items) {
          var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          return items.reduce(function (str, item, index) {
            return index === 0 ? str + item : str + separator + item;
          }, "");
        }
        function warn(msg, err) {
          if (typeof console !== "undefined") {
            console.warn("[intlify] " + msg);
            if (err) {
              console.warn(err.stack);
            }
          }
        }
        var isNotObjectOrIsArray = function isNotObjectOrIsArray(val) {
          return !isObject$1(val) || isArray$1(val);
        };
        function deepCopy(src, des) {
          if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
            throw new Error("Invalid value");
          }
          var stack = [{
            src: src,
            des: des
          }];
          var _loop9 = function _loop9() {
            var _stack$pop = stack.pop(),
              src2 = _stack$pop.src,
              des2 = _stack$pop.des;
            Object.keys(src2).forEach(function (key) {
              if (key === "__proto__") {
                return;
              }
              if (isObject$1(src2[key]) && !isObject$1(des2[key])) {
                des2[key] = Array.isArray(src2[key]) ? [] : create$1();
              }
              if (isNotObjectOrIsArray(des2[key]) || isNotObjectOrIsArray(src2[key])) {
                des2[key] = src2[key];
              } else {
                stack.push({
                  src: src2[key],
                  des: des2[key]
                });
              }
            });
          };
          while (stack.length) {
            _loop9();
          }
        }

        /*!
          * message-compiler v10.0.5
          * (c) 2024 kazuya kawaguchi
          * Released under the MIT License.
          */
        function createPosition(line, column, offset) {
          return {
            line: line,
            column: column,
            offset: offset
          };
        }
        function createLocation(start, end, source) {
          var loc = {
            start: start,
            end: end
          };
          return loc;
        }
        var CompileErrorCodes = {
          // tokenizer error codes
          EXPECTED_TOKEN: 1,
          INVALID_TOKEN_IN_PLACEHOLDER: 2,
          UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
          UNKNOWN_ESCAPE_SEQUENCE: 4,
          INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
          UNBALANCED_CLOSING_BRACE: 6,
          UNTERMINATED_CLOSING_BRACE: 7,
          EMPTY_PLACEHOLDER: 8,
          NOT_ALLOW_NEST_PLACEHOLDER: 9,
          INVALID_LINKED_FORMAT: 10,
          // parser error codes
          MUST_HAVE_MESSAGES_IN_PLURAL: 11,
          UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
          UNEXPECTED_EMPTY_LINKED_KEY: 13,
          UNEXPECTED_LEXICAL_ANALYSIS: 14,
          // generator error codes
          UNHANDLED_CODEGEN_NODE_TYPE: 15,
          // minifier error codes
          UNHANDLED_MINIFIER_NODE_TYPE: 16
        };
        var COMPILE_ERROR_CODES_EXTEND_POINT = 17;
        function createCompileError(code, loc) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var domain = options.domain,
            messages = options.messages,
            args = options.args;
          var msg = code;
          var error = new SyntaxError(String(msg));
          error.code = code;
          if (loc) {
            error.location = loc;
          }
          error.domain = domain;
          return error;
        }
        function defaultOnError(error) {
          throw error;
        }
        var CHAR_SP = " ";
        var CHAR_CR = "\r";
        var CHAR_LF = "\n";
        var CHAR_LS = String.fromCharCode(8232);
        var CHAR_PS = String.fromCharCode(8233);
        function createScanner(str) {
          var _buf = str;
          var _index = 0;
          var _line = 1;
          var _column = 1;
          var _peekOffset = 0;
          var isCRLF = function isCRLF(index2) {
            return _buf[index2] === CHAR_CR && _buf[index2 + 1] === CHAR_LF;
          };
          var isLF = function isLF(index2) {
            return _buf[index2] === CHAR_LF;
          };
          var isPS = function isPS(index2) {
            return _buf[index2] === CHAR_PS;
          };
          var isLS = function isLS(index2) {
            return _buf[index2] === CHAR_LS;
          };
          var isLineEnd = function isLineEnd(index2) {
            return isCRLF(index2) || isLF(index2) || isPS(index2) || isLS(index2);
          };
          var index = function index() {
            return _index;
          };
          var line = function line() {
            return _line;
          };
          var column = function column() {
            return _column;
          };
          var peekOffset = function peekOffset() {
            return _peekOffset;
          };
          var charAt = function charAt(offset) {
            return isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
          };
          var currentChar = function currentChar() {
            return charAt(_index);
          };
          var currentPeek = function currentPeek() {
            return charAt(_index + _peekOffset);
          };
          function next() {
            _peekOffset = 0;
            if (isLineEnd(_index)) {
              _line++;
              _column = 0;
            }
            if (isCRLF(_index)) {
              _index++;
            }
            _index++;
            _column++;
            return _buf[_index];
          }
          function peek() {
            if (isCRLF(_index + _peekOffset)) {
              _peekOffset++;
            }
            _peekOffset++;
            return _buf[_index + _peekOffset];
          }
          function reset() {
            _index = 0;
            _line = 1;
            _column = 1;
            _peekOffset = 0;
          }
          function resetPeek() {
            var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            _peekOffset = offset;
          }
          function skipToPeek() {
            var target = _index + _peekOffset;
            while (target !== _index) {
              next();
            }
            _peekOffset = 0;
          }
          return {
            index: index,
            line: line,
            column: column,
            peekOffset: peekOffset,
            charAt: charAt,
            currentChar: currentChar,
            currentPeek: currentPeek,
            next: next,
            peek: peek,
            reset: reset,
            resetPeek: resetPeek,
            skipToPeek: skipToPeek
          };
        }
        var EOF = void 0;
        var DOT = ".";
        var LITERAL_DELIMITER = "'";
        var ERROR_DOMAIN$3 = "tokenizer";
        function createTokenizer(source) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var location = options.location !== false;
          var _scnr = createScanner(source);
          var currentOffset = function currentOffset() {
            return _scnr.index();
          };
          var currentPosition = function currentPosition() {
            return createPosition(_scnr.line(), _scnr.column(), _scnr.index());
          };
          var _initLoc = currentPosition();
          var _initOffset = currentOffset();
          var _context = {
            currentType: 13,
            offset: _initOffset,
            startLoc: _initLoc,
            endLoc: _initLoc,
            lastType: 13,
            lastOffset: _initOffset,
            lastStartLoc: _initLoc,
            lastEndLoc: _initLoc,
            braceNest: 0,
            inLinked: false,
            text: ""
          };
          var context = function context() {
            return _context;
          };
          var onError = options.onError;
          function emitError(code, pos, offset) {
            var ctx = context();
            pos.column += offset;
            pos.offset += offset;
            if (onError) {
              var loc = location ? createLocation(ctx.startLoc, pos) : null;
              for (var _len19 = arguments.length, args = new Array(_len19 > 3 ? _len19 - 3 : 0), _key29 = 3; _key29 < _len19; _key29++) {
                args[_key29 - 3] = arguments[_key29];
              }
              var err = createCompileError(code, loc, {
                domain: ERROR_DOMAIN$3,
                args: args
              });
              onError(err);
            }
          }
          function getToken(context2, type, value) {
            context2.endLoc = currentPosition();
            context2.currentType = type;
            var token = {
              type: type
            };
            if (location) {
              token.loc = createLocation(context2.startLoc, context2.endLoc);
            }
            if (value != null) {
              token.value = value;
            }
            return token;
          }
          var getEndToken = function getEndToken(context2) {
            return getToken(context2, 13
            /* TokenTypes.EOF */);
          };
          function eat(scnr, ch) {
            if (scnr.currentChar() === ch) {
              scnr.next();
              return ch;
            } else {
              emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
              return "";
            }
          }
          function peekSpaces(scnr) {
            var buf = "";
            while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
              buf += scnr.currentPeek();
              scnr.peek();
            }
            return buf;
          }
          function skipSpaces(scnr) {
            var buf = peekSpaces(scnr);
            scnr.skipToPeek();
            return buf;
          }
          function isIdentifierStart(ch) {
            if (ch === EOF) {
              return false;
            }
            var cc = ch.charCodeAt(0);
            return cc >= 97 && cc <= 122 ||
            // a-z
            cc >= 65 && cc <= 90 ||
            // A-Z
            cc === 95;
          }
          function isNumberStart(ch) {
            if (ch === EOF) {
              return false;
            }
            var cc = ch.charCodeAt(0);
            return cc >= 48 && cc <= 57;
          }
          function isNamedIdentifierStart(scnr, context2) {
            var currentType = context2.currentType;
            if (currentType !== 2) {
              return false;
            }
            peekSpaces(scnr);
            var ret = isIdentifierStart(scnr.currentPeek());
            scnr.resetPeek();
            return ret;
          }
          function isListIdentifierStart(scnr, context2) {
            var currentType = context2.currentType;
            if (currentType !== 2) {
              return false;
            }
            peekSpaces(scnr);
            var ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
            var ret = isNumberStart(ch);
            scnr.resetPeek();
            return ret;
          }
          function isLiteralStart(scnr, context2) {
            var currentType = context2.currentType;
            if (currentType !== 2) {
              return false;
            }
            peekSpaces(scnr);
            var ret = scnr.currentPeek() === LITERAL_DELIMITER;
            scnr.resetPeek();
            return ret;
          }
          function isLinkedDotStart(scnr, context2) {
            var currentType = context2.currentType;
            if (currentType !== 7) {
              return false;
            }
            peekSpaces(scnr);
            var ret = scnr.currentPeek() === ".";
            scnr.resetPeek();
            return ret;
          }
          function isLinkedModifierStart(scnr, context2) {
            var currentType = context2.currentType;
            if (currentType !== 8) {
              return false;
            }
            peekSpaces(scnr);
            var ret = isIdentifierStart(scnr.currentPeek());
            scnr.resetPeek();
            return ret;
          }
          function isLinkedDelimiterStart(scnr, context2) {
            var currentType = context2.currentType;
            if (!(currentType === 7 || currentType === 11)) {
              return false;
            }
            peekSpaces(scnr);
            var ret = scnr.currentPeek() === ":";
            scnr.resetPeek();
            return ret;
          }
          function isLinkedReferStart(scnr, context2) {
            var currentType = context2.currentType;
            if (currentType !== 9) {
              return false;
            }
            var _fn = function fn() {
              var ch = scnr.currentPeek();
              if (ch === "{") {
                return isIdentifierStart(scnr.peek());
              } else if (ch === "@" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
                return false;
              } else if (ch === CHAR_LF) {
                scnr.peek();
                return _fn();
              } else {
                return isTextStart(scnr, false);
              }
            };
            var ret = _fn();
            scnr.resetPeek();
            return ret;
          }
          function isPluralStart(scnr) {
            peekSpaces(scnr);
            var ret = scnr.currentPeek() === "|";
            scnr.resetPeek();
            return ret;
          }
          function isTextStart(scnr) {
            var reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var _fn2 = function fn() {
              var hasSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
              var ch = scnr.currentPeek();
              if (ch === "{") {
                return hasSpace;
              } else if (ch === "@" || !ch) {
                return hasSpace;
              } else if (ch === "|") {
                return !(prev === CHAR_SP || prev === CHAR_LF);
              } else if (ch === CHAR_SP) {
                scnr.peek();
                return _fn2(true, CHAR_SP);
              } else if (ch === CHAR_LF) {
                scnr.peek();
                return _fn2(true, CHAR_LF);
              } else {
                return true;
              }
            };
            var ret = _fn2();
            reset && scnr.resetPeek();
            return ret;
          }
          function takeChar(scnr, fn) {
            var ch = scnr.currentChar();
            if (ch === EOF) {
              return EOF;
            }
            if (fn(ch)) {
              scnr.next();
              return ch;
            }
            return null;
          }
          function isIdentifier(ch) {
            var cc = ch.charCodeAt(0);
            return cc >= 97 && cc <= 122 ||
            // a-z
            cc >= 65 && cc <= 90 ||
            // A-Z
            cc >= 48 && cc <= 57 ||
            // 0-9
            cc === 95 ||
            // _
            cc === 36;
          }
          function takeIdentifierChar(scnr) {
            return takeChar(scnr, isIdentifier);
          }
          function isNamedIdentifier(ch) {
            var cc = ch.charCodeAt(0);
            return cc >= 97 && cc <= 122 ||
            // a-z
            cc >= 65 && cc <= 90 ||
            // A-Z
            cc >= 48 && cc <= 57 ||
            // 0-9
            cc === 95 ||
            // _
            cc === 36 ||
            // $
            cc === 45;
          }
          function takeNamedIdentifierChar(scnr) {
            return takeChar(scnr, isNamedIdentifier);
          }
          function isDigit(ch) {
            var cc = ch.charCodeAt(0);
            return cc >= 48 && cc <= 57;
          }
          function takeDigit(scnr) {
            return takeChar(scnr, isDigit);
          }
          function isHexDigit(ch) {
            var cc = ch.charCodeAt(0);
            return cc >= 48 && cc <= 57 ||
            // 0-9
            cc >= 65 && cc <= 70 ||
            // A-F
            cc >= 97 && cc <= 102;
          }
          function takeHexDigit(scnr) {
            return takeChar(scnr, isHexDigit);
          }
          function getDigits(scnr) {
            var ch = "";
            var num = "";
            while (ch = takeDigit(scnr)) {
              num += ch;
            }
            return num;
          }
          function readText(scnr) {
            var buf = "";
            while (true) {
              var ch = scnr.currentChar();
              if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
                break;
              } else if (ch === CHAR_SP || ch === CHAR_LF) {
                if (isTextStart(scnr)) {
                  buf += ch;
                  scnr.next();
                } else if (isPluralStart(scnr)) {
                  break;
                } else {
                  buf += ch;
                  scnr.next();
                }
              } else {
                buf += ch;
                scnr.next();
              }
            }
            return buf;
          }
          function readNamedIdentifier(scnr) {
            skipSpaces(scnr);
            var ch = "";
            var name = "";
            while (ch = takeNamedIdentifierChar(scnr)) {
              name += ch;
            }
            if (scnr.currentChar() === EOF) {
              emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
            }
            return name;
          }
          function readListIdentifier(scnr) {
            skipSpaces(scnr);
            var value = "";
            if (scnr.currentChar() === "-") {
              scnr.next();
              value += "-".concat(getDigits(scnr));
            } else {
              value += getDigits(scnr);
            }
            if (scnr.currentChar() === EOF) {
              emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
            }
            return value;
          }
          function isLiteral(ch) {
            return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
          }
          function readLiteral(scnr) {
            skipSpaces(scnr);
            eat(scnr, "'");
            var ch = "";
            var literal = "";
            while (ch = takeChar(scnr, isLiteral)) {
              if (ch === "\\") {
                literal += readEscapeSequence(scnr);
              } else {
                literal += ch;
              }
            }
            var current = scnr.currentChar();
            if (current === CHAR_LF || current === EOF) {
              emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
              if (current === CHAR_LF) {
                scnr.next();
                eat(scnr, "'");
              }
              return literal;
            }
            eat(scnr, "'");
            return literal;
          }
          function readEscapeSequence(scnr) {
            var ch = scnr.currentChar();
            switch (ch) {
              case "\\":
              case "'":
                scnr.next();
                return "\\".concat(ch);
              case "u":
                return readUnicodeEscapeSequence(scnr, ch, 4);
              case "U":
                return readUnicodeEscapeSequence(scnr, ch, 6);
              default:
                emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
                return "";
            }
          }
          function readUnicodeEscapeSequence(scnr, unicode, digits) {
            eat(scnr, unicode);
            var sequence = "";
            for (var i = 0; i < digits; i++) {
              var ch = takeHexDigit(scnr);
              if (!ch) {
                emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, "\\".concat(unicode).concat(sequence).concat(scnr.currentChar()));
                break;
              }
              sequence += ch;
            }
            return "\\".concat(unicode).concat(sequence);
          }
          function isInvalidIdentifier(ch) {
            return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
          }
          function readInvalidIdentifier(scnr) {
            skipSpaces(scnr);
            var ch = "";
            var identifiers = "";
            while (ch = takeChar(scnr, isInvalidIdentifier)) {
              identifiers += ch;
            }
            return identifiers;
          }
          function readLinkedModifier(scnr) {
            var ch = "";
            var name = "";
            while (ch = takeIdentifierChar(scnr)) {
              name += ch;
            }
            return name;
          }
          function readLinkedRefer(scnr) {
            var _fn3 = function fn(buf) {
              var ch = scnr.currentChar();
              if (ch === "{" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
                return buf;
              } else if (ch === CHAR_SP) {
                return buf;
              } else if (ch === CHAR_LF || ch === DOT) {
                buf += ch;
                scnr.next();
                return _fn3(buf);
              } else {
                buf += ch;
                scnr.next();
                return _fn3(buf);
              }
            };
            return _fn3("");
          }
          function readPlural(scnr) {
            skipSpaces(scnr);
            var plural = eat(scnr, "|"
            /* TokenChars.Pipe */);
            skipSpaces(scnr);
            return plural;
          }
          function readTokenInPlaceholder(scnr, context2) {
            var token = null;
            var ch = scnr.currentChar();
            switch (ch) {
              case "{":
                if (context2.braceNest >= 1) {
                  emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
                }
                scnr.next();
                token = getToken(context2, 2, "{"
                /* TokenChars.BraceLeft */);
                skipSpaces(scnr);
                context2.braceNest++;
                return token;
              case "}":
                if (context2.braceNest > 0 && context2.currentType === 2) {
                  emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
                }
                scnr.next();
                token = getToken(context2, 3, "}"
                /* TokenChars.BraceRight */);
                context2.braceNest--;
                context2.braceNest > 0 && skipSpaces(scnr);
                if (context2.inLinked && context2.braceNest === 0) {
                  context2.inLinked = false;
                }
                return token;
              case "@":
                if (context2.braceNest > 0) {
                  emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                }
                token = readTokenInLinked(scnr, context2) || getEndToken(context2);
                context2.braceNest = 0;
                return token;
              default:
                {
                  var validNamedIdentifier = true;
                  var validListIdentifier = true;
                  var validLiteral = true;
                  if (isPluralStart(scnr)) {
                    if (context2.braceNest > 0) {
                      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                    }
                    token = getToken(context2, 1, readPlural(scnr));
                    context2.braceNest = 0;
                    context2.inLinked = false;
                    return token;
                  }
                  if (context2.braceNest > 0 && (context2.currentType === 4 || context2.currentType === 5 || context2.currentType === 6)) {
                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                    context2.braceNest = 0;
                    return readToken(scnr, context2);
                  }
                  if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
                    token = getToken(context2, 4, readNamedIdentifier(scnr));
                    skipSpaces(scnr);
                    return token;
                  }
                  if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
                    token = getToken(context2, 5, readListIdentifier(scnr));
                    skipSpaces(scnr);
                    return token;
                  }
                  if (validLiteral = isLiteralStart(scnr, context2)) {
                    token = getToken(context2, 6, readLiteral(scnr));
                    skipSpaces(scnr);
                    return token;
                  }
                  if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
                    token = getToken(context2, 12, readInvalidIdentifier(scnr));
                    emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
                    skipSpaces(scnr);
                    return token;
                  }
                  break;
                }
            }
            return token;
          }
          function readTokenInLinked(scnr, context2) {
            var currentType = context2.currentType;
            var token = null;
            var ch = scnr.currentChar();
            if ((currentType === 7 || currentType === 8 || currentType === 11 || currentType === 9) && (ch === CHAR_LF || ch === CHAR_SP)) {
              emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
            }
            switch (ch) {
              case "@":
                scnr.next();
                token = getToken(context2, 7, "@"
                /* TokenChars.LinkedAlias */);
                context2.inLinked = true;
                return token;
              case ".":
                skipSpaces(scnr);
                scnr.next();
                return getToken(context2, 8, "."
                /* TokenChars.LinkedDot */);
              case ":":
                skipSpaces(scnr);
                scnr.next();
                return getToken(context2, 9, ":"
                /* TokenChars.LinkedDelimiter */);
              default:
                if (isPluralStart(scnr)) {
                  token = getToken(context2, 1, readPlural(scnr));
                  context2.braceNest = 0;
                  context2.inLinked = false;
                  return token;
                }
                if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
                  skipSpaces(scnr);
                  return readTokenInLinked(scnr, context2);
                }
                if (isLinkedModifierStart(scnr, context2)) {
                  skipSpaces(scnr);
                  return getToken(context2, 11, readLinkedModifier(scnr));
                }
                if (isLinkedReferStart(scnr, context2)) {
                  skipSpaces(scnr);
                  if (ch === "{") {
                    return readTokenInPlaceholder(scnr, context2) || token;
                  } else {
                    return getToken(context2, 10, readLinkedRefer(scnr));
                  }
                }
                if (currentType === 7) {
                  emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
                }
                context2.braceNest = 0;
                context2.inLinked = false;
                return readToken(scnr, context2);
            }
          }
          function readToken(scnr, context2) {
            var token = {
              type: 13
              /* TokenTypes.EOF */
            };
            if (context2.braceNest > 0) {
              return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
            }
            if (context2.inLinked) {
              return readTokenInLinked(scnr, context2) || getEndToken(context2);
            }
            var ch = scnr.currentChar();
            switch (ch) {
              case "{":
                return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
              case "}":
                emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
                scnr.next();
                return getToken(context2, 3, "}"
                /* TokenChars.BraceRight */);
              case "@":
                return readTokenInLinked(scnr, context2) || getEndToken(context2);
              default:
                {
                  if (isPluralStart(scnr)) {
                    token = getToken(context2, 1, readPlural(scnr));
                    context2.braceNest = 0;
                    context2.inLinked = false;
                    return token;
                  }
                  if (isTextStart(scnr)) {
                    return getToken(context2, 0, readText(scnr));
                  }
                  break;
                }
            }
            return token;
          }
          function nextToken() {
            var currentType = _context.currentType,
              offset = _context.offset,
              startLoc = _context.startLoc,
              endLoc = _context.endLoc;
            _context.lastType = currentType;
            _context.lastOffset = offset;
            _context.lastStartLoc = startLoc;
            _context.lastEndLoc = endLoc;
            _context.offset = currentOffset();
            _context.startLoc = currentPosition();
            if (_scnr.currentChar() === EOF) {
              return getToken(_context, 13
              /* TokenTypes.EOF */);
            }
            return readToken(_scnr, _context);
          }
          return {
            nextToken: nextToken,
            currentOffset: currentOffset,
            currentPosition: currentPosition,
            context: context
          };
        }
        var ERROR_DOMAIN$2 = "parser";
        var KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
        function fromEscapeSequence(match, codePoint4, codePoint6) {
          switch (match) {
            case "\\\\":
              return "\\";
            case "\\'":
              return "'";
            default:
              {
                var codePoint = parseInt(codePoint4 || codePoint6, 16);
                if (codePoint <= 55295 || codePoint >= 57344) {
                  return String.fromCodePoint(codePoint);
                }
                return "";
              }
          }
        }
        function createParser() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var location = options.location !== false;
          var onError = options.onError;
          function emitError(tokenzer, code, start, offset) {
            var end = tokenzer.currentPosition();
            end.offset += offset;
            end.column += offset;
            if (onError) {
              var loc = location ? createLocation(start, end) : null;
              for (var _len20 = arguments.length, args = new Array(_len20 > 4 ? _len20 - 4 : 0), _key30 = 4; _key30 < _len20; _key30++) {
                args[_key30 - 4] = arguments[_key30];
              }
              var err = createCompileError(code, loc, {
                domain: ERROR_DOMAIN$2,
                args: args
              });
              onError(err);
            }
          }
          function startNode(type, offset, loc) {
            var node = {
              type: type
            };
            if (location) {
              node.start = offset;
              node.end = offset;
              node.loc = {
                start: loc,
                end: loc
              };
            }
            return node;
          }
          function endNode(node, offset, pos, type) {
            if (location) {
              node.end = offset;
              if (node.loc) {
                node.loc.end = pos;
              }
            }
          }
          function parseText(tokenizer, value) {
            var context = tokenizer.context();
            var node = startNode(3, context.offset, context.startLoc);
            node.value = value;
            endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
            return node;
          }
          function parseList(tokenizer, index) {
            var context = tokenizer.context();
            var offset = context.lastOffset,
              loc = context.lastStartLoc;
            var node = startNode(5, offset, loc);
            node.index = parseInt(index, 10);
            tokenizer.nextToken();
            endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
            return node;
          }
          function parseNamed(tokenizer, key) {
            var context = tokenizer.context();
            var offset = context.lastOffset,
              loc = context.lastStartLoc;
            var node = startNode(4, offset, loc);
            node.key = key;
            tokenizer.nextToken();
            endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
            return node;
          }
          function parseLiteral(tokenizer, value) {
            var context = tokenizer.context();
            var offset = context.lastOffset,
              loc = context.lastStartLoc;
            var node = startNode(9, offset, loc);
            node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
            tokenizer.nextToken();
            endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
            return node;
          }
          function parseLinkedModifier(tokenizer) {
            var token = tokenizer.nextToken();
            var context = tokenizer.context();
            var offset = context.lastOffset,
              loc = context.lastStartLoc;
            var node = startNode(8, offset, loc);
            if (token.type !== 11) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
              node.value = "";
              endNode(node, offset, loc);
              return {
                nextConsumeToken: token,
                node: node
              };
            }
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            node.value = token.value || "";
            endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
            return {
              node: node
            };
          }
          function parseLinkedKey(tokenizer, value) {
            var context = tokenizer.context();
            var node = startNode(7, context.offset, context.startLoc);
            node.value = value;
            endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
            return node;
          }
          function parseLinked(tokenizer) {
            var context = tokenizer.context();
            var linkedNode = startNode(6, context.offset, context.startLoc);
            var token = tokenizer.nextToken();
            if (token.type === 8) {
              var parsed = parseLinkedModifier(tokenizer);
              linkedNode.modifier = parsed.node;
              token = parsed.nextConsumeToken || tokenizer.nextToken();
            }
            if (token.type !== 9) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            token = tokenizer.nextToken();
            if (token.type === 2) {
              token = tokenizer.nextToken();
            }
            switch (token.type) {
              case 10:
                if (token.value == null) {
                  emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
                break;
              case 4:
                if (token.value == null) {
                  emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseNamed(tokenizer, token.value || "");
                break;
              case 5:
                if (token.value == null) {
                  emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseList(tokenizer, token.value || "");
                break;
              case 6:
                if (token.value == null) {
                  emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseLiteral(tokenizer, token.value || "");
                break;
              default:
                {
                  emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
                  var nextContext = tokenizer.context();
                  var emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
                  emptyLinkedKeyNode.value = "";
                  endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
                  linkedNode.key = emptyLinkedKeyNode;
                  endNode(linkedNode, nextContext.offset, nextContext.startLoc);
                  return {
                    nextConsumeToken: token,
                    node: linkedNode
                  };
                }
            }
            endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
            return {
              node: linkedNode
            };
          }
          function parseMessage(tokenizer) {
            var context = tokenizer.context();
            var startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
            var startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
            var node = startNode(2, startOffset, startLoc);
            node.items = [];
            var nextToken = null;
            do {
              var token = nextToken || tokenizer.nextToken();
              nextToken = null;
              switch (token.type) {
                case 0:
                  if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                  }
                  node.items.push(parseText(tokenizer, token.value || ""));
                  break;
                case 5:
                  if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                  }
                  node.items.push(parseList(tokenizer, token.value || ""));
                  break;
                case 4:
                  if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                  }
                  node.items.push(parseNamed(tokenizer, token.value || ""));
                  break;
                case 6:
                  if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                  }
                  node.items.push(parseLiteral(tokenizer, token.value || ""));
                  break;
                case 7:
                  {
                    var parsed = parseLinked(tokenizer);
                    node.items.push(parsed.node);
                    nextToken = parsed.nextConsumeToken || null;
                    break;
                  }
              }
            } while (context.currentType !== 13 && context.currentType !== 1);
            var endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
            var endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
            endNode(node, endOffset, endLoc);
            return node;
          }
          function parsePlural(tokenizer, offset, loc, msgNode) {
            var context = tokenizer.context();
            var hasEmptyMessage = msgNode.items.length === 0;
            var node = startNode(1, offset, loc);
            node.cases = [];
            node.cases.push(msgNode);
            do {
              var msg = parseMessage(tokenizer);
              if (!hasEmptyMessage) {
                hasEmptyMessage = msg.items.length === 0;
              }
              node.cases.push(msg);
            } while (context.currentType !== 13);
            if (hasEmptyMessage) {
              emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
            }
            endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
            return node;
          }
          function parseResource(tokenizer) {
            var context = tokenizer.context();
            var offset = context.offset,
              startLoc = context.startLoc;
            var msgNode = parseMessage(tokenizer);
            if (context.currentType === 13) {
              return msgNode;
            } else {
              return parsePlural(tokenizer, offset, startLoc, msgNode);
            }
          }
          function parse(source) {
            var tokenizer = createTokenizer(source, assign$2({}, options));
            var context = tokenizer.context();
            var node = startNode(0, context.offset, context.startLoc);
            if (location && node.loc) {
              node.loc.source = source;
            }
            node.body = parseResource(tokenizer);
            if (options.onCacheKey) {
              node.cacheKey = options.onCacheKey(source);
            }
            if (context.currentType !== 13) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
            }
            endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
            return node;
          }
          return {
            parse: parse
          };
        }
        function getTokenCaption(token) {
          if (token.type === 13) {
            return "EOF";
          }
          var name = (token.value || "").replace(/\r?\n/g, "\\n");
          return name.length > 10 ? name.slice(0, 9) + "" : name;
        }
        function createTransformer(ast) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var _context = {
            ast: ast,
            helpers: /* @__PURE__ */new Set()
          };
          var context = function context() {
            return _context;
          };
          var helper = function helper(name) {
            _context.helpers.add(name);
            return name;
          };
          return {
            context: context,
            helper: helper
          };
        }
        function traverseNodes(nodes, transformer) {
          for (var i = 0; i < nodes.length; i++) {
            traverseNode(nodes[i], transformer);
          }
        }
        function traverseNode(node, transformer) {
          switch (node.type) {
            case 1:
              traverseNodes(node.cases, transformer);
              transformer.helper("plural"
              /* HelperNameMap.PLURAL */);
              break;
            case 2:
              traverseNodes(node.items, transformer);
              break;
            case 6:
              {
                var linked = node;
                traverseNode(linked.key, transformer);
                transformer.helper("linked"
                /* HelperNameMap.LINKED */);
                transformer.helper("type"
                /* HelperNameMap.TYPE */);
                break;
              }
            case 5:
              transformer.helper("interpolate"
              /* HelperNameMap.INTERPOLATE */);
              transformer.helper("list"
              /* HelperNameMap.LIST */);
              break;
            case 4:
              transformer.helper("interpolate"
              /* HelperNameMap.INTERPOLATE */);
              transformer.helper("named"
              /* HelperNameMap.NAMED */);
              break;
          }
        }
        function transform(ast) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var transformer = createTransformer(ast);
          transformer.helper("normalize"
          /* HelperNameMap.NORMALIZE */);
          ast.body && traverseNode(ast.body, transformer);
          var context = transformer.context();
          ast.helpers = Array.from(context.helpers);
        }
        function optimize(ast) {
          var body = ast.body;
          if (body.type === 2) {
            optimizeMessageNode(body);
          } else {
            body.cases.forEach(function (c) {
              return optimizeMessageNode(c);
            });
          }
          return ast;
        }
        function optimizeMessageNode(message) {
          if (message.items.length === 1) {
            var item = message.items[0];
            if (item.type === 3 || item.type === 9) {
              message.static = item.value;
              delete item.value;
            }
          } else {
            var values = [];
            for (var i = 0; i < message.items.length; i++) {
              var _item = message.items[i];
              if (!(_item.type === 3 || _item.type === 9)) {
                break;
              }
              if (_item.value == null) {
                break;
              }
              values.push(_item.value);
            }
            if (values.length === message.items.length) {
              message.static = join(values);
              for (var _i7 = 0; _i7 < message.items.length; _i7++) {
                var _item2 = message.items[_i7];
                if (_item2.type === 3 || _item2.type === 9) {
                  delete _item2.value;
                }
              }
            }
          }
        }
        function minify(node) {
          node.t = node.type;
          switch (node.type) {
            case 0:
              {
                var resource = node;
                minify(resource.body);
                resource.b = resource.body;
                delete resource.body;
                break;
              }
            case 1:
              {
                var plural = node;
                var cases = plural.cases;
                for (var i = 0; i < cases.length; i++) {
                  minify(cases[i]);
                }
                plural.c = cases;
                delete plural.cases;
                break;
              }
            case 2:
              {
                var message = node;
                var items = message.items;
                for (var _i8 = 0; _i8 < items.length; _i8++) {
                  minify(items[_i8]);
                }
                message.i = items;
                delete message.items;
                if (message.static) {
                  message.s = message.static;
                  delete message.static;
                }
                break;
              }
            case 3:
            case 9:
            case 8:
            case 7:
              {
                var valueNode = node;
                if (valueNode.value) {
                  valueNode.v = valueNode.value;
                  delete valueNode.value;
                }
                break;
              }
            case 6:
              {
                var linked = node;
                minify(linked.key);
                linked.k = linked.key;
                delete linked.key;
                if (linked.modifier) {
                  minify(linked.modifier);
                  linked.m = linked.modifier;
                  delete linked.modifier;
                }
                break;
              }
            case 5:
              {
                var list = node;
                list.i = list.index;
                delete list.index;
                break;
              }
            case 4:
              {
                var named = node;
                named.k = named.key;
                delete named.key;
                break;
              }
          }
          delete node.type;
        }
        function createCodeGenerator(ast, options) {
          var sourceMap = options.sourceMap,
            filename = options.filename,
            breakLineCode = options.breakLineCode,
            _needIndent = options.needIndent;
          var location = options.location !== false;
          var _context = {
            filename: filename,
            code: "",
            column: 1,
            line: 1,
            offset: 0,
            map: void 0,
            breakLineCode: breakLineCode,
            needIndent: _needIndent,
            indentLevel: 0
          };
          if (location && ast.loc) {
            _context.source = ast.loc.source;
          }
          var context = function context() {
            return _context;
          };
          function push(code, node) {
            _context.code += code;
          }
          function _newline(n) {
            var withBreakLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var _breakLineCode = withBreakLine ? breakLineCode : "";
            push(_needIndent ? _breakLineCode + "  ".repeat(n) : _breakLineCode);
          }
          function indent() {
            var withNewLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var level = ++_context.indentLevel;
            withNewLine && _newline(level);
          }
          function deindent() {
            var withNewLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var level = --_context.indentLevel;
            withNewLine && _newline(level);
          }
          function newline() {
            _newline(_context.indentLevel);
          }
          var helper = function helper(key) {
            return "_".concat(key);
          };
          var needIndent = function needIndent() {
            return _context.needIndent;
          };
          return {
            context: context,
            push: push,
            indent: indent,
            deindent: deindent,
            newline: newline,
            helper: helper,
            needIndent: needIndent
          };
        }
        function generateLinkedNode(generator, node) {
          var helper = generator.helper;
          generator.push("".concat(helper("linked"
          /* HelperNameMap.LINKED */), "("));
          generateNode(generator, node.key);
          if (node.modifier) {
            generator.push(", ");
            generateNode(generator, node.modifier);
            generator.push(", _type");
          } else {
            generator.push(", undefined, _type");
          }
          generator.push(")");
        }
        function generateMessageNode(generator, node) {
          var helper = generator.helper,
            needIndent = generator.needIndent;
          generator.push("".concat(helper("normalize"
          /* HelperNameMap.NORMALIZE */), "(["));
          generator.indent(needIndent());
          var length = node.items.length;
          for (var i = 0; i < length; i++) {
            generateNode(generator, node.items[i]);
            if (i === length - 1) {
              break;
            }
            generator.push(", ");
          }
          generator.deindent(needIndent());
          generator.push("])");
        }
        function generatePluralNode(generator, node) {
          var helper = generator.helper,
            needIndent = generator.needIndent;
          if (node.cases.length > 1) {
            generator.push("".concat(helper("plural"
            /* HelperNameMap.PLURAL */), "(["));
            generator.indent(needIndent());
            var length = node.cases.length;
            for (var i = 0; i < length; i++) {
              generateNode(generator, node.cases[i]);
              if (i === length - 1) {
                break;
              }
              generator.push(", ");
            }
            generator.deindent(needIndent());
            generator.push("])");
          }
        }
        function generateResource(generator, node) {
          if (node.body) {
            generateNode(generator, node.body);
          } else {
            generator.push("null");
          }
        }
        function generateNode(generator, node) {
          var helper = generator.helper;
          switch (node.type) {
            case 0:
              generateResource(generator, node);
              break;
            case 1:
              generatePluralNode(generator, node);
              break;
            case 2:
              generateMessageNode(generator, node);
              break;
            case 6:
              generateLinkedNode(generator, node);
              break;
            case 8:
              generator.push(JSON.stringify(node.value), node);
              break;
            case 7:
              generator.push(JSON.stringify(node.value), node);
              break;
            case 5:
              generator.push("".concat(helper("interpolate"
              /* HelperNameMap.INTERPOLATE */), "(").concat(helper("list"
              /* HelperNameMap.LIST */), "(").concat(node.index, "))"), node);
              break;
            case 4:
              generator.push("".concat(helper("interpolate"
              /* HelperNameMap.INTERPOLATE */), "(").concat(helper("named"
              /* HelperNameMap.NAMED */), "(").concat(JSON.stringify(node.key), "))"), node);
              break;
            case 9:
              generator.push(JSON.stringify(node.value), node);
              break;
            case 3:
              generator.push(JSON.stringify(node.value), node);
              break;
          }
        }
        var generate = function generate(ast) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var mode = isString(options.mode) ? options.mode : "normal";
          var filename = isString(options.filename) ? options.filename : "message.intl";
          var sourceMap = !!options.sourceMap;
          var breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
          var needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
          var helpers = ast.helpers || [];
          var generator = createCodeGenerator(ast, {
            mode: mode,
            filename: filename,
            sourceMap: sourceMap,
            breakLineCode: breakLineCode,
            needIndent: needIndent
          });
          generator.push(mode === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {");
          generator.indent(needIndent);
          if (helpers.length > 0) {
            generator.push("const { ".concat(join(helpers.map(function (s) {
              return "".concat(s, ": _").concat(s);
            }), ", "), " } = ctx"));
            generator.newline();
          }
          generator.push("return ");
          generateNode(generator, ast);
          generator.deindent(needIndent);
          generator.push("}");
          delete ast.helpers;
          var _generator$context = generator.context(),
            code = _generator$context.code,
            map = _generator$context.map;
          return {
            ast: ast,
            code: code,
            map: map ? map.toJSON() : void 0
            // eslint-disable-line @typescript-eslint/no-explicit-any
          };
        };
        function baseCompile$1(source) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var assignedOptions = assign$2({}, options);
          var jit = !!assignedOptions.jit;
          var enalbeMinify = !!assignedOptions.minify;
          var enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
          var parser = createParser(assignedOptions);
          var ast = parser.parse(source);
          if (!jit) {
            transform(ast, assignedOptions);
            return generate(ast, assignedOptions);
          } else {
            enambeOptimize && optimize(ast);
            enalbeMinify && minify(ast);
            return {
              ast: ast,
              code: ""
            };
          }
        }

        /*!
          * core-base v10.0.5
          * (c) 2024 kazuya kawaguchi
          * Released under the MIT License.
          */
        function initFeatureFlags$1() {
          if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
            getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
          }
          if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
            getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
          }
        }
        function format(ast) {
          var msg = function msg(ctx) {
            return formatParts(ctx, ast);
          };
          return msg;
        }
        function formatParts(ctx, ast) {
          var body = resolveBody(ast);
          if (body == null) {
            throw createUnhandleNodeError(0
            /* NodeTypes.Resource */);
          }
          var type = resolveType(body);
          if (type === 1) {
            var plural = body;
            var cases = resolveCases(plural);
            return ctx.plural(cases.reduce(function (messages, c) {
              return [].concat(_toConsumableArray(messages), [formatMessageParts(ctx, c)]);
            }, []));
          } else {
            return formatMessageParts(ctx, body);
          }
        }
        var PROPS_BODY = ["b", "body"];
        function resolveBody(node) {
          return resolveProps(node, PROPS_BODY);
        }
        var PROPS_CASES = ["c", "cases"];
        function resolveCases(node) {
          return resolveProps(node, PROPS_CASES, []);
        }
        function formatMessageParts(ctx, node) {
          var static_ = resolveStatic(node);
          if (static_ != null) {
            return ctx.type === "text" ? static_ : ctx.normalize([static_]);
          } else {
            var messages = resolveItems(node).reduce(function (acm, c) {
              return [].concat(_toConsumableArray(acm), [formatMessagePart(ctx, c)]);
            }, []);
            return ctx.normalize(messages);
          }
        }
        var PROPS_STATIC = ["s", "static"];
        function resolveStatic(node) {
          return resolveProps(node, PROPS_STATIC);
        }
        var PROPS_ITEMS = ["i", "items"];
        function resolveItems(node) {
          return resolveProps(node, PROPS_ITEMS, []);
        }
        function formatMessagePart(ctx, node) {
          var type = resolveType(node);
          switch (type) {
            case 3:
              {
                return resolveValue$1(node, type);
              }
            case 9:
              {
                return resolveValue$1(node, type);
              }
            case 4:
              {
                var named = node;
                if (hasOwn(named, "k") && named.k) {
                  return ctx.interpolate(ctx.named(named.k));
                }
                if (hasOwn(named, "key") && named.key) {
                  return ctx.interpolate(ctx.named(named.key));
                }
                throw createUnhandleNodeError(type);
              }
            case 5:
              {
                var list = node;
                if (hasOwn(list, "i") && isNumber(list.i)) {
                  return ctx.interpolate(ctx.list(list.i));
                }
                if (hasOwn(list, "index") && isNumber(list.index)) {
                  return ctx.interpolate(ctx.list(list.index));
                }
                throw createUnhandleNodeError(type);
              }
            case 6:
              {
                var linked = node;
                var modifier = resolveLinkedModifier(linked);
                var key = resolveLinkedKey(linked);
                return ctx.linked(formatMessagePart(ctx, key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
              }
            case 7:
              {
                return resolveValue$1(node, type);
              }
            case 8:
              {
                return resolveValue$1(node, type);
              }
            default:
              throw new Error("unhandled node on format message part: ".concat(type));
          }
        }
        var PROPS_TYPE = ["t", "type"];
        function resolveType(node) {
          return resolveProps(node, PROPS_TYPE);
        }
        var PROPS_VALUE = ["v", "value"];
        function resolveValue$1(node, type) {
          var resolved = resolveProps(node, PROPS_VALUE);
          if (resolved) {
            return resolved;
          } else {
            throw createUnhandleNodeError(type);
          }
        }
        var PROPS_MODIFIER = ["m", "modifier"];
        function resolveLinkedModifier(node) {
          return resolveProps(node, PROPS_MODIFIER);
        }
        var PROPS_KEY = ["k", "key"];
        function resolveLinkedKey(node) {
          var resolved = resolveProps(node, PROPS_KEY);
          if (resolved) {
            return resolved;
          } else {
            throw createUnhandleNodeError(6
            /* NodeTypes.Linked */);
          }
        }
        function resolveProps(node, props, defaultValue) {
          for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            if (hasOwn(node, prop) && node[prop] != null) {
              return node[prop];
            }
          }
          return defaultValue;
        }
        function createUnhandleNodeError(type) {
          return new Error("unhandled node type: ".concat(type));
        }
        var defaultOnCacheKey = function defaultOnCacheKey(message) {
          return message;
        };
        var compileCache = create$1();
        function isMessageAST(val) {
          return isObject$1(val) && resolveType(val) === 0 && (hasOwn(val, "b") || hasOwn(val, "body"));
        }
        function baseCompile(message) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var detectError = false;
          var onError = options.onError || defaultOnError;
          options.onError = function (err) {
            detectError = true;
            onError(err);
          };
          return _objectSpread(_objectSpread({}, baseCompile$1(message, options)), {}, {
            detectError: detectError
          });
        }
        // @__NO_SIDE_EFFECTS__
        function compile(message, context) {
          if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && isString(message)) {
            isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
            var onCacheKey = context.onCacheKey || defaultOnCacheKey;
            var cacheKey = onCacheKey(message);
            var cached = compileCache[cacheKey];
            if (cached) {
              return cached;
            }
            var _baseCompile = baseCompile(message, _objectSpread(_objectSpread({}, context), {}, {
                location: false,
                jit: true
              })),
              ast = _baseCompile.ast,
              detectError = _baseCompile.detectError;
            var msg = format(ast);
            return !detectError ? compileCache[cacheKey] = msg : msg;
          } else {
            var _cacheKey = message.cacheKey;
            if (_cacheKey) {
              var _cached = compileCache[_cacheKey];
              if (_cached) {
                return _cached;
              }
              return compileCache[_cacheKey] = format(message);
            } else {
              return format(message);
            }
          }
        }
        var devtools = null;
        function setDevToolsHook(hook) {
          devtools = hook;
        }
        function initI18nDevTools(i18n, version, meta) {
          devtools && devtools.emit("i18n:init", {
            timestamp: Date.now(),
            i18n: i18n,
            version: version,
            meta: meta
          });
        }
        var translateDevTools = /* @__PURE__ */createDevToolsHook("function:translate");
        function createDevToolsHook(hook) {
          return function (payloads) {
            return devtools && devtools.emit(hook, payloads);
          };
        }
        var CoreErrorCodes = {
          INVALID_ARGUMENT: COMPILE_ERROR_CODES_EXTEND_POINT,
          // 17
          INVALID_DATE_ARGUMENT: 18,
          INVALID_ISO_DATE_ARGUMENT: 19,
          NOT_SUPPORT_NON_STRING_MESSAGE: 20,
          NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
          NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
          NOT_SUPPORT_LOCALE_TYPE: 23
        };
        var CORE_ERROR_CODES_EXTEND_POINT = 24;
        function createCoreError(code) {
          return createCompileError(code, null, void 0);
        }
        function getLocale(context, options) {
          return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
        }
        var _resolveLocale;
        function resolveLocale(locale) {
          if (isString(locale)) {
            return locale;
          } else {
            if (isFunction(locale)) {
              if (locale.resolvedOnce && _resolveLocale != null) {
                return _resolveLocale;
              } else if (locale.constructor.name === "Function") {
                var _resolve = locale();
                if (isPromise(_resolve)) {
                  throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
                }
                return _resolveLocale = _resolve;
              } else {
                throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
              }
            } else {
              throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
            }
          }
        }
        function fallbackWithSimple(ctx, fallback, start) {
          return _toConsumableArray(/* @__PURE__ */new Set([start].concat(_toConsumableArray(isArray$1(fallback) ? fallback : isObject$1(fallback) ? Object.keys(fallback) : isString(fallback) ? [fallback] : [start]))));
        }
        function fallbackWithLocaleChain(ctx, fallback, start) {
          var startLocale = isString(start) ? start : DEFAULT_LOCALE;
          var context = ctx;
          if (!context.__localeChainCache) {
            context.__localeChainCache = /* @__PURE__ */new Map();
          }
          var chain = context.__localeChainCache.get(startLocale);
          if (!chain) {
            chain = [];
            var block = [start];
            while (isArray$1(block)) {
              block = appendBlockToChain(chain, block, fallback);
            }
            var defaults = isArray$1(fallback) || !isPlainObject$1(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
            block = isString(defaults) ? [defaults] : defaults;
            if (isArray$1(block)) {
              appendBlockToChain(chain, block, false);
            }
            context.__localeChainCache.set(startLocale, chain);
          }
          return chain;
        }
        function appendBlockToChain(chain, block, blocks) {
          var follow = true;
          for (var i = 0; i < block.length && isBoolean(follow); i++) {
            var locale = block[i];
            if (isString(locale)) {
              follow = appendLocaleToChain(chain, block[i], blocks);
            }
          }
          return follow;
        }
        function appendLocaleToChain(chain, locale, blocks) {
          var follow;
          var tokens = locale.split("-");
          do {
            var target = tokens.join("-");
            follow = appendItemToChain(chain, target, blocks);
            tokens.splice(-1, 1);
          } while (tokens.length && follow === true);
          return follow;
        }
        function appendItemToChain(chain, target, blocks) {
          var follow = false;
          if (!chain.includes(target)) {
            follow = true;
            if (target) {
              follow = target[target.length - 1] !== "!";
              var locale = target.replace(/!/g, "");
              chain.push(locale);
              if ((isArray$1(blocks) || isPlainObject$1(blocks)) && blocks[locale]) {
                follow = blocks[locale];
              }
            }
          }
          return follow;
        }
        var pathStateMachine = [];
        pathStateMachine[0
        /* States.BEFORE_PATH */] = _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, "w"
        /* PathCharTypes.WORKSPACE */, [0
        /* States.BEFORE_PATH */]), "i"
        /* PathCharTypes.IDENT */, [3, 0
        /* Actions.APPEND */]), "["
        /* PathCharTypes.LEFT_BRACKET */, [4
        /* States.IN_SUB_PATH */]), "o"
        /* PathCharTypes.END_OF_FAIL */, [7
        /* States.AFTER_PATH */]);
        pathStateMachine[1
        /* States.IN_PATH */] = _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, "w"
        /* PathCharTypes.WORKSPACE */, [1
        /* States.IN_PATH */]), "."
        /* PathCharTypes.DOT */, [2
        /* States.BEFORE_IDENT */]), "["
        /* PathCharTypes.LEFT_BRACKET */, [4
        /* States.IN_SUB_PATH */]), "o"
        /* PathCharTypes.END_OF_FAIL */, [7
        /* States.AFTER_PATH */]);
        pathStateMachine[2
        /* States.BEFORE_IDENT */] = _defineProperty2(_defineProperty2(_defineProperty2({}, "w"
        /* PathCharTypes.WORKSPACE */, [2
        /* States.BEFORE_IDENT */]), "i"
        /* PathCharTypes.IDENT */, [3, 0
        /* Actions.APPEND */]), "0"
        /* PathCharTypes.ZERO */, [3, 0
        /* Actions.APPEND */]);
        pathStateMachine[3
        /* States.IN_IDENT */] = _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, "i"
        /* PathCharTypes.IDENT */, [3, 0
        /* Actions.APPEND */]), "0"
        /* PathCharTypes.ZERO */, [3, 0
        /* Actions.APPEND */]), "w"
        /* PathCharTypes.WORKSPACE */, [1, 1
        /* Actions.PUSH */]), "."
        /* PathCharTypes.DOT */, [2, 1
        /* Actions.PUSH */]), "["
        /* PathCharTypes.LEFT_BRACKET */, [4, 1
        /* Actions.PUSH */]), "o"
        /* PathCharTypes.END_OF_FAIL */, [7, 1
        /* Actions.PUSH */]);
        pathStateMachine[4
        /* States.IN_SUB_PATH */] = _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, "'"
        /* PathCharTypes.SINGLE_QUOTE */, [5, 0
        /* Actions.APPEND */]), '"'
        /* PathCharTypes.DOUBLE_QUOTE */, [6, 0
        /* Actions.APPEND */]), "["
        /* PathCharTypes.LEFT_BRACKET */, [4, 2
        /* Actions.INC_SUB_PATH_DEPTH */]), "]"
        /* PathCharTypes.RIGHT_BRACKET */, [1, 3
        /* Actions.PUSH_SUB_PATH */]), "o"
        /* PathCharTypes.END_OF_FAIL */, 8), "l"
        /* PathCharTypes.ELSE */, [4, 0
        /* Actions.APPEND */]);
        pathStateMachine[5
        /* States.IN_SINGLE_QUOTE */] = _defineProperty2(_defineProperty2(_defineProperty2({}, "'"
        /* PathCharTypes.SINGLE_QUOTE */, [4, 0
        /* Actions.APPEND */]), "o"
        /* PathCharTypes.END_OF_FAIL */, 8), "l"
        /* PathCharTypes.ELSE */, [5, 0
        /* Actions.APPEND */]);
        pathStateMachine[6
        /* States.IN_DOUBLE_QUOTE */] = _defineProperty2(_defineProperty2(_defineProperty2({}, '"'
        /* PathCharTypes.DOUBLE_QUOTE */, [4, 0
        /* Actions.APPEND */]), "o"
        /* PathCharTypes.END_OF_FAIL */, 8), "l"
        /* PathCharTypes.ELSE */, [6, 0
        /* Actions.APPEND */]);
        var literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
        function isLiteral(exp) {
          return literalValueRE.test(exp);
        }
        function stripQuotes(str) {
          var a = str.charCodeAt(0);
          var b = str.charCodeAt(str.length - 1);
          return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
        }
        function getPathCharType(ch) {
          if (ch === void 0 || ch === null) {
            return "o";
          }
          var code = ch.charCodeAt(0);
          switch (code) {
            case 91:
            case 93:
            case 46:
            case 34:
            case 39:
              return ch;
            case 95:
            case 36:
            case 45:
              return "i";
            case 9:
            case 10:
            case 13:
            case 160:
            case 65279:
            case 8232:
            case 8233:
              return "w";
          }
          return "i";
        }
        function formatSubPath(path) {
          var trimmed = path.trim();
          if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
            return false;
          }
          return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
        }
        function parse(path) {
          var keys = [];
          var index = -1;
          var mode = 0;
          var subPathDepth = 0;
          var c;
          var key;
          var newChar;
          var type;
          var transition;
          var action;
          var typeMap;
          var actions = [];
          actions[0
          /* Actions.APPEND */] = function () {
            if (key === void 0) {
              key = newChar;
            } else {
              key += newChar;
            }
          };
          actions[1
          /* Actions.PUSH */] = function () {
            if (key !== void 0) {
              keys.push(key);
              key = void 0;
            }
          };
          actions[2
          /* Actions.INC_SUB_PATH_DEPTH */] = function () {
            actions[0
            /* Actions.APPEND */]();
            subPathDepth++;
          };
          actions[3
          /* Actions.PUSH_SUB_PATH */] = function () {
            if (subPathDepth > 0) {
              subPathDepth--;
              mode = 4;
              actions[0
              /* Actions.APPEND */]();
            } else {
              subPathDepth = 0;
              if (key === void 0) {
                return false;
              }
              key = formatSubPath(key);
              if (key === false) {
                return false;
              } else {
                actions[1
                /* Actions.PUSH */]();
              }
            }
          };
          function maybeUnescapeQuote() {
            var nextChar = path[index + 1];
            if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
              index++;
              newChar = "\\" + nextChar;
              actions[0
              /* Actions.APPEND */]();
              return true;
            }
          }
          while (mode !== null) {
            index++;
            c = path[index];
            if (c === "\\" && maybeUnescapeQuote()) {
              continue;
            }
            type = getPathCharType(c);
            typeMap = pathStateMachine[mode];
            transition = typeMap[type] || typeMap["l"
            /* PathCharTypes.ELSE */] || 8;
            if (transition === 8) {
              return;
            }
            mode = transition[0];
            if (transition[1] !== void 0) {
              action = actions[transition[1]];
              if (action) {
                newChar = c;
                if (action() === false) {
                  return;
                }
              }
            }
            if (mode === 7) {
              return keys;
            }
          }
        }
        var cache = /* @__PURE__ */new Map();
        function resolveWithKeyValue(obj, path) {
          return isObject$1(obj) ? obj[path] : null;
        }
        function resolveValue(obj, path) {
          if (!isObject$1(obj)) {
            return null;
          }
          var hit = cache.get(path);
          if (!hit) {
            hit = parse(path);
            if (hit) {
              cache.set(path, hit);
            }
          }
          if (!hit) {
            return null;
          }
          var len = hit.length;
          var last = obj;
          var i = 0;
          while (i < len) {
            var val = last[hit[i]];
            if (val === void 0) {
              return null;
            }
            if (isFunction(last)) {
              return null;
            }
            last = val;
            i++;
          }
          return last;
        }
        var VERSION$1 = "10.0.5";
        var NOT_REOSLVED = -1;
        var DEFAULT_LOCALE = "en-US";
        var MISSING_RESOLVE_VALUE = "";
        var _capitalize = function capitalize(str) {
          return "".concat(str.charAt(0).toLocaleUpperCase()).concat(str.substr(1));
        };
        function getDefaultLinkedModifiers() {
          return {
            upper: function upper(val, type) {
              return type === "text" && isString(val) ? val.toUpperCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
            },
            lower: function lower(val, type) {
              return type === "text" && isString(val) ? val.toLowerCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
            },
            capitalize: function capitalize(val, type) {
              return type === "text" && isString(val) ? _capitalize(val) : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? _capitalize(val.children) : val;
            }
          };
        }
        var _compiler;
        function registerMessageCompiler(compiler) {
          _compiler = compiler;
        }
        var _resolver;
        function registerMessageResolver(resolver) {
          _resolver = resolver;
        }
        var _fallbacker;
        function registerLocaleFallbacker(fallbacker) {
          _fallbacker = fallbacker;
        }
        var _additionalMeta = null;
        var setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */function setAdditionalMeta(meta) {
          _additionalMeta = meta;
        };
        var getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */function getAdditionalMeta() {
          return _additionalMeta;
        };
        var _fallbackContext = null;
        var setFallbackContext = function setFallbackContext(context) {
          _fallbackContext = context;
        };
        var getFallbackContext = function getFallbackContext() {
          return _fallbackContext;
        };
        var _cid = 0;
        function createCoreContext() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
          var version = isString(options.version) ? options.version : VERSION$1;
          var locale = isString(options.locale) || isFunction(options.locale) ? options.locale : DEFAULT_LOCALE;
          var _locale = isFunction(locale) ? DEFAULT_LOCALE : locale;
          var fallbackLocale = isArray$1(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || isString(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
          var messages = isPlainObject$1(options.messages) ? options.messages : createResources(_locale);
          var datetimeFormats = isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : createResources(_locale);
          var numberFormats = isPlainObject$1(options.numberFormats) ? options.numberFormats : createResources(_locale);
          var modifiers = assign$2(create$1(), options.modifiers, getDefaultLinkedModifiers());
          var pluralRules = options.pluralRules || create$1();
          var missing = isFunction(options.missing) ? options.missing : null;
          var missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
          var fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
          var fallbackFormat = !!options.fallbackFormat;
          var unresolving = !!options.unresolving;
          var postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
          var processor = isPlainObject$1(options.processor) ? options.processor : null;
          var warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
          var escapeParameter = !!options.escapeParameter;
          var messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
          var messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
          var localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
          var fallbackContext = isObject$1(options.fallbackContext) ? options.fallbackContext : void 0;
          var internalOptions = options;
          var __datetimeFormatters = isObject$1(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */new Map();
          var __numberFormatters = isObject$1(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */new Map();
          var __meta = isObject$1(internalOptions.__meta) ? internalOptions.__meta : {};
          _cid++;
          var context = {
            version: version,
            cid: _cid,
            locale: locale,
            fallbackLocale: fallbackLocale,
            messages: messages,
            modifiers: modifiers,
            pluralRules: pluralRules,
            missing: missing,
            missingWarn: missingWarn,
            fallbackWarn: fallbackWarn,
            fallbackFormat: fallbackFormat,
            unresolving: unresolving,
            postTranslation: postTranslation,
            processor: processor,
            warnHtmlMessage: warnHtmlMessage,
            escapeParameter: escapeParameter,
            messageCompiler: messageCompiler,
            messageResolver: messageResolver,
            localeFallbacker: localeFallbacker,
            fallbackContext: fallbackContext,
            onWarn: onWarn,
            __meta: __meta
          };
          {
            context.datetimeFormats = datetimeFormats;
            context.numberFormats = numberFormats;
            context.__datetimeFormatters = __datetimeFormatters;
            context.__numberFormatters = __numberFormatters;
          }
          if (__INTLIFY_PROD_DEVTOOLS__) {
            initI18nDevTools(context, version, __meta);
          }
          return context;
        }
        var createResources = function createResources(locale) {
          return _defineProperty2({}, locale, create$1());
        };
        function handleMissing(context, key, locale, missingWarn, type) {
          var missing = context.missing,
            onWarn = context.onWarn;
          if (missing !== null) {
            var ret = missing(context, locale, key, type);
            return isString(ret) ? ret : key;
          } else {
            return key;
          }
        }
        function updateFallbackLocale(ctx, locale, fallback) {
          var context = ctx;
          context.__localeChainCache = /* @__PURE__ */new Map();
          ctx.localeFallbacker(ctx, fallback, locale);
        }
        function isAlmostSameLocale(locale, compareLocale) {
          if (locale === compareLocale) return false;
          return locale.split("-")[0] === compareLocale.split("-")[0];
        }
        function isImplicitFallback(targetLocale, locales) {
          var index = locales.indexOf(targetLocale);
          if (index === -1) {
            return false;
          }
          for (var i = index + 1; i < locales.length; i++) {
            if (isAlmostSameLocale(targetLocale, locales[i])) {
              return true;
            }
          }
          return false;
        }
        function datetime(context) {
          var datetimeFormats = context.datetimeFormats,
            unresolving = context.unresolving,
            fallbackLocale = context.fallbackLocale,
            onWarn = context.onWarn,
            localeFallbacker = context.localeFallbacker;
          var __datetimeFormatters = context.__datetimeFormatters;
          for (var _len21 = arguments.length, args = new Array(_len21 > 1 ? _len21 - 1 : 0), _key31 = 1; _key31 < _len21; _key31++) {
            args[_key31 - 1] = arguments[_key31];
          }
          var _parseDateTimeArgs = parseDateTimeArgs.apply(void 0, args),
            _parseDateTimeArgs2 = _slicedToArray(_parseDateTimeArgs, 4),
            key = _parseDateTimeArgs2[0],
            value = _parseDateTimeArgs2[1],
            options = _parseDateTimeArgs2[2],
            overrides = _parseDateTimeArgs2[3];
          var missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
          isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
          var part = !!options.part;
          var locale = getLocale(context, options);
          var locales = localeFallbacker(context,
          // eslint-disable-line @typescript-eslint/no-explicit-any
          fallbackLocale, locale);
          if (!isString(key) || key === "") {
            return new Intl.DateTimeFormat(locale, overrides).format(value);
          }
          var datetimeFormat = {};
          var targetLocale;
          var format2 = null;
          var type = "datetime format";
          for (var i = 0; i < locales.length; i++) {
            targetLocale = locales[i];
            datetimeFormat = datetimeFormats[targetLocale] || {};
            format2 = datetimeFormat[key];
            if (isPlainObject$1(format2)) break;
            handleMissing(context, key, targetLocale, missingWarn, type);
          }
          if (!isPlainObject$1(format2) || !isString(targetLocale)) {
            return unresolving ? NOT_REOSLVED : key;
          }
          var id = "".concat(targetLocale, "__").concat(key);
          if (!isEmptyObject(overrides)) {
            id = "".concat(id, "__").concat(JSON.stringify(overrides));
          }
          var formatter = __datetimeFormatters.get(id);
          if (!formatter) {
            formatter = new Intl.DateTimeFormat(targetLocale, assign$2({}, format2, overrides));
            __datetimeFormatters.set(id, formatter);
          }
          return !part ? formatter.format(value) : formatter.formatToParts(value);
        }
        var DATETIME_FORMAT_OPTIONS_KEYS = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];
        function parseDateTimeArgs() {
          for (var _len22 = arguments.length, args = new Array(_len22), _key32 = 0; _key32 < _len22; _key32++) {
            args[_key32] = arguments[_key32];
          }
          var arg1 = args[0],
            arg2 = args[1],
            arg3 = args[2],
            arg4 = args[3];
          var options = create$1();
          var overrides = create$1();
          var value;
          if (isString(arg1)) {
            var _matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
            if (!_matches) {
              throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
            }
            var dateTime = _matches[3] ? _matches[3].trim().startsWith("T") ? "".concat(_matches[1].trim()).concat(_matches[3].trim()) : "".concat(_matches[1].trim(), "T").concat(_matches[3].trim()) : _matches[1].trim();
            value = new Date(dateTime);
            try {
              value.toISOString();
            } catch (_unused) {
              throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
            }
          } else if (isDate(arg1)) {
            if (isNaN(arg1.getTime())) {
              throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
            }
            value = arg1;
          } else if (isNumber(arg1)) {
            value = arg1;
          } else {
            throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
          }
          if (isString(arg2)) {
            options.key = arg2;
          } else if (isPlainObject$1(arg2)) {
            Object.keys(arg2).forEach(function (key) {
              if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
                overrides[key] = arg2[key];
              } else {
                options[key] = arg2[key];
              }
            });
          }
          if (isString(arg3)) {
            options.locale = arg3;
          } else if (isPlainObject$1(arg3)) {
            overrides = arg3;
          }
          if (isPlainObject$1(arg4)) {
            overrides = arg4;
          }
          return [options.key || "", value, options, overrides];
        }
        function clearDateTimeFormat(ctx, locale, format2) {
          var context = ctx;
          for (var key in format2) {
            var id = "".concat(locale, "__").concat(key);
            if (!context.__datetimeFormatters.has(id)) {
              continue;
            }
            context.__datetimeFormatters.delete(id);
          }
        }
        function number(context) {
          var numberFormats = context.numberFormats,
            unresolving = context.unresolving,
            fallbackLocale = context.fallbackLocale,
            onWarn = context.onWarn,
            localeFallbacker = context.localeFallbacker;
          var __numberFormatters = context.__numberFormatters;
          for (var _len23 = arguments.length, args = new Array(_len23 > 1 ? _len23 - 1 : 0), _key33 = 1; _key33 < _len23; _key33++) {
            args[_key33 - 1] = arguments[_key33];
          }
          var _parseNumberArgs = parseNumberArgs.apply(void 0, args),
            _parseNumberArgs2 = _slicedToArray(_parseNumberArgs, 4),
            key = _parseNumberArgs2[0],
            value = _parseNumberArgs2[1],
            options = _parseNumberArgs2[2],
            overrides = _parseNumberArgs2[3];
          var missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
          isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
          var part = !!options.part;
          var locale = getLocale(context, options);
          var locales = localeFallbacker(context,
          // eslint-disable-line @typescript-eslint/no-explicit-any
          fallbackLocale, locale);
          if (!isString(key) || key === "") {
            return new Intl.NumberFormat(locale, overrides).format(value);
          }
          var numberFormat = {};
          var targetLocale;
          var format2 = null;
          var type = "number format";
          for (var i = 0; i < locales.length; i++) {
            targetLocale = locales[i];
            numberFormat = numberFormats[targetLocale] || {};
            format2 = numberFormat[key];
            if (isPlainObject$1(format2)) break;
            handleMissing(context, key, targetLocale, missingWarn, type);
          }
          if (!isPlainObject$1(format2) || !isString(targetLocale)) {
            return unresolving ? NOT_REOSLVED : key;
          }
          var id = "".concat(targetLocale, "__").concat(key);
          if (!isEmptyObject(overrides)) {
            id = "".concat(id, "__").concat(JSON.stringify(overrides));
          }
          var formatter = __numberFormatters.get(id);
          if (!formatter) {
            formatter = new Intl.NumberFormat(targetLocale, assign$2({}, format2, overrides));
            __numberFormatters.set(id, formatter);
          }
          return !part ? formatter.format(value) : formatter.formatToParts(value);
        }
        var NUMBER_FORMAT_OPTIONS_KEYS = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];
        function parseNumberArgs() {
          for (var _len24 = arguments.length, args = new Array(_len24), _key34 = 0; _key34 < _len24; _key34++) {
            args[_key34] = arguments[_key34];
          }
          var arg1 = args[0],
            arg2 = args[1],
            arg3 = args[2],
            arg4 = args[3];
          var options = create$1();
          var overrides = create$1();
          if (!isNumber(arg1)) {
            throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
          }
          var value = arg1;
          if (isString(arg2)) {
            options.key = arg2;
          } else if (isPlainObject$1(arg2)) {
            Object.keys(arg2).forEach(function (key) {
              if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
                overrides[key] = arg2[key];
              } else {
                options[key] = arg2[key];
              }
            });
          }
          if (isString(arg3)) {
            options.locale = arg3;
          } else if (isPlainObject$1(arg3)) {
            overrides = arg3;
          }
          if (isPlainObject$1(arg4)) {
            overrides = arg4;
          }
          return [options.key || "", value, options, overrides];
        }
        function clearNumberFormat(ctx, locale, format2) {
          var context = ctx;
          for (var key in format2) {
            var id = "".concat(locale, "__").concat(key);
            if (!context.__numberFormatters.has(id)) {
              continue;
            }
            context.__numberFormatters.delete(id);
          }
        }
        var DEFAULT_MODIFIER = function DEFAULT_MODIFIER(str) {
          return str;
        };
        var DEFAULT_MESSAGE = function DEFAULT_MESSAGE(ctx) {
          return "";
        };
        var DEFAULT_MESSAGE_DATA_TYPE = "text";
        var DEFAULT_NORMALIZE = function DEFAULT_NORMALIZE(values) {
          return values.length === 0 ? "" : join(values);
        };
        var DEFAULT_INTERPOLATE = toDisplayString;
        function pluralDefault(choice, choicesLength) {
          choice = Math.abs(choice);
          if (choicesLength === 2) {
            return choice ? choice > 1 ? 1 : 0 : 1;
          }
          return choice ? Math.min(choice, 2) : 0;
        }
        function getPluralIndex(options) {
          var index = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
          return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index : index;
        }
        function normalizeNamed(pluralIndex, props) {
          if (!props.count) {
            props.count = pluralIndex;
          }
          if (!props.n) {
            props.n = pluralIndex;
          }
        }
        function createMessageContext() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var locale = options.locale;
          var pluralIndex = getPluralIndex(options);
          var pluralRule = isObject$1(options.pluralRules) && isString(locale) && isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
          var orgPluralRule = isObject$1(options.pluralRules) && isString(locale) && isFunction(options.pluralRules[locale]) ? pluralDefault : void 0;
          var plural = function plural(messages) {
            return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
          };
          var _list = options.list || [];
          var list = function list(index) {
            return _list[index];
          };
          var _named = options.named || create$1();
          isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
          var named = function named(key) {
            return _named[key];
          };
          function message(key, useLinked) {
            var msg = isFunction(options.messages) ? options.messages(key, !!useLinked) : isObject$1(options.messages) ? options.messages[key] : false;
            return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
          }
          var _modifier = function _modifier(name) {
            return options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
          };
          var normalize = isPlainObject$1(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
          var interpolate = isPlainObject$1(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
          var type = isPlainObject$1(options.processor) && isString(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
          var linked = function linked(key) {
            for (var _len25 = arguments.length, args = new Array(_len25 > 1 ? _len25 - 1 : 0), _key35 = 1; _key35 < _len25; _key35++) {
              args[_key35 - 1] = arguments[_key35];
            }
            var arg1 = args[0],
              arg2 = args[1];
            var type2 = "text";
            var modifier = "";
            if (args.length === 1) {
              if (isObject$1(arg1)) {
                modifier = arg1.modifier || modifier;
                type2 = arg1.type || type2;
              } else if (isString(arg1)) {
                modifier = arg1 || modifier;
              }
            } else if (args.length === 2) {
              if (isString(arg1)) {
                modifier = arg1 || modifier;
              }
              if (isString(arg2)) {
                type2 = arg2 || type2;
              }
            }
            var ret = message(key, true)(ctx);
            var msg =
            // The message in vnode resolved with linked are returned as an array by processor.nomalize
            type2 === "vnode" && isArray$1(ret) && modifier ? ret[0] : ret;
            return modifier ? _modifier(modifier)(msg, type2) : msg;
          };
          var ctx = _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, "list"
          /* HelperNameMap.LIST */, list), "named"
          /* HelperNameMap.NAMED */, named), "plural"
          /* HelperNameMap.PLURAL */, plural), "linked"
          /* HelperNameMap.LINKED */, linked), "message"
          /* HelperNameMap.MESSAGE */, message), "type"
          /* HelperNameMap.TYPE */, type), "interpolate"
          /* HelperNameMap.INTERPOLATE */, interpolate), "normalize"
          /* HelperNameMap.NORMALIZE */, normalize), "values"
          /* HelperNameMap.VALUES */, assign$2(create$1(), _list, _named));
          return ctx;
        }
        var NOOP_MESSAGE_FUNCTION = function NOOP_MESSAGE_FUNCTION() {
          return "";
        };
        var isMessageFunction = function isMessageFunction(val) {
          return isFunction(val);
        };
        function translate(context) {
          var fallbackFormat = context.fallbackFormat,
            postTranslation = context.postTranslation,
            unresolving = context.unresolving,
            messageCompiler = context.messageCompiler,
            fallbackLocale = context.fallbackLocale,
            messages = context.messages;
          for (var _len26 = arguments.length, args = new Array(_len26 > 1 ? _len26 - 1 : 0), _key36 = 1; _key36 < _len26; _key36++) {
            args[_key36 - 1] = arguments[_key36];
          }
          var _parseTranslateArgs = parseTranslateArgs.apply(void 0, args),
            _parseTranslateArgs2 = _slicedToArray(_parseTranslateArgs, 2),
            key = _parseTranslateArgs2[0],
            options = _parseTranslateArgs2[1];
          var missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
          var fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
          var escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
          var resolvedMessage = !!options.resolvedMessage;
          var defaultMsgOrKey = isString(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? function () {
            return key;
          } : key : fallbackFormat ? !messageCompiler ? function () {
            return key;
          } : key : null;
          var enableDefaultMsg = fallbackFormat || defaultMsgOrKey != null && (isString(defaultMsgOrKey) || isFunction(defaultMsgOrKey));
          var locale = getLocale(context, options);
          escapeParameter && escapeParams(options);
          var _ref52 = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [key, locale, messages[locale] || create$1()],
            _ref53 = _slicedToArray(_ref52, 3),
            formatScope = _ref53[0],
            targetLocale = _ref53[1],
            message = _ref53[2];
          var format2 = formatScope;
          var cacheBaseKey = key;
          if (!resolvedMessage && !(isString(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
            if (enableDefaultMsg) {
              format2 = defaultMsgOrKey;
              cacheBaseKey = format2;
            }
          }
          if (!resolvedMessage && (!(isString(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString(targetLocale))) {
            return unresolving ? NOT_REOSLVED : key;
          }
          var occurred = false;
          var onError = function onError() {
            occurred = true;
          };
          var msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
          if (occurred) {
            return format2;
          }
          var ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
          var msgContext = createMessageContext(ctxOptions);
          var messaged = evaluateMessage(context, msg, msgContext);
          var ret = postTranslation ? postTranslation(messaged, key) : messaged;
          if (__INTLIFY_PROD_DEVTOOLS__) {
            var payloads = {
              timestamp: Date.now(),
              key: isString(key) ? key : isMessageFunction(format2) ? format2.key : "",
              locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
              format: isString(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
              message: ret
            };
            payloads.meta = assign$2({}, context.__meta, /* @__PURE__ */getAdditionalMeta() || {});
            translateDevTools(payloads);
          }
          return ret;
        }
        function escapeParams(options) {
          if (isArray$1(options.list)) {
            options.list = options.list.map(function (item) {
              return isString(item) ? escapeHtml(item) : item;
            });
          } else if (isObject$1(options.named)) {
            Object.keys(options.named).forEach(function (key) {
              if (isString(options.named[key])) {
                options.named[key] = escapeHtml(options.named[key]);
              }
            });
          }
        }
        function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
          var messages = context.messages,
            onWarn = context.onWarn,
            resolveValue2 = context.messageResolver,
            localeFallbacker = context.localeFallbacker;
          var locales = localeFallbacker(context, fallbackLocale, locale);
          var message = create$1();
          var targetLocale;
          var format2 = null;
          var type = "translate";
          for (var i = 0; i < locales.length; i++) {
            targetLocale = locales[i];
            message = messages[targetLocale] || create$1();
            if ((format2 = resolveValue2(message, key)) === null) {
              format2 = message[key];
            }
            if (isString(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
              break;
            }
            if (!isImplicitFallback(targetLocale, locales)) {
              var missingRet = handleMissing(context,
              // eslint-disable-line @typescript-eslint/no-explicit-any
              key, targetLocale, missingWarn, type);
              if (missingRet !== key) {
                format2 = missingRet;
              }
            }
          }
          return [format2, targetLocale, message];
        }
        function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
          var messageCompiler = context.messageCompiler,
            warnHtmlMessage = context.warnHtmlMessage;
          if (isMessageFunction(format2)) {
            var msg2 = format2;
            msg2.locale = msg2.locale || targetLocale;
            msg2.key = msg2.key || key;
            return msg2;
          }
          if (messageCompiler == null) {
            var _msg = function _msg() {
              return format2;
            };
            _msg.locale = targetLocale;
            _msg.key = key;
            return _msg;
          }
          var msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
          msg.locale = targetLocale;
          msg.key = key;
          msg.source = format2;
          return msg;
        }
        function evaluateMessage(context, msg, msgCtx) {
          var messaged = msg(msgCtx);
          return messaged;
        }
        function parseTranslateArgs() {
          for (var _len27 = arguments.length, args = new Array(_len27), _key37 = 0; _key37 < _len27; _key37++) {
            args[_key37] = arguments[_key37];
          }
          var arg1 = args[0],
            arg2 = args[1],
            arg3 = args[2];
          var options = create$1();
          if (!isString(arg1) && !isNumber(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
            throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
          }
          var key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
          if (isNumber(arg2)) {
            options.plural = arg2;
          } else if (isString(arg2)) {
            options.default = arg2;
          } else if (isPlainObject$1(arg2) && !isEmptyObject(arg2)) {
            options.named = arg2;
          } else if (isArray$1(arg2)) {
            options.list = arg2;
          }
          if (isNumber(arg3)) {
            options.plural = arg3;
          } else if (isString(arg3)) {
            options.default = arg3;
          } else if (isPlainObject$1(arg3)) {
            assign$2(options, arg3);
          }
          return [key, options];
        }
        function getCompileContext(context, locale, key, source, warnHtmlMessage, _onError) {
          return {
            locale: locale,
            key: key,
            warnHtmlMessage: warnHtmlMessage,
            onError: function onError(err) {
              _onError && _onError(err);
              {
                throw err;
              }
            },
            onCacheKey: function onCacheKey(source2) {
              return generateFormatCacheKey(locale, key, source2);
            }
          };
        }
        function getMessageContextOptions(context, locale, message, options) {
          var modifiers = context.modifiers,
            pluralRules = context.pluralRules,
            resolveValue2 = context.messageResolver,
            fallbackLocale = context.fallbackLocale,
            fallbackWarn = context.fallbackWarn,
            missingWarn = context.missingWarn,
            fallbackContext = context.fallbackContext;
          var resolveMessage = function resolveMessage(key, useLinked) {
            var val = resolveValue2(message, key);
            if (val == null && (fallbackContext || useLinked)) {
              var _resolveMessageFormat = resolveMessageFormat(fallbackContext || context,
                // NOTE: if has fallbackContext, fallback to root, else if use linked, fallback to local context
                key, locale, fallbackLocale, fallbackWarn, missingWarn),
                _resolveMessageFormat2 = _slicedToArray(_resolveMessageFormat, 3),
                message2 = _resolveMessageFormat2[2];
              val = resolveValue2(message2, key);
            }
            if (isString(val) || isMessageAST(val)) {
              var occurred = false;
              var onError = function onError() {
                occurred = true;
              };
              var msg = compileMessageFormat(context, key, locale, val, key, onError);
              return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
            } else if (isMessageFunction(val)) {
              return val;
            } else {
              return NOOP_MESSAGE_FUNCTION;
            }
          };
          var ctxOptions = {
            locale: locale,
            modifiers: modifiers,
            pluralRules: pluralRules,
            messages: resolveMessage
          };
          if (context.processor) {
            ctxOptions.processor = context.processor;
          }
          if (options.list) {
            ctxOptions.list = options.list;
          }
          if (options.named) {
            ctxOptions.named = options.named;
          }
          if (isNumber(options.plural)) {
            ctxOptions.pluralIndex = options.plural;
          }
          return ctxOptions;
        }
        {
          initFeatureFlags$1();
        }

        /*!
          * vue-i18n v10.0.5
          * (c) 2024 kazuya kawaguchi
          * Released under the MIT License.
          */
        var VERSION = "10.0.5";
        function initFeatureFlags() {
          if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
            getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
          }
          if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
            getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
          }
          if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
            getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
          }
          if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
            getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
          }
        }
        var I18nErrorCodes = {
          // composer module errors
          UNEXPECTED_RETURN_TYPE: CORE_ERROR_CODES_EXTEND_POINT,
          // 24
          // legacy module errors
          INVALID_ARGUMENT: 25,
          // i18n module errors
          MUST_BE_CALL_SETUP_TOP: 26,
          NOT_INSTALLED: 27,
          // directive module errors
          REQUIRED_VALUE: 28,
          INVALID_VALUE: 29,
          // vue-devtools errors
          CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: 30,
          NOT_INSTALLED_WITH_PROVIDE: 31,
          // unexpected error
          UNEXPECTED_ERROR: 32,
          // not compatible legacy vue-i18n constructor
          NOT_COMPATIBLE_LEGACY_VUE_I18N: 33,
          // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
          NOT_AVAILABLE_COMPOSITION_IN_LEGACY: 34
        };
        function createI18nError(code) {
          return createCompileError(code, null, void 0);
        }
        var TranslateVNodeSymbol = /* @__PURE__ */makeSymbol("__translateVNode");
        var DatetimePartsSymbol = /* @__PURE__ */makeSymbol("__datetimeParts");
        var NumberPartsSymbol = /* @__PURE__ */makeSymbol("__numberParts");
        var SetPluralRulesSymbol = makeSymbol("__setPluralRules");
        var InejctWithOptionSymbol = /* @__PURE__ */makeSymbol("__injectWithOption");
        var DisposeSymbol = /* @__PURE__ */makeSymbol("__dispose");
        function handleFlatJson(obj) {
          if (!isObject$1(obj)) {
            return obj;
          }
          for (var key in obj) {
            if (!hasOwn(obj, key)) {
              continue;
            }
            if (!key.includes(".")) {
              if (isObject$1(obj[key])) {
                handleFlatJson(obj[key]);
              }
            } else {
              var subKeys = key.split(".");
              var lastIndex = subKeys.length - 1;
              var currentObj = obj;
              var hasStringValue = false;
              for (var i = 0; i < lastIndex; i++) {
                if (!(subKeys[i] in currentObj)) {
                  currentObj[subKeys[i]] = create$1();
                }
                if (!isObject$1(currentObj[subKeys[i]])) {
                  hasStringValue = true;
                  break;
                }
                currentObj = currentObj[subKeys[i]];
              }
              if (!hasStringValue) {
                currentObj[subKeys[lastIndex]] = obj[key];
                delete obj[key];
              }
              if (isObject$1(currentObj[subKeys[lastIndex]])) {
                handleFlatJson(currentObj[subKeys[lastIndex]]);
              }
            }
          }
          return obj;
        }
        function getLocaleMessages(locale, options) {
          var messages = options.messages,
            __i18n = options.__i18n,
            messageResolver = options.messageResolver,
            flatJson = options.flatJson;
          var ret = isPlainObject$1(messages) ? messages : isArray$1(__i18n) ? create$1() : _defineProperty2({}, locale, create$1());
          if (isArray$1(__i18n)) {
            __i18n.forEach(function (custom) {
              if ("locale" in custom && "resource" in custom) {
                var locale2 = custom.locale,
                  resource = custom.resource;
                if (locale2) {
                  ret[locale2] = ret[locale2] || create$1();
                  deepCopy(resource, ret[locale2]);
                } else {
                  deepCopy(resource, ret);
                }
              } else {
                isString(custom) && deepCopy(JSON.parse(custom), ret);
              }
            });
          }
          if (messageResolver == null && flatJson) {
            for (var key in ret) {
              if (hasOwn(ret, key)) {
                handleFlatJson(ret[key]);
              }
            }
          }
          return ret;
        }
        function getComponentOptions(instance) {
          return instance.type;
        }
        function adjustI18nResources(gl, options, componentOptions) {
          var messages = isObject$1(options.messages) ? options.messages : create$1();
          if ("__i18nGlobal" in componentOptions) {
            messages = getLocaleMessages(gl.locale.value, {
              messages: messages,
              __i18n: componentOptions.__i18nGlobal
            });
          }
          var locales = Object.keys(messages);
          if (locales.length) {
            locales.forEach(function (locale) {
              gl.mergeLocaleMessage(locale, messages[locale]);
            });
          }
          {
            if (isObject$1(options.datetimeFormats)) {
              var locales2 = Object.keys(options.datetimeFormats);
              if (locales2.length) {
                locales2.forEach(function (locale) {
                  gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
                });
              }
            }
            if (isObject$1(options.numberFormats)) {
              var _locales = Object.keys(options.numberFormats);
              if (_locales.length) {
                _locales.forEach(function (locale) {
                  gl.mergeNumberFormat(locale, options.numberFormats[locale]);
                });
              }
            }
          }
        }
        function createTextNode(key) {
          return createVNode(Text, null, key, 0);
        }
        var DEVTOOLS_META = "__INTLIFY_META__";
        var NOOP_RETURN_ARRAY = function NOOP_RETURN_ARRAY() {
          return [];
        };
        var NOOP_RETURN_FALSE = function NOOP_RETURN_FALSE() {
          return false;
        };
        var composerID = 0;
        function defineCoreMissingHandler(missing) {
          return function (ctx, locale, key, type) {
            return missing(locale, key, getCurrentInstance() || void 0, type);
          };
        }
        var getMetaInfo = /* @__NO_SIDE_EFFECTS__ */function getMetaInfo() {
          var instance = getCurrentInstance();
          var meta = null;
          return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? _defineProperty2({}, DEVTOOLS_META, meta) : null;
        };
        function createComposer() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var __root = options.__root,
            __injectWithOption = options.__injectWithOption;
          var _isGlobal = __root === void 0;
          var flatJson = options.flatJson;
          var _ref = inBrowser ? ref : shallowRef;
          var _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
          var _locale = _ref(
          // prettier-ignore
          __root && _inheritLocale ? __root.locale.value : isString(options.locale) ? options.locale : DEFAULT_LOCALE);
          var _fallbackLocale = _ref(
          // prettier-ignore
          __root && _inheritLocale ? __root.fallbackLocale.value : isString(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value);
          var _messages = _ref(getLocaleMessages(_locale.value, options));
          var _datetimeFormats = _ref(isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : _defineProperty2({}, _locale.value, {}));
          var _numberFormats = _ref(isPlainObject$1(options.numberFormats) ? options.numberFormats : _defineProperty2({}, _locale.value, {}));
          var _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
          var _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
          var _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
          var _fallbackFormat = !!options.fallbackFormat;
          var _missing = isFunction(options.missing) ? options.missing : null;
          var _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
          var _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
          var _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
          var _escapeParameter = !!options.escapeParameter;
          var _modifiers = __root ? __root.modifiers : isPlainObject$1(options.modifiers) ? options.modifiers : {};
          var _pluralRules = options.pluralRules || __root && __root.pluralRules;
          var _context;
          var getCoreContext = function getCoreContext() {
            _isGlobal && setFallbackContext(null);
            var ctxOptions = {
              version: VERSION,
              locale: _locale.value,
              fallbackLocale: _fallbackLocale.value,
              messages: _messages.value,
              modifiers: _modifiers,
              pluralRules: _pluralRules,
              missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
              missingWarn: _missingWarn,
              fallbackWarn: _fallbackWarn,
              fallbackFormat: _fallbackFormat,
              unresolving: true,
              postTranslation: _postTranslation === null ? void 0 : _postTranslation,
              warnHtmlMessage: _warnHtmlMessage,
              escapeParameter: _escapeParameter,
              messageResolver: options.messageResolver,
              messageCompiler: options.messageCompiler,
              __meta: {
                framework: "vue"
              }
            };
            {
              ctxOptions.datetimeFormats = _datetimeFormats.value;
              ctxOptions.numberFormats = _numberFormats.value;
              ctxOptions.__datetimeFormatters = isPlainObject$1(_context) ? _context.__datetimeFormatters : void 0;
              ctxOptions.__numberFormatters = isPlainObject$1(_context) ? _context.__numberFormatters : void 0;
            }
            var ctx = createCoreContext(ctxOptions);
            _isGlobal && setFallbackContext(ctx);
            return ctx;
          };
          _context = getCoreContext();
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
          function trackReactivityValues() {
            return [_locale.value, _fallbackLocale.value, _messages.value, _datetimeFormats.value, _numberFormats.value];
          }
          var locale = computed({
            get: function get() {
              return _locale.value;
            },
            set: function set(val) {
              _locale.value = val;
              _context.locale = _locale.value;
            }
          });
          var fallbackLocale = computed({
            get: function get() {
              return _fallbackLocale.value;
            },
            set: function set(val) {
              _fallbackLocale.value = val;
              _context.fallbackLocale = _fallbackLocale.value;
              updateFallbackLocale(_context, _locale.value, val);
            }
          });
          var messages = computed(function () {
            return _messages.value;
          });
          var datetimeFormats = /* @__PURE__ */computed(function () {
            return _datetimeFormats.value;
          });
          var numberFormats = /* @__PURE__ */computed(function () {
            return _numberFormats.value;
          });
          function getPostTranslationHandler() {
            return isFunction(_postTranslation) ? _postTranslation : null;
          }
          function setPostTranslationHandler(handler) {
            _postTranslation = handler;
            _context.postTranslation = handler;
          }
          function getMissingHandler() {
            return _missing;
          }
          function setMissingHandler(handler) {
            if (handler !== null) {
              _runtimeMissing = defineCoreMissingHandler(handler);
            }
            _missing = handler;
            _context.missing = _runtimeMissing;
          }
          var wrapWithDeps = function wrapWithDeps(fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) {
            trackReactivityValues();
            var ret;
            try {
              if (__INTLIFY_PROD_DEVTOOLS__) {
                setAdditionalMeta(/* @__PURE__ */getMetaInfo());
              }
              if (!_isGlobal) {
                _context.fallbackContext = __root ? getFallbackContext() : void 0;
              }
              ret = fn(_context);
            } finally {
              if (__INTLIFY_PROD_DEVTOOLS__) ;
              if (!_isGlobal) {
                _context.fallbackContext = void 0;
              }
            }
            if (warnType !== "translate exists" &&
            // for not `te` (e.g `t`)
            isNumber(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
              var _argumentParser = argumentParser(),
                _argumentParser2 = _slicedToArray(_argumentParser, 2),
                key = _argumentParser2[0],
                arg2 = _argumentParser2[1];
              return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
            } else if (successCondition(ret)) {
              return ret;
            } else {
              throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
            }
          };
          function t() {
            for (var _len28 = arguments.length, args = new Array(_len28), _key38 = 0; _key38 < _len28; _key38++) {
              args[_key38] = arguments[_key38];
            }
            return wrapWithDeps(function (context) {
              return Reflect.apply(translate, null, [context].concat(args));
            }, function () {
              return parseTranslateArgs.apply(void 0, args);
            }, "translate", function (root) {
              return Reflect.apply(root.t, root, [].concat(args));
            }, function (key) {
              return key;
            }, function (val) {
              return isString(val);
            });
          }
          function rt() {
            for (var _len29 = arguments.length, args = new Array(_len29), _key39 = 0; _key39 < _len29; _key39++) {
              args[_key39] = arguments[_key39];
            }
            var arg1 = args[0],
              arg2 = args[1],
              arg3 = args[2];
            if (arg3 && !isObject$1(arg3)) {
              throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
            }
            return t.apply(void 0, [arg1, arg2, assign$2({
              resolvedMessage: true
            }, arg3 || {})]);
          }
          function d() {
            for (var _len30 = arguments.length, args = new Array(_len30), _key40 = 0; _key40 < _len30; _key40++) {
              args[_key40] = arguments[_key40];
            }
            return wrapWithDeps(function (context) {
              return Reflect.apply(datetime, null, [context].concat(args));
            }, function () {
              return parseDateTimeArgs.apply(void 0, args);
            }, "datetime format", function (root) {
              return Reflect.apply(root.d, root, [].concat(args));
            }, function () {
              return MISSING_RESOLVE_VALUE;
            }, function (val) {
              return isString(val);
            });
          }
          function n() {
            for (var _len31 = arguments.length, args = new Array(_len31), _key41 = 0; _key41 < _len31; _key41++) {
              args[_key41] = arguments[_key41];
            }
            return wrapWithDeps(function (context) {
              return Reflect.apply(number, null, [context].concat(args));
            }, function () {
              return parseNumberArgs.apply(void 0, args);
            }, "number format", function (root) {
              return Reflect.apply(root.n, root, [].concat(args));
            }, function () {
              return MISSING_RESOLVE_VALUE;
            }, function (val) {
              return isString(val);
            });
          }
          function normalize(values) {
            return values.map(function (val) {
              return isString(val) || isNumber(val) || isBoolean(val) ? createTextNode(String(val)) : val;
            });
          }
          var interpolate = function interpolate(val) {
            return val;
          };
          var processor = {
            normalize: normalize,
            interpolate: interpolate,
            type: "vnode"
          };
          function translateVNode() {
            for (var _len32 = arguments.length, args = new Array(_len32), _key42 = 0; _key42 < _len32; _key42++) {
              args[_key42] = arguments[_key42];
            }
            return wrapWithDeps(function (context) {
              var ret;
              var _context2 = context;
              try {
                _context2.processor = processor;
                ret = Reflect.apply(translate, null, [_context2].concat(args));
              } finally {
                _context2.processor = null;
              }
              return ret;
            }, function () {
              return parseTranslateArgs.apply(void 0, args);
            }, "translate", function (root) {
              return root[TranslateVNodeSymbol].apply(root, args);
            }, function (key) {
              return [createTextNode(key)];
            }, function (val) {
              return isArray$1(val);
            });
          }
          function numberParts() {
            for (var _len33 = arguments.length, args = new Array(_len33), _key43 = 0; _key43 < _len33; _key43++) {
              args[_key43] = arguments[_key43];
            }
            return wrapWithDeps(function (context) {
              return Reflect.apply(number, null, [context].concat(args));
            }, function () {
              return parseNumberArgs.apply(void 0, args);
            }, "number format", function (root) {
              return root[NumberPartsSymbol].apply(root, args);
            }, NOOP_RETURN_ARRAY, function (val) {
              return isString(val) || isArray$1(val);
            });
          }
          function datetimeParts() {
            for (var _len34 = arguments.length, args = new Array(_len34), _key44 = 0; _key44 < _len34; _key44++) {
              args[_key44] = arguments[_key44];
            }
            return wrapWithDeps(function (context) {
              return Reflect.apply(datetime, null, [context].concat(args));
            }, function () {
              return parseDateTimeArgs.apply(void 0, args);
            }, "datetime format", function (root) {
              return root[DatetimePartsSymbol].apply(root, args);
            }, NOOP_RETURN_ARRAY, function (val) {
              return isString(val) || isArray$1(val);
            });
          }
          function setPluralRules(rules) {
            _pluralRules = rules;
            _context.pluralRules = _pluralRules;
          }
          function te(key, locale2) {
            return wrapWithDeps(function () {
              if (!key) {
                return false;
              }
              var targetLocale = isString(locale2) ? locale2 : _locale.value;
              var message = getLocaleMessage(targetLocale);
              var resolved = _context.messageResolver(message, key);
              return isMessageAST(resolved) || isMessageFunction(resolved) || isString(resolved);
            }, function () {
              return [key];
            }, "translate exists", function (root) {
              return Reflect.apply(root.te, root, [key, locale2]);
            }, NOOP_RETURN_FALSE, function (val) {
              return isBoolean(val);
            });
          }
          function resolveMessages(key) {
            var messages2 = null;
            var locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
            for (var i = 0; i < locales.length; i++) {
              var targetLocaleMessages = _messages.value[locales[i]] || {};
              var messageValue = _context.messageResolver(targetLocaleMessages, key);
              if (messageValue != null) {
                messages2 = messageValue;
                break;
              }
            }
            return messages2;
          }
          function tm(key) {
            var messages2 = resolveMessages(key);
            return messages2 != null ? messages2 : __root ? __root.tm(key) || {} : {};
          }
          function getLocaleMessage(locale2) {
            return _messages.value[locale2] || {};
          }
          function setLocaleMessage(locale2, message) {
            if (flatJson) {
              var _message = _defineProperty2({}, locale2, message);
              for (var key in _message) {
                if (hasOwn(_message, key)) {
                  handleFlatJson(_message[key]);
                }
              }
              message = _message[locale2];
            }
            _messages.value[locale2] = message;
            _context.messages = _messages.value;
          }
          function mergeLocaleMessage(locale2, message) {
            _messages.value[locale2] = _messages.value[locale2] || {};
            var _message = _defineProperty2({}, locale2, message);
            if (flatJson) {
              for (var key in _message) {
                if (hasOwn(_message, key)) {
                  handleFlatJson(_message[key]);
                }
              }
            }
            message = _message[locale2];
            deepCopy(message, _messages.value[locale2]);
            _context.messages = _messages.value;
          }
          function getDateTimeFormat(locale2) {
            return _datetimeFormats.value[locale2] || {};
          }
          function setDateTimeFormat(locale2, format2) {
            _datetimeFormats.value[locale2] = format2;
            _context.datetimeFormats = _datetimeFormats.value;
            clearDateTimeFormat(_context, locale2, format2);
          }
          function mergeDateTimeFormat(locale2, format2) {
            _datetimeFormats.value[locale2] = assign$2(_datetimeFormats.value[locale2] || {}, format2);
            _context.datetimeFormats = _datetimeFormats.value;
            clearDateTimeFormat(_context, locale2, format2);
          }
          function getNumberFormat(locale2) {
            return _numberFormats.value[locale2] || {};
          }
          function setNumberFormat(locale2, format2) {
            _numberFormats.value[locale2] = format2;
            _context.numberFormats = _numberFormats.value;
            clearNumberFormat(_context, locale2, format2);
          }
          function mergeNumberFormat(locale2, format2) {
            _numberFormats.value[locale2] = assign$2(_numberFormats.value[locale2] || {}, format2);
            _context.numberFormats = _numberFormats.value;
            clearNumberFormat(_context, locale2, format2);
          }
          composerID++;
          if (__root && inBrowser) {
            watch(__root.locale, function (val) {
              if (_inheritLocale) {
                _locale.value = val;
                _context.locale = val;
                updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
              }
            });
            watch(__root.fallbackLocale, function (val) {
              if (_inheritLocale) {
                _fallbackLocale.value = val;
                _context.fallbackLocale = val;
                updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
              }
            });
          }
          var composer = _defineProperty2({
            id: composerID,
            locale: locale,
            fallbackLocale: fallbackLocale,
            get inheritLocale() {
              return _inheritLocale;
            },
            set inheritLocale(val) {
              _inheritLocale = val;
              if (val && __root) {
                _locale.value = __root.locale.value;
                _fallbackLocale.value = __root.fallbackLocale.value;
                updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
              }
            },
            get availableLocales() {
              return Object.keys(_messages.value).sort();
            },
            messages: messages,
            get modifiers() {
              return _modifiers;
            },
            get pluralRules() {
              return _pluralRules || {};
            },
            get isGlobal() {
              return _isGlobal;
            },
            get missingWarn() {
              return _missingWarn;
            },
            set missingWarn(val) {
              _missingWarn = val;
              _context.missingWarn = _missingWarn;
            },
            get fallbackWarn() {
              return _fallbackWarn;
            },
            set fallbackWarn(val) {
              _fallbackWarn = val;
              _context.fallbackWarn = _fallbackWarn;
            },
            get fallbackRoot() {
              return _fallbackRoot;
            },
            set fallbackRoot(val) {
              _fallbackRoot = val;
            },
            get fallbackFormat() {
              return _fallbackFormat;
            },
            set fallbackFormat(val) {
              _fallbackFormat = val;
              _context.fallbackFormat = _fallbackFormat;
            },
            get warnHtmlMessage() {
              return _warnHtmlMessage;
            },
            set warnHtmlMessage(val) {
              _warnHtmlMessage = val;
              _context.warnHtmlMessage = val;
            },
            get escapeParameter() {
              return _escapeParameter;
            },
            set escapeParameter(val) {
              _escapeParameter = val;
              _context.escapeParameter = val;
            },
            t: t,
            getLocaleMessage: getLocaleMessage,
            setLocaleMessage: setLocaleMessage,
            mergeLocaleMessage: mergeLocaleMessage,
            getPostTranslationHandler: getPostTranslationHandler,
            setPostTranslationHandler: setPostTranslationHandler,
            getMissingHandler: getMissingHandler,
            setMissingHandler: setMissingHandler
          }, SetPluralRulesSymbol, setPluralRules);
          {
            composer.datetimeFormats = datetimeFormats;
            composer.numberFormats = numberFormats;
            composer.rt = rt;
            composer.te = te;
            composer.tm = tm;
            composer.d = d;
            composer.n = n;
            composer.getDateTimeFormat = getDateTimeFormat;
            composer.setDateTimeFormat = setDateTimeFormat;
            composer.mergeDateTimeFormat = mergeDateTimeFormat;
            composer.getNumberFormat = getNumberFormat;
            composer.setNumberFormat = setNumberFormat;
            composer.mergeNumberFormat = mergeNumberFormat;
            composer[InejctWithOptionSymbol] = __injectWithOption;
            composer[TranslateVNodeSymbol] = translateVNode;
            composer[DatetimePartsSymbol] = datetimeParts;
            composer[NumberPartsSymbol] = numberParts;
          }
          return composer;
        }
        function convertComposerOptions(options) {
          var locale = isString(options.locale) ? options.locale : DEFAULT_LOCALE;
          var fallbackLocale = isString(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
          var missing = isFunction(options.missing) ? options.missing : void 0;
          var missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
          var fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
          var fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
          var fallbackFormat = !!options.formatFallbackMessages;
          var modifiers = isPlainObject$1(options.modifiers) ? options.modifiers : {};
          var pluralizationRules = options.pluralizationRules;
          var postTranslation = isFunction(options.postTranslation) ? options.postTranslation : void 0;
          var warnHtmlMessage = isString(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
          var escapeParameter = !!options.escapeParameterHtml;
          var inheritLocale = isBoolean(options.sync) ? options.sync : true;
          var messages = options.messages;
          if (isPlainObject$1(options.sharedMessages)) {
            var sharedMessages = options.sharedMessages;
            var locales = Object.keys(sharedMessages);
            messages = locales.reduce(function (messages2, locale2) {
              var message = messages2[locale2] || (messages2[locale2] = {});
              assign$2(message, sharedMessages[locale2]);
              return messages2;
            }, messages || {});
          }
          var __i18n = options.__i18n,
            __root = options.__root,
            __injectWithOption = options.__injectWithOption;
          var datetimeFormats = options.datetimeFormats;
          var numberFormats = options.numberFormats;
          var flatJson = options.flatJson;
          return {
            locale: locale,
            fallbackLocale: fallbackLocale,
            messages: messages,
            flatJson: flatJson,
            datetimeFormats: datetimeFormats,
            numberFormats: numberFormats,
            missing: missing,
            missingWarn: missingWarn,
            fallbackWarn: fallbackWarn,
            fallbackRoot: fallbackRoot,
            fallbackFormat: fallbackFormat,
            modifiers: modifiers,
            pluralRules: pluralizationRules,
            postTranslation: postTranslation,
            warnHtmlMessage: warnHtmlMessage,
            escapeParameter: escapeParameter,
            messageResolver: options.messageResolver,
            inheritLocale: inheritLocale,
            __i18n: __i18n,
            __root: __root,
            __injectWithOption: __injectWithOption
          };
        }
        function createVueI18n() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var composer = createComposer(convertComposerOptions(options));
          var __extender = options.__extender;
          var vueI18n = {
            // id
            id: composer.id,
            // locale
            get locale() {
              return composer.locale.value;
            },
            set locale(val) {
              composer.locale.value = val;
            },
            // fallbackLocale
            get fallbackLocale() {
              return composer.fallbackLocale.value;
            },
            set fallbackLocale(val) {
              composer.fallbackLocale.value = val;
            },
            // messages
            get messages() {
              return composer.messages.value;
            },
            // datetimeFormats
            get datetimeFormats() {
              return composer.datetimeFormats.value;
            },
            // numberFormats
            get numberFormats() {
              return composer.numberFormats.value;
            },
            // availableLocales
            get availableLocales() {
              return composer.availableLocales;
            },
            // missing
            get missing() {
              return composer.getMissingHandler();
            },
            set missing(handler) {
              composer.setMissingHandler(handler);
            },
            // silentTranslationWarn
            get silentTranslationWarn() {
              return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
            },
            set silentTranslationWarn(val) {
              composer.missingWarn = isBoolean(val) ? !val : val;
            },
            // silentFallbackWarn
            get silentFallbackWarn() {
              return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
            },
            set silentFallbackWarn(val) {
              composer.fallbackWarn = isBoolean(val) ? !val : val;
            },
            // modifiers
            get modifiers() {
              return composer.modifiers;
            },
            // formatFallbackMessages
            get formatFallbackMessages() {
              return composer.fallbackFormat;
            },
            set formatFallbackMessages(val) {
              composer.fallbackFormat = val;
            },
            // postTranslation
            get postTranslation() {
              return composer.getPostTranslationHandler();
            },
            set postTranslation(handler) {
              composer.setPostTranslationHandler(handler);
            },
            // sync
            get sync() {
              return composer.inheritLocale;
            },
            set sync(val) {
              composer.inheritLocale = val;
            },
            // warnInHtmlMessage
            get warnHtmlInMessage() {
              return composer.warnHtmlMessage ? "warn" : "off";
            },
            set warnHtmlInMessage(val) {
              composer.warnHtmlMessage = val !== "off";
            },
            // escapeParameterHtml
            get escapeParameterHtml() {
              return composer.escapeParameter;
            },
            set escapeParameterHtml(val) {
              composer.escapeParameter = val;
            },
            // pluralizationRules
            get pluralizationRules() {
              return composer.pluralRules || {};
            },
            // for internal
            __composer: composer,
            // t
            t: function t() {
              for (var _len35 = arguments.length, args = new Array(_len35), _key45 = 0; _key45 < _len35; _key45++) {
                args[_key45] = arguments[_key45];
              }
              return Reflect.apply(composer.t, composer, [].concat(args));
            },
            // rt
            rt: function rt() {
              for (var _len36 = arguments.length, args = new Array(_len36), _key46 = 0; _key46 < _len36; _key46++) {
                args[_key46] = arguments[_key46];
              }
              return Reflect.apply(composer.rt, composer, [].concat(args));
            },
            // tc
            tc: function tc() {
              for (var _len37 = arguments.length, args = new Array(_len37), _key47 = 0; _key47 < _len37; _key47++) {
                args[_key47] = arguments[_key47];
              }
              var arg1 = args[0],
                arg2 = args[1],
                arg3 = args[2];
              var options2 = {
                plural: 1
              };
              var list = null;
              var named = null;
              if (!isString(arg1)) {
                throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
              }
              var key = arg1;
              if (isString(arg2)) {
                options2.locale = arg2;
              } else if (isNumber(arg2)) {
                options2.plural = arg2;
              } else if (isArray$1(arg2)) {
                list = arg2;
              } else if (isPlainObject$1(arg2)) {
                named = arg2;
              }
              if (isString(arg3)) {
                options2.locale = arg3;
              } else if (isArray$1(arg3)) {
                list = arg3;
              } else if (isPlainObject$1(arg3)) {
                named = arg3;
              }
              return Reflect.apply(composer.t, composer, [key, list || named || {}, options2]);
            },
            // te
            te: function te(key, locale) {
              return composer.te(key, locale);
            },
            // tm
            tm: function tm(key) {
              return composer.tm(key);
            },
            // getLocaleMessage
            getLocaleMessage: function getLocaleMessage(locale) {
              return composer.getLocaleMessage(locale);
            },
            // setLocaleMessage
            setLocaleMessage: function setLocaleMessage(locale, message) {
              composer.setLocaleMessage(locale, message);
            },
            // mergeLocaleMessage
            mergeLocaleMessage: function mergeLocaleMessage(locale, message) {
              composer.mergeLocaleMessage(locale, message);
            },
            // d
            d: function d() {
              for (var _len38 = arguments.length, args = new Array(_len38), _key48 = 0; _key48 < _len38; _key48++) {
                args[_key48] = arguments[_key48];
              }
              return Reflect.apply(composer.d, composer, [].concat(args));
            },
            // getDateTimeFormat
            getDateTimeFormat: function getDateTimeFormat(locale) {
              return composer.getDateTimeFormat(locale);
            },
            // setDateTimeFormat
            setDateTimeFormat: function setDateTimeFormat(locale, format2) {
              composer.setDateTimeFormat(locale, format2);
            },
            // mergeDateTimeFormat
            mergeDateTimeFormat: function mergeDateTimeFormat(locale, format2) {
              composer.mergeDateTimeFormat(locale, format2);
            },
            // n
            n: function n() {
              for (var _len39 = arguments.length, args = new Array(_len39), _key49 = 0; _key49 < _len39; _key49++) {
                args[_key49] = arguments[_key49];
              }
              return Reflect.apply(composer.n, composer, [].concat(args));
            },
            // getNumberFormat
            getNumberFormat: function getNumberFormat(locale) {
              return composer.getNumberFormat(locale);
            },
            // setNumberFormat
            setNumberFormat: function setNumberFormat(locale, format2) {
              composer.setNumberFormat(locale, format2);
            },
            // mergeNumberFormat
            mergeNumberFormat: function mergeNumberFormat(locale, format2) {
              composer.mergeNumberFormat(locale, format2);
            }
          };
          vueI18n.__extender = __extender;
          return vueI18n;
        }
        function defineMixin(vuei18n, composer, i18n) {
          return {
            beforeCreate: function beforeCreate() {
              var _this11 = this;
              var instance = getCurrentInstance();
              if (!instance) {
                throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
              }
              var options = this.$options;
              if (options.i18n) {
                var optionsI18n = options.i18n;
                if (options.__i18n) {
                  optionsI18n.__i18n = options.__i18n;
                }
                optionsI18n.__root = composer;
                if (this === this.$root) {
                  this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
                } else {
                  optionsI18n.__injectWithOption = true;
                  optionsI18n.__extender = i18n.__vueI18nExtend;
                  this.$i18n = createVueI18n(optionsI18n);
                  var _vueI18n = this.$i18n;
                  if (_vueI18n.__extender) {
                    _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
                  }
                }
              } else if (options.__i18n) {
                if (this === this.$root) {
                  this.$i18n = mergeToGlobal(vuei18n, options);
                } else {
                  this.$i18n = createVueI18n({
                    __i18n: options.__i18n,
                    __injectWithOption: true,
                    __extender: i18n.__vueI18nExtend,
                    __root: composer
                  });
                  var _vueI18n2 = this.$i18n;
                  if (_vueI18n2.__extender) {
                    _vueI18n2.__disposer = _vueI18n2.__extender(this.$i18n);
                  }
                }
              } else {
                this.$i18n = vuei18n;
              }
              if (options.__i18nGlobal) {
                adjustI18nResources(composer, options, options);
              }
              this.$t = function () {
                var _this11$$i18n;
                return (_this11$$i18n = _this11.$i18n).t.apply(_this11$$i18n, arguments);
              };
              this.$rt = function () {
                var _this11$$i18n2;
                return (_this11$$i18n2 = _this11.$i18n).rt.apply(_this11$$i18n2, arguments);
              };
              this.$tc = function () {
                var _this11$$i18n3;
                return (_this11$$i18n3 = _this11.$i18n).tc.apply(_this11$$i18n3, arguments);
              };
              this.$te = function (key, locale) {
                return _this11.$i18n.te(key, locale);
              };
              this.$d = function () {
                var _this11$$i18n4;
                return (_this11$$i18n4 = _this11.$i18n).d.apply(_this11$$i18n4, arguments);
              };
              this.$n = function () {
                var _this11$$i18n5;
                return (_this11$$i18n5 = _this11.$i18n).n.apply(_this11$$i18n5, arguments);
              };
              this.$tm = function (key) {
                return _this11.$i18n.tm(key);
              };
              i18n.__setInstance(instance, this.$i18n);
            },
            mounted: function mounted() {},
            unmounted: function unmounted() {
              var instance = getCurrentInstance();
              if (!instance) {
                throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
              }
              var _vueI18n = this.$i18n;
              delete this.$t;
              delete this.$rt;
              delete this.$tc;
              delete this.$te;
              delete this.$d;
              delete this.$n;
              delete this.$tm;
              if (_vueI18n.__disposer) {
                _vueI18n.__disposer();
                delete _vueI18n.__disposer;
                delete _vueI18n.__extender;
              }
              i18n.__deleteInstance(instance);
              delete this.$i18n;
            }
          };
        }
        function mergeToGlobal(g, options) {
          g.locale = options.locale || g.locale;
          g.fallbackLocale = options.fallbackLocale || g.fallbackLocale;
          g.missing = options.missing || g.missing;
          g.silentTranslationWarn = options.silentTranslationWarn || g.silentFallbackWarn;
          g.silentFallbackWarn = options.silentFallbackWarn || g.silentFallbackWarn;
          g.formatFallbackMessages = options.formatFallbackMessages || g.formatFallbackMessages;
          g.postTranslation = options.postTranslation || g.postTranslation;
          g.warnHtmlInMessage = options.warnHtmlInMessage || g.warnHtmlInMessage;
          g.escapeParameterHtml = options.escapeParameterHtml || g.escapeParameterHtml;
          g.sync = options.sync || g.sync;
          g.__composer[SetPluralRulesSymbol](options.pluralizationRules || g.pluralizationRules);
          var messages = getLocaleMessages(g.locale, {
            messages: options.messages,
            __i18n: options.__i18n
          });
          Object.keys(messages).forEach(function (locale) {
            return g.mergeLocaleMessage(locale, messages[locale]);
          });
          if (options.datetimeFormats) {
            Object.keys(options.datetimeFormats).forEach(function (locale) {
              return g.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
            });
          }
          if (options.numberFormats) {
            Object.keys(options.numberFormats).forEach(function (locale) {
              return g.mergeNumberFormat(locale, options.numberFormats[locale]);
            });
          }
          return g;
        }
        var baseFormatProps = {
          tag: {
            type: [String, Object]
          },
          locale: {
            type: String
          },
          scope: {
            type: String,
            // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
            validator: function validator(val) {
              return val === "parent" || val === "global";
            },
            default: "parent"
            /* ComponentI18nScope */
          },
          i18n: {
            type: Object
          }
        };
        function getInterpolateArg(_ref58, keys) {
          var slots = _ref58.slots;
          if (keys.length === 1 && keys[0] === "default") {
            var ret = slots.default ? slots.default() : [];
            return ret.reduce(function (slot, current) {
              return [].concat(_toConsumableArray(slot), _toConsumableArray(current.type === Fragment ? current.children : [current]));
            }, []);
          } else {
            return keys.reduce(function (arg, key) {
              var slot = slots[key];
              if (slot) {
                arg[key] = slot();
              }
              return arg;
            }, create$1());
          }
        }
        function getFragmentableTag() {
          return Fragment;
        }
        var TranslationImpl = /* @__PURE__ */defineComponent({
          /* eslint-disable */
          name: "i18n-t",
          props: assign$2({
            keypath: {
              type: String,
              required: true
            },
            plural: {
              type: [Number, String],
              validator: function validator(val) {
                return isNumber(val) || !isNaN(val);
              }
            }
          }, baseFormatProps),
          /* eslint-enable */
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          setup: function setup(props, context) {
            var slots = context.slots,
              attrs = context.attrs;
            var i18n = props.i18n || useI18n({
              useScope: props.scope,
              __useComponent: true
            });
            return function () {
              var keys = Object.keys(slots).filter(function (key) {
                return key !== "_";
              });
              var options = create$1();
              if (props.locale) {
                options.locale = props.locale;
              }
              if (props.plural !== void 0) {
                options.plural = isString(props.plural) ? +props.plural : props.plural;
              }
              var arg = getInterpolateArg(context, keys);
              var children = i18n[TranslateVNodeSymbol](props.keypath, arg, options);
              var assignedAttrs = assign$2(create$1(), attrs);
              var tag = isString(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
              return h(tag, assignedAttrs, children);
            };
          }
        });
        var Translation = TranslationImpl;
        function isVNode(target) {
          return isArray$1(target) && !isString(target[0]);
        }
        function renderFormatter(props, context, slotKeys, partFormatter) {
          var slots = context.slots,
            attrs = context.attrs;
          return function () {
            var options = {
              part: true
            };
            var overrides = create$1();
            if (props.locale) {
              options.locale = props.locale;
            }
            if (isString(props.format)) {
              options.key = props.format;
            } else if (isObject$1(props.format)) {
              if (isString(props.format.key)) {
                options.key = props.format.key;
              }
              overrides = Object.keys(props.format).reduce(function (options2, prop) {
                return slotKeys.includes(prop) ? assign$2(create$1(), options2, _defineProperty2({}, prop, props.format[prop])) : options2;
              }, create$1());
            }
            var parts = partFormatter.apply(void 0, [props.value, options, overrides]);
            var children = [options.key];
            if (isArray$1(parts)) {
              children = parts.map(function (part, index) {
                var slot = slots[part.type];
                var node = slot ? slot(_defineProperty2(_defineProperty2(_defineProperty2({}, part.type, part.value), "index", index), "parts", parts)) : [part.value];
                if (isVNode(node)) {
                  node[0].key = "".concat(part.type, "-").concat(index);
                }
                return node;
              });
            } else if (isString(parts)) {
              children = [parts];
            }
            var assignedAttrs = assign$2(create$1(), attrs);
            var tag = isString(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
            return h(tag, assignedAttrs, children);
          };
        }
        var NumberFormatImpl = /* @__PURE__ */defineComponent({
          /* eslint-disable */
          name: "i18n-n",
          props: assign$2({
            value: {
              type: Number,
              required: true
            },
            format: {
              type: [String, Object]
            }
          }, baseFormatProps),
          /* eslint-enable */
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          setup: function setup(props, context) {
            var i18n = props.i18n || useI18n({
              useScope: props.scope,
              __useComponent: true
            });
            return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, function () {
              return (
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                i18n[NumberPartsSymbol].apply(i18n, arguments)
              );
            });
          }
        });
        var NumberFormat = NumberFormatImpl;
        var DatetimeFormatImpl = /* @__PURE__ */defineComponent({
          /* eslint-disable */
          name: "i18n-d",
          props: assign$2({
            value: {
              type: [Number, Date],
              required: true
            },
            format: {
              type: [String, Object]
            }
          }, baseFormatProps),
          /* eslint-enable */
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          setup: function setup(props, context) {
            var i18n = props.i18n || useI18n({
              useScope: props.scope,
              __useComponent: true
            });
            return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, function () {
              return (
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                i18n[DatetimePartsSymbol].apply(i18n, arguments)
              );
            });
          }
        });
        var DatetimeFormat = DatetimeFormatImpl;
        function getComposer$1(i18n, instance) {
          var i18nInternal = i18n;
          if (i18n.mode === "composition") {
            return i18nInternal.__getInstance(instance) || i18n.global;
          } else {
            var vueI18n = i18nInternal.__getInstance(instance);
            return vueI18n != null ? vueI18n.__composer : i18n.global.__composer;
          }
        }
        function vTDirective(i18n) {
          var _process = function _process(binding) {
            var instance = binding.instance,
              value = binding.value;
            if (!instance || !instance.$) {
              throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
            }
            var composer = getComposer$1(i18n, instance.$);
            var parsedValue = parseValue(value);
            return [Reflect.apply(composer.t, composer, _toConsumableArray(makeParams(parsedValue))), composer];
          };
          var register = function register(el, binding) {
            var _process2 = _process(binding),
              _process3 = _slicedToArray(_process2, 2),
              textContent = _process3[0],
              composer = _process3[1];
            if (inBrowser && i18n.global === composer) {
              el.__i18nWatcher = watch(composer.locale, function () {
                binding.instance && binding.instance.$forceUpdate();
              });
            }
            el.__composer = composer;
            el.textContent = textContent;
          };
          var unregister = function unregister(el) {
            if (inBrowser && el.__i18nWatcher) {
              el.__i18nWatcher();
              el.__i18nWatcher = void 0;
              delete el.__i18nWatcher;
            }
            if (el.__composer) {
              el.__composer = void 0;
              delete el.__composer;
            }
          };
          var update = function update(el, _ref59) {
            var value = _ref59.value;
            if (el.__composer) {
              var composer = el.__composer;
              var parsedValue = parseValue(value);
              el.textContent = Reflect.apply(composer.t, composer, _toConsumableArray(makeParams(parsedValue)));
            }
          };
          var getSSRProps = function getSSRProps(binding) {
            var _process4 = _process(binding),
              _process5 = _slicedToArray(_process4, 1),
              textContent = _process5[0];
            return {
              textContent: textContent
            };
          };
          return {
            created: register,
            unmounted: unregister,
            beforeUpdate: update,
            getSSRProps: getSSRProps
          };
        }
        function parseValue(value) {
          if (isString(value)) {
            return {
              path: value
            };
          } else if (isPlainObject$1(value)) {
            if (!("path" in value)) {
              throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
            }
            return value;
          } else {
            throw createI18nError(I18nErrorCodes.INVALID_VALUE);
          }
        }
        function makeParams(value) {
          var path = value.path,
            locale = value.locale,
            args = value.args,
            choice = value.choice,
            plural = value.plural;
          var options = {};
          var named = args || {};
          if (isString(locale)) {
            options.locale = locale;
          }
          if (isNumber(choice)) {
            options.plural = choice;
          }
          if (isNumber(plural)) {
            options.plural = plural;
          }
          return [path, named, options];
        }
        function apply$1(app, i18n) {
          var pluginOptions = isPlainObject$1(arguments.length <= 2 ? undefined : arguments[2]) ? arguments.length <= 2 ? undefined : arguments[2] : {};
          var globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
          if (globalInstall) {
            [Translation.name, "I18nT"].forEach(function (name) {
              return app.component(name, Translation);
            });
            [NumberFormat.name, "I18nN"].forEach(function (name) {
              return app.component(name, NumberFormat);
            });
            [DatetimeFormat.name, "I18nD"].forEach(function (name) {
              return app.component(name, DatetimeFormat);
            });
          }
          {
            app.directive("t", vTDirective(i18n));
          }
        }
        var I18nInjectionKey = /* @__PURE__ */makeSymbol("global-vue-i18n");
        function createI18n() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var VueI18nLegacy = arguments.length > 1 ? arguments[1] : undefined;
          var __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
          var __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
          var __instances = /* @__PURE__ */new Map();
          var _createGlobal = createGlobal(options, __legacyMode),
            _createGlobal2 = _slicedToArray(_createGlobal, 2),
            globalScope = _createGlobal2[0],
            __global = _createGlobal2[1];
          var symbol = /* @__PURE__ */makeSymbol("");
          function __getInstance(component) {
            return __instances.get(component) || null;
          }
          function __setInstance(component, instance) {
            __instances.set(component, instance);
          }
          function __deleteInstance(component) {
            __instances.delete(component);
          }
          var i18n = {
            // mode
            get mode() {
              return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
            },
            // install plugin
            install: function install(app) {
              var _arguments = arguments;
              return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                var _len40, options2, _key50, opts, globalReleaseHandler, unmountApp;
                return _regeneratorRuntime().wrap(function _callee$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      app.__VUE_I18N_SYMBOL__ = symbol;
                      app.provide(app.__VUE_I18N_SYMBOL__, i18n);
                      for (_len40 = _arguments.length, options2 = new Array(_len40 > 1 ? _len40 - 1 : 0), _key50 = 1; _key50 < _len40; _key50++) {
                        options2[_key50 - 1] = _arguments[_key50];
                      }
                      if (isPlainObject$1(options2[0])) {
                        opts = options2[0];
                        i18n.__composerExtend = opts.__composerExtend;
                        i18n.__vueI18nExtend = opts.__vueI18nExtend;
                      }
                      globalReleaseHandler = null;
                      if (!__legacyMode && __globalInjection) {
                        globalReleaseHandler = injectGlobalFields(app, i18n.global);
                      }
                      if (__VUE_I18N_FULL_INSTALL__) {
                        apply$1.apply(void 0, [app, i18n].concat(options2));
                      }
                      if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
                        app.mixin(defineMixin(__global, __global.__composer, i18n));
                      }
                      unmountApp = app.unmount;
                      app.unmount = function () {
                        globalReleaseHandler && globalReleaseHandler();
                        i18n.dispose();
                        unmountApp();
                      };
                    case 10:
                    case "end":
                      return _context3.stop();
                  }
                }, _callee);
              }))();
            },
            // global accessor
            get global() {
              return __global;
            },
            dispose: function dispose() {
              globalScope.stop();
            },
            // @internal
            __instances: __instances,
            // @internal
            __getInstance: __getInstance,
            // @internal
            __setInstance: __setInstance,
            // @internal
            __deleteInstance: __deleteInstance
          };
          return i18n;
        }
        function useI18n() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var instance = getCurrentInstance();
          if (instance == null) {
            throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
          }
          if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
            throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
          }
          var i18n = getI18nInstance(instance);
          var gl = getGlobalComposer(i18n);
          var componentOptions = getComponentOptions(instance);
          var scope = getScope(options, componentOptions);
          if (scope === "global") {
            adjustI18nResources(gl, options, componentOptions);
            return gl;
          }
          if (scope === "parent") {
            var composer2 = getComposer(i18n, instance, options.__useComponent);
            if (composer2 == null) {
              composer2 = gl;
            }
            return composer2;
          }
          var i18nInternal = i18n;
          var composer = i18nInternal.__getInstance(instance);
          if (composer == null) {
            var composerOptions = assign$2({}, options);
            if ("__i18n" in componentOptions) {
              composerOptions.__i18n = componentOptions.__i18n;
            }
            if (gl) {
              composerOptions.__root = gl;
            }
            composer = createComposer(composerOptions);
            if (i18nInternal.__composerExtend) {
              composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
            }
            setupLifeCycle(i18nInternal, instance, composer);
            i18nInternal.__setInstance(instance, composer);
          }
          return composer;
        }
        function createGlobal(options, legacyMode, VueI18nLegacy) {
          var scope = effectScope();
          var obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(function () {
            return createVueI18n(options);
          }) : scope.run(function () {
            return createComposer(options);
          });
          if (obj == null) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
          }
          return [scope, obj];
        }
        function getI18nInstance(instance) {
          var i18n = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
          if (!i18n) {
            throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
          }
          return i18n;
        }
        function getScope(options, componentOptions) {
          return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
        }
        function getGlobalComposer(i18n) {
          return i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
        }
        function getComposer(i18n, target) {
          var useComponent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var composer = null;
          var root = target.root;
          var current = getParentComponentInstance(target, useComponent);
          while (current != null) {
            var i18nInternal = i18n;
            if (i18n.mode === "composition") {
              composer = i18nInternal.__getInstance(current);
            } else {
              if (__VUE_I18N_LEGACY_API__) {
                var vueI18n = i18nInternal.__getInstance(current);
                if (vueI18n != null) {
                  composer = vueI18n.__composer;
                  if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
                    composer = null;
                  }
                }
              }
            }
            if (composer != null) {
              break;
            }
            if (root === current) {
              break;
            }
            current = current.parent;
          }
          return composer;
        }
        function getParentComponentInstance(target) {
          var useComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          if (target == null) {
            return null;
          }
          return !useComponent ? target.parent : target.vnode.ctx || target.parent;
        }
        function setupLifeCycle(i18n, target, composer) {
          onMounted(function () {}, target);
          onUnmounted(function () {
            var _composer = composer;
            i18n.__deleteInstance(target);
            var dispose = _composer[DisposeSymbol];
            if (dispose) {
              dispose();
              delete _composer[DisposeSymbol];
            }
          }, target);
        }
        var globalExportProps = ["locale", "fallbackLocale", "availableLocales"];
        var globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
        function injectGlobalFields(app, composer) {
          var i18n = /* @__PURE__ */Object.create(null);
          globalExportProps.forEach(function (prop) {
            var desc = Object.getOwnPropertyDescriptor(composer, prop);
            if (!desc) {
              throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
            }
            var wrap = isRef(desc.value) ? {
              get: function get() {
                return desc.value.value;
              },
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              set: function set(val) {
                desc.value.value = val;
              }
            } : {
              get: function get() {
                return desc.get && desc.get();
              }
            };
            Object.defineProperty(i18n, prop, wrap);
          });
          app.config.globalProperties.$i18n = i18n;
          globalExportMethods.forEach(function (method) {
            var desc = Object.getOwnPropertyDescriptor(composer, method);
            if (!desc || !desc.value) {
              throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
            }
            Object.defineProperty(app.config.globalProperties, "$".concat(method), desc);
          });
          var dispose = function dispose() {
            delete app.config.globalProperties.$i18n;
            globalExportMethods.forEach(function (method) {
              delete app.config.globalProperties["$".concat(method)];
            });
          };
          return dispose;
        }
        {
          initFeatureFlags();
        }
        registerMessageCompiler(compile);
        registerMessageResolver(resolveValue);
        registerLocaleFallbacker(fallbackWithLocaleChain);
        if (__INTLIFY_PROD_DEVTOOLS__) {
          var target = getGlobalThis();
          target.__INTLIFY__ = true;
          setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
        }
        var en = {
          button: {
            enterLottery: "Enter Lottery",
            start: "Start",
            selectLucky: "Draw the Lucky",
            continue: "Continue",
            confirm: "Confirm",
            cancel: "Cancel",
            setting: "Setting",
            delete: "Delete",
            allDelete: "Delete All",
            downloadTemplate: "Download Template",
            importData: "Import Data",
            resetData: "Reset Data",
            exportResult: "Export Result",
            add: "Add",
            resetDefault: "Reset Default",
            resetAllData: "Reset All Data",
            clearPattern: "Clear Pattern",
            DefaultPattern: "Default Pattern",
            upload: "Upload",
            reset: "Reset",
            play: "Play",
            setLayout: "Set Layout",
            close: "Close",
            noInfoAndImport: "No Info and import it",
            useDefault: "Use Default Data"
          },
          sidebar: {
            personConfiguration: "Person Configuration",
            personList: "Person List",
            winnerList: "Winner List",
            prizeConfiguration: "Prize Configuration",
            globalSetting: "Global Configuration",
            viewSetting: "View Setting",
            imagesManagement: "Images Management",
            musicManagement: "Music Management",
            operatingInstructions: "Operating Instructions"
          },
          viewTitle: {
            personManagement: "Person Management",
            winnerManagement: "Winner Management",
            prizeManagement: "Prize Management",
            globalSetting: "Global Setting",
            operatingInstructions: "Operating Instructions"
          },
          table: {
            // person configuration
            number: "Number",
            name: "Name",
            prizeName: "Name",
            department: "Department",
            identity: "Identity",
            isLucky: "Is Lucky",
            operation: "Operation",
            setLuckyNumber: "Set Lucky Number",
            luckyPeopleNumber: "Lucky People Number",
            detail: "Detail",
            noneData: "No Data",
            // prize configuration
            fullParticipation: "FullParticipation",
            numberParticipants: "NumberParticipants",
            isDone: "is Done",
            image: "Image",
            onceNumber: "Once Number",
            time: "Time",
            // view setting
            title: "Main Title",
            columnNumber: "Column Number",
            theme: "Theme",
            language: "Language",
            cardColor: "Card Color",
            winnerColor: "Winner Color",
            textColor: "Text Color",
            cardWidth: "Card Width",
            cardHeight: "Card Height",
            textSize: "Text Size",
            highlightColor: "HighLight Color",
            patternSetting: "Pattern Setting",
            alwaysDisplay: "Always Display Prize List",
            avatarDisplay: "Show avatars or not",
            selectPicture: "Select a Picture",
            backgroundImage: "Select Background Image"
          },
          dialog: {
            titleTip: "Tip!",
            titleTemporary: "Add Temporary Activity",
            dialogPCWeb: "Please use a PC browser to access for optimal display performance",
            dialogDelAllPerson: "This operation will delete all personnel list data. Do you want to continue?",
            dialogResetWinner: "This operation will clear the winning information of personnel. Do you want to continue?",
            dialogResetAllData: "This operation will reset all data. Do you want to continue?",
            dialogSingleDrawLimit: "Only 10 characters can be extracted in a single draw",
            dialogLatestBrowser: "Please use the latest version of Chrome or Edge browser",
            tipResetPrize: "Performing operations may reset data, please proceed with caution"
          },
          tooltip: {
            settingConfiguration: "Setting/Configuration",
            nextSong: "Right Click to Next Song",
            noSongPlay: "No Song to Play",
            prizeList: "Prize List",
            addActivity: "Add Activity",
            downloadTemplateTip: "After downloading the file, please fill in the data in Excel and save it in xlsx format",
            uploadExcelTip: "Upload the modified Excel file",
            leftClick: "Left Click to Slice",
            toHome: "to Home",
            resetLayout: "This item is time-consuming and performance intensive",
            defaultLayout: "The default pattern setting is valid for 17 columns, please set the number of other columns yourself",
            doneCount: "Number of winners",
            edit: "Edit",
            delete: "Delete",
            fullscreen: "Fullscreen",
            exitFullscreen: "Exit Fullscreen"
          },
          error: {
            require: "required field",
            requireNumber: "please enter a number",
            minNumber1: "the minimum is 1",
            maxNumber100: "the maximum is 100",
            uploadSuccess: "Upload Success",
            uploadFail: "Upload Failed",
            notImage: "Not Image",
            personIsAllDone: "All Person Is Done",
            personNotEnough: "Person Is Not Enough",
            startDraw: "Now Draw {count} {leftover} people",
            completeInformation: "Please provide complete information"
          },
          placeHolder: {
            enterTitle: "Enter Title",
            name: "Name",
            winnerCount: "Lucky Person Count"
          },
          data: {
            yes: "Yes",
            no: "No",
            number: "Number",
            isWin: "isWin",
            avatar: "avatar",
            department: "Department",
            name: "Name",
            identity: "Identity",
            prizeName: "Prize Name",
            prizeTime: "Prize Time",
            operation: "Operation",
            delete: "Delete",
            removePerson: "Remove the Person",
            defaultTitle: "The Prelude to the Six Ministries of the Ming Dynasty Cabinet",
            xlsxName: "personListTemplate-en.xlsx",
            readmeName: "readme-en.md"
          },
          footer: {
            "self-reflection": "Turn inward and examine yourself when you encounter difficulties in life.",
            "thiefEasy": "Thief difficult mountain thief easily, breaking heart."
          }
        };
        var zhCn = {
          button: {
            enterLottery: "",
            start: "",
            selectLucky: "",
            continue: "",
            confirm: "",
            cancel: "",
            setting: "",
            delete: "",
            allDelete: "",
            downloadTemplate: "",
            importData: "",
            resetData: "",
            exportResult: "",
            add: "",
            resetDefault: "",
            resetAllData: "",
            clearPattern: "",
            DefaultPattern: "",
            upload: "",
            reset: "",
            play: "",
            setLayout: "",
            close: "",
            noInfoAndImport: "",
            useDefault: ""
          },
          sidebar: {
            personConfiguration: "",
            personList: "",
            winnerList: "",
            prizeConfiguration: "",
            globalSetting: "",
            viewSetting: "",
            imagesManagement: "",
            musicManagement: "",
            operatingInstructions: ""
          },
          viewTitle: {
            personManagement: "",
            winnerManagement: "",
            prizeManagement: "",
            globalSetting: "",
            operatingInstructions: ""
          },
          table: {
            // person configuration
            number: "",
            name: "",
            prizeName: "",
            department: "",
            identity: "",
            isLucky: "",
            operation: "",
            setLuckyNumber: "",
            luckyPeopleNumber: "",
            detail: "",
            noneData: "",
            // prize configuration
            fullParticipation: "",
            numberParticipants: "",
            isDone: "",
            image: "",
            onceNumber: "",
            time: "",
            // view setting
            title: "",
            columnNumber: "",
            theme: "",
            language: "",
            cardColor: "",
            winnerColor: "",
            textColor: "",
            cardWidth: "",
            cardHeight: "",
            textSize: "",
            highlightColor: "",
            patternSetting: "",
            alwaysDisplay: "",
            avatarDisplay: "",
            selectPicture: "",
            backgroundImage: ""
          },
          dialog: {
            titleTip: "!",
            titleTemporary: "",
            dialogPCWeb: "PC",
            dialogDelAllPerson: "",
            dialogResetWinner: "",
            dialogResetAllData: "",
            dialogSingleDrawLimit: "10",
            dialogLatestBrowser: "ChromeEdge",
            tipResetPrize: ""
          },
          tooltip: {
            settingConfiguration: "/",
            nextSong: "",
            noSongPlay: "",
            prizeList: "",
            addActivity: "",
            downloadTemplateTip: "excelxlsx",
            uploadExcelTip: "excel",
            leftClick: "",
            toHome: "",
            resetLayout: "",
            defaultLayout: "17",
            doneCount: "",
            edit: "",
            delete: "",
            fullscreen: "",
            exitFullscreen: ""
          },
          error: {
            require: "",
            requireNumber: "",
            minNumber1: "1",
            maxNumber100: "100",
            uploadSuccess: "",
            uploadFail: "",
            notImage: "",
            personIsAllDone: "",
            personNotEnough: "",
            startDraw: "{count}{leftover}",
            completeInformation: ""
          },
          placeHolder: {
            enterTitle: "",
            name: "",
            winnerCount: ""
          },
          data: {
            yes: "",
            no: "",
            number: "",
            isWin: "",
            avatar: "",
            department: "",
            name: "",
            identity: "",
            prizeName: "",
            prizeTime: "",
            operation: "",
            delete: "",
            removePerson: "",
            defaultTitle: " - ",
            xlsxName: "-zhCn.xlsx",
            readmeName: "readme-zhCn.md"
          },
          footer: {
            "self-reflection": "",
            "thiefEasy": ""
          }
        };
        var languageList = exports("a6", [{
          key: "zhCn",
          name: "",
          flag: "zh-cn"
        }, {
          key: "en",
          name: "English",
          flag: "en-us"
        }]);
        var browserLanguage = navigator.language.toLowerCase().includes("zh") ? "zhCn" : "en";
        var globalConfig = JSON.parse(localStorage.getItem("globalConfig") || "{}").globalConfig || {};
        var i18n = exports("q", createI18n({
          locale: globalConfig.language || browserLanguage,
          legacy: false,
          messages: {
            zhCn: zhCn,
            en: en
          }
        }));
        var scriptRel = 'modulepreload';
        var assetsURL = function assetsURL(dep, importerUrl) {
          return new URL(dep, importerUrl).href;
        };
        var seen = {};
        var __vitePreload = function preload(baseModule, deps, importerUrl) {
          var promise = Promise.resolve();
          if (false && deps && deps.length > 0) {
            var links = document.getElementsByTagName("link");
            var cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
            var cspNonce = (cspNonceMeta === null || cspNonceMeta === void 0 ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta === null || cspNonceMeta === void 0 ? void 0 : cspNonceMeta.getAttribute("nonce"));
            promise = Promise.allSettled(deps.map(function (dep) {
              dep = assetsURL(dep, importerUrl);
              if (dep in seen) return;
              seen[dep] = true;
              var isCss = dep.endsWith(".css");
              var cssSelector = isCss ? '[rel="stylesheet"]' : "";
              var isBaseRelative = !!importerUrl;
              if (isBaseRelative) {
                for (var i = links.length - 1; i >= 0; i--) {
                  var link2 = links[i];
                  if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
                    return;
                  }
                }
              } else if (document.querySelector("link[href=\"".concat(dep, "\"]").concat(cssSelector))) {
                return;
              }
              var link = document.createElement("link");
              link.rel = isCss ? "stylesheet" : scriptRel;
              if (!isCss) {
                link.as = "script";
              }
              link.crossOrigin = "";
              link.href = dep;
              if (cspNonce) {
                link.setAttribute("nonce", cspNonce);
              }
              document.head.appendChild(link);
              if (isCss) {
                return new Promise(function (res, rej) {
                  link.addEventListener("load", res);
                  link.addEventListener("error", function () {
                    return rej(new Error("Unable to preload CSS for ".concat(dep)));
                  });
                });
              }
            }));
          }
          function handlePreloadError(err) {
            var e = new Event("vite:preloadError", {
              cancelable: true
            });
            e.payload = err;
            window.dispatchEvent(e);
            if (!e.defaultPrevented) {
              throw err;
            }
          }
          return promise.then(function (res) {
            var _iterator16 = _createForOfIteratorHelper(res || []),
              _step16;
            try {
              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                var item = _step16.value;
                if (item.status !== "rejected") continue;
                handlePreloadError(item.reason);
              }
            } catch (err) {
              _iterator16.e(err);
            } finally {
              _iterator16.f();
            }
            return baseModule().catch(handlePreloadError);
          });
        };
        var _sfc_main$8 = {};
        var _hoisted_1$8 = {
          class: "fixed z-50 flex items-center justify-center w-10 h-10 rounded-full shadow-lg cursor-pointer right-12 bottom-12 bg-slate-700 hover:bg-slate-600"
        };
        function _sfc_render(_ctx, _cache) {
          var _component_svg_icon = __unplugin_components_0;
          return openBlock(), createElementBlock("div", _hoisted_1$8, [createVNode(_component_svg_icon, {
            name: "toTop"
          })]);
        }
        var ToTop = /*#__PURE__*/_export_sfc(_sfc_main$8, [['render', _sfc_render]]);
        var isVue2 = false;
        function tryOnScopeDispose(fn) {
          if (getCurrentScope()) {
            onScopeDispose(fn);
            return true;
          }
          return false;
        }
        function toValue(r) {
          return typeof r === "function" ? r() : unref(r);
        }
        var isClient = typeof window !== "undefined" && typeof document !== "undefined";
        typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
        var toString = Object.prototype.toString;
        var isObject = function isObject(val) {
          return toString.call(val) === "[object Object]";
        };
        var noop$2 = function noop$2() {};
        var isIOS = /* @__PURE__ */getIsIOS();
        function getIsIOS() {
          var _a, _b;
          return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
        }
        function createFilterWrapper(filter, fn) {
          function wrapper() {
            var _this12 = this;
            for (var _len41 = arguments.length, args = new Array(_len41), _key51 = 0; _key51 < _len41; _key51++) {
              args[_key51] = arguments[_key51];
            }
            return new Promise(function (resolve, reject) {
              Promise.resolve(filter(function () {
                return fn.apply(_this12, args);
              }, {
                fn: fn,
                thisArg: _this12,
                args: args
              })).then(resolve).catch(reject);
            });
          }
          return wrapper;
        }
        var bypassFilter = function bypassFilter(invoke2) {
          return invoke2();
        };
        function debounceFilter(ms) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var timer;
          var maxTimer;
          var lastRejector = noop$2;
          var _clearTimeout = function _clearTimeout(timer2) {
            clearTimeout(timer2);
            lastRejector();
            lastRejector = noop$2;
          };
          var filter = function filter(invoke2) {
            var duration = toValue(ms);
            var maxDuration = toValue(options.maxWait);
            if (timer) _clearTimeout(timer);
            if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
              if (maxTimer) {
                _clearTimeout(maxTimer);
                maxTimer = null;
              }
              return Promise.resolve(invoke2());
            }
            return new Promise(function (resolve, reject) {
              lastRejector = options.rejectOnCancel ? reject : resolve;
              if (maxDuration && !maxTimer) {
                maxTimer = setTimeout(function () {
                  if (timer) _clearTimeout(timer);
                  maxTimer = null;
                  resolve(invoke2());
                }, maxDuration);
              }
              timer = setTimeout(function () {
                if (maxTimer) _clearTimeout(maxTimer);
                maxTimer = null;
                resolve(invoke2());
              }, duration);
            });
          };
          return filter;
        }
        function throttleFilter() {
          var lastExec = 0;
          var timer;
          var isLeading = true;
          var lastRejector = noop$2;
          var lastValue;
          var ms;
          var trailing;
          var leading;
          var rejectOnCancel;
          for (var _len42 = arguments.length, args = new Array(_len42), _key52 = 0; _key52 < _len42; _key52++) {
            args[_key52] = arguments[_key52];
          }
          if (!isRef(args[0]) && _typeof2(args[0]) === "object") {
            var _args$ = args[0];
            ms = _args$.delay;
            var _args$$trailing = _args$.trailing;
            trailing = _args$$trailing === void 0 ? true : _args$$trailing;
            var _args$$leading = _args$.leading;
            leading = _args$$leading === void 0 ? true : _args$$leading;
            var _args$$rejectOnCancel = _args$.rejectOnCancel;
            rejectOnCancel = _args$$rejectOnCancel === void 0 ? false : _args$$rejectOnCancel;
          } else {
            ms = args[0];
            var _args$2 = args[1];
            trailing = _args$2 === void 0 ? true : _args$2;
            var _args$3 = args[2];
            leading = _args$3 === void 0 ? true : _args$3;
            var _args$4 = args[3];
            rejectOnCancel = _args$4 === void 0 ? false : _args$4;
          }
          var clear = function clear() {
            if (timer) {
              clearTimeout(timer);
              timer = void 0;
              lastRejector();
              lastRejector = noop$2;
            }
          };
          var filter = function filter(_invoke) {
            var duration = toValue(ms);
            var elapsed = Date.now() - lastExec;
            var invoke2 = function invoke2() {
              return lastValue = _invoke();
            };
            clear();
            if (duration <= 0) {
              lastExec = Date.now();
              return invoke2();
            }
            if (elapsed > duration && (leading || !isLeading)) {
              lastExec = Date.now();
              invoke2();
            } else if (trailing) {
              lastValue = new Promise(function (resolve, reject) {
                lastRejector = rejectOnCancel ? reject : resolve;
                timer = setTimeout(function () {
                  lastExec = Date.now();
                  isLeading = true;
                  resolve(invoke2());
                  clear();
                }, Math.max(0, duration - elapsed));
              });
            }
            if (!leading && !timer) timer = setTimeout(function () {
              return isLeading = true;
            }, duration);
            isLeading = false;
            return lastValue;
          };
          return filter;
        }
        function pausableFilter() {
          var extendFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bypassFilter;
          var isActive = ref(true);
          function pause() {
            isActive.value = false;
          }
          function resume() {
            isActive.value = true;
          }
          var eventFilter = function eventFilter() {
            if (isActive.value) extendFilter.apply(void 0, arguments);
          };
          return {
            isActive: readonly(isActive),
            pause: pause,
            resume: resume,
            eventFilter: eventFilter
          };
        }
        function createSingletonPromise(fn) {
          var _promise;
          function wrapper() {
            if (!_promise) _promise = fn();
            return _promise;
          }
          wrapper.reset = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
            var _prev;
            return _regeneratorRuntime().wrap(function _callee2$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  _prev = _promise;
                  _promise = void 0;
                  if (!_prev) {
                    _context4.next = 5;
                    break;
                  }
                  _context4.next = 5;
                  return _prev;
                case 5:
                case "end":
                  return _context4.stop();
              }
            }, _callee2);
          }));
          return wrapper;
        }
        function getLifeCycleTarget(target) {
          return getCurrentInstance();
        }
        function useDebounceFn(fn) {
          var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          return createFilterWrapper(debounceFilter(ms, options), fn);
        }
        function useThrottleFn(fn) {
          var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
          var trailing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var leading = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
          var rejectOnCancel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn);
        }
        function watchWithFilter(source, cb) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var _options$eventFilter = options.eventFilter,
            eventFilter = _options$eventFilter === void 0 ? bypassFilter : _options$eventFilter,
            watchOptions = _objectWithoutProperties(options, _excluded);
          return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
        }
        function watchPausable(source, cb) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var filter = options.eventFilter,
            watchOptions = _objectWithoutProperties(options, _excluded2);
          var _pausableFilter = pausableFilter(filter),
            eventFilter = _pausableFilter.eventFilter,
            pause = _pausableFilter.pause,
            resume = _pausableFilter.resume,
            isActive = _pausableFilter.isActive;
          var stop = watchWithFilter(source, cb, _objectSpread(_objectSpread({}, watchOptions), {}, {
            eventFilter: eventFilter
          }));
          return {
            stop: stop,
            pause: pause,
            resume: resume,
            isActive: isActive
          };
        }
        function tryOnMounted(fn) {
          var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var target = arguments.length > 2 ? arguments[2] : undefined;
          var instance = getLifeCycleTarget();
          if (instance) onMounted(fn, target);else if (sync) fn();else nextTick(fn);
        }
        function useTimeoutFn(cb, interval) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var _options$immediate = options.immediate,
            immediate = _options$immediate === void 0 ? true : _options$immediate;
          var isPending = ref(false);
          var timer = null;
          function clear() {
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }
          }
          function stop() {
            isPending.value = false;
            clear();
          }
          function start() {
            for (var _len43 = arguments.length, args = new Array(_len43), _key53 = 0; _key53 < _len43; _key53++) {
              args[_key53] = arguments[_key53];
            }
            clear();
            isPending.value = true;
            timer = setTimeout(function () {
              isPending.value = false;
              timer = null;
              cb.apply(void 0, args);
            }, toValue(interval));
          }
          if (immediate) {
            isPending.value = true;
            if (isClient) start();
          }
          tryOnScopeDispose(stop);
          return {
            isPending: readonly(isPending),
            start: start,
            stop: stop
          };
        }
        function whenever(source, cb, options) {
          var stop = watch(source, function (v, ov, onInvalidate) {
            if (v) {
              if (options == null ? void 0 : options.once) nextTick(function () {
                return stop();
              });
              cb(v, ov, onInvalidate);
            }
          }, _objectSpread(_objectSpread({}, options), {}, {
            once: false
          }));
          return stop;
        }
        var defaultWindow = isClient ? window : void 0;
        var defaultNavigator = isClient ? window.navigator : void 0;
        function unrefElement(elRef) {
          var _a;
          var plain = toValue(elRef);
          return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
        }
        function useEventListener() {
          var target;
          var events2;
          var listeners;
          var options;
          for (var _len44 = arguments.length, args = new Array(_len44), _key54 = 0; _key54 < _len44; _key54++) {
            args[_key54] = arguments[_key54];
          }
          if (typeof args[0] === "string" || Array.isArray(args[0])) {
            events2 = args[0];
            listeners = args[1];
            options = args[2];
            target = defaultWindow;
          } else {
            target = args[0];
            events2 = args[1];
            listeners = args[2];
            options = args[3];
          }
          if (!target) return noop$2;
          if (!Array.isArray(events2)) events2 = [events2];
          if (!Array.isArray(listeners)) listeners = [listeners];
          var cleanups = [];
          var cleanup = function cleanup() {
            cleanups.forEach(function (fn) {
              return fn();
            });
            cleanups.length = 0;
          };
          var register = function register(el, event, listener, options2) {
            el.addEventListener(event, listener, options2);
            return function () {
              return el.removeEventListener(event, listener, options2);
            };
          };
          var stopWatch = watch(function () {
            return [unrefElement(target), toValue(options)];
          }, function (_ref61) {
            var _ref62 = _slicedToArray(_ref61, 2),
              el = _ref62[0],
              options2 = _ref62[1];
            cleanup();
            if (!el) return;
            var optionsClone = isObject(options2) ? _objectSpread({}, options2) : options2;
            cleanups.push.apply(cleanups, _toConsumableArray(events2.flatMap(function (event) {
              return listeners.map(function (listener) {
                return register(el, event, listener, optionsClone);
              });
            })));
          }, {
            immediate: true,
            flush: "post"
          });
          var stop = function stop() {
            stopWatch();
            cleanup();
          };
          tryOnScopeDispose(stop);
          return stop;
        }
        var _iOSWorkaround = false;
        function onClickOutside(target, handler) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var _options$window = options.window,
            window2 = _options$window === void 0 ? defaultWindow : _options$window,
            _options$ignore = options.ignore,
            ignore = _options$ignore === void 0 ? [] : _options$ignore,
            _options$capture = options.capture,
            capture = _options$capture === void 0 ? true : _options$capture,
            _options$detectIframe = options.detectIframe,
            detectIframe = _options$detectIframe === void 0 ? false : _options$detectIframe;
          if (!window2) return noop$2;
          if (isIOS && !_iOSWorkaround) {
            _iOSWorkaround = true;
            Array.from(window2.document.body.children).forEach(function (el) {
              return el.addEventListener("click", noop$2);
            });
            window2.document.documentElement.addEventListener("click", noop$2);
          }
          var shouldListen = true;
          var shouldIgnore = function shouldIgnore(event) {
            return toValue(ignore).some(function (target2) {
              if (typeof target2 === "string") {
                return Array.from(window2.document.querySelectorAll(target2)).some(function (el) {
                  return el === event.target || event.composedPath().includes(el);
                });
              } else {
                var el = unrefElement(target2);
                return el && (event.target === el || event.composedPath().includes(el));
              }
            });
          };
          function hasMultipleRoots(target2) {
            var vm = toValue(target2);
            return vm && vm.$.subTree.shapeFlag === 16;
          }
          function checkMultipleRoots(target2, event) {
            var vm = toValue(target2);
            var children = vm.$.subTree && vm.$.subTree.children;
            if (children == null || !Array.isArray(children)) return false;
            return children.some(function (child) {
              return child.el === event.target || event.composedPath().includes(child.el);
            });
          }
          var listener = function listener(event) {
            var el = unrefElement(target);
            if (event.target == null) return;
            if (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event)) return;
            if (!el || el === event.target || event.composedPath().includes(el)) return;
            if (event.detail === 0) shouldListen = !shouldIgnore(event);
            if (!shouldListen) {
              shouldListen = true;
              return;
            }
            handler(event);
          };
          var isProcessingClick = false;
          var cleanup = [useEventListener(window2, "click", function (event) {
            if (!isProcessingClick) {
              isProcessingClick = true;
              setTimeout(function () {
                isProcessingClick = false;
              }, 0);
              listener(event);
            }
          }, {
            passive: true,
            capture: capture
          }), useEventListener(window2, "pointerdown", function (e) {
            var el = unrefElement(target);
            shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));
          }, {
            passive: true
          }), detectIframe && useEventListener(window2, "blur", function (event) {
            setTimeout(function () {
              var _a;
              var el = unrefElement(target);
              if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement))) {
                handler(event);
              }
            }, 0);
          })].filter(Boolean);
          var stop = function stop() {
            return cleanup.forEach(function (fn) {
              return fn();
            });
          };
          return stop;
        }
        function useMounted() {
          var isMounted = ref(false);
          var instance = getCurrentInstance();
          if (instance) {
            onMounted(function () {
              isMounted.value = true;
            }, instance);
          }
          return isMounted;
        }
        function useSupported(callback) {
          var isMounted = useMounted();
          return computed(function () {
            isMounted.value;
            return Boolean(callback());
          });
        }
        function usePermission(permissionDesc) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var _options$controls = options.controls,
            controls = _options$controls === void 0 ? false : _options$controls,
            _options$navigator = options.navigator,
            navigator = _options$navigator === void 0 ? defaultNavigator : _options$navigator;
          var isSupported = useSupported(function () {
            return navigator && "permissions" in navigator;
          });
          var permissionStatus = shallowRef();
          var desc = typeof permissionDesc === "string" ? {
            name: permissionDesc
          } : permissionDesc;
          var state = shallowRef();
          var update = function update() {
            var _a, _b;
            state.value = (_b = (_a = permissionStatus.value) == null ? void 0 : _a.state) != null ? _b : "prompt";
          };
          useEventListener(permissionStatus, "change", update);
          var query = createSingletonPromise(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
            return _regeneratorRuntime().wrap(function _callee3$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  if (isSupported.value) {
                    _context5.next = 2;
                    break;
                  }
                  return _context5.abrupt("return");
                case 2:
                  if (permissionStatus.value) {
                    _context5.next = 15;
                    break;
                  }
                  _context5.prev = 3;
                  _context5.next = 6;
                  return navigator.permissions.query(desc);
                case 6:
                  permissionStatus.value = _context5.sent;
                  _context5.next = 12;
                  break;
                case 9:
                  _context5.prev = 9;
                  _context5.t0 = _context5["catch"](3);
                  permissionStatus.value = void 0;
                case 12:
                  _context5.prev = 12;
                  update();
                  return _context5.finish(12);
                case 15:
                  if (!controls) {
                    _context5.next = 17;
                    break;
                  }
                  return _context5.abrupt("return", toRaw(permissionStatus.value));
                case 17:
                case "end":
                  return _context5.stop();
              }
            }, _callee3, null, [[3, 9, 12, 15]]);
          })));
          query();
          if (controls) {
            return {
              state: state,
              isSupported: isSupported,
              query: query
            };
          } else {
            return state;
          }
        }
        function useClipboard() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var _options$navigator2 = options.navigator,
            navigator = _options$navigator2 === void 0 ? defaultNavigator : _options$navigator2,
            _options$read = options.read,
            read = _options$read === void 0 ? false : _options$read,
            source = options.source,
            _options$copiedDuring = options.copiedDuring,
            copiedDuring = _options$copiedDuring === void 0 ? 1500 : _options$copiedDuring,
            _options$legacy = options.legacy,
            legacy = _options$legacy === void 0 ? false : _options$legacy;
          var isClipboardApiSupported = useSupported(function () {
            return navigator && "clipboard" in navigator;
          });
          var permissionRead = usePermission("clipboard-read");
          var permissionWrite = usePermission("clipboard-write");
          var isSupported = computed(function () {
            return isClipboardApiSupported.value || legacy;
          });
          var text = ref("");
          var copied = ref(false);
          var timeout = useTimeoutFn(function () {
            return copied.value = false;
          }, copiedDuring);
          function updateText() {
            if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) {
              navigator.clipboard.readText().then(function (value) {
                text.value = value;
              });
            } else {
              text.value = legacyRead();
            }
          }
          if (isSupported.value && read) useEventListener(["copy", "cut"], updateText);
          function copy() {
            return _copy.apply(this, arguments);
          }
          function _copy() {
            _copy = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
              var value,
                _args5 = arguments;
              return _regeneratorRuntime().wrap(function _callee4$(_context6) {
                while (1) switch (_context6.prev = _context6.next) {
                  case 0:
                    value = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : toValue(source);
                    if (!(isSupported.value && value != null)) {
                      _context6.next = 11;
                      break;
                    }
                    if (!(isClipboardApiSupported.value && isAllowed(permissionWrite.value))) {
                      _context6.next = 7;
                      break;
                    }
                    _context6.next = 5;
                    return navigator.clipboard.writeText(value);
                  case 5:
                    _context6.next = 8;
                    break;
                  case 7:
                    legacyCopy(value);
                  case 8:
                    text.value = value;
                    copied.value = true;
                    timeout.start();
                  case 11:
                  case "end":
                    return _context6.stop();
                }
              }, _callee4);
            }));
            return _copy.apply(this, arguments);
          }
          function legacyCopy(value) {
            var ta = document.createElement("textarea");
            ta.value = value != null ? value : "";
            ta.style.position = "absolute";
            ta.style.opacity = "0";
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            ta.remove();
          }
          function legacyRead() {
            var _a, _b, _c;
            return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
          }
          function isAllowed(status) {
            return status === "granted" || status === "prompt";
          }
          return {
            isSupported: isSupported,
            text: text,
            copied: copied,
            copy: copy
          };
        }
        var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
        var globalKey = "__vueuse_ssr_handlers__";
        var handlers = /* @__PURE__ */getHandlers();
        function getHandlers() {
          if (!(globalKey in _global)) _global[globalKey] = _global[globalKey] || {};
          return _global[globalKey];
        }
        function getSSRHandler(key, fallback) {
          return handlers[key] || fallback;
        }
        function guessSerializerType(rawInit) {
          return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : _typeof2(rawInit) === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
        }
        var StorageSerializers = {
          boolean: {
            read: function read(v) {
              return v === "true";
            },
            write: function write(v) {
              return String(v);
            }
          },
          object: {
            read: function read(v) {
              return JSON.parse(v);
            },
            write: function write(v) {
              return JSON.stringify(v);
            }
          },
          number: {
            read: function read(v) {
              return Number.parseFloat(v);
            },
            write: function write(v) {
              return String(v);
            }
          },
          any: {
            read: function read(v) {
              return v;
            },
            write: function write(v) {
              return String(v);
            }
          },
          string: {
            read: function read(v) {
              return v;
            },
            write: function write(v) {
              return String(v);
            }
          },
          map: {
            read: function read(v) {
              return new Map(JSON.parse(v));
            },
            write: function write(v) {
              return JSON.stringify(Array.from(v.entries()));
            }
          },
          set: {
            read: function read(v) {
              return new Set(JSON.parse(v));
            },
            write: function write(v) {
              return JSON.stringify(Array.from(v));
            }
          },
          date: {
            read: function read(v) {
              return new Date(v);
            },
            write: function write(v) {
              return v.toISOString();
            }
          }
        };
        var customStorageEventName = "vueuse-storage";
        function useStorage(key, defaults2, storage) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
          var _a;
          var _options$flush = options.flush,
            flush = _options$flush === void 0 ? "pre" : _options$flush,
            _options$deep = options.deep,
            deep = _options$deep === void 0 ? true : _options$deep,
            _options$listenToStor = options.listenToStorageChanges,
            listenToStorageChanges = _options$listenToStor === void 0 ? true : _options$listenToStor,
            _options$writeDefault = options.writeDefaults,
            writeDefaults = _options$writeDefault === void 0 ? true : _options$writeDefault,
            _options$mergeDefault = options.mergeDefaults,
            mergeDefaults = _options$mergeDefault === void 0 ? false : _options$mergeDefault,
            shallow = options.shallow,
            _options$window2 = options.window,
            window2 = _options$window2 === void 0 ? defaultWindow : _options$window2,
            eventFilter = options.eventFilter,
            _options$onError = options.onError,
            onError = _options$onError === void 0 ? function (e) {
              console.error(e);
            } : _options$onError,
            initOnMounted = options.initOnMounted;
          var data = (shallow ? shallowRef : ref)(typeof defaults2 === "function" ? defaults2() : defaults2);
          if (!storage) {
            try {
              storage = getSSRHandler("getDefaultStorage", function () {
                var _a2;
                return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
              })();
            } catch (e) {
              onError(e);
            }
          }
          if (!storage) return data;
          var rawInit = toValue(defaults2);
          var type = guessSerializerType(rawInit);
          var serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];
          var _watchPausable = watchPausable(data, function () {
              return write(data.value);
            }, {
              flush: flush,
              deep: deep,
              eventFilter: eventFilter
            }),
            pauseWatch = _watchPausable.pause,
            resumeWatch = _watchPausable.resume;
          if (window2 && listenToStorageChanges) {
            tryOnMounted(function () {
              if (storage instanceof Storage) useEventListener(window2, "storage", update);else useEventListener(window2, customStorageEventName, updateFromCustomEvent);
              if (initOnMounted) update();
            });
          }
          if (!initOnMounted) update();
          function dispatchWriteEvent(oldValue, newValue) {
            if (window2) {
              var payload = {
                key: key,
                oldValue: oldValue,
                newValue: newValue,
                storageArea: storage
              };
              window2.dispatchEvent(storage instanceof Storage ? new StorageEvent("storage", payload) : new CustomEvent(customStorageEventName, {
                detail: payload
              }));
            }
          }
          function write(v) {
            try {
              var oldValue = storage.getItem(key);
              if (v == null) {
                dispatchWriteEvent(oldValue, null);
                storage.removeItem(key);
              } else {
                var serialized = serializer.write(v);
                if (oldValue !== serialized) {
                  storage.setItem(key, serialized);
                  dispatchWriteEvent(oldValue, serialized);
                }
              }
            } catch (e) {
              onError(e);
            }
          }
          function read(event) {
            var rawValue = event ? event.newValue : storage.getItem(key);
            if (rawValue == null) {
              if (writeDefaults && rawInit != null) storage.setItem(key, serializer.write(rawInit));
              return rawInit;
            } else if (!event && mergeDefaults) {
              var value = serializer.read(rawValue);
              if (typeof mergeDefaults === "function") return mergeDefaults(value, rawInit);else if (type === "object" && !Array.isArray(value)) return _objectSpread(_objectSpread({}, rawInit), value);
              return value;
            } else if (typeof rawValue !== "string") {
              return rawValue;
            } else {
              return serializer.read(rawValue);
            }
          }
          function update(event) {
            if (event && event.storageArea !== storage) return;
            if (event && event.key == null) {
              data.value = rawInit;
              return;
            }
            if (event && event.key !== key) return;
            pauseWatch();
            try {
              if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value)) data.value = read(event);
            } catch (e) {
              onError(e);
            } finally {
              if (event) nextTick(resumeWatch);else resumeWatch();
            }
          }
          function updateFromCustomEvent(event) {
            update(event.detail);
          }
          return data;
        }
        function useResizeObserver(target, callback) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var _options$window3 = options.window,
            window2 = _options$window3 === void 0 ? defaultWindow : _options$window3,
            observerOptions = _objectWithoutProperties(options, _excluded3);
          var observer;
          var isSupported = useSupported(function () {
            return window2 && "ResizeObserver" in window2;
          });
          var cleanup = function cleanup() {
            if (observer) {
              observer.disconnect();
              observer = void 0;
            }
          };
          var targets = computed(function () {
            var _targets = toValue(target);
            return Array.isArray(_targets) ? _targets.map(function (el) {
              return unrefElement(el);
            }) : [unrefElement(_targets)];
          });
          var stopWatch = watch(targets, function (els) {
            cleanup();
            if (isSupported.value && window2) {
              observer = new ResizeObserver(callback);
              var _iterator17 = _createForOfIteratorHelper(els),
                _step17;
              try {
                for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                  var _el = _step17.value;
                  if (_el) observer.observe(_el, observerOptions);
                }
              } catch (err) {
                _iterator17.e(err);
              } finally {
                _iterator17.f();
              }
            }
          }, {
            immediate: true,
            flush: "post"
          });
          var stop = function stop() {
            cleanup();
            stopWatch();
          };
          tryOnScopeDispose(stop);
          return {
            isSupported: isSupported,
            stop: stop
          };
        }
        function useElementSize(target) {
          var initialSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            width: 0,
            height: 0
          };
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var _options$window4 = options.window,
            window2 = _options$window4 === void 0 ? defaultWindow : _options$window4,
            _options$box = options.box,
            box = _options$box === void 0 ? "content-box" : _options$box;
          var isSVG = computed(function () {
            var _a, _b;
            return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
          });
          var width = ref(initialSize.width);
          var height = ref(initialSize.height);
          var _useResizeObserver = useResizeObserver(target, function (_ref64) {
              var _ref65 = _slicedToArray(_ref64, 1),
                entry = _ref65[0];
              var boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
              if (window2 && isSVG.value) {
                var $elem = unrefElement(target);
                if ($elem) {
                  var rect = $elem.getBoundingClientRect();
                  width.value = rect.width;
                  height.value = rect.height;
                }
              } else {
                if (boxSize) {
                  var formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
                  width.value = formatBoxSize.reduce(function (acc, _ref66) {
                    var inlineSize = _ref66.inlineSize;
                    return acc + inlineSize;
                  }, 0);
                  height.value = formatBoxSize.reduce(function (acc, _ref67) {
                    var blockSize = _ref67.blockSize;
                    return acc + blockSize;
                  }, 0);
                } else {
                  width.value = entry.contentRect.width;
                  height.value = entry.contentRect.height;
                }
              }
            }, options),
            stop1 = _useResizeObserver.stop;
          tryOnMounted(function () {
            var ele = unrefElement(target);
            if (ele) {
              width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
              height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
            }
          });
          var stop2 = watch(function () {
            return unrefElement(target);
          }, function (ele) {
            width.value = ele ? initialSize.width : 0;
            height.value = ele ? initialSize.height : 0;
          });
          function stop() {
            stop1();
            stop2();
          }
          return {
            width: width,
            height: height,
            stop: stop
          };
        }
        var ARRIVED_STATE_THRESHOLD_PIXELS = 1;
        function useScroll(element) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var _options$throttle = options.throttle,
            throttle = _options$throttle === void 0 ? 0 : _options$throttle,
            _options$idle = options.idle,
            idle = _options$idle === void 0 ? 200 : _options$idle,
            _options$onStop = options.onStop,
            onStop = _options$onStop === void 0 ? noop$2 : _options$onStop,
            _options$onScroll = options.onScroll,
            onScroll = _options$onScroll === void 0 ? noop$2 : _options$onScroll,
            _options$offset = options.offset,
            offset = _options$offset === void 0 ? {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            } : _options$offset,
            _options$eventListene = options.eventListenerOptions,
            eventListenerOptions = _options$eventListene === void 0 ? {
              capture: false,
              passive: true
            } : _options$eventListene,
            _options$behavior = options.behavior,
            behavior = _options$behavior === void 0 ? "auto" : _options$behavior,
            _options$window5 = options.window,
            window2 = _options$window5 === void 0 ? defaultWindow : _options$window5,
            _options$onError2 = options.onError,
            onError = _options$onError2 === void 0 ? function (e) {
              console.error(e);
            } : _options$onError2;
          var internalX = ref(0);
          var internalY = ref(0);
          var x = computed({
            get: function get() {
              return internalX.value;
            },
            set: function set(x2) {
              scrollTo2(x2, void 0);
            }
          });
          var y = computed({
            get: function get() {
              return internalY.value;
            },
            set: function set(y2) {
              scrollTo2(void 0, y2);
            }
          });
          function scrollTo2(_x, _y) {
            var _a, _b, _c, _d;
            if (!window2) return;
            var _element = toValue(element);
            if (!_element) return;
            (_c = _element instanceof Document ? window2.document.body : _element) == null ? void 0 : _c.scrollTo({
              top: (_a = toValue(_y)) != null ? _a : y.value,
              left: (_b = toValue(_x)) != null ? _b : x.value,
              behavior: toValue(behavior)
            });
            var scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;
            if (x != null) internalX.value = scrollContainer.scrollLeft;
            if (y != null) internalY.value = scrollContainer.scrollTop;
          }
          var isScrolling = ref(false);
          var arrivedState = reactive({
            left: true,
            right: false,
            top: true,
            bottom: false
          });
          var directions = reactive({
            left: false,
            right: false,
            top: false,
            bottom: false
          });
          var onScrollEnd = function onScrollEnd(e) {
            if (!isScrolling.value) return;
            isScrolling.value = false;
            directions.left = false;
            directions.right = false;
            directions.top = false;
            directions.bottom = false;
            onStop(e);
          };
          var onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);
          var setArrivedState = function setArrivedState(target) {
            var _a;
            if (!window2) return;
            var el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);
            var _getComputedStyle = getComputedStyle(el),
              display = _getComputedStyle.display,
              flexDirection = _getComputedStyle.flexDirection;
            var scrollLeft = el.scrollLeft;
            directions.left = scrollLeft < internalX.value;
            directions.right = scrollLeft > internalX.value;
            var left = Math.abs(scrollLeft) <= (offset.left || 0);
            var right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
            if (display === "flex" && flexDirection === "row-reverse") {
              arrivedState.left = right;
              arrivedState.right = left;
            } else {
              arrivedState.left = left;
              arrivedState.right = right;
            }
            internalX.value = scrollLeft;
            var scrollTop = el.scrollTop;
            if (target === window2.document && !scrollTop) scrollTop = window2.document.body.scrollTop;
            directions.top = scrollTop < internalY.value;
            directions.bottom = scrollTop > internalY.value;
            var top = Math.abs(scrollTop) <= (offset.top || 0);
            var bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
            if (display === "flex" && flexDirection === "column-reverse") {
              arrivedState.top = bottom;
              arrivedState.bottom = top;
            } else {
              arrivedState.top = top;
              arrivedState.bottom = bottom;
            }
            internalY.value = scrollTop;
          };
          var onScrollHandler = function onScrollHandler(e) {
            var _a;
            if (!window2) return;
            var eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;
            setArrivedState(eventTarget);
            isScrolling.value = true;
            onScrollEndDebounced(e);
            onScroll(e);
          };
          useEventListener(element, "scroll", throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler, eventListenerOptions);
          tryOnMounted(function () {
            try {
              var _element = toValue(element);
              if (!_element) return;
              setArrivedState(_element);
            } catch (e) {
              onError(e);
            }
          });
          useEventListener(element, "scrollend", onScrollEnd, eventListenerOptions);
          return {
            x: x,
            y: y,
            isScrolling: isScrolling,
            arrivedState: arrivedState,
            directions: directions,
            measure: function measure() {
              var _element = toValue(element);
              if (window2 && _element) setArrivedState(_element);
            }
          };
        }
        function useLocalStorage(key, initialValue) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var _options$window6 = options.window,
            window2 = _options$window6 === void 0 ? defaultWindow : _options$window6;
          return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
        }
        var _hoisted_1$7 = {
          class: "w-screen"
        };
        var _sfc_main$7 = /* @__PURE__ */defineComponent({
          __name: "index",
          setup: function setup(__props) {
            var mainContainer = ref(null);
            var _useScroll = useScroll(mainContainer),
              y = _useScroll.y;
            function scrollToTop() {
              y.value = 0;
            }
            return function (_ctx, _cache) {
              var _component_router_view = resolveComponent("router-view");
              return openBlock(), createElementBlock("div", _hoisted_1$7, [unref(y) > 400 ? (openBlock(), createBlock(ToTop, {
                key: 0,
                onClick: scrollToTop
              })) : createCommentVNode("", true), createBaseVNode("main", {
                ref_key: "mainContainer",
                ref: mainContainer,
                class: "box-content w-screen h-screen overflow-x-hidden overflow-y-auto main-container"
              }, [createVNode(_component_router_view, {
                class: "h-full main-container-content"
              })], 512)]);
            };
          }
        });
        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
        function getDefaultExportFromCjs(x) {
          return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
        }
        function getAugmentedNamespace(n) {
          if (n.__esModule) return n;
          var f = n.default;
          if (typeof f == "function") {
            var a = function a() {
              if (this instanceof a) {
                return Reflect.construct(f, arguments, this.constructor);
              }
              return f.apply(this, arguments);
            };
            a.prototype = f.prototype;
          } else a = {};
          Object.defineProperty(a, '__esModule', {
            value: true
          });
          Object.keys(n).forEach(function (k) {
            var d = Object.getOwnPropertyDescriptor(n, k);
            Object.defineProperty(a, k, d.get ? d : {
              enumerable: true,
              get: function get() {
                return n[k];
              }
            });
          });
          return a;
        }
        function commonjsRequire(path) {
          throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
        }
        var localforage$1 = {
          exports: {}
        };

        /*!
            localForage -- Offline Storage, Improved
            Version 1.10.0
            https://localforage.github.io/localForage
            (c) 2013-2017 Mozilla, Apache License 2.0
        */

        (function (module, exports) {
          (function (f) {
            {
              module.exports = f();
            }
          })(function () {
            return function e(t, n, r) {
              function s(o, u) {
                if (!n[o]) {
                  if (!t[o]) {
                    var a = typeof commonjsRequire == "function" && commonjsRequire;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f;
                  }
                  var l = n[o] = {
                    exports: {}
                  };
                  t[o][0].call(l.exports, function (e) {
                    var n = t[o][1][e];
                    return s(n ? n : e);
                  }, l, l.exports, e, t, n, r);
                }
                return n[o].exports;
              }
              var i = typeof commonjsRequire == "function" && commonjsRequire;
              for (var o = 0; o < r.length; o++) s(r[o]);
              return s;
            }({
              1: [function (_dereq_, module, exports) {
                (function (global) {
                  var Mutation = global.MutationObserver || global.WebKitMutationObserver;
                  var scheduleDrain;
                  {
                    if (Mutation) {
                      var called = 0;
                      var observer = new Mutation(nextTick);
                      var element = global.document.createTextNode('');
                      observer.observe(element, {
                        characterData: true
                      });
                      scheduleDrain = function scheduleDrain() {
                        element.data = called = ++called % 2;
                      };
                    } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
                      var channel = new global.MessageChannel();
                      channel.port1.onmessage = nextTick;
                      scheduleDrain = function scheduleDrain() {
                        channel.port2.postMessage(0);
                      };
                    } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
                      scheduleDrain = function scheduleDrain() {
                        // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                        // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                        var scriptEl = global.document.createElement('script');
                        scriptEl.onreadystatechange = function () {
                          nextTick();
                          scriptEl.onreadystatechange = null;
                          scriptEl.parentNode.removeChild(scriptEl);
                          scriptEl = null;
                        };
                        global.document.documentElement.appendChild(scriptEl);
                      };
                    } else {
                      scheduleDrain = function scheduleDrain() {
                        setTimeout(nextTick, 0);
                      };
                    }
                  }
                  var draining;
                  var queue = [];
                  //named nextTick for less confusing stack traces
                  function nextTick() {
                    draining = true;
                    var i, oldQueue;
                    var len = queue.length;
                    while (len) {
                      oldQueue = queue;
                      queue = [];
                      i = -1;
                      while (++i < len) {
                        oldQueue[i]();
                      }
                      len = queue.length;
                    }
                    draining = false;
                  }
                  module.exports = immediate;
                  function immediate(task) {
                    if (queue.push(task) === 1 && !draining) {
                      scheduleDrain();
                    }
                  }
                }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
              }, {}],
              2: [function (_dereq_, module, exports) {
                var immediate = _dereq_(1);

                /* istanbul ignore next */
                function INTERNAL() {}
                var handlers = {};
                var REJECTED = ['REJECTED'];
                var FULFILLED = ['FULFILLED'];
                var PENDING = ['PENDING'];
                module.exports = Promise;
                function Promise(resolver) {
                  if (typeof resolver !== 'function') {
                    throw new TypeError('resolver must be a function');
                  }
                  this.state = PENDING;
                  this.queue = [];
                  this.outcome = void 0;
                  if (resolver !== INTERNAL) {
                    safelyResolveThenable(this, resolver);
                  }
                }
                Promise.prototype["catch"] = function (onRejected) {
                  return this.then(null, onRejected);
                };
                Promise.prototype.then = function (onFulfilled, onRejected) {
                  if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {
                    return this;
                  }
                  var promise = new this.constructor(INTERNAL);
                  if (this.state !== PENDING) {
                    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
                    unwrap(promise, resolver, this.outcome);
                  } else {
                    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
                  }
                  return promise;
                };
                function QueueItem(promise, onFulfilled, onRejected) {
                  this.promise = promise;
                  if (typeof onFulfilled === 'function') {
                    this.onFulfilled = onFulfilled;
                    this.callFulfilled = this.otherCallFulfilled;
                  }
                  if (typeof onRejected === 'function') {
                    this.onRejected = onRejected;
                    this.callRejected = this.otherCallRejected;
                  }
                }
                QueueItem.prototype.callFulfilled = function (value) {
                  handlers.resolve(this.promise, value);
                };
                QueueItem.prototype.otherCallFulfilled = function (value) {
                  unwrap(this.promise, this.onFulfilled, value);
                };
                QueueItem.prototype.callRejected = function (value) {
                  handlers.reject(this.promise, value);
                };
                QueueItem.prototype.otherCallRejected = function (value) {
                  unwrap(this.promise, this.onRejected, value);
                };
                function unwrap(promise, func, value) {
                  immediate(function () {
                    var returnValue;
                    try {
                      returnValue = func(value);
                    } catch (e) {
                      return handlers.reject(promise, e);
                    }
                    if (returnValue === promise) {
                      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
                    } else {
                      handlers.resolve(promise, returnValue);
                    }
                  });
                }
                handlers.resolve = function (self, value) {
                  var result = tryCatch(getThen, value);
                  if (result.status === 'error') {
                    return handlers.reject(self, result.value);
                  }
                  var thenable = result.value;
                  if (thenable) {
                    safelyResolveThenable(self, thenable);
                  } else {
                    self.state = FULFILLED;
                    self.outcome = value;
                    var i = -1;
                    var len = self.queue.length;
                    while (++i < len) {
                      self.queue[i].callFulfilled(value);
                    }
                  }
                  return self;
                };
                handlers.reject = function (self, error) {
                  self.state = REJECTED;
                  self.outcome = error;
                  var i = -1;
                  var len = self.queue.length;
                  while (++i < len) {
                    self.queue[i].callRejected(error);
                  }
                  return self;
                };
                function getThen(obj) {
                  // Make sure we only access the accessor once as required by the spec
                  var then = obj && obj.then;
                  if (obj && (_typeof2(obj) === 'object' || typeof obj === 'function') && typeof then === 'function') {
                    return function appyThen() {
                      then.apply(obj, arguments);
                    };
                  }
                }
                function safelyResolveThenable(self, thenable) {
                  // Either fulfill, reject or reject with error
                  var called = false;
                  function onError(value) {
                    if (called) {
                      return;
                    }
                    called = true;
                    handlers.reject(self, value);
                  }
                  function onSuccess(value) {
                    if (called) {
                      return;
                    }
                    called = true;
                    handlers.resolve(self, value);
                  }
                  function tryToUnwrap() {
                    thenable(onSuccess, onError);
                  }
                  var result = tryCatch(tryToUnwrap);
                  if (result.status === 'error') {
                    onError(result.value);
                  }
                }
                function tryCatch(func, value) {
                  var out = {};
                  try {
                    out.value = func(value);
                    out.status = 'success';
                  } catch (e) {
                    out.status = 'error';
                    out.value = e;
                  }
                  return out;
                }
                Promise.resolve = resolve;
                function resolve(value) {
                  if (value instanceof this) {
                    return value;
                  }
                  return handlers.resolve(new this(INTERNAL), value);
                }
                Promise.reject = reject;
                function reject(reason) {
                  var promise = new this(INTERNAL);
                  return handlers.reject(promise, reason);
                }
                Promise.all = all;
                function all(iterable) {
                  var self = this;
                  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
                    return this.reject(new TypeError('must be an array'));
                  }
                  var len = iterable.length;
                  var called = false;
                  if (!len) {
                    return this.resolve([]);
                  }
                  var values = new Array(len);
                  var resolved = 0;
                  var i = -1;
                  var promise = new this(INTERNAL);
                  while (++i < len) {
                    allResolver(iterable[i], i);
                  }
                  return promise;
                  function allResolver(value, i) {
                    self.resolve(value).then(resolveFromAll, function (error) {
                      if (!called) {
                        called = true;
                        handlers.reject(promise, error);
                      }
                    });
                    function resolveFromAll(outValue) {
                      values[i] = outValue;
                      if (++resolved === len && !called) {
                        called = true;
                        handlers.resolve(promise, values);
                      }
                    }
                  }
                }
                Promise.race = race;
                function race(iterable) {
                  var self = this;
                  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
                    return this.reject(new TypeError('must be an array'));
                  }
                  var len = iterable.length;
                  var called = false;
                  if (!len) {
                    return this.resolve([]);
                  }
                  var i = -1;
                  var promise = new this(INTERNAL);
                  while (++i < len) {
                    resolver(iterable[i]);
                  }
                  return promise;
                  function resolver(value) {
                    self.resolve(value).then(function (response) {
                      if (!called) {
                        called = true;
                        handlers.resolve(promise, response);
                      }
                    }, function (error) {
                      if (!called) {
                        called = true;
                        handlers.reject(promise, error);
                      }
                    });
                  }
                }
              }, {
                "1": 1
              }],
              3: [function (_dereq_, module, exports) {
                (function (global) {
                  if (typeof global.Promise !== 'function') {
                    global.Promise = _dereq_(2);
                  }
                }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
              }, {
                "2": 2
              }],
              4: [function (_dereq_, module, exports) {
                var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
                  return _typeof2(obj);
                } : function (obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
                };
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function getIDB() {
                  /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
                  try {
                    if (typeof indexedDB !== 'undefined') {
                      return indexedDB;
                    }
                    if (typeof webkitIndexedDB !== 'undefined') {
                      return webkitIndexedDB;
                    }
                    if (typeof mozIndexedDB !== 'undefined') {
                      return mozIndexedDB;
                    }
                    if (typeof OIndexedDB !== 'undefined') {
                      return OIndexedDB;
                    }
                    if (typeof msIndexedDB !== 'undefined') {
                      return msIndexedDB;
                    }
                  } catch (e) {
                    return;
                  }
                }
                var idb = getIDB();
                function isIndexedDBValid() {
                  try {
                    // Initialize IndexedDB; fall back to vendor-prefixed versions
                    // if needed.
                    if (!idb || !idb.open) {
                      return false;
                    }
                    // We mimic PouchDB here;
                    //
                    // We test for openDatabase because IE Mobile identifies itself
                    // as Safari. Oh the lulz...
                    var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
                    var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;

                    // Safari <10.1 does not meet our requirements for IDB support
                    // (see: https://github.com/pouchdb/pouchdb/issues/5572).
                    // Safari 10.1 shipped with fetch, we can use that to detect it.
                    // Note: this creates issues with `window.fetch` polyfills and
                    // overrides; see:
                    // https://github.com/localForage/localForage/issues/856
                    return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
                    // some outdated implementations of IDB that appear on Samsung
                    // and HTC Android devices <4.4 are missing IDBKeyRange
                    // See: https://github.com/mozilla/localForage/issues/128
                    // See: https://github.com/mozilla/localForage/issues/272
                    typeof IDBKeyRange !== 'undefined';
                  } catch (e) {
                    return false;
                  }
                }

                // Abstracts constructing a Blob object, so it also works in older
                // browsers that don't support the native Blob constructor. (i.e.
                // old QtWebKit versions, at least).
                // Abstracts constructing a Blob object, so it also works in older
                // browsers that don't support the native Blob constructor. (i.e.
                // old QtWebKit versions, at least).
                function createBlob(parts, properties) {
                  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
                  parts = parts || [];
                  properties = properties || {};
                  try {
                    return new Blob(parts, properties);
                  } catch (e) {
                    if (e.name !== 'TypeError') {
                      throw e;
                    }
                    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
                    var builder = new Builder();
                    for (var i = 0; i < parts.length; i += 1) {
                      builder.append(parts[i]);
                    }
                    return builder.getBlob(properties.type);
                  }
                }

                // This is CommonJS because lie is an external dependency, so Rollup
                // can just ignore it.
                if (typeof Promise === 'undefined') {
                  // In the "nopromises" build this will just throw if you don't have
                  // a global promise object, but it would throw anyway later.
                  _dereq_(3);
                }
                var Promise$1 = Promise;
                function executeCallback(promise, callback) {
                  if (callback) {
                    promise.then(function (result) {
                      callback(null, result);
                    }, function (error) {
                      callback(error);
                    });
                  }
                }
                function executeTwoCallbacks(promise, callback, errorCallback) {
                  if (typeof callback === 'function') {
                    promise.then(callback);
                  }
                  if (typeof errorCallback === 'function') {
                    promise["catch"](errorCallback);
                  }
                }
                function normalizeKey(key) {
                  // Cast the key to a string, as that's all we can set as a key.
                  if (typeof key !== 'string') {
                    console.warn(key + ' used as a key, but it is not a string.');
                    key = String(key);
                  }
                  return key;
                }
                function getCallback() {
                  if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
                    return arguments[arguments.length - 1];
                  }
                }

                // Some code originally from async_storage.js in
                // [Gaia](https://github.com/mozilla-b2g/gaia).

                var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
                var supportsBlobs = void 0;
                var dbContexts = {};
                var toString = Object.prototype.toString;

                // Transaction Modes
                var READ_ONLY = 'readonly';
                var READ_WRITE = 'readwrite';

                // Transform a binary string to an array buffer, because otherwise
                // weird stuff happens when you try to work with the binary string directly.
                // It is known.
                // From http://stackoverflow.com/questions/14967647/ (continues on next line)
                // encode-decode-image-with-base64-breaks-image (2013-04-21)
                function _binStringToArrayBuffer(bin) {
                  var length = bin.length;
                  var buf = new ArrayBuffer(length);
                  var arr = new Uint8Array(buf);
                  for (var i = 0; i < length; i++) {
                    arr[i] = bin.charCodeAt(i);
                  }
                  return buf;
                }

                //
                // Blobs are not supported in all versions of IndexedDB, notably
                // Chrome <37 and Android <5. In those versions, storing a blob will throw.
                //
                // Various other blob bugs exist in Chrome v37-42 (inclusive).
                // Detecting them is expensive and confusing to users, and Chrome 37-42
                // is at very low usage worldwide, so we do a hacky userAgent check instead.
                //
                // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
                // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
                // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
                //
                // Code borrowed from PouchDB. See:
                // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
                //
                function _checkBlobSupportWithoutCaching(idb) {
                  return new Promise$1(function (resolve) {
                    var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
                    var blob = createBlob(['']);
                    txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');
                    txn.onabort = function (e) {
                      // If the transaction aborts now its due to not being able to
                      // write to the database, likely due to the disk being full
                      e.preventDefault();
                      e.stopPropagation();
                      resolve(false);
                    };
                    txn.oncomplete = function () {
                      var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
                      var matchedEdge = navigator.userAgent.match(/Edge\//);
                      // MS Edge pretends to be Chrome 42:
                      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
                      resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
                    };
                  })["catch"](function () {
                    return false; // error, so assume unsupported
                  });
                }
                function _checkBlobSupport(idb) {
                  if (typeof supportsBlobs === 'boolean') {
                    return Promise$1.resolve(supportsBlobs);
                  }
                  return _checkBlobSupportWithoutCaching(idb).then(function (value) {
                    supportsBlobs = value;
                    return supportsBlobs;
                  });
                }
                function _deferReadiness(dbInfo) {
                  var dbContext = dbContexts[dbInfo.name];

                  // Create a deferred object representing the current database operation.
                  var deferredOperation = {};
                  deferredOperation.promise = new Promise$1(function (resolve, reject) {
                    deferredOperation.resolve = resolve;
                    deferredOperation.reject = reject;
                  });

                  // Enqueue the deferred operation.
                  dbContext.deferredOperations.push(deferredOperation);

                  // Chain its promise to the database readiness.
                  if (!dbContext.dbReady) {
                    dbContext.dbReady = deferredOperation.promise;
                  } else {
                    dbContext.dbReady = dbContext.dbReady.then(function () {
                      return deferredOperation.promise;
                    });
                  }
                }
                function _advanceReadiness(dbInfo) {
                  var dbContext = dbContexts[dbInfo.name];

                  // Dequeue a deferred operation.
                  var deferredOperation = dbContext.deferredOperations.pop();

                  // Resolve its promise (which is part of the database readiness
                  // chain of promises).
                  if (deferredOperation) {
                    deferredOperation.resolve();
                    return deferredOperation.promise;
                  }
                }
                function _rejectReadiness(dbInfo, err) {
                  var dbContext = dbContexts[dbInfo.name];

                  // Dequeue a deferred operation.
                  var deferredOperation = dbContext.deferredOperations.pop();

                  // Reject its promise (which is part of the database readiness
                  // chain of promises).
                  if (deferredOperation) {
                    deferredOperation.reject(err);
                    return deferredOperation.promise;
                  }
                }
                function _getConnection(dbInfo, upgradeNeeded) {
                  return new Promise$1(function (resolve, reject) {
                    dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
                    if (dbInfo.db) {
                      if (upgradeNeeded) {
                        _deferReadiness(dbInfo);
                        dbInfo.db.close();
                      } else {
                        return resolve(dbInfo.db);
                      }
                    }
                    var dbArgs = [dbInfo.name];
                    if (upgradeNeeded) {
                      dbArgs.push(dbInfo.version);
                    }
                    var openreq = idb.open.apply(idb, dbArgs);
                    if (upgradeNeeded) {
                      openreq.onupgradeneeded = function (e) {
                        var db = openreq.result;
                        try {
                          db.createObjectStore(dbInfo.storeName);
                          if (e.oldVersion <= 1) {
                            // Added when support for blob shims was added
                            db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                          }
                        } catch (ex) {
                          if (ex.name === 'ConstraintError') {
                            console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                          } else {
                            throw ex;
                          }
                        }
                      };
                    }
                    openreq.onerror = function (e) {
                      e.preventDefault();
                      reject(openreq.error);
                    };
                    openreq.onsuccess = function () {
                      var db = openreq.result;
                      db.onversionchange = function (e) {
                        // Triggered when the database is modified (e.g. adding an objectStore) or
                        // deleted (even when initiated by other sessions in different tabs).
                        // Closing the connection here prevents those operations from being blocked.
                        // If the database is accessed again later by this instance, the connection
                        // will be reopened or the database recreated as needed.
                        e.target.close();
                      };
                      resolve(db);
                      _advanceReadiness(dbInfo);
                    };
                  });
                }
                function _getOriginalConnection(dbInfo) {
                  return _getConnection(dbInfo, false);
                }
                function _getUpgradedConnection(dbInfo) {
                  return _getConnection(dbInfo, true);
                }
                function _isUpgradeNeeded(dbInfo, defaultVersion) {
                  if (!dbInfo.db) {
                    return true;
                  }
                  var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
                  var isDowngrade = dbInfo.version < dbInfo.db.version;
                  var isUpgrade = dbInfo.version > dbInfo.db.version;
                  if (isDowngrade) {
                    // If the version is not the default one
                    // then warn for impossible downgrade.
                    if (dbInfo.version !== defaultVersion) {
                      console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
                    }
                    // Align the versions to prevent errors.
                    dbInfo.version = dbInfo.db.version;
                  }
                  if (isUpgrade || isNewStore) {
                    // If the store is new then increment the version (if needed).
                    // This will trigger an "upgradeneeded" event which is required
                    // for creating a store.
                    if (isNewStore) {
                      var incVersion = dbInfo.db.version + 1;
                      if (incVersion > dbInfo.version) {
                        dbInfo.version = incVersion;
                      }
                    }
                    return true;
                  }
                  return false;
                }

                // encode a blob for indexeddb engines that don't support blobs
                function _encodeBlob(blob) {
                  return new Promise$1(function (resolve, reject) {
                    var reader = new FileReader();
                    reader.onerror = reject;
                    reader.onloadend = function (e) {
                      var base64 = btoa(e.target.result || '');
                      resolve({
                        __local_forage_encoded_blob: true,
                        data: base64,
                        type: blob.type
                      });
                    };
                    reader.readAsBinaryString(blob);
                  });
                }

                // decode an encoded blob
                function _decodeBlob(encodedBlob) {
                  var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
                  return createBlob([arrayBuff], {
                    type: encodedBlob.type
                  });
                }

                // is this one of our fancy encoded blobs?
                function _isEncodedBlob(value) {
                  return value && value.__local_forage_encoded_blob;
                }

                // Specialize the default `ready()` function by making it dependent
                // on the current database operations. Thus, the driver will be actually
                // ready when it's been initialized (default) *and* there are no pending
                // operations on the database (initiated by some other instances).
                function _fullyReady(callback) {
                  var self = this;
                  var promise = self._initReady().then(function () {
                    var dbContext = dbContexts[self._dbInfo.name];
                    if (dbContext && dbContext.dbReady) {
                      return dbContext.dbReady;
                    }
                  });
                  executeTwoCallbacks(promise, callback, callback);
                  return promise;
                }

                // Try to establish a new db connection to replace the
                // current one which is broken (i.e. experiencing
                // InvalidStateError while creating a transaction).
                function _tryReconnect(dbInfo) {
                  _deferReadiness(dbInfo);
                  var dbContext = dbContexts[dbInfo.name];
                  var forages = dbContext.forages;
                  for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    if (forage._dbInfo.db) {
                      forage._dbInfo.db.close();
                      forage._dbInfo.db = null;
                    }
                  }
                  dbInfo.db = null;
                  return _getOriginalConnection(dbInfo).then(function (db) {
                    dbInfo.db = db;
                    if (_isUpgradeNeeded(dbInfo)) {
                      // Reopen the database for upgrading.
                      return _getUpgradedConnection(dbInfo);
                    }
                    return db;
                  }).then(function (db) {
                    // store the latest db reference
                    // in case the db was upgraded
                    dbInfo.db = dbContext.db = db;
                    for (var i = 0; i < forages.length; i++) {
                      forages[i]._dbInfo.db = db;
                    }
                  })["catch"](function (err) {
                    _rejectReadiness(dbInfo, err);
                    throw err;
                  });
                }

                // FF doesn't like Promises (micro-tasks) and IDDB store operations,
                // so we have to do it with callbacks
                function createTransaction(dbInfo, mode, callback, retries) {
                  if (retries === undefined) {
                    retries = 1;
                  }
                  try {
                    var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
                    callback(null, tx);
                  } catch (err) {
                    if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
                      return Promise$1.resolve().then(function () {
                        if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                          // increase the db version, to create the new ObjectStore
                          if (dbInfo.db) {
                            dbInfo.version = dbInfo.db.version + 1;
                          }
                          // Reopen the database for upgrading.
                          return _getUpgradedConnection(dbInfo);
                        }
                      }).then(function () {
                        return _tryReconnect(dbInfo).then(function () {
                          createTransaction(dbInfo, mode, callback, retries - 1);
                        });
                      })["catch"](callback);
                    }
                    callback(err);
                  }
                }
                function createDbContext() {
                  return {
                    // Running localForages sharing a database.
                    forages: [],
                    // Shared database.
                    db: null,
                    // Database readiness (promise).
                    dbReady: null,
                    // Deferred operations on the database.
                    deferredOperations: []
                  };
                }

                // Open the IndexedDB database (automatically creates one if one didn't
                // previously exist), using any options set in the config.
                function _initStorage(options) {
                  var self = this;
                  var dbInfo = {
                    db: null
                  };
                  if (options) {
                    for (var i in options) {
                      dbInfo[i] = options[i];
                    }
                  }

                  // Get the current context of the database;
                  var dbContext = dbContexts[dbInfo.name];

                  // ...or create a new context.
                  if (!dbContext) {
                    dbContext = createDbContext();
                    // Register the new context in the global container.
                    dbContexts[dbInfo.name] = dbContext;
                  }

                  // Register itself as a running localForage in the current context.
                  dbContext.forages.push(self);

                  // Replace the default `ready()` function with the specialized one.
                  if (!self._initReady) {
                    self._initReady = self.ready;
                    self.ready = _fullyReady;
                  }

                  // Create an array of initialization states of the related localForages.
                  var initPromises = [];
                  function ignoreErrors() {
                    // Don't handle errors here,
                    // just makes sure related localForages aren't pending.
                    return Promise$1.resolve();
                  }
                  for (var j = 0; j < dbContext.forages.length; j++) {
                    var forage = dbContext.forages[j];
                    if (forage !== self) {
                      // Don't wait for itself...
                      initPromises.push(forage._initReady()["catch"](ignoreErrors));
                    }
                  }

                  // Take a snapshot of the related localForages.
                  var forages = dbContext.forages.slice(0);

                  // Initialize the connection process only when
                  // all the related localForages aren't pending.
                  return Promise$1.all(initPromises).then(function () {
                    dbInfo.db = dbContext.db;
                    // Get the connection or open a new one without upgrade.
                    return _getOriginalConnection(dbInfo);
                  }).then(function (db) {
                    dbInfo.db = db;
                    if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
                      // Reopen the database for upgrading.
                      return _getUpgradedConnection(dbInfo);
                    }
                    return db;
                  }).then(function (db) {
                    dbInfo.db = dbContext.db = db;
                    self._dbInfo = dbInfo;
                    // Share the final connection amongst related localForages.
                    for (var k = 0; k < forages.length; k++) {
                      var forage = forages[k];
                      if (forage !== self) {
                        // Self is already up-to-date.
                        forage._dbInfo.db = dbInfo.db;
                        forage._dbInfo.version = dbInfo.version;
                      }
                    }
                  });
                }
                function getItem(key, callback) {
                  var self = this;
                  key = normalizeKey(key);
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                        if (err) {
                          return reject(err);
                        }
                        try {
                          var store = transaction.objectStore(self._dbInfo.storeName);
                          var req = store.get(key);
                          req.onsuccess = function () {
                            var value = req.result;
                            if (value === undefined) {
                              value = null;
                            }
                            if (_isEncodedBlob(value)) {
                              value = _decodeBlob(value);
                            }
                            resolve(value);
                          };
                          req.onerror = function () {
                            reject(req.error);
                          };
                        } catch (e) {
                          reject(e);
                        }
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }

                // Iterate over all items stored in database.
                function iterate(iterator, callback) {
                  var self = this;
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                        if (err) {
                          return reject(err);
                        }
                        try {
                          var store = transaction.objectStore(self._dbInfo.storeName);
                          var req = store.openCursor();
                          var iterationNumber = 1;
                          req.onsuccess = function () {
                            var cursor = req.result;
                            if (cursor) {
                              var value = cursor.value;
                              if (_isEncodedBlob(value)) {
                                value = _decodeBlob(value);
                              }
                              var result = iterator(value, cursor.key, iterationNumber++);

                              // when the iterator callback returns any
                              // (non-`undefined`) value, then we stop
                              // the iteration immediately
                              if (result !== void 0) {
                                resolve(result);
                              } else {
                                cursor["continue"]();
                              }
                            } else {
                              resolve();
                            }
                          };
                          req.onerror = function () {
                            reject(req.error);
                          };
                        } catch (e) {
                          reject(e);
                        }
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }
                function setItem(key, value, callback) {
                  var self = this;
                  key = normalizeKey(key);
                  var promise = new Promise$1(function (resolve, reject) {
                    var dbInfo;
                    self.ready().then(function () {
                      dbInfo = self._dbInfo;
                      if (toString.call(value) === '[object Blob]') {
                        return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
                          if (blobSupport) {
                            return value;
                          }
                          return _encodeBlob(value);
                        });
                      }
                      return value;
                    }).then(function (value) {
                      createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                        if (err) {
                          return reject(err);
                        }
                        try {
                          var store = transaction.objectStore(self._dbInfo.storeName);

                          // The reason we don't _save_ null is because IE 10 does
                          // not support saving the `null` type in IndexedDB. How
                          // ironic, given the bug below!
                          // See: https://github.com/mozilla/localForage/issues/161
                          if (value === null) {
                            value = undefined;
                          }
                          var req = store.put(value, key);
                          transaction.oncomplete = function () {
                            // Cast to undefined so the value passed to
                            // callback/promise is the same as what one would get out
                            // of `getItem()` later. This leads to some weirdness
                            // (setItem('foo', undefined) will return `null`), but
                            // it's not my fault localStorage is our baseline and that
                            // it's weird.
                            if (value === undefined) {
                              value = null;
                            }
                            resolve(value);
                          };
                          transaction.onabort = transaction.onerror = function () {
                            var err = req.error ? req.error : req.transaction.error;
                            reject(err);
                          };
                        } catch (e) {
                          reject(e);
                        }
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }
                function removeItem(key, callback) {
                  var self = this;
                  key = normalizeKey(key);
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                        if (err) {
                          return reject(err);
                        }
                        try {
                          var store = transaction.objectStore(self._dbInfo.storeName);
                          // We use a Grunt task to make this safe for IE and some
                          // versions of Android (including those used by Cordova).
                          // Normally IE won't like `.delete()` and will insist on
                          // using `['delete']()`, but we have a build step that
                          // fixes this for us now.
                          var req = store["delete"](key);
                          transaction.oncomplete = function () {
                            resolve();
                          };
                          transaction.onerror = function () {
                            reject(req.error);
                          };

                          // The request will be also be aborted if we've exceeded our storage
                          // space.
                          transaction.onabort = function () {
                            var err = req.error ? req.error : req.transaction.error;
                            reject(err);
                          };
                        } catch (e) {
                          reject(e);
                        }
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }
                function clear(callback) {
                  var self = this;
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                        if (err) {
                          return reject(err);
                        }
                        try {
                          var store = transaction.objectStore(self._dbInfo.storeName);
                          var req = store.clear();
                          transaction.oncomplete = function () {
                            resolve();
                          };
                          transaction.onabort = transaction.onerror = function () {
                            var err = req.error ? req.error : req.transaction.error;
                            reject(err);
                          };
                        } catch (e) {
                          reject(e);
                        }
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }
                function length(callback) {
                  var self = this;
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                        if (err) {
                          return reject(err);
                        }
                        try {
                          var store = transaction.objectStore(self._dbInfo.storeName);
                          var req = store.count();
                          req.onsuccess = function () {
                            resolve(req.result);
                          };
                          req.onerror = function () {
                            reject(req.error);
                          };
                        } catch (e) {
                          reject(e);
                        }
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }
                function key(n, callback) {
                  var self = this;
                  var promise = new Promise$1(function (resolve, reject) {
                    if (n < 0) {
                      resolve(null);
                      return;
                    }
                    self.ready().then(function () {
                      createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                        if (err) {
                          return reject(err);
                        }
                        try {
                          var store = transaction.objectStore(self._dbInfo.storeName);
                          var advanced = false;
                          var req = store.openKeyCursor();
                          req.onsuccess = function () {
                            var cursor = req.result;
                            if (!cursor) {
                              // this means there weren't enough keys
                              resolve(null);
                              return;
                            }
                            if (n === 0) {
                              // We have the first key, return it if that's what they
                              // wanted.
                              resolve(cursor.key);
                            } else {
                              if (!advanced) {
                                // Otherwise, ask the cursor to skip ahead n
                                // records.
                                advanced = true;
                                cursor.advance(n);
                              } else {
                                // When we get here, we've got the nth key.
                                resolve(cursor.key);
                              }
                            }
                          };
                          req.onerror = function () {
                            reject(req.error);
                          };
                        } catch (e) {
                          reject(e);
                        }
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }
                function keys(callback) {
                  var self = this;
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                        if (err) {
                          return reject(err);
                        }
                        try {
                          var store = transaction.objectStore(self._dbInfo.storeName);
                          var req = store.openKeyCursor();
                          var keys = [];
                          req.onsuccess = function () {
                            var cursor = req.result;
                            if (!cursor) {
                              resolve(keys);
                              return;
                            }
                            keys.push(cursor.key);
                            cursor["continue"]();
                          };
                          req.onerror = function () {
                            reject(req.error);
                          };
                        } catch (e) {
                          reject(e);
                        }
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }
                function dropInstance(options, callback) {
                  callback = getCallback.apply(this, arguments);
                  var currentConfig = this.config();
                  options = typeof options !== 'function' && options || {};
                  if (!options.name) {
                    options.name = options.name || currentConfig.name;
                    options.storeName = options.storeName || currentConfig.storeName;
                  }
                  var self = this;
                  var promise;
                  if (!options.name) {
                    promise = Promise$1.reject('Invalid arguments');
                  } else {
                    var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;
                    var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
                      var dbContext = dbContexts[options.name];
                      var forages = dbContext.forages;
                      dbContext.db = db;
                      for (var i = 0; i < forages.length; i++) {
                        forages[i]._dbInfo.db = db;
                      }
                      return db;
                    });
                    if (!options.storeName) {
                      promise = dbPromise.then(function (db) {
                        _deferReadiness(options);
                        var dbContext = dbContexts[options.name];
                        var forages = dbContext.forages;
                        db.close();
                        for (var i = 0; i < forages.length; i++) {
                          var forage = forages[i];
                          forage._dbInfo.db = null;
                        }
                        var dropDBPromise = new Promise$1(function (resolve, reject) {
                          var req = idb.deleteDatabase(options.name);
                          req.onerror = function () {
                            var db = req.result;
                            if (db) {
                              db.close();
                            }
                            reject(req.error);
                          };
                          req.onblocked = function () {
                            // Closing all open connections in onversionchange handler should prevent this situation, but if
                            // we do get here, it just means the request remains pending - eventually it will succeed or error
                            console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                          };
                          req.onsuccess = function () {
                            var db = req.result;
                            if (db) {
                              db.close();
                            }
                            resolve(db);
                          };
                        });
                        return dropDBPromise.then(function (db) {
                          dbContext.db = db;
                          for (var i = 0; i < forages.length; i++) {
                            var _forage = forages[i];
                            _advanceReadiness(_forage._dbInfo);
                          }
                        })["catch"](function (err) {
                          (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                          throw err;
                        });
                      });
                    } else {
                      promise = dbPromise.then(function (db) {
                        if (!db.objectStoreNames.contains(options.storeName)) {
                          return;
                        }
                        var newVersion = db.version + 1;
                        _deferReadiness(options);
                        var dbContext = dbContexts[options.name];
                        var forages = dbContext.forages;
                        db.close();
                        for (var i = 0; i < forages.length; i++) {
                          var forage = forages[i];
                          forage._dbInfo.db = null;
                          forage._dbInfo.version = newVersion;
                        }
                        var dropObjectPromise = new Promise$1(function (resolve, reject) {
                          var req = idb.open(options.name, newVersion);
                          req.onerror = function (err) {
                            var db = req.result;
                            db.close();
                            reject(err);
                          };
                          req.onupgradeneeded = function () {
                            var db = req.result;
                            db.deleteObjectStore(options.storeName);
                          };
                          req.onsuccess = function () {
                            var db = req.result;
                            db.close();
                            resolve(db);
                          };
                        });
                        return dropObjectPromise.then(function (db) {
                          dbContext.db = db;
                          for (var j = 0; j < forages.length; j++) {
                            var _forage2 = forages[j];
                            _forage2._dbInfo.db = db;
                            _advanceReadiness(_forage2._dbInfo);
                          }
                        })["catch"](function (err) {
                          (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                          throw err;
                        });
                      });
                    }
                  }
                  executeCallback(promise, callback);
                  return promise;
                }
                var asyncStorage = {
                  _driver: 'asyncStorage',
                  _initStorage: _initStorage,
                  _support: isIndexedDBValid(),
                  iterate: iterate,
                  getItem: getItem,
                  setItem: setItem,
                  removeItem: removeItem,
                  clear: clear,
                  length: length,
                  key: key,
                  keys: keys,
                  dropInstance: dropInstance
                };
                function isWebSQLValid() {
                  return typeof openDatabase === 'function';
                }

                // Sadly, the best way to save binary data in WebSQL/localStorage is serializing
                // it to Base64, so this is how we store it to prevent very strange errors with less
                // verbose ways of binary <-> string data storage.
                var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var BLOB_TYPE_PREFIX = '~~local_forage_type~';
                var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
                var SERIALIZED_MARKER = '__lfsc__:';
                var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

                // OMG the serializations!
                var TYPE_ARRAYBUFFER = 'arbf';
                var TYPE_BLOB = 'blob';
                var TYPE_INT8ARRAY = 'si08';
                var TYPE_UINT8ARRAY = 'ui08';
                var TYPE_UINT8CLAMPEDARRAY = 'uic8';
                var TYPE_INT16ARRAY = 'si16';
                var TYPE_INT32ARRAY = 'si32';
                var TYPE_UINT16ARRAY = 'ur16';
                var TYPE_UINT32ARRAY = 'ui32';
                var TYPE_FLOAT32ARRAY = 'fl32';
                var TYPE_FLOAT64ARRAY = 'fl64';
                var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
                var toString$1 = Object.prototype.toString;
                function stringToBuffer(serializedString) {
                  // Fill the string into a ArrayBuffer.
                  var bufferLength = serializedString.length * 0.75;
                  var len = serializedString.length;
                  var i;
                  var p = 0;
                  var encoded1, encoded2, encoded3, encoded4;
                  if (serializedString[serializedString.length - 1] === '=') {
                    bufferLength--;
                    if (serializedString[serializedString.length - 2] === '=') {
                      bufferLength--;
                    }
                  }
                  var buffer = new ArrayBuffer(bufferLength);
                  var bytes = new Uint8Array(buffer);
                  for (i = 0; i < len; i += 4) {
                    encoded1 = BASE_CHARS.indexOf(serializedString[i]);
                    encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
                    encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
                    encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);

                    /*jslint bitwise: true */
                    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
                    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
                    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
                  }
                  return buffer;
                }

                // Converts a buffer to a string to store, serialized, in the backend
                // storage library.
                function bufferToString(buffer) {
                  // base64-arraybuffer
                  var bytes = new Uint8Array(buffer);
                  var base64String = '';
                  var i;
                  for (i = 0; i < bytes.length; i += 3) {
                    /*jslint bitwise: true */
                    base64String += BASE_CHARS[bytes[i] >> 2];
                    base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
                    base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
                    base64String += BASE_CHARS[bytes[i + 2] & 63];
                  }
                  if (bytes.length % 3 === 2) {
                    base64String = base64String.substring(0, base64String.length - 1) + '=';
                  } else if (bytes.length % 3 === 1) {
                    base64String = base64String.substring(0, base64String.length - 2) + '==';
                  }
                  return base64String;
                }

                // Serialize a value, afterwards executing a callback (which usually
                // instructs the `setItem()` callback/promise to be executed). This is how
                // we store binary data with localStorage.
                function serialize(value, callback) {
                  var valueType = '';
                  if (value) {
                    valueType = toString$1.call(value);
                  }

                  // Cannot use `value instanceof ArrayBuffer` or such here, as these
                  // checks fail when running the tests using casper.js...
                  //
                  // TODO: See why those tests fail and use a better solution.
                  if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
                    // Convert binary arrays to a string and prefix the string with
                    // a special marker.
                    var buffer;
                    var marker = SERIALIZED_MARKER;
                    if (value instanceof ArrayBuffer) {
                      buffer = value;
                      marker += TYPE_ARRAYBUFFER;
                    } else {
                      buffer = value.buffer;
                      if (valueType === '[object Int8Array]') {
                        marker += TYPE_INT8ARRAY;
                      } else if (valueType === '[object Uint8Array]') {
                        marker += TYPE_UINT8ARRAY;
                      } else if (valueType === '[object Uint8ClampedArray]') {
                        marker += TYPE_UINT8CLAMPEDARRAY;
                      } else if (valueType === '[object Int16Array]') {
                        marker += TYPE_INT16ARRAY;
                      } else if (valueType === '[object Uint16Array]') {
                        marker += TYPE_UINT16ARRAY;
                      } else if (valueType === '[object Int32Array]') {
                        marker += TYPE_INT32ARRAY;
                      } else if (valueType === '[object Uint32Array]') {
                        marker += TYPE_UINT32ARRAY;
                      } else if (valueType === '[object Float32Array]') {
                        marker += TYPE_FLOAT32ARRAY;
                      } else if (valueType === '[object Float64Array]') {
                        marker += TYPE_FLOAT64ARRAY;
                      } else {
                        callback(new Error('Failed to get type for BinaryArray'));
                      }
                    }
                    callback(marker + bufferToString(buffer));
                  } else if (valueType === '[object Blob]') {
                    // Conver the blob to a binaryArray and then to a string.
                    var fileReader = new FileReader();
                    fileReader.onload = function () {
                      // Backwards-compatible prefix for the blob type.
                      var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);
                      callback(SERIALIZED_MARKER + TYPE_BLOB + str);
                    };
                    fileReader.readAsArrayBuffer(value);
                  } else {
                    try {
                      callback(JSON.stringify(value));
                    } catch (e) {
                      console.error("Couldn't convert value into a JSON string: ", value);
                      callback(null, e);
                    }
                  }
                }

                // Deserialize data we've inserted into a value column/field. We place
                // special markers into our strings to mark them as encoded; this isn't
                // as nice as a meta field, but it's the only sane thing we can do whilst
                // keeping localStorage support intact.
                //
                // Oftentimes this will just deserialize JSON content, but if we have a
                // special marker (SERIALIZED_MARKER, defined above), we will extract
                // some kind of arraybuffer/binary data/typed array out of the string.
                function deserialize(value) {
                  // If we haven't marked this string as being specially serialized (i.e.
                  // something other than serialized JSON), we can just return it and be
                  // done with it.
                  if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
                    return JSON.parse(value);
                  }

                  // The following code deals with deserializing some kind of Blob or
                  // TypedArray. First we separate out the type of data we're dealing
                  // with from the data itself.
                  var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
                  var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
                  var blobType;
                  // Backwards-compatible blob type serialization strategy.
                  // DBs created with older versions of localForage will simply not have the blob type.
                  if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
                    var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
                    blobType = matcher[1];
                    serializedString = serializedString.substring(matcher[0].length);
                  }
                  var buffer = stringToBuffer(serializedString);

                  // Return the right type based on the code/type set during
                  // serialization.
                  switch (type) {
                    case TYPE_ARRAYBUFFER:
                      return buffer;
                    case TYPE_BLOB:
                      return createBlob([buffer], {
                        type: blobType
                      });
                    case TYPE_INT8ARRAY:
                      return new Int8Array(buffer);
                    case TYPE_UINT8ARRAY:
                      return new Uint8Array(buffer);
                    case TYPE_UINT8CLAMPEDARRAY:
                      return new Uint8ClampedArray(buffer);
                    case TYPE_INT16ARRAY:
                      return new Int16Array(buffer);
                    case TYPE_UINT16ARRAY:
                      return new Uint16Array(buffer);
                    case TYPE_INT32ARRAY:
                      return new Int32Array(buffer);
                    case TYPE_UINT32ARRAY:
                      return new Uint32Array(buffer);
                    case TYPE_FLOAT32ARRAY:
                      return new Float32Array(buffer);
                    case TYPE_FLOAT64ARRAY:
                      return new Float64Array(buffer);
                    default:
                      throw new Error('Unkown type: ' + type);
                  }
                }
                var localforageSerializer = {
                  serialize: serialize,
                  deserialize: deserialize,
                  stringToBuffer: stringToBuffer,
                  bufferToString: bufferToString
                };

                /*
                 * Includes code from:
                 *
                 * base64-arraybuffer
                 * https://github.com/niklasvh/base64-arraybuffer
                 *
                 * Copyright (c) 2012 Niklas von Hertzen
                 * Licensed under the MIT license.
                 */

                function createDbTable(t, dbInfo, callback, errorCallback) {
                  t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
                }

                // Open the WebSQL database (automatically creates one if one didn't
                // previously exist), using any options set in the config.
                function _initStorage$1(options) {
                  var self = this;
                  var dbInfo = {
                    db: null
                  };
                  if (options) {
                    for (var i in options) {
                      dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
                    }
                  }
                  var dbInfoPromise = new Promise$1(function (resolve, reject) {
                    // Open the database; the openDatabase API will automatically
                    // create it for us if it doesn't exist.
                    try {
                      dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
                    } catch (e) {
                      return reject(e);
                    }

                    // Create our key/value table if it doesn't exist.
                    dbInfo.db.transaction(function (t) {
                      createDbTable(t, dbInfo, function () {
                        self._dbInfo = dbInfo;
                        resolve();
                      }, function (t, error) {
                        reject(error);
                      });
                    }, reject);
                  });
                  dbInfo.serializer = localforageSerializer;
                  return dbInfoPromise;
                }
                function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
                  t.executeSql(sqlStatement, args, callback, function (t, error) {
                    if (error.code === error.SYNTAX_ERR) {
                      t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [dbInfo.storeName], function (t, results) {
                        if (!results.rows.length) {
                          // if the table is missing (was deleted)
                          // re-create it table and retry
                          createDbTable(t, dbInfo, function () {
                            t.executeSql(sqlStatement, args, callback, errorCallback);
                          }, errorCallback);
                        } else {
                          errorCallback(t, error);
                        }
                      }, errorCallback);
                    } else {
                      errorCallback(t, error);
                    }
                  }, errorCallback);
                }
                function getItem$1(key, callback) {
                  var self = this;
                  key = normalizeKey(key);
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      var dbInfo = self._dbInfo;
                      dbInfo.db.transaction(function (t) {
                        tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
                          var result = results.rows.length ? results.rows.item(0).value : null;

                          // Check to see if this is serialized content we need to
                          // unpack.
                          if (result) {
                            result = dbInfo.serializer.deserialize(result);
                          }
                          resolve(result);
                        }, function (t, error) {
                          reject(error);
                        });
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }
                function iterate$1(iterator, callback) {
                  var self = this;
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      var dbInfo = self._dbInfo;
                      dbInfo.db.transaction(function (t) {
                        tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
                          var rows = results.rows;
                          var length = rows.length;
                          for (var i = 0; i < length; i++) {
                            var item = rows.item(i);
                            var result = item.value;

                            // Check to see if this is serialized content
                            // we need to unpack.
                            if (result) {
                              result = dbInfo.serializer.deserialize(result);
                            }
                            result = iterator(result, item.key, i + 1);

                            // void(0) prevents problems with redefinition
                            // of `undefined`.
                            if (result !== void 0) {
                              resolve(result);
                              return;
                            }
                          }
                          resolve();
                        }, function (t, error) {
                          reject(error);
                        });
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }
                function _setItem(key, value, callback, retriesLeft) {
                  var self = this;
                  key = normalizeKey(key);
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      // The localStorage API doesn't return undefined values in an
                      // "expected" way, so undefined is always cast to null in all
                      // drivers. See: https://github.com/mozilla/localForage/pull/42
                      if (value === undefined) {
                        value = null;
                      }

                      // Save the original value to pass to the callback.
                      var originalValue = value;
                      var dbInfo = self._dbInfo;
                      dbInfo.serializer.serialize(value, function (value, error) {
                        if (error) {
                          reject(error);
                        } else {
                          dbInfo.db.transaction(function (t) {
                            tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
                              resolve(originalValue);
                            }, function (t, error) {
                              reject(error);
                            });
                          }, function (sqlError) {
                            // The transaction failed; check
                            // to see if it's a quota error.
                            if (sqlError.code === sqlError.QUOTA_ERR) {
                              // We reject the callback outright for now, but
                              // it's worth trying to re-run the transaction.
                              // Even if the user accepts the prompt to use
                              // more storage on Safari, this error will
                              // be called.
                              //
                              // Try to re-run the transaction.
                              if (retriesLeft > 0) {
                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
                                return;
                              }
                              reject(sqlError);
                            }
                          });
                        }
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }
                function setItem$1(key, value, callback) {
                  return _setItem.apply(this, [key, value, callback, 1]);
                }
                function removeItem$1(key, callback) {
                  var self = this;
                  key = normalizeKey(key);
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      var dbInfo = self._dbInfo;
                      dbInfo.db.transaction(function (t) {
                        tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
                          resolve();
                        }, function (t, error) {
                          reject(error);
                        });
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }

                // Deletes every item in the table.
                // TODO: Find out if this resets the AUTO_INCREMENT number.
                function clear$1(callback) {
                  var self = this;
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      var dbInfo = self._dbInfo;
                      dbInfo.db.transaction(function (t) {
                        tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
                          resolve();
                        }, function (t, error) {
                          reject(error);
                        });
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }

                // Does a simple `COUNT(key)` to get the number of items stored in
                // localForage.
                function length$1(callback) {
                  var self = this;
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      var dbInfo = self._dbInfo;
                      dbInfo.db.transaction(function (t) {
                        // Ahhh, SQL makes this one soooooo easy.
                        tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
                          var result = results.rows.item(0).c;
                          resolve(result);
                        }, function (t, error) {
                          reject(error);
                        });
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }

                // Return the key located at key index X; essentially gets the key from a
                // `WHERE id = ?`. This is the most efficient way I can think to implement
                // this rarely-used (in my experience) part of the API, but it can seem
                // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
                // the ID of each key will change every time it's updated. Perhaps a stored
                // procedure for the `setItem()` SQL would solve this problem?
                // TODO: Don't change ID on `setItem()`.
                function key$1(n, callback) {
                  var self = this;
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      var dbInfo = self._dbInfo;
                      dbInfo.db.transaction(function (t) {
                        tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
                          var result = results.rows.length ? results.rows.item(0).key : null;
                          resolve(result);
                        }, function (t, error) {
                          reject(error);
                        });
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }
                function keys$1(callback) {
                  var self = this;
                  var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                      var dbInfo = self._dbInfo;
                      dbInfo.db.transaction(function (t) {
                        tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
                          var keys = [];
                          for (var i = 0; i < results.rows.length; i++) {
                            keys.push(results.rows.item(i).key);
                          }
                          resolve(keys);
                        }, function (t, error) {
                          reject(error);
                        });
                      });
                    })["catch"](reject);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }

                // https://www.w3.org/TR/webdatabase/#databases
                // > There is no way to enumerate or delete the databases available for an origin from this API.
                function getAllStoreNames(db) {
                  return new Promise$1(function (resolve, reject) {
                    db.transaction(function (t) {
                      t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
                        var storeNames = [];
                        for (var i = 0; i < results.rows.length; i++) {
                          storeNames.push(results.rows.item(i).name);
                        }
                        resolve({
                          db: db,
                          storeNames: storeNames
                        });
                      }, function (t, error) {
                        reject(error);
                      });
                    }, function (sqlError) {
                      reject(sqlError);
                    });
                  });
                }
                function dropInstance$1(options, callback) {
                  callback = getCallback.apply(this, arguments);
                  var currentConfig = this.config();
                  options = typeof options !== 'function' && options || {};
                  if (!options.name) {
                    options.name = options.name || currentConfig.name;
                    options.storeName = options.storeName || currentConfig.storeName;
                  }
                  var self = this;
                  var promise;
                  if (!options.name) {
                    promise = Promise$1.reject('Invalid arguments');
                  } else {
                    promise = new Promise$1(function (resolve) {
                      var db;
                      if (options.name === currentConfig.name) {
                        // use the db reference of the current instance
                        db = self._dbInfo.db;
                      } else {
                        db = openDatabase(options.name, '', '', 0);
                      }
                      if (!options.storeName) {
                        // drop all database tables
                        resolve(getAllStoreNames(db));
                      } else {
                        resolve({
                          db: db,
                          storeNames: [options.storeName]
                        });
                      }
                    }).then(function (operationInfo) {
                      return new Promise$1(function (resolve, reject) {
                        operationInfo.db.transaction(function (t) {
                          function dropTable(storeName) {
                            return new Promise$1(function (resolve, reject) {
                              t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
                                resolve();
                              }, function (t, error) {
                                reject(error);
                              });
                            });
                          }
                          var operations = [];
                          for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                            operations.push(dropTable(operationInfo.storeNames[i]));
                          }
                          Promise$1.all(operations).then(function () {
                            resolve();
                          })["catch"](function (e) {
                            reject(e);
                          });
                        }, function (sqlError) {
                          reject(sqlError);
                        });
                      });
                    });
                  }
                  executeCallback(promise, callback);
                  return promise;
                }
                var webSQLStorage = {
                  _driver: 'webSQLStorage',
                  _initStorage: _initStorage$1,
                  _support: isWebSQLValid(),
                  iterate: iterate$1,
                  getItem: getItem$1,
                  setItem: setItem$1,
                  removeItem: removeItem$1,
                  clear: clear$1,
                  length: length$1,
                  key: key$1,
                  keys: keys$1,
                  dropInstance: dropInstance$1
                };
                function isLocalStorageValid() {
                  try {
                    return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
                    // in IE8 typeof localStorage.setItem === 'object'
                    !!localStorage.setItem;
                  } catch (e) {
                    return false;
                  }
                }
                function _getKeyPrefix(options, defaultConfig) {
                  var keyPrefix = options.name + '/';
                  if (options.storeName !== defaultConfig.storeName) {
                    keyPrefix += options.storeName + '/';
                  }
                  return keyPrefix;
                }

                // Check if localStorage throws when saving an item
                function checkIfLocalStorageThrows() {
                  var localStorageTestKey = '_localforage_support_test';
                  try {
                    localStorage.setItem(localStorageTestKey, true);
                    localStorage.removeItem(localStorageTestKey);
                    return false;
                  } catch (e) {
                    return true;
                  }
                }

                // Check if localStorage is usable and allows to save an item
                // This method checks if localStorage is usable in Safari Private Browsing
                // mode, or in any other case where the available quota for localStorage
                // is 0 and there wasn't any saved items yet.
                function _isLocalStorageUsable() {
                  return !checkIfLocalStorageThrows() || localStorage.length > 0;
                }

                // Config the localStorage backend, using options set in the config.
                function _initStorage$2(options) {
                  var self = this;
                  var dbInfo = {};
                  if (options) {
                    for (var i in options) {
                      dbInfo[i] = options[i];
                    }
                  }
                  dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);
                  if (!_isLocalStorageUsable()) {
                    return Promise$1.reject();
                  }
                  self._dbInfo = dbInfo;
                  dbInfo.serializer = localforageSerializer;
                  return Promise$1.resolve();
                }

                // Remove all keys from the datastore, effectively destroying all data in
                // the app's key/value store!
                function clear$2(callback) {
                  var self = this;
                  var promise = self.ready().then(function () {
                    var keyPrefix = self._dbInfo.keyPrefix;
                    for (var i = localStorage.length - 1; i >= 0; i--) {
                      var key = localStorage.key(i);
                      if (key.indexOf(keyPrefix) === 0) {
                        localStorage.removeItem(key);
                      }
                    }
                  });
                  executeCallback(promise, callback);
                  return promise;
                }

                // Retrieve an item from the store. Unlike the original async_storage
                // library in Gaia, we don't modify return values at all. If a key's value
                // is `undefined`, we pass that value to the callback function.
                function getItem$2(key, callback) {
                  var self = this;
                  key = normalizeKey(key);
                  var promise = self.ready().then(function () {
                    var dbInfo = self._dbInfo;
                    var result = localStorage.getItem(dbInfo.keyPrefix + key);

                    // If a result was found, parse it from the serialized
                    // string into a JS object. If result isn't truthy, the key
                    // is likely undefined and we'll pass it straight to the
                    // callback.
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    return result;
                  });
                  executeCallback(promise, callback);
                  return promise;
                }

                // Iterate over all items in the store.
                function iterate$2(iterator, callback) {
                  var self = this;
                  var promise = self.ready().then(function () {
                    var dbInfo = self._dbInfo;
                    var keyPrefix = dbInfo.keyPrefix;
                    var keyPrefixLength = keyPrefix.length;
                    var length = localStorage.length;

                    // We use a dedicated iterator instead of the `i` variable below
                    // so other keys we fetch in localStorage aren't counted in
                    // the `iterationNumber` argument passed to the `iterate()`
                    // callback.
                    //
                    // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
                    var iterationNumber = 1;
                    for (var i = 0; i < length; i++) {
                      var key = localStorage.key(i);
                      if (key.indexOf(keyPrefix) !== 0) {
                        continue;
                      }
                      var value = localStorage.getItem(key);

                      // If a result was found, parse it from the serialized
                      // string into a JS object. If result isn't truthy, the
                      // key is likely undefined and we'll pass it straight
                      // to the iterator.
                      if (value) {
                        value = dbInfo.serializer.deserialize(value);
                      }
                      value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);
                      if (value !== void 0) {
                        return value;
                      }
                    }
                  });
                  executeCallback(promise, callback);
                  return promise;
                }

                // Same as localStorage's key() method, except takes a callback.
                function key$2(n, callback) {
                  var self = this;
                  var promise = self.ready().then(function () {
                    var dbInfo = self._dbInfo;
                    var result;
                    try {
                      result = localStorage.key(n);
                    } catch (error) {
                      result = null;
                    }

                    // Remove the prefix from the key, if a key is found.
                    if (result) {
                      result = result.substring(dbInfo.keyPrefix.length);
                    }
                    return result;
                  });
                  executeCallback(promise, callback);
                  return promise;
                }
                function keys$2(callback) {
                  var self = this;
                  var promise = self.ready().then(function () {
                    var dbInfo = self._dbInfo;
                    var length = localStorage.length;
                    var keys = [];
                    for (var i = 0; i < length; i++) {
                      var itemKey = localStorage.key(i);
                      if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                        keys.push(itemKey.substring(dbInfo.keyPrefix.length));
                      }
                    }
                    return keys;
                  });
                  executeCallback(promise, callback);
                  return promise;
                }

                // Supply the number of keys in the datastore to the callback function.
                function length$2(callback) {
                  var self = this;
                  var promise = self.keys().then(function (keys) {
                    return keys.length;
                  });
                  executeCallback(promise, callback);
                  return promise;
                }

                // Remove an item from the store, nice and simple.
                function removeItem$2(key, callback) {
                  var self = this;
                  key = normalizeKey(key);
                  var promise = self.ready().then(function () {
                    var dbInfo = self._dbInfo;
                    localStorage.removeItem(dbInfo.keyPrefix + key);
                  });
                  executeCallback(promise, callback);
                  return promise;
                }

                // Set a key's value and run an optional callback once the value is set.
                // Unlike Gaia's implementation, the callback function is passed the value,
                // in case you want to operate on that value only after you're sure it
                // saved, or something like that.
                function setItem$2(key, value, callback) {
                  var self = this;
                  key = normalizeKey(key);
                  var promise = self.ready().then(function () {
                    // Convert undefined values to null.
                    // https://github.com/mozilla/localForage/pull/42
                    if (value === undefined) {
                      value = null;
                    }

                    // Save the original value to pass to the callback.
                    var originalValue = value;
                    return new Promise$1(function (resolve, reject) {
                      var dbInfo = self._dbInfo;
                      dbInfo.serializer.serialize(value, function (value, error) {
                        if (error) {
                          reject(error);
                        } else {
                          try {
                            localStorage.setItem(dbInfo.keyPrefix + key, value);
                            resolve(originalValue);
                          } catch (e) {
                            // localStorage capacity exceeded.
                            // TODO: Make this a specific error/event.
                            if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                              reject(e);
                            }
                            reject(e);
                          }
                        }
                      });
                    });
                  });
                  executeCallback(promise, callback);
                  return promise;
                }
                function dropInstance$2(options, callback) {
                  callback = getCallback.apply(this, arguments);
                  options = typeof options !== 'function' && options || {};
                  if (!options.name) {
                    var currentConfig = this.config();
                    options.name = options.name || currentConfig.name;
                    options.storeName = options.storeName || currentConfig.storeName;
                  }
                  var self = this;
                  var promise;
                  if (!options.name) {
                    promise = Promise$1.reject('Invalid arguments');
                  } else {
                    promise = new Promise$1(function (resolve) {
                      if (!options.storeName) {
                        resolve(options.name + '/');
                      } else {
                        resolve(_getKeyPrefix(options, self._defaultConfig));
                      }
                    }).then(function (keyPrefix) {
                      for (var i = localStorage.length - 1; i >= 0; i--) {
                        var key = localStorage.key(i);
                        if (key.indexOf(keyPrefix) === 0) {
                          localStorage.removeItem(key);
                        }
                      }
                    });
                  }
                  executeCallback(promise, callback);
                  return promise;
                }
                var localStorageWrapper = {
                  _driver: 'localStorageWrapper',
                  _initStorage: _initStorage$2,
                  _support: isLocalStorageValid(),
                  iterate: iterate$2,
                  getItem: getItem$2,
                  setItem: setItem$2,
                  removeItem: removeItem$2,
                  clear: clear$2,
                  length: length$2,
                  key: key$2,
                  keys: keys$2,
                  dropInstance: dropInstance$2
                };
                var sameValue = function sameValue(x, y) {
                  return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
                };
                var includes = function includes(array, searchElement) {
                  var len = array.length;
                  var i = 0;
                  while (i < len) {
                    if (sameValue(array[i], searchElement)) {
                      return true;
                    }
                    i++;
                  }
                  return false;
                };
                var isArray = Array.isArray || function (arg) {
                  return Object.prototype.toString.call(arg) === '[object Array]';
                };

                // Drivers are stored here when `defineDriver()` is called.
                // They are shared across all instances of localForage.
                var DefinedDrivers = {};
                var DriverSupport = {};
                var DefaultDrivers = {
                  INDEXEDDB: asyncStorage,
                  WEBSQL: webSQLStorage,
                  LOCALSTORAGE: localStorageWrapper
                };
                var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
                var OptionalDriverMethods = ['dropInstance'];
                var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);
                var DefaultConfig = {
                  description: '',
                  driver: DefaultDriverOrder.slice(),
                  name: 'localforage',
                  // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
                  // we can use without a prompt.
                  size: 4980736,
                  storeName: 'keyvaluepairs',
                  version: 1.0
                };
                function callWhenReady(localForageInstance, libraryMethod) {
                  localForageInstance[libraryMethod] = function () {
                    var _args = arguments;
                    return localForageInstance.ready().then(function () {
                      return localForageInstance[libraryMethod].apply(localForageInstance, _args);
                    });
                  };
                }
                function extend() {
                  for (var i = 1; i < arguments.length; i++) {
                    var arg = arguments[i];
                    if (arg) {
                      for (var _key in arg) {
                        if (arg.hasOwnProperty(_key)) {
                          if (isArray(arg[_key])) {
                            arguments[0][_key] = arg[_key].slice();
                          } else {
                            arguments[0][_key] = arg[_key];
                          }
                        }
                      }
                    }
                  }
                  return arguments[0];
                }
                var LocalForage = function () {
                  function LocalForage(options) {
                    _classCallCheck(this, LocalForage);
                    for (var driverTypeKey in DefaultDrivers) {
                      if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                        var driver = DefaultDrivers[driverTypeKey];
                        var driverName = driver._driver;
                        this[driverTypeKey] = driverName;
                        if (!DefinedDrivers[driverName]) {
                          // we don't need to wait for the promise,
                          // since the default drivers can be defined
                          // in a blocking manner
                          this.defineDriver(driver);
                        }
                      }
                    }
                    this._defaultConfig = extend({}, DefaultConfig);
                    this._config = extend({}, this._defaultConfig, options);
                    this._driverSet = null;
                    this._initDriver = null;
                    this._ready = false;
                    this._dbInfo = null;
                    this._wrapLibraryMethodsWithReady();
                    this.setDriver(this._config.driver)["catch"](function () {});
                  }

                  // Set any config values for localForage; can be called anytime before
                  // the first API call (e.g. `getItem`, `setItem`).
                  // We loop through options so we don't overwrite existing config
                  // values.

                  LocalForage.prototype.config = function config(options) {
                    // If the options argument is an object, we use it to set values.
                    // Otherwise, we return either a specified config value or all
                    // config values.
                    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
                      // If localforage is ready and fully initialized, we can't set
                      // any new configuration values. Instead, we return an error.
                      if (this._ready) {
                        return new Error("Can't call config() after localforage " + 'has been used.');
                      }
                      for (var i in options) {
                        if (i === 'storeName') {
                          options[i] = options[i].replace(/\W/g, '_');
                        }
                        if (i === 'version' && typeof options[i] !== 'number') {
                          return new Error('Database version must be a number.');
                        }
                        this._config[i] = options[i];
                      }

                      // after all config options are set and
                      // the driver option is used, try setting it
                      if ('driver' in options && options.driver) {
                        return this.setDriver(this._config.driver);
                      }
                      return true;
                    } else if (typeof options === 'string') {
                      return this._config[options];
                    } else {
                      return this._config;
                    }
                  };

                  // Used to define a custom driver, shared across all instances of
                  // localForage.

                  LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
                    var promise = new Promise$1(function (resolve, reject) {
                      try {
                        var driverName = driverObject._driver;
                        var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');

                        // A driver name should be defined and not overlap with the
                        // library-defined, default drivers.
                        if (!driverObject._driver) {
                          reject(complianceError);
                          return;
                        }
                        var driverMethods = LibraryMethods.concat('_initStorage');
                        for (var i = 0, len = driverMethods.length; i < len; i++) {
                          var driverMethodName = driverMethods[i];

                          // when the property is there,
                          // it should be a method even when optional
                          var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                          if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
                            reject(complianceError);
                            return;
                          }
                        }
                        var configureMissingMethods = function configureMissingMethods() {
                          var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
                            return function () {
                              var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
                              var promise = Promise$1.reject(error);
                              executeCallback(promise, arguments[arguments.length - 1]);
                              return promise;
                            };
                          };
                          for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                            var optionalDriverMethod = OptionalDriverMethods[_i];
                            if (!driverObject[optionalDriverMethod]) {
                              driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                            }
                          }
                        };
                        configureMissingMethods();
                        var setDriverSupport = function setDriverSupport(support) {
                          if (DefinedDrivers[driverName]) {
                            console.info('Redefining LocalForage driver: ' + driverName);
                          }
                          DefinedDrivers[driverName] = driverObject;
                          DriverSupport[driverName] = support;
                          // don't use a then, so that we can define
                          // drivers that have simple _support methods
                          // in a blocking manner
                          resolve();
                        };
                        if ('_support' in driverObject) {
                          if (driverObject._support && typeof driverObject._support === 'function') {
                            driverObject._support().then(setDriverSupport, reject);
                          } else {
                            setDriverSupport(!!driverObject._support);
                          }
                        } else {
                          setDriverSupport(true);
                        }
                      } catch (e) {
                        reject(e);
                      }
                    });
                    executeTwoCallbacks(promise, callback, errorCallback);
                    return promise;
                  };
                  LocalForage.prototype.driver = function driver() {
                    return this._driver || null;
                  };
                  LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
                    var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));
                    executeTwoCallbacks(getDriverPromise, callback, errorCallback);
                    return getDriverPromise;
                  };
                  LocalForage.prototype.getSerializer = function getSerializer(callback) {
                    var serializerPromise = Promise$1.resolve(localforageSerializer);
                    executeTwoCallbacks(serializerPromise, callback);
                    return serializerPromise;
                  };
                  LocalForage.prototype.ready = function ready(callback) {
                    var self = this;
                    var promise = self._driverSet.then(function () {
                      if (self._ready === null) {
                        self._ready = self._initDriver();
                      }
                      return self._ready;
                    });
                    executeTwoCallbacks(promise, callback, callback);
                    return promise;
                  };
                  LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
                    var self = this;
                    if (!isArray(drivers)) {
                      drivers = [drivers];
                    }
                    var supportedDrivers = this._getSupportedDrivers(drivers);
                    function setDriverToConfig() {
                      self._config.driver = self.driver();
                    }
                    function extendSelfWithDriver(driver) {
                      self._extend(driver);
                      setDriverToConfig();
                      self._ready = self._initStorage(self._config);
                      return self._ready;
                    }
                    function initDriver(supportedDrivers) {
                      return function () {
                        var currentDriverIndex = 0;
                        function driverPromiseLoop() {
                          while (currentDriverIndex < supportedDrivers.length) {
                            var driverName = supportedDrivers[currentDriverIndex];
                            currentDriverIndex++;
                            self._dbInfo = null;
                            self._ready = null;
                            return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                          }
                          setDriverToConfig();
                          var error = new Error('No available storage method found.');
                          self._driverSet = Promise$1.reject(error);
                          return self._driverSet;
                        }
                        return driverPromiseLoop();
                      };
                    }

                    // There might be a driver initialization in progress
                    // so wait for it to finish in order to avoid a possible
                    // race condition to set _dbInfo
                    var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
                      return Promise$1.resolve();
                    }) : Promise$1.resolve();
                    this._driverSet = oldDriverSetDone.then(function () {
                      var driverName = supportedDrivers[0];
                      self._dbInfo = null;
                      self._ready = null;
                      return self.getDriver(driverName).then(function (driver) {
                        self._driver = driver._driver;
                        setDriverToConfig();
                        self._wrapLibraryMethodsWithReady();
                        self._initDriver = initDriver(supportedDrivers);
                      });
                    })["catch"](function () {
                      setDriverToConfig();
                      var error = new Error('No available storage method found.');
                      self._driverSet = Promise$1.reject(error);
                      return self._driverSet;
                    });
                    executeTwoCallbacks(this._driverSet, callback, errorCallback);
                    return this._driverSet;
                  };
                  LocalForage.prototype.supports = function supports(driverName) {
                    return !!DriverSupport[driverName];
                  };
                  LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
                    extend(this, libraryMethodsAndProperties);
                  };
                  LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
                    var supportedDrivers = [];
                    for (var i = 0, len = drivers.length; i < len; i++) {
                      var driverName = drivers[i];
                      if (this.supports(driverName)) {
                        supportedDrivers.push(driverName);
                      }
                    }
                    return supportedDrivers;
                  };
                  LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
                    // Add a stub for each driver API method that delays the call to the
                    // corresponding driver method until localForage is ready. These stubs
                    // will be replaced by the driver methods as soon as the driver is
                    // loaded, so there is no performance impact.
                    for (var i = 0, len = LibraryMethods.length; i < len; i++) {
                      callWhenReady(this, LibraryMethods[i]);
                    }
                  };
                  LocalForage.prototype.createInstance = function createInstance(options) {
                    return new LocalForage(options);
                  };
                  return LocalForage;
                }();

                // The actual localForage object that we expose as a module or via a
                // global. It's extended by pulling in one of our other libraries.

                var localforage_js = new LocalForage();
                module.exports = localforage_js;
              }, {
                "3": 3
              }]
            }, {}, [4])(4);
          });
        })(localforage$1);
        var localforageExports = localforage$1.exports;
        var localforage = exports("C", /*@__PURE__*/getDefaultExportFromCjs(localforageExports));

        /**!
         * Sparticles - Lightweight, High Performance Particles in Canvas
         * @version 1.3.1
         * @license MPL-2.0
         * @author simeydotme <simey.me@gmail.com>
         * @website http://sparticlesjs.dev
         * @repository https://github.com/simeydotme/sparticles.git
         */

        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) {
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            }
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread2(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys(Object(source), true).forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }

        /**
         * Limited Animation Frame method, to allow running
         * a given handler at the maximum desired frame rate.
         * inspired from https://gist.github.com/addyosmani/5434533
         * @param {Function} handler method to execute upon every frame
         * @param {Number} fps how many frames to render every second
         */
        var AnimationFrame = function AnimationFrame() {
          var handler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
          var fps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;
          this.fps = fps;
          this.handler = handler;
          var renderId = 0;
          /**
           * begin the animation loop which is assigned
           * to the instance in the constructor
           */

          this.start = function () {
            var _this = this;
            if (!this.started) {
              var then = performance.now();
              var interval = 1000 / this.fps;
              var tolerance = 0;
              var loop = function loop(now) {
                var delta = now - then;
                renderId = requestAnimationFrame(loop);
                if (delta >= interval - tolerance) {
                  _this.handler(delta);
                  then = now - delta % interval;
                }
              };
              renderId = requestAnimationFrame(loop);
              this.started = true;
            }
          };
          /**
           * stop the currently running animation loop
           */

          this.stop = function () {
            cancelAnimationFrame(renderId);
            this.started = false;
          };
        };

        /**
         * return the cartesian x/y delta value from a degree
         * eg: 90 () = [1,0]
         * @param {Number} angle angle in degrees
         * @returns {Number[]} cartesian delta values
         */
        var cartesian = function cartesian(angle) {
          return [Math.cos(radian(angle - 90)), Math.sin(radian(angle - 90))];
        };
        /**
         * clamp the input number to the min/max values
         * @param {Number} value value to clamp between min and max
         * @param {Number} min minimum value possible
         * @param {Number} max maximum value possible
         * @returns {Number} the input num clamped between min/max
         */

        var clamp$1 = function clamp(value) {
          var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
          return Math.max(min, Math.min(max, value));
        };
        /**
         * return the radian equivalent to a degree value
         * @param {Number} angle angle in degrees
         * @returns {Number} radian equivalent
         */

        var radian = function radian(angle) {
          return angle * Math.PI / 180;
        };
        /**
         * return random number between a min and max value
         * @param {Number} min minimum value
         * @param {Number} max maximum value
         * @param {Boolean} rounded should the result be rounded
         * @returns {Number} a random number between min and max
         */

        var random = function random() {
          var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
          var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Math.random();
          if (max <= min) {
            value = min;
          } else if ((min !== 0 || max !== 1) && max > min) {
            value = value * (max - min) + min;
          }
          return value;
        };
        /**
         * return a random value from an array
         * @param {Array} array an array to get random value from
         * @returns {*} random value from array
         */

        var randomArray = function randomArray(array) {
          return array[Math.floor(random(0, array.length))];
        };
        /**
         * return a random HSL colour string for use in random color effect
         * @returns {String} "hsl(100,100,80)"
         */

        var randomHsl = function randomHsl() {
          var h = round(random(0, 360));
          var s = round(random(90, 100));
          var l = round(random(45, 85));
          return "hsl(".concat(h, ",").concat(s, "%,").concat(l, "%)");
        };
        /**
         * return a boolean to pass a dice roll
         * @param {Number} odds a fraction to use as the probability, can be supplied as "1/2"
         * @returns {Boolean}
         */

        var roll = function roll(odds) {
          return odds > random();
        };
        /**
         * round a number to the nearest integer value
         * @param {Number} value value to round to the nearest integer
         * @returns {Number} nearest integer
         */

        var round = function round(value) {
          return 0.5 + value | 0;
        };

        /**
         * Sparticle Constructor;
         * creates an individual particle for use in the Sparticles() class
         * @param {Object} parent - the parent Sparticles() instance this belongs to
         * @returns {Object} - reference to a new Sparticle instance
         */

        var Sparticle = function Sparticle(parent) {
          if (parent) {
            this.canvas = parent.canvas;
            this.settings = parent.settings;
            this.colors = parent.colors;
            this.shapes = parent.shapes;
            this.images = parent.images;
            this.styles = parent.styles;
            this.ctx = parent.canvas.getContext("2d");
            this.setup();
            this.init();
          } else {
            console.warn("Invalid parameters given to Sparticle()", arguments);
          }
          return this;
        };
        /**
         * set up the particle with some random values
         * before it is initialised on the canvas
         * these values will randomize when the particle goes offscreen
         */

        Sparticle.prototype.setup = function () {
          var _ = this.settings;
          this.frame = 0;
          this.frameoffset = round(random(0, 360));
          this.size = round(random(_.minSize, _.maxSize));
          this.da = this.getAlphaDelta();
          this.dx = this.getDeltaX();
          this.dy = this.getDeltaY();
          this.dd = this.getDriftDelta();
          this.dr = this.getRotationDelta();
          this.color = this.getColor();
          this.shape = this.getShape();
          this.image = this.getImage();
          this.style = this.getStyle();
          this.rotation = _.rotate ? radian(random(0, 360)) : 0;
          this.vertical = _.direction > 150 && _.direction < 210 || _.direction > 330 && _.direction < 390 || _.direction > -30 && _.direction < 30;
          this.horizontal = _.direction > 60 && _.direction < 120 || _.direction > 240 && _.direction < 300;
        };
        /**
         * initialise a particle with the default values from
         * the Sparticles instance settings.
         * these values do not change when the particle goes offscreen
         */

        Sparticle.prototype.init = function () {
          var _ = this.settings;
          var canvas = this.canvas;
          this.alpha = 0;
          if (_.speed > 0 || _.alphaSpeed === 0) {
            this.alpha = random(_.minAlpha, _.maxAlpha);
          }
          if (_.bounce) {
            this.px = round(random(2, canvas.width - this.size - 2));
            this.py = round(random(2, canvas.height - this.size - 2));
          } else {
            this.px = round(random(-this.size * 2, canvas.width + this.size));
            this.py = round(random(-this.size * 2, canvas.height + this.size));
          }
        };
        /**
         * reset the particle after it has gone off canvas.
         * this should be better than popping it from the array
         * and creating a new particle instance.
         */

        Sparticle.prototype.reset = function () {
          // give the particle a new set of initial values
          this.setup(); // set the particle's Y position

          if (this.py < 0) {
            this.py = this.canvas.height + this.size * 2;
          } else if (this.py > this.canvas.height) {
            this.py = 0 - this.size * 2;
          } // set the particle's X position

          if (this.px < 0) {
            this.px = this.canvas.width + this.size * 2;
          } else if (this.px > this.canvas.width) {
            this.px = 0 - this.size * 2;
          }
        };
        /**
         * bounce the particle off the edge of canvas
         * when it has touched
         */

        Sparticle.prototype.bounce = function () {
          var _ = this.settings;
          _.direction; // reverse the particle's Y position

          if (this.py <= 0 || this.py + this.size >= this.canvas.height) {
            this.dy = -this.dy;
            if (this.horizontal) {
              this.dd = -this.dd;
            }
          } // reverse the particle's X position

          if (this.px <= 0 || this.px + this.size >= this.canvas.width) {
            this.dx = -this.dx;
            if (this.vertical) {
              this.dd = -this.dd;
            }
          }
        };
        /**
         * check if the particle is off the canvas based
         * on it's current position
         * @returns {Boolean} is the particle completely off canvas
         */

        Sparticle.prototype.isOffCanvas = function () {
          var topleft = 0 - this.size * 2;
          var bottom = this.canvas.height + this.size * 2;
          var right = this.canvas.width + this.size * 2;
          return this.px < topleft || this.px > right || this.py < topleft || this.py > bottom;
        };
        /**
         * check if the particle is touching the canvas edge
         * @returns {Boolean} is the particle touching edge
         */

        Sparticle.prototype.isTouchingEdge = function () {
          var topleft = 0;
          var bottom = this.canvas.height - this.size;
          var right = this.canvas.width - this.size;
          return this.px < topleft || this.px > right || this.py < topleft || this.py > bottom;
        };
        /**
         * get a random color for the particle from the
         * array of colors set in the options object
         * @returns {String} - random color from color array
         */

        Sparticle.prototype.getColor = function () {
          if (this.settings.color === "random") {
            return randomArray(this.colors);
          } else if (Array.isArray(this.settings.color)) {
            return randomArray(this.settings.color);
          } else {
            return this.settings.color;
          }
        };
        /**
         * get a random shape for the particle from the
         * array of shapes set in the options object
         * @returns {String} - random shape from shape array
         */

        Sparticle.prototype.getShape = function () {
          if (this.settings.shape === "random") {
            return randomArray(this.shapes);
          } else if (Array.isArray(this.settings.shape)) {
            return randomArray(this.settings.shape);
          } else {
            return this.settings.shape;
          }
        };
        /**
         * get the image for the particle from the array
         * of possible image urls
         * @returns {String} - random imageUrl from imageUrl array
         */

        Sparticle.prototype.getImage = function () {
          if (Array.isArray(this.settings.imageUrl)) {
            return randomArray(this.settings.imageUrl);
          } else {
            return this.settings.imageUrl;
          }
        };
        /**
         * get the style of the particle, either "fill" or "stroke"
         * depending on the settings as fill/stroke/both
         * @returns {String} - either "fill" or "stroke"
         */

        Sparticle.prototype.getStyle = function () {
          return randomArray(this.styles);
        };
        /**
         * get a random delta (velocity) for the particle
         * based on the speed, and the parallax value (if applicable)
         * @returns {Number} - the velocity to be applied to the particle
         */

        Sparticle.prototype.getDelta = function () {
          var baseDelta = this.settings.speed * 0.1;
          if (this.settings.speed && this.settings.parallax) {
            return baseDelta + this.size * this.settings.parallax / 50;
          } else {
            return baseDelta;
          }
        };
        /**
         * get a random variable speed for use as a multiplier,
         * based on the values given in the settings object, this
         * can be positive or negative
         * @returns {Number} - a variable delta speed
         */

        Sparticle.prototype.getDeltaVariance = function () {
          var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var s = this.settings.speed || 10;
          if (v > 0) {
            return random(-v, v) * s / 100;
          } else {
            return 0;
          }
        };
        /**
         * get a random delta on the X axis, taking in to account
         * the variance range in the settings object and the particle's
         * direction as a multiplier
         * @returns {Number} - the X delta to be applied to particle
         */

        Sparticle.prototype.getDeltaX = function () {
          var d = this.getDelta();
          var dv = this.getDeltaVariance(this.settings.xVariance);
          return cartesian(this.settings.direction)[0] * d + dv;
        };
        /**
         * get a random delta on the Y axis, taking in to account
         * the variance range in the settings object and the particle's
         * direction as a multiplier
         * @returns {Number} - the Y delta to be applied to particle
         */

        Sparticle.prototype.getDeltaY = function () {
          var d = this.getDelta();
          var dv = this.getDeltaVariance(this.settings.yVariance);
          return cartesian(this.settings.direction)[1] * d + dv;
        };
        /**
         * get a random delta for the alpha change over time from
         * between a positive and negative alpha variance value
         * @returns {Number} - the alpha delta to be applied to particle
         */

        Sparticle.prototype.getAlphaDelta = function () {
          var variance = this.settings.alphaVariance;
          var a = random(1, variance + 1);
          if (roll(1 / 2)) {
            a = -a;
          }
          return a;
        };
        /**
         * return a random drift value either positive or negative
         * @returns {Number} - the drift value
         */

        Sparticle.prototype.getDriftDelta = function () {
          if (!this.settings.drift) {
            return 0;
          } else {
            return random(this.settings.drift - this.settings.drift / 2, this.settings.drift + this.settings.drift / 2);
          }
        };
        /**
         * return a random rotation value either positive or negative
         * @returns {Number} - the rotation value
         */

        Sparticle.prototype.getRotationDelta = function () {
          var r = 0;
          if (this.settings.rotate && this.settings.rotation) {
            r = radian(random(0.5, 1.5) * this.settings.rotation);
            if (roll(1 / 2)) {
              r = -r;
            }
          }
          return r;
        };
        /**
         * progress the particle's frame number, as well
         * as the internal values for both the particle's
         * position and the particle's alpha.
         * @returns {Object} - reference to the current Sparticle instance
         */

        Sparticle.prototype.update = function () {
          this.frame += 1;
          this.updatePosition();
          this.updateAlpha();
          return this;
        };
        /**
         * progress the particle's alpha value depending on the
         * alphaSpeed and the twinkle setting
         * @returns {Number} - new alpha value of the particle
         */

        Sparticle.prototype.updateAlpha = function () {
          if (this.settings.alphaSpeed > 0) {
            if (this.settings.twinkle) {
              this.alpha = this.updateTwinkle();
            } else {
              this.alpha = this.updateFade();
            }
          }
          return this.alpha;
        };
        /**
         * progress the particle's alpha value according to
         * the fading effect
         * @returns {Number} - new alpha value of the particle
         */

        Sparticle.prototype.updateFade = function () {
          var tick = this.da / 1000 * this.settings.alphaSpeed * 0.5;
          var alpha = this.alpha + tick;
          var over = this.da > 0 && alpha > this.settings.maxAlpha;
          var under = this.da < 0 && alpha < this.settings.minAlpha; // if the alpha is over or under the min or max values,
          // then we reverse the delta so that it can increase or
          // decrease in opacity in the opposite direction

          if (over || under) {
            this.da = -this.da;
            alpha = this.settings.maxAlpha;
            if (under) {
              alpha = this.settings.minAlpha;
            }
          }
          return alpha;
        };
        /**
         * progress the particle's alpha value according to
         * the twinkle effect
         * @returns {Number} - new alpha value of the particle
         */

        Sparticle.prototype.updateTwinkle = function () {
          var alpha = this.alpha;
          var delta = Math.abs(this.da);
          var over = alpha > this.settings.maxAlpha;
          var under = alpha < this.settings.minAlpha;
          var tick = delta / 1000 * this.settings.alphaSpeed * 0.5;
          var flickerOn = roll(1 / 30);
          var flickerOff = roll(1 / 30); // if the particle is resetting the twinkle effect, then
          // we simply want to quickly get back to max alpha
          // over a short period of time, otherwise just advance the tick

          if (this.resettingTwinkle) {
            alpha += tick * 5;
          } else if (flickerOn) {
            alpha += tick * 50;
          } else if (flickerOff) {
            alpha -= tick * 25;
          } else {
            alpha -= tick;
          } // once the alpha is under the min alpha value, then we need
          // to set the twinkle effect to reset, and once it is over
          // the max alpha, we stop resetting.

          if (under) {
            this.resettingTwinkle = true;
            alpha = this.settings.minAlpha;
          } else if (over) {
            this.resettingTwinkle = false;
            alpha = this.settings.maxAlpha;
          }
          return alpha;
        };
        /**
         * progress the particle's position values, rotation and drift
         * according to the settings given
         */

        Sparticle.prototype.updatePosition = function () {
          if (this.settings.bounce && this.isTouchingEdge()) {
            this.bounce();
          } else if (this.isOffCanvas()) {
            this.reset();
            return;
          }
          this.px += this.dx;
          this.py += this.dy; // drift must be applied after position x/y
          // as it modifies the values by wave function

          this.updateDrift();
          this.updateRotation();
        };
        /**
         * progress the particle's rotation value according
         * to the settings given
         */

        Sparticle.prototype.updateRotation = function () {
          if (this.settings.rotate && this.settings.rotation) {
            this.rotation += this.dr;
          }
        };
        /**
         * progress the particle's drift value according
         * to the settings given
         */

        Sparticle.prototype.updateDrift = function () {
          var _ = this.settings;
          _.direction;
          if (_.drift && _.speed) {
            if (this.vertical) {
              // apply HORIZONTAL drift ~ when "direction" is mostly vertical.
              this.px += cartesian(this.frame + this.frameoffset)[0] * this.dd / (this.getDelta() * 15);
            } else if (this.horizontal) {
              // apply VERTICAL drift ~ when "direction" is mostly horizontal.
              this.py += cartesian(this.frame + this.frameoffset)[1] * this.dd / (this.getDelta() * 15);
            }
          }
        };
        Sparticle.prototype.render = function (canvasses) {
          var particleCanvas;
          if (this.shape !== "image") {
            particleCanvas = canvasses[this.color][this.shape][this.style];
          } else {
            particleCanvas = canvasses[this.color][this.shape][this.image];
          }
          var canvasSize = particleCanvas.width;
          var scale = this.size / canvasSize;
          var px = this.px / scale;
          var py = this.py / scale;
          this.ctx.globalAlpha = clamp$1(this.alpha, 0, 1);
          this.renderRotate();
          this.ctx.transform(scale, 0, 0, scale, 0, 0);
          this.ctx.drawImage(particleCanvas, 0, 0, canvasSize, canvasSize, px, py, canvasSize, canvasSize);
          this.ctx.setTransform(1, 0, 0, 1, 0, 0);
          return this;
        };
        Sparticle.prototype.renderRotate = function () {
          if (this.shape !== "circle" && this.settings.rotate) {
            var centerX = this.px + this.size / 2;
            var centerY = this.py + this.size / 2;
            this.ctx.translate(centerX, centerY);
            this.ctx.rotate(this.rotation);
            this.ctx.translate(-centerX, -centerY);
          }
        };

        /**
         * Sparticles Constructor;
         * Create a <canvas>, append to the given node, and start the particle effect
         * @param {HTMLElement} [node=document.body] - element to which canvas is appended to
         * @param {Object} [options={}] - settings to use for the particle effect
         * @param {String} [options.composition=source-over] - canvas globalCompositeOperation value for particles
         * @param {Number} [options.count=50] - number of particles on the canvas simultaneously
         * @param {Number} [options.speed=10] - default velocity of every particle
         * @param {Number} [options.parallax=1] - speed multiplier effect for larger particles (0 = none)
         * @param {Number} [options.direction=180] - default direction of particles in degrees (0 = , 180 = )
         * @param {Number} [options.xVariance=2] - random deviation of particles on x-axis from default direction
         * @param {Number} [options.yVariance=2] - random deviation of particles on y-axis from default direction
         * @param {Number} [options.rotate=true] - can particles rotate
         * @param {Number} [options.rotation=1] - default rotational speed for every particle
         * @param {Number} [options.alphaSpeed=10] - rate of change in alpha over time
         * @param {Number} [options.alphaVariance=1] - random deviation of alpha change
         * @param {Number} [options.minAlpha=0] - minumum alpha value of every particle
         * @param {Number} [options.maxAlpha=1] - maximum alpha value of every particle
         * @param {Number} [options.minSize=1] - minimum size of every particle
         * @param {Number} [options.maxSize=10] - maximum size of every particle
         * @param {Boolean} [options.bounce=false] - should the particles bounce off edge of canvas
         * @param {Number} [options.drift=1] - the "driftiness" of particles which have a horizontal/vertical direction
         * @param {Number} [options.glow=0] - the glow effect size of each particle
         * @param {Boolean} [options.twinkle=false] - particles to exhibit an alternative alpha transition as "twinkling"
         * @param {String} [options.style=fill] - fill style of particles (one of; "fill", "stroke" or "both")
         * @param {(String|String[])} [options.shape=circle] - shape of particles (any of; circle, square, triangle, diamond, line, image) or "random"
         * @param {(String|String[])} [options.imageUrl=] - if shape is "image", define an image url (can be data-uri, must be square (1:1 ratio))
         * @param {(String|String[])} [options.color=random] - css color as string, or array of color strings (can also be "random")
         * @param {Function} [options.randomColor=randomHsl(index,total)] - a custom function for setting the random colors when color="random"
         * @param {Number} [options.randomColorCount=3] - the number of random colors to generate when color is "random"
         * @param {Number} [width] - the width of the canvas element
         * @param {Number} [height=width] - the height of the canvas element
         * @returns {Object} - reference to a new Sparticles instance
         */

        var Sparticles = function Sparticles(node, options, width, height) {
          if (arguments.length >= 1 && !(arguments[0] instanceof HTMLElement)) {
            options = arguments[0];
            width = arguments[1];
            height = arguments[2];
            node = undefined;
          }
          if (width && !height) {
            height = width;
          }
          var defaults = {
            alphaSpeed: 10,
            alphaVariance: 1,
            bounce: false,
            color: "random",
            randomColor: randomHsl,
            randomColorCount: 3,
            composition: "source-over",
            count: 50,
            direction: 180,
            drift: 1,
            glow: 0,
            imageUrl: "",
            maxAlpha: 1,
            maxSize: 10,
            minAlpha: 0,
            minSize: 1,
            parallax: 1,
            rotate: true,
            rotation: 1,
            shape: "circle",
            speed: 10,
            style: "fill",
            twinkle: false,
            xVariance: 2,
            yVariance: 2
          };
          this.el = node || document.body;
          this.settings = _objectSpread2(_objectSpread2({}, defaults), options);
          this.resizable = !width && !height;
          this.width = this.resizable ? this.el.clientWidth : width;
          this.height = this.resizable ? this.el.clientHeight : height;
          /**
           * initialise the sparticles instance
           * @returns {Object} - reference to the Sparticles instance
           */

          this.init = function () {
            var _this = this;
            this.sparticles = [];
            this.colors = this.getColorArray();
            this.shapes = this.getShapeArray();
            this.styles = this.getStyleArray();
            this.imageUrls = this.getImageArray();
            this.setupMainCanvas();
            this.setupOffscreenCanvasses(function () {
              _this.createSparticles();
              _this.start();
            }); // defer to the default "handleEvent" handler
            // https://developer.mozilla.org/en-US/docs/Web/API/EventListener/handleEvent

            window.addEventListener("resize", this);
            return this;
          };
          /**
           * handle event for screen resize;
           * debounce a canvas resize,
           * reset the particles
           */

          this.handleEvent = function (event) {
            var _this2 = this;
            if (event.type === "resize") {
              clearTimeout(this.resizeTimer);
              this.resizeTimer = setTimeout(function () {
                if (_this2.resizable) {
                  _this2.width = _this2.el.clientWidth;
                  _this2.height = _this2.el.clientHeight;
                  _this2.setCanvasSize().resetSparticles();
                }
              }, 200);
            }
          };
          /**
           * start/resume the sparticles animation
           * @returns {Object} - the Sparticle instance (for chaining)
           */

          this.start = function () {
            var me = this;
            if (!this.loop) {
              this.loop = new AnimationFrame(function (t) {
                me.drawFrame(t);
              });
            }
            this.loop.start();
            return this;
          };
          /**
           * stop/pause the sparticles animation
           * @returns {Object} - the Sparticle instance (for chaining)
           */

          this.stop = function () {
            this.loop.stop();
            return this;
          };
          /**
           * destroy the current instance and free up some memory
           * @returns {Object} - the Sparticle instance (for chaining)
           */

          this.destroy = function () {
            // stop the rendering and updating
            this.stop(); // remove the canvas element from the DOM

            this.el.removeChild(this.canvas); // remove the resize event for this instance

            window.removeEventListener("resize", this); // delete all the properties from the instance
            // to free up memory

            for (var prop in this) {
              if (this.hasOwnProperty(prop)) {
                delete this[prop];
              }
            }
            return this;
          };
          /**
           * set the canvas width and height
           * @param {Number} width - the width of the canvas
           * @param {Number} height - the height of the canvas
           * @returns {Object} - the Sparticle instance (for chaining)
           */

          this.setCanvasSize = function (width, height) {
            if (width) {
              this.resizable = false;
            }
            this.width = width || this.width;
            this.height = height || this.height;
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            return this;
          };
          /**
           * create an array and populate it with new Sparticle instances.
           * @returns {Array} the array of Sparticle instances
           */

          this.resetSparticles = this.createSparticles = function () {
            this.sparticles = [];
            this.ctx.globalCompositeOperation = this.settings.composition;
            for (var i = 0; i < this.settings.count; i++) {
              this.sparticles.push(new Sparticle(this, i));
            }
            this.sort();
            return this.sparticles;
          };
          /**
           * sort the particle array by size so that parallax effect
           * doesn't appear to have slower/smaller particles in foreground
           */

          this.sort = function () {
            if (this.settings.parallax) {
              this.sparticles.sort(function (a, b) {
                return a.size - b.size;
              });
            }
          }; // initialise the sparticles, and return the instance.

          return this.init();
        };
        /**
         * convert the input color to an array if it isn't already
         * @returns {Array} - array of colors for use in rendering
         */

        Sparticles.prototype.getColorArray = function () {
          var colors = Array.isArray(this.settings.color) ? this.settings.color : [this.settings.color];
          var isRandom = colors.some(function (c) {
            return c === "random";
          });
          if (isRandom) {
            for (var i = 0; i < this.settings.randomColorCount; i++) {
              colors[i] = this.settings.randomColor(i, this.settings.randomColorCount);
            }
          }
          return colors;
        };
        /**
         * convert the input shape to an array if it isn't already
         * @returns {Array} - array of shapes for use in rendering
         */

        Sparticles.prototype.getShapeArray = function () {
          var shapes = Array.isArray(this.settings.shape) ? this.settings.shape : [this.settings.shape];
          var isRandom = shapes.some(function (c) {
            return c === "random";
          });
          if (isRandom) {
            shapes = ["square", "circle", "triangle"];
          }
          return shapes;
        };
        /**
         * convert the imageUrl option to an array if it isn't already
         * @returns {Array} - array of image urls for use in rendering
         */

        Sparticles.prototype.getImageArray = function () {
          return Array.isArray(this.settings.imageUrl) ? this.settings.imageUrl : [this.settings.imageUrl];
        };
        /**
         * convert the input style to an array
         * @returns {Array} - array of styles for use in rendering
         */

        Sparticles.prototype.getStyleArray = function () {
          var styles = this.settings.style;
          if (styles !== "fill" && styles !== "stroke") {
            styles = ["fill", "stroke"];
          } else {
            styles = [styles];
          }
          return styles;
        };
        /**
         * set up the canvas and bind to a property for
         * access later on, append it to the DOM
         * @returns {HTMLCanvasElement} - the canvas element which was appended to DOM
         */

        Sparticles.prototype.setupMainCanvas = function () {
          this.canvas = document.createElement("canvas");
          this.canvas.setAttribute("class", "sparticles");
          this.ctx = this.canvas.getContext("2d");
          this.setCanvasSize();
          this.el.appendChild(this.canvas);
          return this.canvas;
        };
        /**
         * create a new offscreen canvas element for each color & shape
         * combination, so that we can reference it later during render
         * (huge performance gains here)
         * @param {Function} [callback] - function to execute after image loads
         * @returns {HTMLCanvasElement} - the created offscreen canvas
         */

        Sparticles.prototype.setupOffscreenCanvasses = function (callback) {
          var _this3 = this;
          var colors = this.colors.filter(function (item, index) {
            return _this3.colors.indexOf(item) === index;
          });
          var shapes = this.shapes.filter(function (item, index) {
            return _this3.shapes.indexOf(item) === index;
          });
          var styles = this.styles.filter(function (item, index) {
            return _this3.styles.indexOf(item) === index;
          });
          var imageUrls = this.imageUrls.filter(function (item, index) {
            return _this3.imageUrls.indexOf(item) === index;
          });
          var imageCount = colors.length * imageUrls.length;
          var canvasCount = colors.length * shapes.length * styles.length;
          var imagesLoaded = 0;
          var canvassesCreated = 0;
          this.canvasses = this.canvasses || {};
          colors.forEach(function (color) {
            _this3.canvasses[color] = _this3.canvasses[color] || {};
            shapes.forEach(function (shape) {
              _this3.canvasses[color][shape] = _this3.canvasses[color][shape] || {};
              if (shape === "image") {
                imageUrls.forEach(function (imageUrl, i) {
                  var image = new Image();
                  var imageCanvas = document.createElement("canvas");
                  _this3.canvasses[color][shape][imageUrl] = imageCanvas;
                  image.onload = function () {
                    imagesLoaded++;
                    _this3.drawOffscreenCanvasForImage(image, color, imageCanvas);
                    if (callback && imagesLoaded === imageCount) {
                      callback();
                    }
                  };
                  image.onerror = function () {
                    console.error("failed to load source image: ", imageUrl);
                  };
                  image.src = imageUrl;
                });
              } else {
                styles.forEach(function (style) {
                  var canvas = document.createElement("canvas");
                  _this3.canvasses[color][shape][style] = canvas;
                  canvassesCreated++;
                  _this3.drawOffscreenCanvas(shape, style, color, canvas);
                  if (callback && canvassesCreated === canvasCount) {
                    callback();
                  }
                });
              }
            });
          });
        };
        /**
         * return the size of the glow effect (shadowBlur) for each particle
         * @param {Number} size - the size of the particle
         * @returns {Number} - the size of the glow/shadow
         */

        Sparticles.prototype.getGlowSize = function (size) {
          return this.settings.glow;
        };
        /**
         * return the outline or stroke size of each particle
         * @param {Number} size - the size of the particle
         * @returns {Number} - the size of the outline/stroke
         */

        Sparticles.prototype.getLineSize = function (size) {
          return clamp$1(size / 20, 1, 5);
        };
        /**
         * return the offscreenCanvas size to generate for
         * @returns {Number} - the maxSize of the offscreen canvas
         */

        Sparticles.prototype.getOffscreenCanvasSize = function () {
          return clamp$1(this.settings.maxSize, this.settings.minSize, this.settings.maxSize);
        };
        /**
         * set the fill/stroke style (color & width) for each particle's offscreen canvas
         * @param {CanvasRenderingContext2D} ctx - the canvas context
         * @param {String} color - the color to fill/stroke with
         * @param {Number} lineSize - size/thickness of the stroke
         * @param {String} style - style (either "fill" or "stroke")
         */

        Sparticles.prototype.renderStyle = function (ctx, color, lineSize, style) {
          if (style === "fill") {
            ctx.fillStyle = color;
          } else {
            ctx.lineWidth = lineSize;
            ctx.strokeStyle = color;
          }
        };
        /**
         * set the shadowBlur (glow effect) for each particle's offscreen canvas
         * @param {CanvasRenderingContext2D} ctx - the canvas context
         * @param {String} color - the color to fill/stroke with
         * @param {Number} size - size of the shadow/glow
         */

        Sparticles.prototype.renderGlow = function (ctx, color, size) {
          var glowSize = this.getGlowSize(size) / 2;
          ctx.shadowColor = color;
          ctx.shadowBlur = glowSize;
        };
        /**
         * fill or stroke each particle's offscreen canvas depending on the given setting
         * @param {CanvasRenderingContext2D} ctx - the canvas context
         * @param {String} style - style (either "fill" or "stroke")
         */

        Sparticles.prototype.renderColor = function (ctx, style, path) {
          if (style === "fill") {
            if (path) {
              ctx.fill(path);
            } else {
              ctx.fill();
            }
          } else {
            if (path) {
              ctx.stroke(path);
            } else {
              ctx.stroke();
            }
          }
        };
        /**
         * pass-through the needed parameters to the offscreen canvas
         * draw function associated with the given shape
         * @param {String} shape -  shape of the canvas to draw (eg: "circle")
         * @param {String} style -  style (either "fill" or "stroke")
         * @param {String} color - the color to fill/stroke with
         * @param {HTMLCanvasElement} canvas - the canvas element
         * @returns {HTMLCanvasElement} - the created offscreen canvas
         */

        Sparticles.prototype.drawOffscreenCanvas = function (shape, style, color, canvas) {
          return this.offScreenCanvas[shape].call(this, style, color, canvas);
        };
        /**
         * object of shapes to draw
         */

        Sparticles.prototype.offScreenCanvas = {};
        /**
         * create, setup and render an offscreen canvas for a
         * Circle Particle of the given color
         * @param {String} style -  style (either "fill" or "stroke")
         * @param {String} color - the color to fill/stroke with
         * @param {HTMLCanvasElement} canvas - the canvas element
         * @returns {HTMLCanvasElement} - the created offscreen canvas
         */

        Sparticles.prototype.offScreenCanvas.circle = function (style, color, canvas) {
          var ctx = canvas.getContext("2d");
          var size = this.getOffscreenCanvasSize();
          var lineSize = this.getLineSize(size);
          var glowSize = this.getGlowSize(size);
          var canvasSize = size + lineSize * 2 + glowSize;
          var shapeSize = style === "stroke" ? size - lineSize : size;
          canvas.width = canvasSize;
          canvas.height = canvasSize;
          this.renderGlow(ctx, color, size);
          this.renderStyle(ctx, color, lineSize, style);
          ctx.beginPath();
          ctx.ellipse(canvasSize / 2, canvasSize / 2, shapeSize / 2, shapeSize / 2, 0, 0, 360);
          this.renderColor(ctx, style);
          return canvas;
        };
        /**
         * create, setup and render an offscreen canvas for a
         * Square Particle of the given color
         * @param {String} style -  style (either "fill" or "stroke")
         * @param {String} color - the color to fill/stroke with
         * @param {HTMLCanvasElement} canvas - the canvas element
         * @returns {HTMLCanvasElement} - the created offscreen canvas
         */

        Sparticles.prototype.offScreenCanvas.square = function (style, color, canvas) {
          var ctx = canvas.getContext("2d");
          var size = this.getOffscreenCanvasSize();
          var lineSize = this.getLineSize(size);
          var glowSize = this.getGlowSize(size);
          var canvasSize = size + lineSize * 2 + glowSize;
          var shapeSize = style === "stroke" ? size - lineSize : size;
          canvas.width = canvasSize;
          canvas.height = canvasSize;
          this.renderGlow(ctx, color, size);
          this.renderStyle(ctx, color, lineSize, style);
          ctx.beginPath();
          ctx.rect(canvasSize / 2 - shapeSize / 2, canvasSize / 2 - shapeSize / 2, shapeSize, shapeSize);
          this.renderColor(ctx, style);
          return canvas;
        };
        /**
         * create, setup and render an offscreen canvas for a
         * Line/Curve Particle of the given color
         * @param {String} style -  style (either "fill" or "stroke")
         * @param {String} color - the color to fill/stroke with
         * @param {HTMLCanvasElement} canvas - the canvas element
         * @returns {HTMLCanvasElement} - the created offscreen canvas
         */

        Sparticles.prototype.offScreenCanvas.line = function (style, color, canvas) {
          var ctx = canvas.getContext("2d");
          var size = this.getOffscreenCanvasSize() * 1.5;
          var lineSize = this.getLineSize(size);
          var glowSize = this.getGlowSize(size);
          var canvasSize = size + lineSize * 2 + glowSize;
          var startx = canvasSize / 2 - size / 2;
          var starty = canvasSize / 2 - size / 2;
          canvas.width = canvasSize;
          canvas.height = canvasSize;
          this.renderGlow(ctx, color, size);
          ctx.lineWidth = lineSize;
          ctx.strokeStyle = color;
          ctx.beginPath();
          ctx.moveTo(startx, starty);
          ctx.lineTo(startx + size, starty + size);
          ctx.stroke();
          ctx.closePath();
          return canvas;
        };
        /**
         * create, setup and render an offscreen canvas for a
         * Triangle Particle of the given color
         * @param {String} style -  style (either "fill" or "stroke")
         * @param {String} color - the color to fill/stroke with
         * @param {HTMLCanvasElement} canvas - the canvas element
         * @returns {HTMLCanvasElement} - the created offscreen canvas
         */

        Sparticles.prototype.offScreenCanvas.triangle = function (style, color, canvas) {
          var ctx = canvas.getContext("2d");
          var size = this.getOffscreenCanvasSize();
          var lineSize = this.getLineSize(size);
          var glowSize = this.getGlowSize(size);
          var canvasSize = size + lineSize * 2 + glowSize;
          var shapeSize = style === "stroke" ? size - lineSize : size;
          var height = shapeSize * (Math.sqrt(3) / 2);
          var startx = canvasSize / 2;
          var starty = canvasSize / 2 - shapeSize / 2;
          canvas.width = canvasSize;
          canvas.height = canvasSize;
          this.renderGlow(ctx, color, size);
          this.renderStyle(ctx, color, lineSize, style);
          ctx.beginPath();
          ctx.moveTo(startx, starty);
          ctx.lineTo(startx - shapeSize / 2, starty + height);
          ctx.lineTo(startx + shapeSize / 2, starty + height);
          ctx.closePath();
          this.renderColor(ctx, style);
          return canvas;
        };
        /**
         * create, setup and render an offscreen canvas for a
         * Diamond Sparkle Particle of the given color
         * @param {String} style -  style (either "fill" or "stroke")
         * @param {String} color - the color to fill/stroke with
         * @param {HTMLCanvasElement} canvas - the canvas element
         * @returns {HTMLCanvasElement} - the created offscreen canvas
         */

        Sparticles.prototype.offScreenCanvas.diamond = function (style, color, canvas) {
          var pathSize = 100;
          var path = new Path2D("M43,83.74,48.63,99a1.46,1.46,0,0,0,2.74,0L57,83.74A45.09,45.09,0,0,1,83.74,57L99,51.37a1.46,1.46,0,0,0,0-2.74L83.74,43A45.11,45.11,0,0,1,57,16.26L51.37,1a1.46,1.46,0,0,0-2.74,0L43,16.26A45.11,45.11,0,0,1,16.26,43L1,48.63a1.46,1.46,0,0,0,0,2.74L16.26,57A45.09,45.09,0,0,1,43,83.74Z");
          var ctx = canvas.getContext("2d");
          var size = this.getOffscreenCanvasSize();
          var lineSize = this.getLineSize(size);
          var glowSize = this.getGlowSize(size);
          var canvasSize = size + lineSize * 2 + glowSize;
          var scale = canvasSize / ((pathSize + glowSize) * 1.1);
          canvas.width = canvasSize;
          canvas.height = canvasSize;
          this.renderGlow(ctx, color, size);
          this.renderStyle(ctx, color, lineSize / scale, style);
          ctx.scale(scale, scale);
          ctx.translate(pathSize * 0.05 + glowSize * 0.5, pathSize * 0.05 + glowSize * 0.5);
          this.renderColor(ctx, style, path);
          return canvas;
        };
        /**
         * create, setup and render an offscreen canvas for a
         * Star Particle of the given color
         * @param {String} style -  style (either "fill" or "stroke")
         * @param {String} color - the color to fill/stroke with
         * @param {HTMLCanvasElement} canvas - the canvas element
         * @returns {HTMLCanvasElement} - the created offscreen canvas
         */

        Sparticles.prototype.offScreenCanvas.star = function (style, color, canvas) {
          var pathSize = 100;
          var path = new Path2D("M99.86,36.45a2.94,2.94,0,0,0-2.37-2l-31-4.54L52.63,1.64a2.93,2.93,0,0,0-5.26,0L33.51,29.91l-31,4.54a3,3,0,0,0-2.37,2,3,3,0,0,0,.74,3l22.44,22L18,92.55A2.94,2.94,0,0,0,20.91,96a2.86,2.86,0,0,0,1.36-.34L50,81,77.73,95.66a2.91,2.91,0,0,0,3.08-.22A3,3,0,0,0,82,92.55l-5.3-31.07,22.44-22A3,3,0,0,0,99.86,36.45Z");
          var ctx = canvas.getContext("2d");
          var size = this.getOffscreenCanvasSize();
          var lineSize = this.getLineSize(size);
          var glowSize = this.getGlowSize(size);
          var canvasSize = size + lineSize * 2 + glowSize;
          var scale = canvasSize / ((pathSize + glowSize) * 1.1);
          canvas.width = canvasSize;
          canvas.height = canvasSize;
          ctx.scale(scale, scale);
          this.renderGlow(ctx, color, size);
          this.renderStyle(ctx, color, lineSize / scale, style);
          ctx.translate(pathSize * 0.05 + glowSize * 0.5, pathSize * 0.05 + glowSize * 0.5);
          this.renderColor(ctx, style, path);
          return canvas;
        };
        /**
         * create, setup and render an offscreen canvas for a
         * Custom Image Particle of the given color
         * @param {HTMLImageElement} image - the image element that has loaded
         * @param {String} color - the color to fill/stroke with
         * @param {HTMLCanvasElement} canvas - the canvas element
         * @returns {HTMLCanvasElement} - the created offscreen canvas
         */

        Sparticles.prototype.drawOffscreenCanvasForImage = function (image, color, canvas) {
          var size = image.width;
          var ctx = canvas.getContext("2d");
          canvas.width = size;
          canvas.height = size;
          ctx.drawImage(image, 0, 0, size, size, 0, 0, size, size);
          ctx.globalCompositeOperation = "source-atop";
          ctx.fillStyle = color;
          ctx.fillRect(0, 0, size, size);
          return canvas;
        };
        /**
         * - wipe the canvas,
         * - update each sparticle,
         * - render each sparticle
         * - sort so that larger particles on top
         * @returns {Array} the array of Sparticle instances
         */

        Sparticles.prototype.drawFrame = function () {
          this.ctx.clearRect(0, 0, this.width, this.height);
          for (var i = 0; i < this.sparticles.length; i++) {
            var sparticle = this.sparticles[i];
            sparticle.update().render(this.canvasses);
          }
          this.sort();
          return this.sparticles;
        };
        var _hoisted_1$6 = {
          key: 0,
          class: "home-background w-screen h-screen overflow-hidden"
        };
        var _hoisted_2$5 = ["src"];
        var _sfc_main$6 = /* @__PURE__ */defineComponent({
          __name: "index",
          props: {
            homeBackground: {
              type: Object,
              default: function _default() {
                return {
                  id: "",
                  name: "",
                  url: ""
                };
              }
            }
          },
          setup: function setup(__props) {
            var props = __props;
            var imageDbStore = localforage.createInstance({
              name: "imgStore"
            });
            var imgUrl = ref("");
            var starRef = ref(null);
            var _useElementSize = useElementSize(starRef),
              width = _useElementSize.width,
              height = _useElementSize.height;
            var sparticlesOptions = {
              shape: "star",
              parallax: 1.2,
              rotate: true,
              twinkle: true,
              speed: 10,
              count: 200
            };
            function addSparticles(node, width2, height2) {
              new Sparticles(node, sparticlesOptions, width2, height2);
            }
            function handleResize() {
              if (!starRef.value) {
                return;
              }
              if (width.value && height.value) {
                addSparticles(starRef.value, width.value, height.value);
              }
            }
            function getImageStoreItem(_x2) {
              return _getImageStoreItem.apply(this, arguments);
            }
            function _getImageStoreItem() {
              _getImageStoreItem = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(item) {
                var key;
                return _regeneratorRuntime().wrap(function _callee5$(_context7) {
                  while (1) switch (_context7.prev = _context7.next) {
                    case 0:
                      if (!((item === null || item === void 0 ? void 0 : item.url) === "Storage")) {
                        _context7.next = 5;
                        break;
                      }
                      key = item.id;
                      _context7.next = 4;
                      return imageDbStore.getItem(key);
                    case 4:
                      return _context7.abrupt("return", _context7.sent);
                    case 5:
                      return _context7.abrupt("return", (item === null || item === void 0 ? void 0 : item.url) || "");
                    case 6:
                    case "end":
                      return _context7.stop();
                  }
                }, _callee5);
              }));
              return _getImageStoreItem.apply(this, arguments);
            }
            onMounted(function () {
              getImageStoreItem(props.homeBackground).then(function (image) {
                imgUrl.value = image;
              });
              if (starRef.value) {
                addSparticles(starRef.value, width.value, height.value);
              }
              window.addEventListener("resize", handleResize);
            });
            onUnmounted(function () {
              window.removeEventListener("resize", handleResize);
            });
            return function (_ctx, _cache) {
              return __props.homeBackground.url ? (openBlock(), createElementBlock("div", _hoisted_1$6, [createBaseVNode("img", {
                src: imgUrl.value,
                class: "w-full h-full object-cover",
                alt: ""
              }, null, 8, _hoisted_2$5)])) : (openBlock(), createElementBlock("div", {
                key: 1,
                ref_key: "starRef",
                ref: starRef,
                class: "w-screen h-screen overflow-hidden"
              }, null, 512));
            };
          }
        });
        function isRgbOrRgba(color) {
          return color.includes("rgb") || color.includes("rgba");
        }
        function isHex(color) {
          return color.includes("#");
        }
        function hexToRgba(hex) {
          var r = Number.parseInt(hex.slice(1, 3), 16);
          var g = Number.parseInt(hex.slice(3, 5), 16);
          var b = Number.parseInt(hex.slice(5, 7), 16);
          return {
            r: r,
            g: g,
            b: b
          };
        }
        function rgbToRgba(rgb) {
          var rgbArr = rgb.split("(")[1].split(")")[0].split(",");
          return {
            r: rgbArr[0],
            g: rgbArr[1],
            b: rgbArr[2]
          };
        }
        function rgba(color, opacity) {
          opacity = opacity || 1;
          var rgbaStr = "";
          if (isHex(color)) {
            var _hexToRgba = hexToRgba(color),
              r = _hexToRgba.r,
              _g = _hexToRgba.g,
              b = _hexToRgba.b;
            rgbaStr = "rgba(".concat(r, ",").concat(_g, ",").concat(b, ",").concat(opacity, ")");
          } else {
            var _rgbToRgba = rgbToRgba(color),
              _r = _rgbToRgba.r,
              _g2 = _rgbToRgba.g,
              _b2 = _rgbToRgba.b;
            rgbaStr = "rgba(".concat(_r, ",").concat(_g2, ",").concat(_b2, ",").concat(opacity, ")");
          }
          return rgbaStr;
        }
        function useElementStyle(element, person, index, patternList, patternColor, cardColor, cardSize, textSize) {
          var _person$department, _person$identity;
          var mod = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : "default";
          var type = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : "add";
          if (patternList.includes(index + 1) && mod === "default") {
            element.style.backgroundColor = rgba(patternColor, Math.random() * 0.2 + 0.8);
          } else if (mod === "sphere" || mod === "default") {
            element.style.backgroundColor = rgba(cardColor, Math.random() * 0.5 + 0.25);
          } else if (mod === "lucky") {
            element.style.backgroundColor = rgba(cardColor, 0.8);
          }
          element.style.border = "1px solid ".concat(rgba(cardColor, 0.25));
          element.style.boxShadow = "0 0 12px ".concat(rgba(cardColor, 0.5));
          element.style.width = "".concat(cardSize.width, "px");
          element.style.height = "".concat(cardSize.height, "px");
          if (mod === "lucky") {
            element.className = "lucky-element-card";
          } else {
            element.className = "element-card";
          }
          if (type === "add") {
            element.addEventListener("mouseenter", function (ev) {
              var target = ev.target;
              target.style.border = "1px solid ".concat(rgba(cardColor, 0.75));
              target.style.boxShadow = "0 0 12px ".concat(rgba(cardColor, 0.75));
            });
            element.addEventListener("mouseleave", function (ev) {
              var target = ev.target;
              target.style.border = "1px solid ".concat(rgba(cardColor, 0.25));
              target.style.boxShadow = "0 0 12px ".concat(rgba(cardColor, 0.5));
            });
          }
          element.children[0].style.fontSize = "".concat(textSize * 0.5, "px");
          if (person.uid) {
            element.children[0].textContent = person.uid;
          }
          element.children[1].style.fontSize = "".concat(textSize, "px");
          element.children[1].style.lineHeight = "".concat(textSize * 3, "px");
          element.children[1].style.textShadow = "0 0 12px ".concat(rgba(cardColor, 0.95));
          if (person.name) {
            element.children[1].textContent = person.name;
          }
          element.children[2].style.fontSize = "".concat(textSize * 0.5, "px");
          var detailEl = element.children[2];
          detailEl.textContent = "";
          var dept = (_person$department = person.department) !== null && _person$department !== void 0 ? _person$department : "";
          var identity = (_person$identity = person.identity) !== null && _person$identity !== void 0 ? _person$identity : "";
          if (dept) {
            detailEl.append(document.createTextNode(dept));
          }
          if (dept && identity) {
            detailEl.append(document.createElement("br"));
          }
          if (identity) {
            detailEl.append(document.createTextNode(identity));
          }
          var avatarEl = element.children[3];
          if (person.avatar) {
            avatarEl.src = person.avatar;
          }
          return element;
        }
        function useElementPosition(element, count, totalCount, cardSize, windowSize, cardIndex) {
          var xTable = 0;
          var yTable = 0;
          var centerPosition = {
            x: 0,
            y: windowSize.height / 2 - cardSize.height / 2
          };
          var specialPosition = [2, 4, 7, 9];
          if (!specialPosition.includes(totalCount) || totalCount > 5 && cardIndex < 5) {
            var _index4 = cardIndex % 5;
            if (_index4 === 0) {
              xTable = centerPosition.x;
              yTable = centerPosition.y - Math.floor(cardIndex / 5) * (cardSize.height + 60);
            } else {
              xTable = _index4 % 2 === 0 ? Math.ceil(_index4 / 2) * (cardSize.width + 100) : -Math.ceil(_index4 / 2) * (cardSize.width + 100);
              yTable = centerPosition.y - Math.floor(cardIndex / 5) * (cardSize.height + 60);
            }
          } else {
            var _index5 = cardIndex % 5;
            if (_index5 === 0) {
              xTable = centerPosition.x + (cardSize.width + 100) / 2;
              yTable = centerPosition.y - Math.floor(cardIndex / 5) * (cardSize.height + 60);
            } else {
              xTable = _index5 % 2 === 0 ? Math.ceil(_index5 / 2) * (cardSize.width + 100) + (cardSize.width + 100) / 2 : -(Math.ceil(_index5 / 2) * (cardSize.width + 100)) + (cardSize.width + 100) / 2;
              yTable = centerPosition.y - Math.floor(cardIndex / 5) * (cardSize.height + 60);
            }
          }
          return {
            xTable: xTable,
            yTable: yTable
          };
        }

        /*!
         * pinia v2.2.6
         * (c) 2024 Eduardo San Martin Morote
         * @license MIT
         */
        var activePinia;
        var setActivePinia = function setActivePinia(pinia) {
          return activePinia = pinia;
        };
        var piniaSymbol = /* istanbul ignore next */
        Symbol();
        function isPlainObject(o) {
          return o && _typeof2(o) === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
        }
        var MutationType;
        (function (MutationType2) {
          MutationType2["direct"] = "direct";
          MutationType2["patchObject"] = "patch object";
          MutationType2["patchFunction"] = "patch function";
        })(MutationType || (MutationType = {}));
        function createPinia() {
          var scope = effectScope(true);
          var state = scope.run(function () {
            return ref({});
          });
          var _p = [];
          var toBeInstalled = [];
          var pinia = markRaw({
            install: function install(app) {
              setActivePinia(pinia);
              {
                pinia._a = app;
                app.provide(piniaSymbol, pinia);
                app.config.globalProperties.$pinia = pinia;
                toBeInstalled.forEach(function (plugin) {
                  return _p.push(plugin);
                });
                toBeInstalled = [];
              }
            },
            use: function use(plugin) {
              if (!this._a && !isVue2) {
                toBeInstalled.push(plugin);
              } else {
                _p.push(plugin);
              }
              return this;
            },
            _p: _p,
            // it's actually undefined here
            // @ts-expect-error
            _a: null,
            _e: scope,
            _s: /* @__PURE__ */new Map(),
            state: state
          });
          return pinia;
        }
        var noop$1 = function noop$1() {};
        function addSubscription(subscriptions, callback, detached) {
          var onCleanup = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop$1;
          subscriptions.push(callback);
          var removeSubscription = function removeSubscription() {
            var idx = subscriptions.indexOf(callback);
            if (idx > -1) {
              subscriptions.splice(idx, 1);
              onCleanup();
            }
          };
          if (!detached && getCurrentScope()) {
            onScopeDispose(removeSubscription);
          }
          return removeSubscription;
        }
        function triggerSubscriptions(subscriptions) {
          for (var _len45 = arguments.length, args = new Array(_len45 > 1 ? _len45 - 1 : 0), _key55 = 1; _key55 < _len45; _key55++) {
            args[_key55 - 1] = arguments[_key55];
          }
          subscriptions.slice().forEach(function (callback) {
            callback.apply(void 0, args);
          });
        }
        var fallbackRunWithContext = function fallbackRunWithContext(fn) {
          return fn();
        };
        var ACTION_MARKER = Symbol();
        var ACTION_NAME = Symbol();
        function mergeReactiveObjects(target, patchToApply) {
          if (target instanceof Map && patchToApply instanceof Map) {
            patchToApply.forEach(function (value, key) {
              return target.set(key, value);
            });
          } else if (target instanceof Set && patchToApply instanceof Set) {
            patchToApply.forEach(target.add, target);
          }
          for (var key in patchToApply) {
            if (!patchToApply.hasOwnProperty(key)) continue;
            var subPatch = patchToApply[key];
            var targetValue = target[key];
            if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
              target[key] = mergeReactiveObjects(targetValue, subPatch);
            } else {
              target[key] = subPatch;
            }
          }
          return target;
        }
        var skipHydrateSymbol = /* istanbul ignore next */
        Symbol();
        function shouldHydrate(obj) {
          return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
        }
        var assign$1 = Object.assign;
        function isComputed(o) {
          return !!(isRef(o) && o.effect);
        }
        function createOptionsStore(id, options, pinia, hot) {
          var state = options.state,
            actions = options.actions,
            getters = options.getters;
          var initialState = pinia.state.value[id];
          var store;
          function setup() {
            if (!initialState && true) {
              {
                pinia.state.value[id] = state ? state() : {};
              }
            }
            var localState = toRefs(pinia.state.value[id]);
            return assign$1(localState, actions, Object.keys(getters || {}).reduce(function (computedGetters, name) {
              computedGetters[name] = markRaw(computed(function () {
                setActivePinia(pinia);
                var store2 = pinia._s.get(id);
                return getters[name].call(store2, store2);
              }));
              return computedGetters;
            }, {}));
          }
          store = createSetupStore(id, setup, options, pinia, hot, true);
          return store;
        }
        function createSetupStore($id, setup) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var pinia = arguments.length > 3 ? arguments[3] : undefined;
          var hot = arguments.length > 4 ? arguments[4] : undefined;
          var isOptionsStore = arguments.length > 5 ? arguments[5] : undefined;
          var scope;
          var optionsForPlugin = assign$1({
            actions: {}
          }, options);
          var $subscribeOptions = {
            deep: true
          };
          var isListening;
          var isSyncListening;
          var subscriptions = [];
          var actionSubscriptions = [];
          var debuggerEvents;
          var initialState = pinia.state.value[$id];
          if (!isOptionsStore && !initialState && true) {
            {
              pinia.state.value[$id] = {};
            }
          }
          ref({});
          var activeListener;
          function $patch(partialStateOrMutator) {
            var subscriptionMutation;
            isListening = isSyncListening = false;
            if (typeof partialStateOrMutator === "function") {
              partialStateOrMutator(pinia.state.value[$id]);
              subscriptionMutation = {
                type: MutationType.patchFunction,
                storeId: $id,
                events: debuggerEvents
              };
            } else {
              mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
              subscriptionMutation = {
                type: MutationType.patchObject,
                payload: partialStateOrMutator,
                storeId: $id,
                events: debuggerEvents
              };
            }
            var myListenerId = activeListener = Symbol();
            nextTick().then(function () {
              if (activeListener === myListenerId) {
                isListening = true;
              }
            });
            isSyncListening = true;
            triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
          }
          var $reset = isOptionsStore ? function $reset2() {
            var state = options.state;
            var newState = state ? state() : {};
            this.$patch(function ($state) {
              assign$1($state, newState);
            });
          } : (/* istanbul ignore next */
          noop$1);
          function $dispose() {
            scope.stop();
            subscriptions = [];
            actionSubscriptions = [];
            pinia._s.delete($id);
          }
          var action = function action(fn) {
            var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            if (ACTION_MARKER in fn) {
              fn[ACTION_NAME] = name;
              return fn;
            }
            var _wrappedAction = function wrappedAction() {
              setActivePinia(pinia);
              var args = Array.from(arguments);
              var afterCallbackList = [];
              var onErrorCallbackList = [];
              function after(callback) {
                afterCallbackList.push(callback);
              }
              function onError(callback) {
                onErrorCallbackList.push(callback);
              }
              triggerSubscriptions(actionSubscriptions, {
                args: args,
                name: _wrappedAction[ACTION_NAME],
                store: store,
                after: after,
                onError: onError
              });
              var ret;
              try {
                ret = fn.apply(this && this.$id === $id ? this : store, args);
              } catch (error) {
                triggerSubscriptions(onErrorCallbackList, error);
                throw error;
              }
              if (ret instanceof Promise) {
                return ret.then(function (value) {
                  triggerSubscriptions(afterCallbackList, value);
                  return value;
                }).catch(function (error) {
                  triggerSubscriptions(onErrorCallbackList, error);
                  return Promise.reject(error);
                });
              }
              triggerSubscriptions(afterCallbackList, ret);
              return ret;
            };
            _wrappedAction[ACTION_MARKER] = true;
            _wrappedAction[ACTION_NAME] = name;
            return _wrappedAction;
          };
          var partialStore = {
            _p: pinia,
            // _s: scope,
            $id: $id,
            $onAction: addSubscription.bind(null, actionSubscriptions),
            $patch: $patch,
            $reset: $reset,
            $subscribe: function $subscribe(callback) {
              var options2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var removeSubscription = addSubscription(subscriptions, callback, options2.detached, function () {
                return stopWatcher();
              });
              var stopWatcher = scope.run(function () {
                return watch(function () {
                  return pinia.state.value[$id];
                }, function (state) {
                  if (options2.flush === "sync" ? isSyncListening : isListening) {
                    callback({
                      storeId: $id,
                      type: MutationType.direct,
                      events: debuggerEvents
                    }, state);
                  }
                }, assign$1({}, $subscribeOptions, options2));
              });
              return removeSubscription;
            },
            $dispose: $dispose
          };
          var store = reactive(partialStore);
          pinia._s.set($id, store);
          var runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
          var setupStore = runWithContext(function () {
            return pinia._e.run(function () {
              return (scope = effectScope()).run(function () {
                return setup({
                  action: action
                });
              });
            });
          });
          for (var key in setupStore) {
            var prop = setupStore[key];
            if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
              if (!isOptionsStore) {
                if (initialState && shouldHydrate(prop)) {
                  if (isRef(prop)) {
                    prop.value = initialState[key];
                  } else {
                    mergeReactiveObjects(prop, initialState[key]);
                  }
                }
                {
                  pinia.state.value[$id][key] = prop;
                }
              }
            } else if (typeof prop === "function") {
              var actionValue = action(prop, key);
              {
                setupStore[key] = actionValue;
              }
              optionsForPlugin.actions[key] = prop;
            } else ;
          }
          {
            assign$1(store, setupStore);
            assign$1(toRaw(store), setupStore);
          }
          Object.defineProperty(store, "$state", {
            get: function get() {
              return pinia.state.value[$id];
            },
            set: function set(state) {
              $patch(function ($state) {
                assign$1($state, state);
              });
            }
          });
          pinia._p.forEach(function (extender) {
            {
              assign$1(store, scope.run(function () {
                return extender({
                  store: store,
                  app: pinia._a,
                  pinia: pinia,
                  options: optionsForPlugin
                });
              }));
            }
          });
          if (initialState && isOptionsStore && options.hydrate) {
            options.hydrate(store.$state, initialState);
          }
          isListening = true;
          isSyncListening = true;
          return store;
        }
        /*! #__NO_SIDE_EFFECTS__ */
        // @__NO_SIDE_EFFECTS__
        function defineStore(idOrOptions, setup, setupOptions) {
          var id;
          var options;
          var isSetupStore = typeof setup === "function";
          if (typeof idOrOptions === "string") {
            id = idOrOptions;
            options = isSetupStore ? setupOptions : setup;
          } else {
            options = idOrOptions;
            id = idOrOptions.id;
          }
          function useStore(pinia, hot) {
            var hasContext = hasInjectionContext();
            pinia =
            // in test mode, ignore the argument provided as we can always retrieve a
            // pinia instance with getActivePinia()
            pinia || (hasContext ? inject(piniaSymbol, null) : null);
            if (pinia) setActivePinia(pinia);
            pinia = activePinia;
            if (!pinia._s.has(id)) {
              if (isSetupStore) {
                createSetupStore(id, setup, options, pinia);
              } else {
                createOptionsStore(id, options, pinia);
              }
            }
            var store = pinia._s.get(id);
            return store;
          }
          useStore.$id = id;
          return useStore;
        }
        function storeToRefs(store) {
          {
            var rawStore = toRaw(store);
            var refs = {};
            for (var key in rawStore) {
              var value = rawStore[key];
              if (isRef(value) || isReactive(value)) {
                refs[key] =
                // ---
                toRef(store, key);
              }
            }
            return refs;
          }
        }
        var originUrl = "https://to2026.xyz";
        var baseUrl = "./";
        function generateRandomSixDigits() {
          return Math.floor(1e5 + Math.random() * 9e5).toString();
        }
        function generateUid() {
          return "hx".concat(generateRandomSixDigits());
        }
        function randomPick(list) {
          return list[Math.floor(Math.random() * list.length)];
        }
        function randomIntInclusive(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        var surnameList = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
        var maleGivenNameFirst = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
        var maleGivenNameSecond = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
        var femaleGivenNameFirst = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
        var femaleGivenNameSecond = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
        function generateName(gender) {
          var surname = randomPick(surnameList);
          var givenLen = Math.random() < 0.85 ? 2 : 1;
          if (gender === "men") {
            var first2 = randomPick(maleGivenNameFirst);
            var second2 = givenLen === 2 ? randomPick(maleGivenNameSecond) : "";
            return "".concat(surname).concat(first2).concat(second2);
          }
          var first = randomPick(femaleGivenNameFirst);
          var second = givenLen === 2 ? randomPick(femaleGivenNameSecond) : "";
          return "".concat(surname).concat(first).concat(second);
        }
        var departmentList = ["", "", "", "", "", "", "", "", ""];
        var identityList = ["", "", "", "", ""];
        function generateDefaultPersonList() {
          var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
          var personList = [];
          var currentTime = (/* @__PURE__ */new Date()).toLocaleString("zh-CN", {
            timeZone: "Asia/Shanghai"
          });
          var usedNames = /* @__PURE__ */new Set();
          var usedUids = /* @__PURE__ */new Set();
          for (var i = 0; i < count; i++) {
            var randomDepartment = randomPick(departmentList);
            var randomIdentity = randomPick(identityList);
            var avatarGender = Math.random() > 0.5 ? "men" : "women";
            var name = "";
            for (var tryCount = 0; tryCount < 2e3; tryCount++) {
              name = generateName(avatarGender);
              if (!usedNames.has(name)) {
                usedNames.add(name);
                break;
              }
            }
            if (!name) {
              name = "".concat(generateName(avatarGender)).concat(i);
              usedNames.add(name);
            }
            var _uid = "";
            for (var _tryCount = 0; _tryCount < 2e3; _tryCount++) {
              _uid = generateUid();
              if (!usedUids.has(_uid)) {
                usedUids.add(_uid);
                break;
              }
            }
            if (!_uid) {
              _uid = "hx".concat((1e5 + i).toString().padStart(6, "0"));
              usedUids.add(_uid);
            }
            var randomAvatarIndex = randomIntInclusive(1, 99);
            var x = i % 17 + 1;
            var y = Math.floor(i / 17) + 1;
            personList.push({
              uid: _uid,
              name: name,
              department: randomDepartment,
              identity: randomIdentity,
              avatar: "https://randomuser.me/api/portraits/".concat(avatarGender, "/").concat(randomAvatarIndex, ".jpg"),
              x: x,
              y: y,
              id: i,
              isWin: false,
              createTime: currentTime,
              updateTime: currentTime,
              prizeName: [],
              prizeTime: [],
              prizeId: []
            });
          }
          return personList;
        }
        function getDefaultPersonList() {
          var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
          return generateDefaultPersonList(count);
        }
        generateDefaultPersonList(50);
        var defaultMusicList = [{
          id: "Geoff Knorr - China (The Industrial Era).ogg".concat((/* @__PURE__ */new Date()).getTime().toString()),
          name: "Geoff Knorr - China (The Industrial Era).ogg",
          url: "".concat(originUrl, "/resource/audio/Geoff Knorr - China (The Industrial Era).ogg")
        }, {
          id: "Geoff Knorr&Phill Boucher - China (The Atomic Era).ogg".concat((/* @__PURE__ */new Date()).getTime().toString()),
          name: "Geoff Knorr&Phill Boucher - China (The Atomic Era).ogg",
          url: "".concat(originUrl, "/resource/audio/Geoff Knorr&Phill Boucher - China (The Atomic Era).ogg")
        }, {
          id: "Radetzky March.mp3".concat((/* @__PURE__ */new Date()).getTime().toString()),
          name: "Radetzky March.mp3",
          url: "".concat(originUrl, "/resource/audio/Radetzky March.mp3")
        }, {
          id: "Shanghai.mp3".concat((/* @__PURE__ */new Date()).getTime().toString()),
          name: "Shanghai.mp3",
          url: "".concat(originUrl, "/resource/audio/Shanghai.mp3")
        }, {
          id: "Waltz No.2.mp3".concat((/* @__PURE__ */new Date()).getTime().toString()),
          name: "Waltz No.2.mp3",
          url: "".concat(originUrl, "/resource/audio/Waltz No.2.mp3")
        }, {
          id: "WildChinaTheme.mp3".concat((/* @__PURE__ */new Date()).getTime().toString()),
          name: "WildChinaTheme.mp3",
          url: "".concat(originUrl, "/resource/audio/WildChinaTheme.mp3")
        }, {
          id: "\u8FB9\u7A0B&\u623F\u4E1C\u7684\u732B - \u7F8E\u597D\u4E8B\u7269-\u518D\u9047\u5C11\u5E74.ogg".concat((/* @__PURE__ */new Date()).getTime().toString()),
          name: "& - -.ogg",
          url: "".concat(originUrl, "/resource/audio/\u8FB9\u7A0B&\u623F\u4E1C\u7684\u732B - \u7F8E\u597D\u4E8B\u7269-\u518D\u9047\u5C11\u5E74.ogg")
        }, {
          id: "\u5927\u4E54\u5C0F\u4E54 - \u76F8\u89C1\u96BE\u522B\u4EA6\u96BE.ogg".concat((/* @__PURE__ */new Date()).getTime().toString()),
          name: " - .ogg",
          url: "".concat(originUrl, "/resource/audio/\u5927\u4E54\u5C0F\u4E54 - \u76F8\u89C1\u96BE\u522B\u4EA6\u96BE.ogg")
        }, {
          id: "\u4F60\u8981\u8DF3\u821E\u5417-\u65B0\u88E4\u5B50.mp3".concat((/* @__PURE__ */new Date()).getTime().toString()),
          name: "-.mp3",
          url: "".concat(originUrl, "/resource/audio/\u4F60\u8981\u8DF3\u821E\u5417-\u65B0\u88E4\u5B50.mp3")
        }, {
          id: "\u751F\u547D-\u58F0\u97F3\u73A9\u5177.mp3".concat((/* @__PURE__ */new Date()).getTime().toString()),
          name: "-.mp3",
          url: "".concat(originUrl, "/resource/audio/\u751F\u547D-\u58F0\u97F3\u73A9\u5177.mp3")
        }, {
          id: "\u4E0E\u975E\u95E8 - Happy New Year.ogg".concat((/* @__PURE__ */new Date()).getTime().toString()),
          name: " - Happy New Year.ogg",
          url: "".concat(originUrl, "/resource/audio/\u4E0E\u975E\u95E8 - Happy New Year.ogg")
        }];
        var defaultPrizeList = [{
          id: "001",
          name: "",
          sort: 1,
          isAll: false,
          count: 3,
          isUsedCount: 0,
          picture: {
            id: "2",
            name: "",
            url: "".concat(baseUrl, "images/image3.png")
          },
          separateCount: {
            enable: true,
            countList: []
          },
          desc: "",
          isShow: true,
          isUsed: false,
          frequency: 1
        }, {
          id: "002",
          name: "",
          sort: 2,
          isAll: false,
          count: 2,
          isUsedCount: 0,
          picture: {
            id: "1",
            name: "",
            url: "".concat(baseUrl, "images/image2.png")
          },
          separateCount: {
            enable: false,
            countList: []
          },
          desc: "",
          isShow: true,
          isUsed: false,
          frequency: 1
        }, {
          id: "003",
          name: "",
          sort: 3,
          isAll: false,
          count: 1,
          isUsedCount: 0,
          picture: {
            id: "0",
            name: "",
            url: "".concat(baseUrl, "images/image1.png")
          },
          separateCount: {
            enable: false,
            countList: []
          },
          desc: "",
          isShow: true,
          isUsed: false,
          frequency: 1
        }, {
          id: "004",
          name: "",
          sort: 4,
          isAll: false,
          count: 1,
          isUsedCount: 0,
          picture: {
            id: "3",
            name: "",
            url: "".concat(baseUrl, "images/image4.png")
          },
          separateCount: {
            enable: false,
            countList: []
          },
          desc: "",
          isShow: true,
          isUsed: false,
          frequency: 1
        }, {
          id: "005",
          name: "",
          sort: 5,
          isAll: false,
          count: 1,
          isUsedCount: 0,
          picture: {
            id: "4",
            name: "",
            url: "".concat(baseUrl, "images/image5.png")
          },
          separateCount: {
            enable: false,
            countList: []
          },
          desc: "",
          isShow: true,
          isUsed: false,
          frequency: 1
        }];
        var defaultCurrentPrize = {
          id: "001",
          name: "",
          sort: 1,
          isAll: false,
          count: 12,
          isUsedCount: 0,
          picture: {
            id: "2",
            name: "",
            url: "/images/image3.png"
          },
          separateCount: {
            enable: true,
            countList: []
          },
          desc: "",
          isShow: true,
          isUsed: false,
          frequency: 1
        };
        var defaultTemporaryPrize = {
          id: "",
          name: "",
          sort: 0,
          isAll: false,
          count: 1,
          isUsedCount: 0,
          picture: {
            id: "-1",
            name: "",
            url: ""
          },
          separateCount: {
            enable: true,
            countList: []
          },
          desc: "",
          isShow: false,
          isUsed: false,
          frequency: 1
        };
        var defaultImageList = [{
          id: "0",
          name: "",
          url: "/images/image1.png"
        }, {
          id: "1",
          name: "",
          url: "/images/image2.png"
        }, {
          id: "2",
          name: "",
          url: "/images/image3.png"
        }, {
          id: "3",
          name: "",
          url: "/images/image4.png"
        }, {
          id: "4",
          name: "",
          url: "/images/image5.png"
        }];
        var defaultPatternList = [21, 38, 55, 54, 53, 70, 87, 88, 89, 23, 40, 57, 74, 91, 92, 93, 76, 59, 42, 25, 24, 27, 28, 29, 46, 63, 62, 61, 78, 95, 96, 97, 20, 19, 31, 48, 65, 66, 67, 84, 101, 100, 99, 32, 33];
        function clone$2(val) {
          return structuredClone(val);
        }
        function createDefaultGlobalConfig() {
          var musicList = clone$2(defaultMusicList);
          var imageList = clone$2(defaultImageList);
          return {
            globalConfig: {
              rowCount: 17,
              isSHowPrizeList: true,
              isShowAvatar: false,
              topTitle: i18n.global.t("data.defaultTitle"),
              language: browserLanguage,
              theme: {
                name: "dracula",
                detail: {
                  primary: "#0f5fd3"
                },
                cardColor: "#ff79c6",
                cardWidth: 140,
                cardHeight: 200,
                textColor: "#ffffff",
                luckyCardColor: "#ECB1AC",
                textSize: 30,
                patternColor: "#1b66c9",
                patternList: clone$2(defaultPatternList),
                background: {}
                // 
              },
              musicList: musicList,
              imageList: imageList
            },
            currentMusic: {
              item: musicList[0],
              paused: true
            }
          };
        }
        var useGlobalConfig = defineStore("global", {
          state: function state() {
            return createDefaultGlobalConfig();
          },
          getters: {
            // 
            getGlobalConfig: function getGlobalConfig(state) {
              return state.globalConfig;
            },
            // 
            getTopTitle: function getTopTitle(state) {
              return state.globalConfig.topTitle;
            },
            // 
            getRowCount: function getRowCount(state) {
              return state.globalConfig.rowCount;
            },
            // 
            getTheme: function getTheme(state) {
              return state.globalConfig.theme;
            },
            // 
            getCardColor: function getCardColor(state) {
              return state.globalConfig.theme.cardColor;
            },
            // 
            getLuckyColor: function getLuckyColor(state) {
              return state.globalConfig.theme.luckyCardColor;
            },
            // 
            getTextColor: function getTextColor(state) {
              return state.globalConfig.theme.textColor;
            },
            // 
            getCardSize: function getCardSize(state) {
              return {
                width: state.globalConfig.theme.cardWidth,
                height: state.globalConfig.theme.cardHeight
              };
            },
            // 
            getTextSize: function getTextSize(state) {
              return state.globalConfig.theme.textSize;
            },
            // 
            getPatterColor: function getPatterColor(state) {
              return state.globalConfig.theme.patternColor;
            },
            // 
            getPatternList: function getPatternList(state) {
              return state.globalConfig.theme.patternList;
            },
            // 
            getMusicList: function getMusicList(state) {
              return state.globalConfig.musicList;
            },
            // 
            getCurrentMusic: function getCurrentMusic(state) {
              return state.currentMusic;
            },
            // 
            getImageList: function getImageList(state) {
              return state.globalConfig.imageList;
            },
            // 
            getIsShowPrizeList: function getIsShowPrizeList(state) {
              return state.globalConfig.isSHowPrizeList;
            },
            // 
            getLanguage: function getLanguage(state) {
              return state.globalConfig.language;
            },
            // 
            getBackground: function getBackground(state) {
              return state.globalConfig.theme.background;
            },
            // 
            getIsShowAvatar: function getIsShowAvatar(state) {
              return state.globalConfig.isShowAvatar;
            }
          },
          actions: {
            // rowCount
            setRowCount: function setRowCount(rowCount) {
              this.globalConfig.rowCount = rowCount;
            },
            // 
            setTopTitle: function setTopTitle(topTitle) {
              this.globalConfig.topTitle = topTitle;
            },
            // 
            setTheme: function setTheme(theme) {
              var name = theme.name,
                detail = theme.detail;
              this.globalConfig.theme.name = name;
              this.globalConfig.theme.detail = detail;
            },
            // 
            setCardColor: function setCardColor(cardColor) {
              this.globalConfig.theme.cardColor = cardColor;
            },
            // 
            setLuckyCardColor: function setLuckyCardColor(luckyCardColor) {
              this.globalConfig.theme.luckyCardColor = luckyCardColor;
            },
            // 
            setTextColor: function setTextColor(textColor) {
              this.globalConfig.theme.textColor = textColor;
            },
            // 
            setCardSize: function setCardSize(cardSize) {
              this.globalConfig.theme.cardWidth = cardSize.width;
              this.globalConfig.theme.cardHeight = cardSize.height;
            },
            // 
            setTextSize: function setTextSize(textSize) {
              this.globalConfig.theme.textSize = textSize;
            },
            // 
            setPatterColor: function setPatterColor(patterColor) {
              this.globalConfig.theme.patternColor = patterColor;
            },
            // 
            setPatternList: function setPatternList(patternList) {
              this.globalConfig.theme.patternList = patternList;
            },
            // 
            resetPatternList: function resetPatternList() {
              this.globalConfig.theme.patternList = defaultPatternList;
            },
            // 
            addMusic: function addMusic(music) {
              for (var i = 0; i < this.globalConfig.musicList.length; i++) {
                if (this.globalConfig.musicList[i].name === music.name) {
                  return;
                }
              }
              this.globalConfig.musicList.push(music);
            },
            // 
            removeMusic: function removeMusic(musicId) {
              for (var i = 0; i < this.globalConfig.musicList.length; i++) {
                if (this.globalConfig.musicList[i].id === musicId) {
                  this.globalConfig.musicList.splice(i, 1);
                  break;
                }
              }
            },
            // 
            setCurrentMusic: function setCurrentMusic(musicItem) {
              var paused = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
              this.currentMusic = {
                item: musicItem,
                paused: paused
              };
            },
            // 
            resetMusicList: function resetMusicList() {
              this.globalConfig.musicList = JSON.parse(JSON.stringify(defaultMusicList));
            },
            // 
            clearMusicList: function clearMusicList() {
              this.globalConfig.musicList = [];
            },
            // 
            addImage: function addImage(image) {
              for (var i = 0; i < this.globalConfig.imageList.length; i++) {
                if (this.globalConfig.imageList[i].name === image.name) {
                  return;
                }
              }
              this.globalConfig.imageList.push(image);
            },
            // 
            removeImage: function removeImage(imageId) {
              for (var i = 0; i < this.globalConfig.imageList.length; i++) {
                if (this.globalConfig.imageList[i].id === imageId) {
                  this.globalConfig.imageList.splice(i, 1);
                  break;
                }
              }
            },
            // 
            resetImageList: function resetImageList() {
              this.globalConfig.imageList = defaultImageList;
            },
            // 
            clearImageList: function clearImageList() {
              this.globalConfig.imageList = [];
            },
            // 
            setIsShowPrizeList: function setIsShowPrizeList(isShowPrizeList) {
              this.globalConfig.isSHowPrizeList = isShowPrizeList;
            },
            // 
            setLanguage: function setLanguage(language) {
              this.globalConfig.language = language;
              i18n.global.locale.value = language;
            },
            // 
            setBackground: function setBackground(background) {
              this.globalConfig.theme.background = background;
            },
            // 
            setIsShowAvatar: function setIsShowAvatar(isShowAvatar) {
              this.globalConfig.isShowAvatar = isShowAvatar;
            },
            // 
            reset: function reset() {
              var defaults = createDefaultGlobalConfig();
              this.globalConfig = defaults.globalConfig;
              this.currentMusic = defaults.currentMusic;
            }
          },
          persist: {
            enabled: true,
            strategies: [{
              // localStorage
              storage: localStorage,
              key: "globalConfig",
              paths: ["globalConfig"]
            }]
          }
        });
        var dayjs_min = {
          exports: {}
        };
        (function (module, exports) {
          !function (t, e) {
            module.exports = e();
          }(commonjsGlobal, function () {
            var t = 1e3,
              e = 6e4,
              n = 36e5,
              r = "millisecond",
              i = "second",
              s = "minute",
              u = "hour",
              a = "day",
              o = "week",
              c = "month",
              f = "quarter",
              h = "year",
              d = "date",
              l = "Invalid Date",
              $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
              y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
              M = {
                name: "en",
                weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                ordinal: function ordinal(t) {
                  var e = ["th", "st", "nd", "rd"],
                    n = t % 100;
                  return "[" + t + (e[(n - 20) % 10] || e[n] || e[0]) + "]";
                }
              },
              m = function m(t, e, n) {
                var r = String(t);
                return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t;
              },
              v = {
                s: m,
                z: function z(t) {
                  var e = -t.utcOffset(),
                    n = Math.abs(e),
                    r = Math.floor(n / 60),
                    i = n % 60;
                  return (e <= 0 ? "+" : "-") + m(r, 2, "0") + ":" + m(i, 2, "0");
                },
                m: function t(e, n) {
                  if (e.date() < n.date()) return -t(n, e);
                  var r = 12 * (n.year() - e.year()) + (n.month() - e.month()),
                    i = e.clone().add(r, c),
                    s = n - i < 0,
                    u = e.clone().add(r + (s ? -1 : 1), c);
                  return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
                },
                a: function a(t) {
                  return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
                },
                p: function p(t) {
                  return {
                    M: c,
                    y: h,
                    w: o,
                    d: a,
                    D: d,
                    h: u,
                    m: s,
                    s: i,
                    ms: r,
                    Q: f
                  }[t] || String(t || "").toLowerCase().replace(/s$/, "");
                },
                u: function u(t) {
                  return void 0 === t;
                }
              },
              g = "en",
              D = {};
            D[g] = M;
            var p = "$isDayjsObject",
              S = function S(t) {
                return t instanceof _ || !(!t || !t[p]);
              },
              w = function t(e, n, r) {
                var i;
                if (!e) return g;
                if ("string" == typeof e) {
                  var s = e.toLowerCase();
                  D[s] && (i = s), n && (D[s] = n, i = s);
                  var u = e.split("-");
                  if (!i && u.length > 1) return t(u[0]);
                } else {
                  var a = e.name;
                  D[a] = e, i = a;
                }
                return !r && i && (g = i), i || !r && g;
              },
              O = function O(t, e) {
                if (S(t)) return t.clone();
                var n = "object" == _typeof2(e) ? e : {};
                return n.date = t, n.args = arguments, new _(n);
              },
              b = v;
            b.l = w, b.i = S, b.w = function (t, e) {
              return O(t, {
                locale: e.$L,
                utc: e.$u,
                x: e.$x,
                $offset: e.$offset
              });
            };
            var _ = function () {
                function M(t) {
                  this.$L = w(t.locale, null, !0), this.parse(t), this.$x = this.$x || t.x || {}, this[p] = !0;
                }
                var m = M.prototype;
                return m.parse = function (t) {
                  this.$d = function (t) {
                    var e = t.date,
                      n = t.utc;
                    if (null === e) return new Date(NaN);
                    if (b.u(e)) return new Date();
                    if (e instanceof Date) return new Date(e);
                    if ("string" == typeof e && !/Z$/i.test(e)) {
                      var r = e.match($);
                      if (r) {
                        var i = r[2] - 1 || 0,
                          s = (r[7] || "0").substring(0, 3);
                        return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
                      }
                    }
                    return new Date(e);
                  }(t), this.init();
                }, m.init = function () {
                  var t = this.$d;
                  this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
                }, m.$utils = function () {
                  return b;
                }, m.isValid = function () {
                  return !(this.$d.toString() === l);
                }, m.isSame = function (t, e) {
                  var n = O(t);
                  return this.startOf(e) <= n && n <= this.endOf(e);
                }, m.isAfter = function (t, e) {
                  return O(t) < this.startOf(e);
                }, m.isBefore = function (t, e) {
                  return this.endOf(e) < O(t);
                }, m.$g = function (t, e, n) {
                  return b.u(t) ? this[e] : this.set(n, t);
                }, m.unix = function () {
                  return Math.floor(this.valueOf() / 1e3);
                }, m.valueOf = function () {
                  return this.$d.getTime();
                }, m.startOf = function (t, e) {
                  var n = this,
                    r = !!b.u(e) || e,
                    f = b.p(t),
                    l = function l(t, e) {
                      var i = b.w(n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t), n);
                      return r ? i : i.endOf(a);
                    },
                    $ = function $(t, e) {
                      return b.w(n.toDate()[t].apply(n.toDate("s"), (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e)), n);
                    },
                    y = this.$W,
                    M = this.$M,
                    m = this.$D,
                    v = "set" + (this.$u ? "UTC" : "");
                  switch (f) {
                    case h:
                      return r ? l(1, 0) : l(31, 11);
                    case c:
                      return r ? l(1, M) : l(0, M + 1);
                    case o:
                      var g = this.$locale().weekStart || 0,
                        D = (y < g ? y + 7 : y) - g;
                      return l(r ? m - D : m + (6 - D), M);
                    case a:
                    case d:
                      return $(v + "Hours", 0);
                    case u:
                      return $(v + "Minutes", 1);
                    case s:
                      return $(v + "Seconds", 2);
                    case i:
                      return $(v + "Milliseconds", 3);
                    default:
                      return this.clone();
                  }
                }, m.endOf = function (t) {
                  return this.startOf(t, !1);
                }, m.$set = function (t, e) {
                  var n,
                    o = b.p(t),
                    f = "set" + (this.$u ? "UTC" : ""),
                    l = (n = {}, n[a] = f + "Date", n[d] = f + "Date", n[c] = f + "Month", n[h] = f + "FullYear", n[u] = f + "Hours", n[s] = f + "Minutes", n[i] = f + "Seconds", n[r] = f + "Milliseconds", n)[o],
                    $ = o === a ? this.$D + (e - this.$W) : e;
                  if (o === c || o === h) {
                    var y = this.clone().set(d, 1);
                    y.$d[l]($), y.init(), this.$d = y.set(d, Math.min(this.$D, y.daysInMonth())).$d;
                  } else l && this.$d[l]($);
                  return this.init(), this;
                }, m.set = function (t, e) {
                  return this.clone().$set(t, e);
                }, m.get = function (t) {
                  return this[b.p(t)]();
                }, m.add = function (r, f) {
                  var d,
                    l = this;
                  r = Number(r);
                  var $ = b.p(f),
                    y = function y(t) {
                      var e = O(l);
                      return b.w(e.date(e.date() + Math.round(t * r)), l);
                    };
                  if ($ === c) return this.set(c, this.$M + r);
                  if ($ === h) return this.set(h, this.$y + r);
                  if ($ === a) return y(1);
                  if ($ === o) return y(7);
                  var M = (d = {}, d[s] = e, d[u] = n, d[i] = t, d)[$] || 1,
                    m = this.$d.getTime() + r * M;
                  return b.w(m, this);
                }, m.subtract = function (t, e) {
                  return this.add(-1 * t, e);
                }, m.format = function (t) {
                  var e = this,
                    n = this.$locale();
                  if (!this.isValid()) return n.invalidDate || l;
                  var r = t || "YYYY-MM-DDTHH:mm:ssZ",
                    i = b.z(this),
                    s = this.$H,
                    u = this.$m,
                    a = this.$M,
                    o = n.weekdays,
                    c = n.months,
                    f = n.meridiem,
                    h = function h(t, n, i, s) {
                      return t && (t[n] || t(e, r)) || i[n].slice(0, s);
                    },
                    d = function d(t) {
                      return b.s(s % 12 || 12, t, "0");
                    },
                    $ = f || function (t, e, n) {
                      var r = t < 12 ? "AM" : "PM";
                      return n ? r.toLowerCase() : r;
                    };
                  return r.replace(y, function (t, r) {
                    return r || function (t) {
                      switch (t) {
                        case "YY":
                          return String(e.$y).slice(-2);
                        case "YYYY":
                          return b.s(e.$y, 4, "0");
                        case "M":
                          return a + 1;
                        case "MM":
                          return b.s(a + 1, 2, "0");
                        case "MMM":
                          return h(n.monthsShort, a, c, 3);
                        case "MMMM":
                          return h(c, a);
                        case "D":
                          return e.$D;
                        case "DD":
                          return b.s(e.$D, 2, "0");
                        case "d":
                          return String(e.$W);
                        case "dd":
                          return h(n.weekdaysMin, e.$W, o, 2);
                        case "ddd":
                          return h(n.weekdaysShort, e.$W, o, 3);
                        case "dddd":
                          return o[e.$W];
                        case "H":
                          return String(s);
                        case "HH":
                          return b.s(s, 2, "0");
                        case "h":
                          return d(1);
                        case "hh":
                          return d(2);
                        case "a":
                          return $(s, u, !0);
                        case "A":
                          return $(s, u, !1);
                        case "m":
                          return String(u);
                        case "mm":
                          return b.s(u, 2, "0");
                        case "s":
                          return String(e.$s);
                        case "ss":
                          return b.s(e.$s, 2, "0");
                        case "SSS":
                          return b.s(e.$ms, 3, "0");
                        case "Z":
                          return i;
                      }
                      return null;
                    }(t) || i.replace(":", "");
                  });
                }, m.utcOffset = function () {
                  return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
                }, m.diff = function (r, d, l) {
                  var $,
                    y = this,
                    M = b.p(d),
                    m = O(r),
                    v = (m.utcOffset() - this.utcOffset()) * e,
                    g = this - m,
                    D = function D() {
                      return b.m(y, m);
                    };
                  switch (M) {
                    case h:
                      $ = D() / 12;
                      break;
                    case c:
                      $ = D();
                      break;
                    case f:
                      $ = D() / 3;
                      break;
                    case o:
                      $ = (g - v) / 6048e5;
                      break;
                    case a:
                      $ = (g - v) / 864e5;
                      break;
                    case u:
                      $ = g / n;
                      break;
                    case s:
                      $ = g / e;
                      break;
                    case i:
                      $ = g / t;
                      break;
                    default:
                      $ = g;
                  }
                  return l ? $ : b.a($);
                }, m.daysInMonth = function () {
                  return this.endOf(c).$D;
                }, m.$locale = function () {
                  return D[this.$L];
                }, m.locale = function (t, e) {
                  if (!t) return this.$L;
                  var n = this.clone(),
                    r = w(t, e, !0);
                  return r && (n.$L = r), n;
                }, m.clone = function () {
                  return b.w(this.$d, this);
                }, m.toDate = function () {
                  return new Date(this.valueOf());
                }, m.toJSON = function () {
                  return this.isValid() ? this.toISOString() : null;
                }, m.toISOString = function () {
                  return this.$d.toISOString();
                }, m.toString = function () {
                  return this.$d.toUTCString();
                }, M;
              }(),
              k = _.prototype;
            return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function (t) {
              k[t[1]] = function (e) {
                return this.$g(e, t[0], t[1]);
              };
            }), O.extend = function (t, e) {
              return t.$i || (t(e, _, O), t.$i = !0), O;
            }, O.locale = w, O.isDayjs = S, O.unix = function (t) {
              return O(1e3 * t);
            }, O.en = D[g], O.Ls = D, O.p = {}, O;
          });
        })(dayjs_min);
        var dayjs_minExports = dayjs_min.exports;
        var dayjs = /*@__PURE__*/getDefaultExportFromCjs(dayjs_minExports);
        function clone$1(val) {
          return structuredClone(val);
        }
        function createDefaultPrizeConfig() {
          return {
            prizeList: clone$1(defaultPrizeList),
            currentPrize: clone$1(defaultCurrentPrize),
            temporaryPrize: clone$1(defaultTemporaryPrize)
          };
        }
        var usePrizeConfig = defineStore("prize", {
          state: function state() {
            return {
              prizeConfig: _objectSpread({}, createDefaultPrizeConfig())
            };
          },
          getters: {
            // 
            getPrizeConfigAll: function getPrizeConfigAll(state) {
              return state.prizeConfig;
            },
            // 
            getPrizeConfig: function getPrizeConfig(state) {
              return state.prizeConfig.prizeList;
            },
            // id
            getPrizeConfigById: function getPrizeConfigById(state) {
              return function (id) {
                return state.prizeConfig.prizeList.find(function (item) {
                  return item.id === id;
                });
              };
            },
            // 
            getCurrentPrize: function getCurrentPrize(state) {
              return state.prizeConfig.currentPrize;
            },
            // 
            getTemporaryPrize: function getTemporaryPrize(state) {
              return state.prizeConfig.temporaryPrize;
            }
          },
          actions: {
            // 
            setPrizeConfig: function setPrizeConfig(prizeList) {
              this.prizeConfig.prizeList = prizeList;
            },
            // 
            addPrizeConfig: function addPrizeConfig(prizeConfigItem) {
              this.prizeConfig.prizeList.push(prizeConfigItem);
            },
            // 
            deletePrizeConfig: function deletePrizeConfig(prizeConfigItemId) {
              this.prizeConfig.prizeList = this.prizeConfig.prizeList.filter(function (item) {
                return item.id !== prizeConfigItemId;
              });
            },
            // 
            updatePrizeConfig: function updatePrizeConfig(prizeConfigItem) {
              var prizeListLength = this.prizeConfig.prizeList.length;
              if (prizeConfigItem.isUsed && prizeListLength) {
                for (var i = 0; i < prizeListLength; i++) {
                  if (!this.prizeConfig.prizeList[i].isUsed) {
                    this.setCurrentPrize(this.prizeConfig.prizeList[i]);
                    break;
                  }
                }
              } else {
                return;
              }
              this.resetTemporaryPrize();
            },
            // 
            deleteAllPrizeConfig: function deleteAllPrizeConfig() {
              this.prizeConfig.prizeList = [];
            },
            // 
            setCurrentPrize: function setCurrentPrize(prizeConfigItem) {
              this.prizeConfig.currentPrize = prizeConfigItem;
            },
            // 
            setTemporaryPrize: function setTemporaryPrize(prizeItem) {
              if (prizeItem.isShow === false) {
                for (var i = 0; i < this.prizeConfig.prizeList.length; i++) {
                  if (this.prizeConfig.prizeList[i].isUsed === false) {
                    this.setCurrentPrize(this.prizeConfig.prizeList[i]);
                    break;
                  }
                }
                this.resetTemporaryPrize();
                return;
              }
              this.prizeConfig.temporaryPrize = prizeItem;
            },
            // 
            resetTemporaryPrize: function resetTemporaryPrize() {
              this.prizeConfig.temporaryPrize = clone$1(defaultTemporaryPrize);
            },
            // 
            resetDefault: function resetDefault() {
              this.prizeConfig = createDefaultPrizeConfig();
            },
            // //
            // 
            resetDrawProgress: function resetDrawProgress() {
              var list = this.prizeConfig.prizeList;
              if (!(list !== null && list !== void 0 && list.length)) {
                return;
              }
              var _iterator18 = _createForOfIteratorHelper(list),
                _step18;
              try {
                for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                  var _prize$separateCount;
                  var prize = _step18.value;
                  prize.isUsed = false;
                  prize.isUsedCount = 0;
                  if ((_prize$separateCount = prize.separateCount) !== null && _prize$separateCount !== void 0 && (_prize$separateCount = _prize$separateCount.countList) !== null && _prize$separateCount !== void 0 && _prize$separateCount.length) {
                    var _iterator19 = _createForOfIteratorHelper(prize.separateCount.countList),
                      _step19;
                    try {
                      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                        var countItem = _step19.value;
                        countItem.isUsedCount = 0;
                      }
                    } catch (err) {
                      _iterator19.e(err);
                    } finally {
                      _iterator19.f();
                    }
                  }
                }
              } catch (err) {
                _iterator18.e(err);
              } finally {
                _iterator18.f();
              }
              this.setCurrentPrize(list[0]);
              this.resetTemporaryPrize();
            }
          },
          persist: {
            enabled: true,
            strategies: [{
              // localStorage
              storage: localStorage,
              key: "prizeConfig"
            }]
          }
        });
        var usePersonConfig = defineStore("person", {
          state: function state() {
            return {
              personConfig: {
                allPersonList: [],
                alreadyPersonList: []
              }
            };
          },
          getters: {
            // 
            getPersonConfig: function getPersonConfig(state) {
              return state.personConfig;
            },
            // 
            getAllPersonList: function getAllPersonList(state) {
              return state.personConfig.allPersonList.filter(function (item) {
                return item;
              });
            },
            // 
            getNotThisPrizePersonList: function getNotThisPrizePersonList(state) {
              var currentPrize = usePrizeConfig().prizeConfig.currentPrize;
              var data = state.personConfig.allPersonList.filter(function (item) {
                return !item.prizeId.includes(currentPrize.id);
              });
              return data;
            },
            // 
            getAlreadyPersonList: function getAlreadyPersonList(state) {
              return state.personConfig.allPersonList.filter(function (item) {
                return item.isWin === true;
              });
            },
            // 
            getAlreadyPersonDetail: function getAlreadyPersonDetail(state) {
              return state.personConfig.alreadyPersonList;
            },
            // 
            getNotPersonList: function getNotPersonList(state) {
              return state.personConfig.allPersonList.filter(function (item) {
                return item.isWin === false;
              });
            }
          },
          actions: {
            // 
            addNotPersonList: function addNotPersonList(personList) {
              var _this13 = this;
              if (personList.length <= 0) {
                return;
              }
              personList.forEach(function (item) {
                _this13.personConfig.allPersonList.push(item);
              });
            },
            // 
            addAlreadyPersonList: function addAlreadyPersonList(personList, prize) {
              var _this14 = this;
              if (personList.length <= 0) {
                return;
              }
              personList.forEach(function (person) {
                _this14.personConfig.allPersonList.map(function (item) {
                  if (item.id === person.id && prize != null) {
                    item.isWin = true;
                    item.prizeName.push(prize.name);
                    item.prizeTime.push(dayjs(/* @__PURE__ */new Date()).format("YYYY-MM-DD HH:mm:ss"));
                    item.prizeId.push(prize.id);
                  }
                  return item;
                });
                _this14.personConfig.alreadyPersonList.push(person);
              });
            },
            // 
            moveAlreadyToNot: function moveAlreadyToNot(person) {
              if (person.id === void 0 || person.id == null) {
                return;
              }
              var alreadyPersonListLength = this.personConfig.alreadyPersonList.length;
              for (var i = 0; i < this.personConfig.allPersonList.length; i++) {
                if (person.id === this.personConfig.allPersonList[i].id) {
                  this.personConfig.allPersonList[i].isWin = false;
                  this.personConfig.allPersonList[i].prizeName = [];
                  this.personConfig.allPersonList[i].prizeTime = [];
                  this.personConfig.allPersonList[i].prizeId = [];
                  break;
                }
              }
              for (var _i9 = 0; _i9 < alreadyPersonListLength; _i9++) {
                this.personConfig.alreadyPersonList = this.personConfig.alreadyPersonList.filter(function (item) {
                  return item.id !== person.id;
                });
              }
            },
            // 
            deletePerson: function deletePerson(person) {
              if (person.id !== void 0 || person.id != null) {
                this.personConfig.allPersonList = this.personConfig.allPersonList.filter(function (item) {
                  return item.id !== person.id;
                });
                this.personConfig.alreadyPersonList = this.personConfig.alreadyPersonList.filter(function (item) {
                  return item.id !== person.id;
                });
              }
            },
            // 
            deleteAllPerson: function deleteAllPerson() {
              this.personConfig.allPersonList = [];
              this.personConfig.alreadyPersonList = [];
            },
            // 
            resetPerson: function resetPerson() {
              this.personConfig.allPersonList = [];
              this.personConfig.alreadyPersonList = [];
            },
            // 
            resetAlreadyPerson: function resetAlreadyPerson() {
              this.personConfig.allPersonList.forEach(function (item) {
                item.isWin = false;
                item.prizeName = [];
                item.prizeTime = [];
                item.prizeId = [];
              });
              this.personConfig.alreadyPersonList = [];
            },
            setDefaultPersonList: function setDefaultPersonList() {
              this.personConfig.allPersonList = getDefaultPersonList(50);
              this.personConfig.alreadyPersonList = [];
            },
            // 
            reset: function reset() {
              this.personConfig = {
                allPersonList: [],
                alreadyPersonList: []
              };
            }
          },
          persist: {
            enabled: true,
            strategies: [{
              // localStorage
              storage: localStorage,
              key: "personConfig"
            }]
          }
        });
        var useSystem = defineStore("system", {
          state: function state() {
            return {
              isMobile: false,
              isChrome: true
            };
          },
          getters: {
            getIsMobile: function getIsMobile(state) {
              return state.isMobile;
            },
            getIsChrome: function getIsChrome(state) {
              return state.isChrome;
            }
          },
          actions: {
            setIsMobile: function setIsMobile(isMobile) {
              this.isMobile = isMobile;
            },
            setIsChrome: function setIsChrome(isChrome) {
              this.isChrome = isChrome;
            }
          },
          persist: {
            enabled: true,
            strategies: [{
              // localStorage
              // storage: localStorage,
              // key: 'globalConfig',
              // paths: ['globalConfig'],
            }]
          }
        });
        function useStore() {
          return {
            personConfig: usePersonConfig(),
            prizeConfig: usePrizeConfig(),
            globalConfig: useGlobalConfig(),
            system: useSystem()
          };
        }
        function filterData(tableData, localRowCount) {
          var dataLength = tableData.length;
          var j = 0;
          for (var i = 0; i < dataLength; i++) {
            if (i % localRowCount === 0) {
              j++;
            }
            tableData[i].x = i % localRowCount + 1;
            tableData[i].y = j;
            tableData[i].id = i;
          }
          return tableData;
        }
        function addOtherInfo(personList) {
          var len = personList.length;
          for (var i = 0; i < len; i++) {
            personList[i].id = i;
            personList[i].createTime = dayjs(/* @__PURE__ */new Date()).format("YYYY-MM-DD HH:mm:ss");
            personList[i].updateTime = dayjs(/* @__PURE__ */new Date()).format("YYYY-MM-DD HH:mm:ss");
            personList[i].prizeName = [];
            personList[i].prizeTime = [];
            personList[i].prizeId = [];
            personList[i].isWin = false;
          }
          return personList;
        }
        function selectCard(cardIndexArr, tableLength, _personId) {
          if (tableLength <= 0) {
            return 0;
          }
          var cardIndex = Math.floor(Math.random() * tableLength);
          var guard = 0;
          while (cardIndexArr.includes(cardIndex) && guard < tableLength) {
            cardIndex = Math.floor(Math.random() * tableLength);
            guard++;
          }
          return cardIndex;
        }
        function themeChange(theme) {
          var html = document.querySelectorAll("html");
          if (html) {
            html[0].setAttribute("data-theme", theme);
            localStorage.setItem("theme", theme);
          }
        }

        /**
         * The Ease class provides a collection of easing functions for use with tween.js.
         */
        var Easing = Object.freeze({
          Linear: Object.freeze({
            None: function None(amount) {
              return amount;
            },
            In: function In(amount) {
              return amount;
            },
            Out: function Out(amount) {
              return amount;
            },
            InOut: function InOut(amount) {
              return amount;
            }
          }),
          Quadratic: Object.freeze({
            In: function In(amount) {
              return amount * amount;
            },
            Out: function Out(amount) {
              return amount * (2 - amount);
            },
            InOut: function InOut(amount) {
              if ((amount *= 2) < 1) {
                return 0.5 * amount * amount;
              }
              return -0.5 * (--amount * (amount - 2) - 1);
            }
          }),
          Cubic: Object.freeze({
            In: function In(amount) {
              return amount * amount * amount;
            },
            Out: function Out(amount) {
              return --amount * amount * amount + 1;
            },
            InOut: function InOut(amount) {
              if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount;
              }
              return 0.5 * ((amount -= 2) * amount * amount + 2);
            }
          }),
          Quartic: Object.freeze({
            In: function In(amount) {
              return amount * amount * amount * amount;
            },
            Out: function Out(amount) {
              return 1 - --amount * amount * amount * amount;
            },
            InOut: function InOut(amount) {
              if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount;
              }
              return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
            }
          }),
          Quintic: Object.freeze({
            In: function In(amount) {
              return amount * amount * amount * amount * amount;
            },
            Out: function Out(amount) {
              return --amount * amount * amount * amount * amount + 1;
            },
            InOut: function InOut(amount) {
              if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount * amount;
              }
              return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
            }
          }),
          Sinusoidal: Object.freeze({
            In: function In(amount) {
              return 1 - Math.sin((1.0 - amount) * Math.PI / 2);
            },
            Out: function Out(amount) {
              return Math.sin(amount * Math.PI / 2);
            },
            InOut: function InOut(amount) {
              return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));
            }
          }),
          Exponential: Object.freeze({
            In: function In(amount) {
              return amount === 0 ? 0 : Math.pow(1024, amount - 1);
            },
            Out: function Out(amount) {
              return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
            },
            InOut: function InOut(amount) {
              if (amount === 0) {
                return 0;
              }
              if (amount === 1) {
                return 1;
              }
              if ((amount *= 2) < 1) {
                return 0.5 * Math.pow(1024, amount - 1);
              }
              return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
            }
          }),
          Circular: Object.freeze({
            In: function In(amount) {
              return 1 - Math.sqrt(1 - amount * amount);
            },
            Out: function Out(amount) {
              return Math.sqrt(1 - --amount * amount);
            },
            InOut: function InOut(amount) {
              if ((amount *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
              }
              return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
            }
          }),
          Elastic: Object.freeze({
            In: function In(amount) {
              if (amount === 0) {
                return 0;
              }
              if (amount === 1) {
                return 1;
              }
              return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
            },
            Out: function Out(amount) {
              if (amount === 0) {
                return 0;
              }
              if (amount === 1) {
                return 1;
              }
              return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
            },
            InOut: function InOut(amount) {
              if (amount === 0) {
                return 0;
              }
              if (amount === 1) {
                return 1;
              }
              amount *= 2;
              if (amount < 1) {
                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
              }
              return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
            }
          }),
          Back: Object.freeze({
            In: function In(amount) {
              var s = 1.70158;
              return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);
            },
            Out: function Out(amount) {
              var s = 1.70158;
              return amount === 0 ? 0 : --amount * amount * ((s + 1) * amount + s) + 1;
            },
            InOut: function InOut(amount) {
              var s = 1.70158 * 1.525;
              if ((amount *= 2) < 1) {
                return 0.5 * (amount * amount * ((s + 1) * amount - s));
              }
              return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
            }
          }),
          Bounce: Object.freeze({
            In: function In(amount) {
              return 1 - Easing.Bounce.Out(1 - amount);
            },
            Out: function Out(amount) {
              if (amount < 1 / 2.75) {
                return 7.5625 * amount * amount;
              } else if (amount < 2 / 2.75) {
                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
              } else if (amount < 2.5 / 2.75) {
                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
              } else {
                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
              }
            },
            InOut: function InOut(amount) {
              if (amount < 0.5) {
                return Easing.Bounce.In(amount * 2) * 0.5;
              }
              return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
            }
          }),
          generatePow: function generatePow(power) {
            if (power === void 0) {
              power = 4;
            }
            power = power < Number.EPSILON ? Number.EPSILON : power;
            power = power > 10000 ? 10000 : power;
            return {
              In: function In(amount) {
                return Math.pow(amount, power);
              },
              Out: function Out(amount) {
                return 1 - Math.pow(1 - amount, power);
              },
              InOut: function InOut(amount) {
                if (amount < 0.5) {
                  return Math.pow(amount * 2, power) / 2;
                }
                return (1 - Math.pow(2 - amount * 2, power)) / 2 + 0.5;
              }
            };
          }
        });
        var now$1 = function now$1() {
          return performance.now();
        };

        /**
         * Controlling groups of tweens
         *
         * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
         * In these cases, you may want to create your own smaller groups of tween
         */
        var Group$1 = /** @class */function () {
          function Group() {
            this._tweens = {};
            this._tweensAddedDuringUpdate = {};
          }
          Group.prototype.getAll = function () {
            var _this = this;
            return Object.keys(this._tweens).map(function (tweenId) {
              return _this._tweens[tweenId];
            });
          };
          Group.prototype.removeAll = function () {
            this._tweens = {};
          };
          Group.prototype.add = function (tween) {
            this._tweens[tween.getId()] = tween;
            this._tweensAddedDuringUpdate[tween.getId()] = tween;
          };
          Group.prototype.remove = function (tween) {
            delete this._tweens[tween.getId()];
            delete this._tweensAddedDuringUpdate[tween.getId()];
          };
          Group.prototype.update = function (time, preserve) {
            if (time === void 0) {
              time = now$1();
            }
            if (preserve === void 0) {
              preserve = false;
            }
            var tweenIds = Object.keys(this._tweens);
            if (tweenIds.length === 0) {
              return false;
            }
            // Tweens are updated in "batches". If you add a new tween during an
            // update, then the new tween will be updated in the next batch.
            // If you remove a tween during an update, it may or may not be updated.
            // However, if the removed tween was added during the current batch,
            // then it will not be updated.
            while (tweenIds.length > 0) {
              this._tweensAddedDuringUpdate = {};
              for (var i = 0; i < tweenIds.length; i++) {
                var tween = this._tweens[tweenIds[i]];
                var autoStart = !preserve;
                if (tween && tween.update(time, autoStart) === false && !preserve) {
                  delete this._tweens[tweenIds[i]];
                }
              }
              tweenIds = Object.keys(this._tweensAddedDuringUpdate);
            }
            return true;
          };
          return Group;
        }();

        /**
         *
         */
        var Interpolation = {
          Linear: function Linear(v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            var fn = Interpolation.Utils.Linear;
            if (k < 0) {
              return fn(v[0], v[1], f);
            }
            if (k > 1) {
              return fn(v[m], v[m - 1], m - f);
            }
            return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
          },
          Bezier: function Bezier(v, k) {
            var b = 0;
            var n = v.length - 1;
            var pw = Math.pow;
            var bn = Interpolation.Utils.Bernstein;
            for (var i = 0; i <= n; i++) {
              b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
            }
            return b;
          },
          CatmullRom: function CatmullRom(v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            var fn = Interpolation.Utils.CatmullRom;
            if (v[0] === v[m]) {
              if (k < 0) {
                i = Math.floor(f = m * (1 + k));
              }
              return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
            } else {
              if (k < 0) {
                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
              }
              if (k > 1) {
                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
              }
              return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
            }
          },
          Utils: {
            Linear: function Linear(p0, p1, t) {
              return (p1 - p0) * t + p0;
            },
            Bernstein: function Bernstein(n, i) {
              var fc = Interpolation.Utils.Factorial;
              return fc(n) / fc(i) / fc(n - i);
            },
            Factorial: function () {
              var a = [1];
              return function (n) {
                var s = 1;
                if (a[n]) {
                  return a[n];
                }
                for (var i = n; i > 1; i--) {
                  s *= i;
                }
                a[n] = s;
                return s;
              };
            }(),
            CatmullRom: function CatmullRom(p0, p1, p2, p3, t) {
              var v0 = (p2 - p0) * 0.5;
              var v1 = (p3 - p1) * 0.5;
              var t2 = t * t;
              var t3 = t * t2;
              return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
            }
          }
        };

        /**
         * Utils
         */
        var Sequence = /** @class */function () {
          function Sequence() {}
          Sequence.nextId = function () {
            return Sequence._nextId++;
          };
          Sequence._nextId = 0;
          return Sequence;
        }();
        var mainGroup = new Group$1();

        /**
         * Tween.js - Licensed under the MIT license
         * https://github.com/tweenjs/tween.js
         * ----------------------------------------------
         *
         * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
         * Thank you all, you're awesome!
         */
        var Tween = /** @class */function () {
          function Tween(_object, _group) {
            if (_group === void 0) {
              _group = mainGroup;
            }
            this._object = _object;
            this._group = _group;
            this._isPaused = false;
            this._pauseStart = 0;
            this._valuesStart = {};
            this._valuesEnd = {};
            this._valuesStartRepeat = {};
            this._duration = 1000;
            this._isDynamic = false;
            this._initialRepeat = 0;
            this._repeat = 0;
            this._yoyo = false;
            this._isPlaying = false;
            this._reversed = false;
            this._delayTime = 0;
            this._startTime = 0;
            this._easingFunction = Easing.Linear.None;
            this._interpolationFunction = Interpolation.Linear;
            // eslint-disable-next-line
            this._chainedTweens = [];
            this._onStartCallbackFired = false;
            this._onEveryStartCallbackFired = false;
            this._id = Sequence.nextId();
            this._isChainStopped = false;
            this._propertiesAreSetUp = false;
            this._goToEnd = false;
          }
          Tween.prototype.getId = function () {
            return this._id;
          };
          Tween.prototype.isPlaying = function () {
            return this._isPlaying;
          };
          Tween.prototype.isPaused = function () {
            return this._isPaused;
          };
          Tween.prototype.getDuration = function () {
            return this._duration;
          };
          Tween.prototype.to = function (target, duration) {
            if (duration === void 0) {
              duration = 1000;
            }
            if (this._isPlaying) throw new Error('Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.');
            this._valuesEnd = target;
            this._propertiesAreSetUp = false;
            this._duration = duration < 0 ? 0 : duration;
            return this;
          };
          Tween.prototype.duration = function (duration) {
            if (duration === void 0) {
              duration = 1000;
            }
            this._duration = duration < 0 ? 0 : duration;
            return this;
          };
          Tween.prototype.dynamic = function (dynamic) {
            if (dynamic === void 0) {
              dynamic = false;
            }
            this._isDynamic = dynamic;
            return this;
          };
          Tween.prototype.start = function (time, overrideStartingValues) {
            if (time === void 0) {
              time = now$1();
            }
            if (overrideStartingValues === void 0) {
              overrideStartingValues = false;
            }
            if (this._isPlaying) {
              return this;
            }
            // eslint-disable-next-line
            this._group && this._group.add(this);
            this._repeat = this._initialRepeat;
            if (this._reversed) {
              // If we were reversed (f.e. using the yoyo feature) then we need to
              // flip the tween direction back to forward.
              this._reversed = false;
              for (var property in this._valuesStartRepeat) {
                this._swapEndStartRepeatValues(property);
                this._valuesStart[property] = this._valuesStartRepeat[property];
              }
            }
            this._isPlaying = true;
            this._isPaused = false;
            this._onStartCallbackFired = false;
            this._onEveryStartCallbackFired = false;
            this._isChainStopped = false;
            this._startTime = time;
            this._startTime += this._delayTime;
            if (!this._propertiesAreSetUp || overrideStartingValues) {
              this._propertiesAreSetUp = true;
              // If dynamic is not enabled, clone the end values instead of using the passed-in end values.
              if (!this._isDynamic) {
                var tmp = {};
                for (var prop in this._valuesEnd) tmp[prop] = this._valuesEnd[prop];
                this._valuesEnd = tmp;
              }
              this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);
            }
            return this;
          };
          Tween.prototype.startFromCurrentValues = function (time) {
            return this.start(time, true);
          };
          Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overrideStartingValues) {
            for (var property in _valuesEnd) {
              var startValue = _object[property];
              var startValueIsArray = Array.isArray(startValue);
              var propType = startValueIsArray ? 'array' : _typeof2(startValue);
              var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
              // If `to()` specifies a property that doesn't exist in the source object,
              // we should not set that property in the object
              if (propType === 'undefined' || propType === 'function') {
                continue;
              }
              // Check if an Array was provided as property value
              if (isInterpolationList) {
                var endValues = _valuesEnd[property];
                if (endValues.length === 0) {
                  continue;
                }
                // Handle an array of relative values.
                // Creates a local copy of the Array with the start value at the front
                var temp = [startValue];
                for (var i = 0, l = endValues.length; i < l; i += 1) {
                  var value = this._handleRelativeValue(startValue, endValues[i]);
                  if (isNaN(value)) {
                    isInterpolationList = false;
                    console.warn('Found invalid interpolation list. Skipping.');
                    break;
                  }
                  temp.push(value);
                }
                if (isInterpolationList) {
                  // if (_valuesStart[property] === undefined) { // handle end values only the first time. NOT NEEDED? setupProperties is now guarded by _propertiesAreSetUp.
                  _valuesEnd[property] = temp;
                  // }
                }
              }
              // handle the deepness of the values
              if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
                _valuesStart[property] = startValueIsArray ? [] : {};
                var nestedObject = startValue;
                for (var prop in nestedObject) {
                  _valuesStart[property][prop] = nestedObject[prop];
                }
                // TODO? repeat nested values? And yoyo? And array values?
                _valuesStartRepeat[property] = startValueIsArray ? [] : {};
                var endValues = _valuesEnd[property];
                // If dynamic is not enabled, clone the end values instead of using the passed-in end values.
                if (!this._isDynamic) {
                  var tmp = {};
                  for (var prop in endValues) tmp[prop] = endValues[prop];
                  _valuesEnd[property] = endValues = tmp;
                }
                this._setupProperties(nestedObject, _valuesStart[property], endValues, _valuesStartRepeat[property], overrideStartingValues);
              } else {
                // Save the starting value, but only once unless override is requested.
                if (typeof _valuesStart[property] === 'undefined' || overrideStartingValues) {
                  _valuesStart[property] = startValue;
                }
                if (!startValueIsArray) {
                  // eslint-disable-next-line
                  // @ts-ignore FIXME?
                  _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
                }
                if (isInterpolationList) {
                  // eslint-disable-next-line
                  // @ts-ignore FIXME?
                  _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                } else {
                  _valuesStartRepeat[property] = _valuesStart[property] || 0;
                }
              }
            }
          };
          Tween.prototype.stop = function () {
            if (!this._isChainStopped) {
              this._isChainStopped = true;
              this.stopChainedTweens();
            }
            if (!this._isPlaying) {
              return this;
            }
            // eslint-disable-next-line
            this._group && this._group.remove(this);
            this._isPlaying = false;
            this._isPaused = false;
            if (this._onStopCallback) {
              this._onStopCallback(this._object);
            }
            return this;
          };
          Tween.prototype.end = function () {
            this._goToEnd = true;
            this.update(Infinity);
            return this;
          };
          Tween.prototype.pause = function (time) {
            if (time === void 0) {
              time = now$1();
            }
            if (this._isPaused || !this._isPlaying) {
              return this;
            }
            this._isPaused = true;
            this._pauseStart = time;
            // eslint-disable-next-line
            this._group && this._group.remove(this);
            return this;
          };
          Tween.prototype.resume = function (time) {
            if (time === void 0) {
              time = now$1();
            }
            if (!this._isPaused || !this._isPlaying) {
              return this;
            }
            this._isPaused = false;
            this._startTime += time - this._pauseStart;
            this._pauseStart = 0;
            // eslint-disable-next-line
            this._group && this._group.add(this);
            return this;
          };
          Tween.prototype.stopChainedTweens = function () {
            for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
              this._chainedTweens[i].stop();
            }
            return this;
          };
          Tween.prototype.group = function (group) {
            if (group === void 0) {
              group = mainGroup;
            }
            this._group = group;
            return this;
          };
          Tween.prototype.delay = function (amount) {
            if (amount === void 0) {
              amount = 0;
            }
            this._delayTime = amount;
            return this;
          };
          Tween.prototype.repeat = function (times) {
            if (times === void 0) {
              times = 0;
            }
            this._initialRepeat = times;
            this._repeat = times;
            return this;
          };
          Tween.prototype.repeatDelay = function (amount) {
            this._repeatDelayTime = amount;
            return this;
          };
          Tween.prototype.yoyo = function (yoyo) {
            if (yoyo === void 0) {
              yoyo = false;
            }
            this._yoyo = yoyo;
            return this;
          };
          Tween.prototype.easing = function (easingFunction) {
            if (easingFunction === void 0) {
              easingFunction = Easing.Linear.None;
            }
            this._easingFunction = easingFunction;
            return this;
          };
          Tween.prototype.interpolation = function (interpolationFunction) {
            if (interpolationFunction === void 0) {
              interpolationFunction = Interpolation.Linear;
            }
            this._interpolationFunction = interpolationFunction;
            return this;
          };
          // eslint-disable-next-line
          Tween.prototype.chain = function () {
            var tweens = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              tweens[_i] = arguments[_i];
            }
            this._chainedTweens = tweens;
            return this;
          };
          Tween.prototype.onStart = function (callback) {
            this._onStartCallback = callback;
            return this;
          };
          Tween.prototype.onEveryStart = function (callback) {
            this._onEveryStartCallback = callback;
            return this;
          };
          Tween.prototype.onUpdate = function (callback) {
            this._onUpdateCallback = callback;
            return this;
          };
          Tween.prototype.onRepeat = function (callback) {
            this._onRepeatCallback = callback;
            return this;
          };
          Tween.prototype.onComplete = function (callback) {
            this._onCompleteCallback = callback;
            return this;
          };
          Tween.prototype.onStop = function (callback) {
            this._onStopCallback = callback;
            return this;
          };
          /**
           * @returns true if the tween is still playing after the update, false
           * otherwise (calling update on a paused tween still returns true because
           * it is still playing, just paused).
           */
          Tween.prototype.update = function (time, autoStart) {
            var _a;
            if (time === void 0) {
              time = now$1();
            }
            if (autoStart === void 0) {
              autoStart = true;
            }
            if (this._isPaused) return true;
            var endTime = this._startTime + this._duration;
            if (!this._goToEnd && !this._isPlaying) {
              if (time > endTime) return false;
              if (autoStart) this.start(time, true);
            }
            this._goToEnd = false;
            if (time < this._startTime) {
              return true;
            }
            if (this._onStartCallbackFired === false) {
              if (this._onStartCallback) {
                this._onStartCallback(this._object);
              }
              this._onStartCallbackFired = true;
            }
            if (this._onEveryStartCallbackFired === false) {
              if (this._onEveryStartCallback) {
                this._onEveryStartCallback(this._object);
              }
              this._onEveryStartCallbackFired = true;
            }
            var elapsedTime = time - this._startTime;
            var durationAndDelay = this._duration + ((_a = this._repeatDelayTime) !== null && _a !== void 0 ? _a : this._delayTime);
            var totalTime = this._duration + this._repeat * durationAndDelay;
            var elapsed = this._calculateElapsedPortion(elapsedTime, durationAndDelay, totalTime);
            var value = this._easingFunction(elapsed);
            var status = this._calculateCompletionStatus(elapsedTime, durationAndDelay);
            if (status === 'repeat') {
              // the current update is happening after the instant the tween repeated
              this._processRepetition(elapsedTime, durationAndDelay);
            }
            this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
            if (status === 'about-to-repeat') {
              // the current update is happening at the exact instant the tween is going to repeat
              // the values should match the end of the tween, not the beginning,
              // that's why _processRepetition happens after _updateProperties
              this._processRepetition(elapsedTime, durationAndDelay);
            }
            if (this._onUpdateCallback) {
              this._onUpdateCallback(this._object, elapsed);
            }
            if (status === 'repeat' || status === 'about-to-repeat') {
              if (this._onRepeatCallback) {
                this._onRepeatCallback(this._object);
              }
              this._onEveryStartCallbackFired = false;
            } else if (status === 'completed') {
              this._isPlaying = false;
              if (this._onCompleteCallback) {
                this._onCompleteCallback(this._object);
              }
              for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                // Make the chained tweens start exactly at the time they should,
                // even if the `update()` method was called way past the duration of the tween
                this._chainedTweens[i].start(this._startTime + this._duration, false);
              }
            }
            return status !== 'completed';
          };
          Tween.prototype._calculateElapsedPortion = function (elapsedTime, durationAndDelay, totalTime) {
            if (this._duration === 0 || elapsedTime > totalTime) {
              return 1;
            }
            var timeIntoCurrentRepeat = elapsedTime % durationAndDelay;
            var portion = Math.min(timeIntoCurrentRepeat / this._duration, 1);
            if (portion === 0 && elapsedTime !== 0 && elapsedTime % this._duration === 0) {
              return 1;
            }
            return portion;
          };
          Tween.prototype._calculateCompletionStatus = function (elapsedTime, durationAndDelay) {
            if (this._duration !== 0 && elapsedTime < this._duration) {
              return 'playing';
            }
            if (this._repeat <= 0) {
              return 'completed';
            }
            if (elapsedTime === this._duration) {
              return 'about-to-repeat';
            }
            return 'repeat';
          };
          Tween.prototype._processRepetition = function (elapsedTime, durationAndDelay) {
            var completeCount = Math.min(Math.trunc((elapsedTime - this._duration) / durationAndDelay) + 1, this._repeat);
            if (isFinite(this._repeat)) {
              this._repeat -= completeCount;
            }
            // Reassign starting values, restart by making startTime = now
            for (var property in this._valuesStartRepeat) {
              var valueEnd = this._valuesEnd[property];
              if (!this._yoyo && typeof valueEnd === 'string') {
                this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(valueEnd);
              }
              if (this._yoyo) {
                this._swapEndStartRepeatValues(property);
              }
              this._valuesStart[property] = this._valuesStartRepeat[property];
            }
            if (this._yoyo) {
              this._reversed = !this._reversed;
            }
            this._startTime += durationAndDelay * completeCount;
          };
          Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
            for (var property in _valuesEnd) {
              // Don't update properties that do not exist in the source object
              if (_valuesStart[property] === undefined) {
                continue;
              }
              var start = _valuesStart[property] || 0;
              var end = _valuesEnd[property];
              var startIsArray = Array.isArray(_object[property]);
              var endIsArray = Array.isArray(end);
              var isInterpolationList = !startIsArray && endIsArray;
              if (isInterpolationList) {
                _object[property] = this._interpolationFunction(end, value);
              } else if (_typeof2(end) === 'object' && end) {
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._updateProperties(_object[property], start, end, value);
              } else {
                // Parses relative end values with start as base (e.g.: +10, -3)
                end = this._handleRelativeValue(start, end);
                // Protect against non numeric properties.
                if (typeof end === 'number') {
                  // eslint-disable-next-line
                  // @ts-ignore FIXME?
                  _object[property] = start + (end - start) * value;
                }
              }
            }
          };
          Tween.prototype._handleRelativeValue = function (start, end) {
            if (typeof end !== 'string') {
              return end;
            }
            if (end.charAt(0) === '+' || end.charAt(0) === '-') {
              return start + parseFloat(end);
            }
            return parseFloat(end);
          };
          Tween.prototype._swapEndStartRepeatValues = function (property) {
            var tmp = this._valuesStartRepeat[property];
            var endValue = this._valuesEnd[property];
            if (typeof endValue === 'string') {
              this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
            } else {
              this._valuesStartRepeat[property] = this._valuesEnd[property];
            }
            this._valuesEnd[property] = tmp;
          };
          return Tween;
        }();
        /**
         * Controlling groups of tweens
         *
         * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
         * In these cases, you may want to create your own smaller groups of tweens.
         */
        var TWEEN = mainGroup;
        // This is the best way to export things in a way that's compatible with both ES
        // Modules and CommonJS, without build hacks, and so as not to break the
        // existing API.
        // https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
        TWEEN.getAll.bind(TWEEN);
        var removeAll = TWEEN.removeAll.bind(TWEEN);
        TWEEN.add.bind(TWEEN);
        TWEEN.remove.bind(TWEEN);
        var update = TWEEN.update.bind(TWEEN);

        // canvas-confetti v1.9.3 built on 2024-04-30T22:19:17.794Z
        var module$1 = {};

        // source content
        /* globals Map */

        (function main(global, module, isWorker, workerSize) {
          var canUseWorker = !!(global.Worker && global.Blob && global.Promise && global.OffscreenCanvas && global.OffscreenCanvasRenderingContext2D && global.HTMLCanvasElement && global.HTMLCanvasElement.prototype.transferControlToOffscreen && global.URL && global.URL.createObjectURL);
          var canUsePaths = typeof Path2D === 'function' && typeof DOMMatrix === 'function';
          var canDrawBitmap = function () {
            // this mostly supports ssr
            if (!global.OffscreenCanvas) {
              return false;
            }
            var canvas = new OffscreenCanvas(1, 1);
            var ctx = canvas.getContext('2d');
            ctx.fillRect(0, 0, 1, 1);
            var bitmap = canvas.transferToImageBitmap();
            try {
              ctx.createPattern(bitmap, 'no-repeat');
            } catch (e) {
              return false;
            }
            return true;
          }();
          function noop() {}

          // create a promise if it exists, otherwise, just
          // call the function directly
          function promise(func) {
            var ModulePromise = module.exports.Promise;
            var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;
            if (typeof Prom === 'function') {
              return new Prom(func);
            }
            func(noop, noop);
            return null;
          }
          var bitmapMapper = function (skipTransform, map) {
            // see https://github.com/catdad/canvas-confetti/issues/209
            // creating canvases is actually pretty expensive, so we should create a
            // 1:1 map for bitmap:canvas, so that we can animate the confetti in
            // a performant manner, but also not store them forever so that we don't
            // have a memory leak
            return {
              transform: function transform(bitmap) {
                if (skipTransform) {
                  return bitmap;
                }
                if (map.has(bitmap)) {
                  return map.get(bitmap);
                }
                var canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
                var ctx = canvas.getContext('2d');
                ctx.drawImage(bitmap, 0, 0);
                map.set(bitmap, canvas);
                return canvas;
              },
              clear: function clear() {
                map.clear();
              }
            };
          }(canDrawBitmap, new Map());
          var raf = function () {
            var TIME = Math.floor(1000 / 60);
            var frame, cancel;
            var frames = {};
            var lastFrameTime = 0;
            if (typeof requestAnimationFrame === 'function' && typeof cancelAnimationFrame === 'function') {
              frame = function frame(cb) {
                var id = Math.random();
                frames[id] = requestAnimationFrame(function onFrame(time) {
                  if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {
                    lastFrameTime = time;
                    delete frames[id];
                    cb();
                  } else {
                    frames[id] = requestAnimationFrame(onFrame);
                  }
                });
                return id;
              };
              cancel = function cancel(id) {
                if (frames[id]) {
                  cancelAnimationFrame(frames[id]);
                }
              };
            } else {
              frame = function frame(cb) {
                return setTimeout(cb, TIME);
              };
              cancel = function cancel(timer) {
                return clearTimeout(timer);
              };
            }
            return {
              frame: frame,
              cancel: cancel
            };
          }();
          var getWorker = function () {
            var worker;
            var prom;
            var resolves = {};
            function decorate(worker) {
              function execute(options, callback) {
                worker.postMessage({
                  options: options || {},
                  callback: callback
                });
              }
              worker.init = function initWorker(canvas) {
                var offscreen = canvas.transferControlToOffscreen();
                worker.postMessage({
                  canvas: offscreen
                }, [offscreen]);
              };
              worker.fire = function fireWorker(options, size, done) {
                if (prom) {
                  execute(options, null);
                  return prom;
                }
                var id = Math.random().toString(36).slice(2);
                prom = promise(function (resolve) {
                  function workerDone(msg) {
                    if (msg.data.callback !== id) {
                      return;
                    }
                    delete resolves[id];
                    worker.removeEventListener('message', workerDone);
                    prom = null;
                    bitmapMapper.clear();
                    done();
                    resolve();
                  }
                  worker.addEventListener('message', workerDone);
                  execute(options, id);
                  resolves[id] = workerDone.bind(null, {
                    data: {
                      callback: id
                    }
                  });
                });
                return prom;
              };
              worker.reset = function resetWorker() {
                worker.postMessage({
                  reset: true
                });
                for (var id in resolves) {
                  resolves[id]();
                  delete resolves[id];
                }
              };
            }
            return function () {
              if (worker) {
                return worker;
              }
              if (!isWorker && canUseWorker) {
                var code = ['var CONFETTI, SIZE = {}, module = {};', '(' + main.toString() + ')(this, module, true, SIZE);', 'onmessage = function(msg) {', '  if (msg.data.options) {', '    CONFETTI(msg.data.options).then(function () {', '      if (msg.data.callback) {', '        postMessage({ callback: msg.data.callback });', '      }', '    });', '  } else if (msg.data.reset) {', '    CONFETTI && CONFETTI.reset();', '  } else if (msg.data.resize) {', '    SIZE.width = msg.data.resize.width;', '    SIZE.height = msg.data.resize.height;', '  } else if (msg.data.canvas) {', '    SIZE.width = msg.data.canvas.width;', '    SIZE.height = msg.data.canvas.height;', '    CONFETTI = module.exports.create(msg.data.canvas);', '  }', '}'].join('\n');
                try {
                  worker = new Worker(URL.createObjectURL(new Blob([code])));
                } catch (e) {
                  // eslint-disable-next-line no-console
                  (typeof console === "undefined" ? "undefined" : _typeof2(console)) !== undefined && typeof console.warn === 'function' ? console.warn(' Could not load worker', e) : null;
                  return null;
                }
                decorate(worker);
              }
              return worker;
            };
          }();
          var defaults = {
            particleCount: 50,
            angle: 90,
            spread: 45,
            startVelocity: 45,
            decay: 0.9,
            gravity: 1,
            drift: 0,
            ticks: 200,
            x: 0.5,
            y: 0.5,
            shapes: ['square', 'circle'],
            zIndex: 100,
            colors: ['#26ccff', '#a25afd', '#ff5e7e', '#88ff5a', '#fcff42', '#ffa62d', '#ff36ff'],
            // probably should be true, but back-compat
            disableForReducedMotion: false,
            scalar: 1
          };
          function convert(val, transform) {
            return transform ? transform(val) : val;
          }
          function isOk(val) {
            return !(val === null || val === undefined);
          }
          function prop(options, name, transform) {
            return convert(options && isOk(options[name]) ? options[name] : defaults[name], transform);
          }
          function onlyPositiveInt(number) {
            return number < 0 ? 0 : Math.floor(number);
          }
          function randomInt(min, max) {
            // [min, max)
            return Math.floor(Math.random() * (max - min)) + min;
          }
          function toDecimal(str) {
            return parseInt(str, 16);
          }
          function colorsToRgb(colors) {
            return colors.map(hexToRgb);
          }
          function hexToRgb(str) {
            var val = String(str).replace(/[^0-9a-f]/gi, '');
            if (val.length < 6) {
              val = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];
            }
            return {
              r: toDecimal(val.substring(0, 2)),
              g: toDecimal(val.substring(2, 4)),
              b: toDecimal(val.substring(4, 6))
            };
          }
          function getOrigin(options) {
            var origin = prop(options, 'origin', Object);
            origin.x = prop(origin, 'x', Number);
            origin.y = prop(origin, 'y', Number);
            return origin;
          }
          function setCanvasWindowSize(canvas) {
            canvas.width = document.documentElement.clientWidth;
            canvas.height = document.documentElement.clientHeight;
          }
          function setCanvasRectSize(canvas) {
            var rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
          }
          function getCanvas(zIndex) {
            var canvas = document.createElement('canvas');
            canvas.style.position = 'fixed';
            canvas.style.top = '0px';
            canvas.style.left = '0px';
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = zIndex;
            return canvas;
          }
          function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {
            context.save();
            context.translate(x, y);
            context.rotate(rotation);
            context.scale(radiusX, radiusY);
            context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);
            context.restore();
          }
          function randomPhysics(opts) {
            var radAngle = opts.angle * (Math.PI / 180);
            var radSpread = opts.spread * (Math.PI / 180);
            return {
              x: opts.x,
              y: opts.y,
              wobble: Math.random() * 10,
              wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),
              velocity: opts.startVelocity * 0.5 + Math.random() * opts.startVelocity,
              angle2D: -radAngle + (0.5 * radSpread - Math.random() * radSpread),
              tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,
              color: opts.color,
              shape: opts.shape,
              tick: 0,
              totalTicks: opts.ticks,
              decay: opts.decay,
              drift: opts.drift,
              random: Math.random() + 2,
              tiltSin: 0,
              tiltCos: 0,
              wobbleX: 0,
              wobbleY: 0,
              gravity: opts.gravity * 3,
              ovalScalar: 0.6,
              scalar: opts.scalar,
              flat: opts.flat
            };
          }
          function updateFetti(context, fetti) {
            fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;
            fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;
            fetti.velocity *= fetti.decay;
            if (fetti.flat) {
              fetti.wobble = 0;
              fetti.wobbleX = fetti.x + 10 * fetti.scalar;
              fetti.wobbleY = fetti.y + 10 * fetti.scalar;
              fetti.tiltSin = 0;
              fetti.tiltCos = 0;
              fetti.random = 1;
            } else {
              fetti.wobble += fetti.wobbleSpeed;
              fetti.wobbleX = fetti.x + 10 * fetti.scalar * Math.cos(fetti.wobble);
              fetti.wobbleY = fetti.y + 10 * fetti.scalar * Math.sin(fetti.wobble);
              fetti.tiltAngle += 0.1;
              fetti.tiltSin = Math.sin(fetti.tiltAngle);
              fetti.tiltCos = Math.cos(fetti.tiltAngle);
              fetti.random = Math.random() + 2;
            }
            var progress = fetti.tick++ / fetti.totalTicks;
            var x1 = fetti.x + fetti.random * fetti.tiltCos;
            var y1 = fetti.y + fetti.random * fetti.tiltSin;
            var x2 = fetti.wobbleX + fetti.random * fetti.tiltCos;
            var y2 = fetti.wobbleY + fetti.random * fetti.tiltSin;
            context.fillStyle = 'rgba(' + fetti.color.r + ', ' + fetti.color.g + ', ' + fetti.color.b + ', ' + (1 - progress) + ')';
            context.beginPath();
            if (canUsePaths && fetti.shape.type === 'path' && typeof fetti.shape.path === 'string' && Array.isArray(fetti.shape.matrix)) {
              context.fill(transformPath2D(fetti.shape.path, fetti.shape.matrix, fetti.x, fetti.y, Math.abs(x2 - x1) * 0.1, Math.abs(y2 - y1) * 0.1, Math.PI / 10 * fetti.wobble));
            } else if (fetti.shape.type === 'bitmap') {
              var rotation = Math.PI / 10 * fetti.wobble;
              var scaleX = Math.abs(x2 - x1) * 0.1;
              var scaleY = Math.abs(y2 - y1) * 0.1;
              var width = fetti.shape.bitmap.width * fetti.scalar;
              var height = fetti.shape.bitmap.height * fetti.scalar;
              var matrix = new DOMMatrix([Math.cos(rotation) * scaleX, Math.sin(rotation) * scaleX, -Math.sin(rotation) * scaleY, Math.cos(rotation) * scaleY, fetti.x, fetti.y]);

              // apply the transform matrix from the confetti shape
              matrix.multiplySelf(new DOMMatrix(fetti.shape.matrix));
              var pattern = context.createPattern(bitmapMapper.transform(fetti.shape.bitmap), 'no-repeat');
              pattern.setTransform(matrix);
              context.globalAlpha = 1 - progress;
              context.fillStyle = pattern;
              context.fillRect(fetti.x - width / 2, fetti.y - height / 2, width, height);
              context.globalAlpha = 1;
            } else if (fetti.shape === 'circle') {
              context.ellipse ? context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) : ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);
            } else if (fetti.shape === 'star') {
              var rot = Math.PI / 2 * 3;
              var innerRadius = 4 * fetti.scalar;
              var outerRadius = 8 * fetti.scalar;
              var x = fetti.x;
              var y = fetti.y;
              var spikes = 5;
              var step = Math.PI / spikes;
              while (spikes--) {
                x = fetti.x + Math.cos(rot) * outerRadius;
                y = fetti.y + Math.sin(rot) * outerRadius;
                context.lineTo(x, y);
                rot += step;
                x = fetti.x + Math.cos(rot) * innerRadius;
                y = fetti.y + Math.sin(rot) * innerRadius;
                context.lineTo(x, y);
                rot += step;
              }
            } else {
              context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));
              context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));
              context.lineTo(Math.floor(x2), Math.floor(y2));
              context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));
            }
            context.closePath();
            context.fill();
            return fetti.tick < fetti.totalTicks;
          }
          function animate(canvas, fettis, resizer, size, done) {
            var animatingFettis = fettis.slice();
            var context = canvas.getContext('2d');
            var animationFrame;
            var destroy;
            var prom = promise(function (resolve) {
              function onDone() {
                animationFrame = destroy = null;
                context.clearRect(0, 0, size.width, size.height);
                bitmapMapper.clear();
                done();
                resolve();
              }
              function update() {
                if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {
                  size.width = canvas.width = workerSize.width;
                  size.height = canvas.height = workerSize.height;
                }
                if (!size.width && !size.height) {
                  resizer(canvas);
                  size.width = canvas.width;
                  size.height = canvas.height;
                }
                context.clearRect(0, 0, size.width, size.height);
                animatingFettis = animatingFettis.filter(function (fetti) {
                  return updateFetti(context, fetti);
                });
                if (animatingFettis.length) {
                  animationFrame = raf.frame(update);
                } else {
                  onDone();
                }
              }
              animationFrame = raf.frame(update);
              destroy = onDone;
            });
            return {
              addFettis: function addFettis(fettis) {
                animatingFettis = animatingFettis.concat(fettis);
                return prom;
              },
              canvas: canvas,
              promise: prom,
              reset: function reset() {
                if (animationFrame) {
                  raf.cancel(animationFrame);
                }
                if (destroy) {
                  destroy();
                }
              }
            };
          }
          function confettiCannon(canvas, globalOpts) {
            var isLibCanvas = !canvas;
            var allowResize = !!prop(globalOpts || {}, 'resize');
            var hasResizeEventRegistered = false;
            var globalDisableForReducedMotion = prop(globalOpts, 'disableForReducedMotion', Boolean);
            var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, 'useWorker');
            var worker = shouldUseWorker ? getWorker() : null;
            var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;
            var initialized = canvas && worker ? !!canvas.__confetti_initialized : false;
            var preferLessMotion = typeof matchMedia === 'function' && matchMedia('(prefers-reduced-motion)').matches;
            var animationObj;
            function fireLocal(options, size, done) {
              var particleCount = prop(options, 'particleCount', onlyPositiveInt);
              var angle = prop(options, 'angle', Number);
              var spread = prop(options, 'spread', Number);
              var startVelocity = prop(options, 'startVelocity', Number);
              var decay = prop(options, 'decay', Number);
              var gravity = prop(options, 'gravity', Number);
              var drift = prop(options, 'drift', Number);
              var colors = prop(options, 'colors', colorsToRgb);
              var ticks = prop(options, 'ticks', Number);
              var shapes = prop(options, 'shapes');
              var scalar = prop(options, 'scalar');
              var flat = !!prop(options, 'flat');
              var origin = getOrigin(options);
              var temp = particleCount;
              var fettis = [];
              var startX = canvas.width * origin.x;
              var startY = canvas.height * origin.y;
              while (temp--) {
                fettis.push(randomPhysics({
                  x: startX,
                  y: startY,
                  angle: angle,
                  spread: spread,
                  startVelocity: startVelocity,
                  color: colors[temp % colors.length],
                  shape: shapes[randomInt(0, shapes.length)],
                  ticks: ticks,
                  decay: decay,
                  gravity: gravity,
                  drift: drift,
                  scalar: scalar,
                  flat: flat
                }));
              }

              // if we have a previous canvas already animating,
              // add to it
              if (animationObj) {
                return animationObj.addFettis(fettis);
              }
              animationObj = animate(canvas, fettis, resizer, size, done);
              return animationObj.promise;
            }
            function fire(options) {
              var disableForReducedMotion = globalDisableForReducedMotion || prop(options, 'disableForReducedMotion', Boolean);
              var zIndex = prop(options, 'zIndex', Number);
              if (disableForReducedMotion && preferLessMotion) {
                return promise(function (resolve) {
                  resolve();
                });
              }
              if (isLibCanvas && animationObj) {
                // use existing canvas from in-progress animation
                canvas = animationObj.canvas;
              } else if (isLibCanvas && !canvas) {
                // create and initialize a new canvas
                canvas = getCanvas(zIndex);
                document.body.appendChild(canvas);
              }
              if (allowResize && !initialized) {
                // initialize the size of a user-supplied canvas
                resizer(canvas);
              }
              var size = {
                width: canvas.width,
                height: canvas.height
              };
              if (worker && !initialized) {
                worker.init(canvas);
              }
              initialized = true;
              if (worker) {
                canvas.__confetti_initialized = true;
              }
              function onResize() {
                if (worker) {
                  // TODO this really shouldn't be immediate, because it is expensive
                  var obj = {
                    getBoundingClientRect: function getBoundingClientRect() {
                      if (!isLibCanvas) {
                        return canvas.getBoundingClientRect();
                      }
                    }
                  };
                  resizer(obj);
                  worker.postMessage({
                    resize: {
                      width: obj.width,
                      height: obj.height
                    }
                  });
                  return;
                }

                // don't actually query the size here, since this
                // can execute frequently and rapidly
                size.width = size.height = null;
              }
              function done() {
                animationObj = null;
                if (allowResize) {
                  hasResizeEventRegistered = false;
                  global.removeEventListener('resize', onResize);
                }
                if (isLibCanvas && canvas) {
                  if (document.body.contains(canvas)) {
                    document.body.removeChild(canvas);
                  }
                  canvas = null;
                  initialized = false;
                }
              }
              if (allowResize && !hasResizeEventRegistered) {
                hasResizeEventRegistered = true;
                global.addEventListener('resize', onResize, false);
              }
              if (worker) {
                return worker.fire(options, size, done);
              }
              return fireLocal(options, size, done);
            }
            fire.reset = function () {
              if (worker) {
                worker.reset();
              }
              if (animationObj) {
                animationObj.reset();
              }
            };
            return fire;
          }

          // Make default export lazy to defer worker creation until called.
          var defaultFire;
          function getDefaultFire() {
            if (!defaultFire) {
              defaultFire = confettiCannon(null, {
                useWorker: true,
                resize: true
              });
            }
            return defaultFire;
          }
          function transformPath2D(pathString, pathMatrix, x, y, scaleX, scaleY, rotation) {
            var path2d = new Path2D(pathString);
            var t1 = new Path2D();
            t1.addPath(path2d, new DOMMatrix(pathMatrix));
            var t2 = new Path2D();
            // see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/DOMMatrix
            t2.addPath(t1, new DOMMatrix([Math.cos(rotation) * scaleX, Math.sin(rotation) * scaleX, -Math.sin(rotation) * scaleY, Math.cos(rotation) * scaleY, x, y]));
            return t2;
          }
          function shapeFromPath(pathData) {
            if (!canUsePaths) {
              throw new Error('path confetti are not supported in this browser');
            }
            var path, matrix;
            if (typeof pathData === 'string') {
              path = pathData;
            } else {
              path = pathData.path;
              matrix = pathData.matrix;
            }
            var path2d = new Path2D(path);
            var tempCanvas = document.createElement('canvas');
            var tempCtx = tempCanvas.getContext('2d');
            if (!matrix) {
              // attempt to figure out the width of the path, up to 1000x1000
              var maxSize = 1000;
              var minX = maxSize;
              var minY = maxSize;
              var maxX = 0;
              var maxY = 0;
              var width, height;

              // do some line skipping... this is faster than checking
              // every pixel and will be mostly still correct
              for (var x = 0; x < maxSize; x += 2) {
                for (var y = 0; y < maxSize; y += 2) {
                  if (tempCtx.isPointInPath(path2d, x, y, 'nonzero')) {
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                  }
                }
              }
              width = maxX - minX;
              height = maxY - minY;
              var maxDesiredSize = 10;
              var scale = Math.min(maxDesiredSize / width, maxDesiredSize / height);
              matrix = [scale, 0, 0, scale, -Math.round(width / 2 + minX) * scale, -Math.round(height / 2 + minY) * scale];
            }
            return {
              type: 'path',
              path: path,
              matrix: matrix
            };
          }
          function shapeFromText(textData) {
            var text,
              scalar = 1,
              color = '#000000',
              // see https://nolanlawson.com/2022/04/08/the-struggle-of-using-native-emoji-on-the-web/
              fontFamily = '"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", "EmojiOne Color", "Android Emoji", "Twemoji Mozilla", "system emoji", sans-serif';
            if (typeof textData === 'string') {
              text = textData;
            } else {
              text = textData.text;
              scalar = 'scalar' in textData ? textData.scalar : scalar;
              fontFamily = 'fontFamily' in textData ? textData.fontFamily : fontFamily;
              color = 'color' in textData ? textData.color : color;
            }

            // all other confetti are 10 pixels,
            // so this pixel size is the de-facto 100% scale confetti
            var fontSize = 10 * scalar;
            var font = '' + fontSize + 'px ' + fontFamily;
            var canvas = new OffscreenCanvas(fontSize, fontSize);
            var ctx = canvas.getContext('2d');
            ctx.font = font;
            var size = ctx.measureText(text);
            var width = Math.ceil(size.actualBoundingBoxRight + size.actualBoundingBoxLeft);
            var height = Math.ceil(size.actualBoundingBoxAscent + size.actualBoundingBoxDescent);
            var padding = 2;
            var x = size.actualBoundingBoxLeft + padding;
            var y = size.actualBoundingBoxAscent + padding;
            width += padding + padding;
            height += padding + padding;
            canvas = new OffscreenCanvas(width, height);
            ctx = canvas.getContext('2d');
            ctx.font = font;
            ctx.fillStyle = color;
            ctx.fillText(text, x, y);
            var scale = 1 / scalar;
            return {
              type: 'bitmap',
              // TODO these probably need to be transfered for workers
              bitmap: canvas.transferToImageBitmap(),
              matrix: [scale, 0, 0, scale, -width * scale / 2, -height * scale / 2]
            };
          }
          module.exports = function () {
            return getDefaultFire().apply(this, arguments);
          };
          module.exports.reset = function () {
            getDefaultFire().reset();
          };
          module.exports.create = confettiCannon;
          module.exports.shapeFromPath = shapeFromPath;
          module.exports.shapeFromText = shapeFromText;
        })(function () {
          if (typeof window !== 'undefined') {
            return window;
          }
          if (typeof self !== 'undefined') {
            return self;
          }
          return this || {};
        }(), module$1, false);

        // end source content

        var confetti = module$1.exports;
        module$1.exports.create;

        /**
         * @license
         * Copyright 2010-2024 Three.js Authors
         * SPDX-License-Identifier: MIT
         */
        var REVISION = '166';
        var MOUSE = {
          LEFT: 0,
          MIDDLE: 1,
          RIGHT: 2,
          ROTATE: 0,
          DOLLY: 1,
          PAN: 2
        };
        var TOUCH = {
          ROTATE: 0,
          PAN: 1,
          DOLLY_PAN: 2,
          DOLLY_ROTATE: 3
        };
        var CullFaceNone = 0;
        var CullFaceBack = 1;
        var CullFaceFront = 2;
        var CullFaceFrontBack = 3;
        var BasicShadowMap = 0;
        var PCFShadowMap = 1;
        var PCFSoftShadowMap = 2;
        var VSMShadowMap = 3;
        var FrontSide = 0;
        var BackSide = 1;
        var DoubleSide = 2;
        var NoBlending = 0;
        var NormalBlending = 1;
        var AdditiveBlending = 2;
        var SubtractiveBlending = 3;
        var MultiplyBlending = 4;
        var CustomBlending = 5;
        var AddEquation = 100;
        var SubtractEquation = 101;
        var ReverseSubtractEquation = 102;
        var MinEquation = 103;
        var MaxEquation = 104;
        var ZeroFactor = 200;
        var OneFactor = 201;
        var SrcColorFactor = 202;
        var OneMinusSrcColorFactor = 203;
        var SrcAlphaFactor = 204;
        var OneMinusSrcAlphaFactor = 205;
        var DstAlphaFactor = 206;
        var OneMinusDstAlphaFactor = 207;
        var DstColorFactor = 208;
        var OneMinusDstColorFactor = 209;
        var SrcAlphaSaturateFactor = 210;
        var ConstantColorFactor = 211;
        var OneMinusConstantColorFactor = 212;
        var ConstantAlphaFactor = 213;
        var OneMinusConstantAlphaFactor = 214;
        var NeverDepth = 0;
        var AlwaysDepth = 1;
        var LessDepth = 2;
        var LessEqualDepth = 3;
        var EqualDepth = 4;
        var GreaterEqualDepth = 5;
        var GreaterDepth = 6;
        var NotEqualDepth = 7;
        var MultiplyOperation = 0;
        var MixOperation = 1;
        var AddOperation = 2;
        var NoToneMapping = 0;
        var LinearToneMapping = 1;
        var ReinhardToneMapping = 2;
        var CineonToneMapping = 3;
        var ACESFilmicToneMapping = 4;
        var CustomToneMapping = 5;
        var AgXToneMapping = 6;
        var NeutralToneMapping = 7;
        var AttachedBindMode = 'attached';
        var DetachedBindMode = 'detached';
        var UVMapping = 300;
        var CubeReflectionMapping = 301;
        var CubeRefractionMapping = 302;
        var EquirectangularReflectionMapping = 303;
        var EquirectangularRefractionMapping = 304;
        var CubeUVReflectionMapping = 306;
        var RepeatWrapping = 1000;
        var ClampToEdgeWrapping = 1001;
        var MirroredRepeatWrapping = 1002;
        var NearestFilter = 1003;
        var NearestMipmapNearestFilter = 1004;
        var NearestMipMapNearestFilter = 1004;
        var NearestMipmapLinearFilter = 1005;
        var NearestMipMapLinearFilter = 1005;
        var LinearFilter = 1006;
        var LinearMipmapNearestFilter = 1007;
        var LinearMipMapNearestFilter = 1007;
        var LinearMipmapLinearFilter = 1008;
        var LinearMipMapLinearFilter = 1008;
        var UnsignedByteType = 1009;
        var ByteType = 1010;
        var ShortType = 1011;
        var UnsignedShortType = 1012;
        var IntType = 1013;
        var UnsignedIntType = 1014;
        var FloatType = 1015;
        var HalfFloatType = 1016;
        var UnsignedShort4444Type = 1017;
        var UnsignedShort5551Type = 1018;
        var UnsignedInt248Type = 1020;
        var UnsignedInt5999Type = 35902;
        var AlphaFormat = 1021;
        var RGBFormat = 1022;
        var RGBAFormat = 1023;
        var LuminanceFormat = 1024;
        var LuminanceAlphaFormat = 1025;
        var DepthFormat = 1026;
        var DepthStencilFormat = 1027;
        var RedFormat = 1028;
        var RedIntegerFormat = 1029;
        var RGFormat = 1030;
        var RGIntegerFormat = 1031;
        var RGBIntegerFormat = 1032;
        var RGBAIntegerFormat = 1033;
        var RGB_S3TC_DXT1_Format = 33776;
        var RGBA_S3TC_DXT1_Format = 33777;
        var RGBA_S3TC_DXT3_Format = 33778;
        var RGBA_S3TC_DXT5_Format = 33779;
        var RGB_PVRTC_4BPPV1_Format = 35840;
        var RGB_PVRTC_2BPPV1_Format = 35841;
        var RGBA_PVRTC_4BPPV1_Format = 35842;
        var RGBA_PVRTC_2BPPV1_Format = 35843;
        var RGB_ETC1_Format = 36196;
        var RGB_ETC2_Format = 37492;
        var RGBA_ETC2_EAC_Format = 37496;
        var RGBA_ASTC_4x4_Format = 37808;
        var RGBA_ASTC_5x4_Format = 37809;
        var RGBA_ASTC_5x5_Format = 37810;
        var RGBA_ASTC_6x5_Format = 37811;
        var RGBA_ASTC_6x6_Format = 37812;
        var RGBA_ASTC_8x5_Format = 37813;
        var RGBA_ASTC_8x6_Format = 37814;
        var RGBA_ASTC_8x8_Format = 37815;
        var RGBA_ASTC_10x5_Format = 37816;
        var RGBA_ASTC_10x6_Format = 37817;
        var RGBA_ASTC_10x8_Format = 37818;
        var RGBA_ASTC_10x10_Format = 37819;
        var RGBA_ASTC_12x10_Format = 37820;
        var RGBA_ASTC_12x12_Format = 37821;
        var RGBA_BPTC_Format = 36492;
        var RGB_BPTC_SIGNED_Format = 36494;
        var RGB_BPTC_UNSIGNED_Format = 36495;
        var RED_RGTC1_Format = 36283;
        var SIGNED_RED_RGTC1_Format = 36284;
        var RED_GREEN_RGTC2_Format = 36285;
        var SIGNED_RED_GREEN_RGTC2_Format = 36286;
        var LoopOnce = 2200;
        var LoopRepeat = 2201;
        var LoopPingPong = 2202;
        var InterpolateDiscrete = 2300;
        var InterpolateLinear = 2301;
        var InterpolateSmooth = 2302;
        var ZeroCurvatureEnding = 2400;
        var ZeroSlopeEnding = 2401;
        var WrapAroundEnding = 2402;
        var NormalAnimationBlendMode = 2500;
        var AdditiveAnimationBlendMode = 2501;
        var TrianglesDrawMode = 0;
        var TriangleStripDrawMode = 1;
        var TriangleFanDrawMode = 2;
        var BasicDepthPacking = 3200;
        var RGBADepthPacking = 3201;
        var TangentSpaceNormalMap = 0;
        var ObjectSpaceNormalMap = 1;

        // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
        var NoColorSpace = '';
        var SRGBColorSpace = 'srgb';
        var LinearSRGBColorSpace = 'srgb-linear';
        var DisplayP3ColorSpace = 'display-p3';
        var LinearDisplayP3ColorSpace = 'display-p3-linear';
        var LinearTransfer = 'linear';
        var SRGBTransfer = 'srgb';
        var Rec709Primaries = 'rec709';
        var P3Primaries = 'p3';
        var ZeroStencilOp = 0;
        var KeepStencilOp = 7680;
        var ReplaceStencilOp = 7681;
        var IncrementStencilOp = 7682;
        var DecrementStencilOp = 7683;
        var IncrementWrapStencilOp = 34055;
        var DecrementWrapStencilOp = 34056;
        var InvertStencilOp = 5386;
        var NeverStencilFunc = 512;
        var LessStencilFunc = 513;
        var EqualStencilFunc = 514;
        var LessEqualStencilFunc = 515;
        var GreaterStencilFunc = 516;
        var NotEqualStencilFunc = 517;
        var GreaterEqualStencilFunc = 518;
        var AlwaysStencilFunc = 519;
        var NeverCompare = 512;
        var LessCompare = 513;
        var EqualCompare = 514;
        var LessEqualCompare = 515;
        var GreaterCompare = 516;
        var NotEqualCompare = 517;
        var GreaterEqualCompare = 518;
        var AlwaysCompare = 519;
        var StaticDrawUsage = 35044;
        var DynamicDrawUsage = 35048;
        var StreamDrawUsage = 35040;
        var StaticReadUsage = 35045;
        var DynamicReadUsage = 35049;
        var StreamReadUsage = 35041;
        var StaticCopyUsage = 35046;
        var DynamicCopyUsage = 35050;
        var StreamCopyUsage = 35042;
        var GLSL1 = '100';
        var GLSL3 = '300 es';
        var WebGLCoordinateSystem = 2000;
        var WebGPUCoordinateSystem = 2001;

        /**
         * https://github.com/mrdoob/eventdispatcher.js/
         */
        var EventDispatcher = /*#__PURE__*/function () {
          function EventDispatcher() {
            _classCallCheck2(this, EventDispatcher);
          }
          return _createClass(EventDispatcher, [{
            key: "addEventListener",
            value: function addEventListener(type, listener) {
              if (this._listeners === undefined) this._listeners = {};
              var listeners = this._listeners;
              if (listeners[type] === undefined) {
                listeners[type] = [];
              }
              if (listeners[type].indexOf(listener) === -1) {
                listeners[type].push(listener);
              }
            }
          }, {
            key: "hasEventListener",
            value: function hasEventListener(type, listener) {
              if (this._listeners === undefined) return false;
              var listeners = this._listeners;
              return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
            }
          }, {
            key: "removeEventListener",
            value: function removeEventListener(type, listener) {
              if (this._listeners === undefined) return;
              var listeners = this._listeners;
              var listenerArray = listeners[type];
              if (listenerArray !== undefined) {
                var _index6 = listenerArray.indexOf(listener);
                if (_index6 !== -1) {
                  listenerArray.splice(_index6, 1);
                }
              }
            }
          }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {
              if (this._listeners === undefined) return;
              var listeners = this._listeners;
              var listenerArray = listeners[event.type];
              if (listenerArray !== undefined) {
                event.target = this;

                // Make a copy, in case listeners are removed while iterating.
                var array = listenerArray.slice(0);
                for (var i = 0, l = array.length; i < l; i++) {
                  array[i].call(this, event);
                }
                event.target = null;
              }
            }
          }]);
        }();
        var _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
        var _seed = 1234567;
        var DEG2RAD = Math.PI / 180;
        var RAD2DEG = 180 / Math.PI;

        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
        function generateUUID() {
          var d0 = Math.random() * 0xffffffff | 0;
          var d1 = Math.random() * 0xffffffff | 0;
          var d2 = Math.random() * 0xffffffff | 0;
          var d3 = Math.random() * 0xffffffff | 0;
          var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];

          // .toLowerCase() here flattens concatenated strings to save heap memory space.
          return uuid.toLowerCase();
        }
        function clamp(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }

        // compute euclidean modulo of m % n
        // https://en.wikipedia.org/wiki/Modulo_operation
        function euclideanModulo(n, m) {
          return (n % m + m) % m;
        }

        // Linear mapping from range <a1, a2> to range <b1, b2>
        function mapLinear(x, a1, a2, b1, b2) {
          return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        }

        // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
        function inverseLerp(x, y, value) {
          if (x !== y) {
            return (value - x) / (y - x);
          } else {
            return 0;
          }
        }

        // https://en.wikipedia.org/wiki/Linear_interpolation
        function lerp(x, y, t) {
          return (1 - t) * x + t * y;
        }

        // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
        function damp(x, y, lambda, dt) {
          return lerp(x, y, 1 - Math.exp(-lambda * dt));
        }

        // https://www.desmos.com/calculator/vcsjnyz7x4
        function pingpong(x) {
          var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
          return length - Math.abs(euclideanModulo(x, length * 2) - length);
        }

        // http://en.wikipedia.org/wiki/Smoothstep
        function smoothstep(x, min, max) {
          if (x <= min) return 0;
          if (x >= max) return 1;
          x = (x - min) / (max - min);
          return x * x * (3 - 2 * x);
        }
        function smootherstep(x, min, max) {
          if (x <= min) return 0;
          if (x >= max) return 1;
          x = (x - min) / (max - min);
          return x * x * x * (x * (x * 6 - 15) + 10);
        }

        // Random integer from <low, high> interval
        function randInt(low, high) {
          return low + Math.floor(Math.random() * (high - low + 1));
        }

        // Random float from <low, high> interval
        function randFloat(low, high) {
          return low + Math.random() * (high - low);
        }

        // Random float from <-range/2, range/2> interval
        function randFloatSpread(range) {
          return range * (0.5 - Math.random());
        }

        // Deterministic pseudo-random float in the interval [ 0, 1 ]
        function seededRandom(s) {
          if (s !== undefined) _seed = s;

          // Mulberry32 generator

          var t = _seed += 0x6D2B79F5;
          t = Math.imul(t ^ t >>> 15, t | 1);
          t ^= t + Math.imul(t ^ t >>> 7, t | 61);
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
        function degToRad(degrees) {
          return degrees * DEG2RAD;
        }
        function radToDeg(radians) {
          return radians * RAD2DEG;
        }
        function isPowerOfTwo(value) {
          return (value & value - 1) === 0 && value !== 0;
        }
        function ceilPowerOfTwo(value) {
          return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
        }
        function floorPowerOfTwo(value) {
          return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
        }
        function setQuaternionFromProperEuler(q, a, b, c, order) {
          // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

          // rotations are applied to the axes in the order specified by 'order'
          // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
          // angles are in radians

          var cos = Math.cos;
          var sin = Math.sin;
          var c2 = cos(b / 2);
          var s2 = sin(b / 2);
          var c13 = cos((a + c) / 2);
          var s13 = sin((a + c) / 2);
          var c1_3 = cos((a - c) / 2);
          var s1_3 = sin((a - c) / 2);
          var c3_1 = cos((c - a) / 2);
          var s3_1 = sin((c - a) / 2);
          switch (order) {
            case 'XYX':
              q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
              break;
            case 'YZY':
              q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
              break;
            case 'ZXZ':
              q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
              break;
            case 'XZX':
              q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
              break;
            case 'YXY':
              q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
              break;
            case 'ZYZ':
              q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
              break;
            default:
              console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
          }
        }
        function denormalize(value, array) {
          switch (array.constructor) {
            case Float32Array:
              return value;
            case Uint32Array:
              return value / 4294967295.0;
            case Uint16Array:
              return value / 65535.0;
            case Uint8Array:
              return value / 255.0;
            case Int32Array:
              return Math.max(value / 2147483647.0, -1.0);
            case Int16Array:
              return Math.max(value / 32767.0, -1.0);
            case Int8Array:
              return Math.max(value / 127.0, -1.0);
            default:
              throw new Error('Invalid component type.');
          }
        }
        function normalize(value, array) {
          switch (array.constructor) {
            case Float32Array:
              return value;
            case Uint32Array:
              return Math.round(value * 4294967295.0);
            case Uint16Array:
              return Math.round(value * 65535.0);
            case Uint8Array:
              return Math.round(value * 255.0);
            case Int32Array:
              return Math.round(value * 2147483647.0);
            case Int16Array:
              return Math.round(value * 32767.0);
            case Int8Array:
              return Math.round(value * 127.0);
            default:
              throw new Error('Invalid component type.');
          }
        }
        var MathUtils = {
          DEG2RAD: DEG2RAD,
          RAD2DEG: RAD2DEG,
          generateUUID: generateUUID,
          clamp: clamp,
          euclideanModulo: euclideanModulo,
          mapLinear: mapLinear,
          inverseLerp: inverseLerp,
          lerp: lerp,
          damp: damp,
          pingpong: pingpong,
          smoothstep: smoothstep,
          smootherstep: smootherstep,
          randInt: randInt,
          randFloat: randFloat,
          randFloatSpread: randFloatSpread,
          seededRandom: seededRandom,
          degToRad: degToRad,
          radToDeg: radToDeg,
          isPowerOfTwo: isPowerOfTwo,
          ceilPowerOfTwo: ceilPowerOfTwo,
          floorPowerOfTwo: floorPowerOfTwo,
          setQuaternionFromProperEuler: setQuaternionFromProperEuler,
          normalize: normalize,
          denormalize: denormalize
        };
        var Vector2 = /*#__PURE__*/function () {
          function Vector2() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            _classCallCheck2(this, Vector2);
            Vector2.prototype.isVector2 = true;
            this.x = x;
            this.y = y;
          }
          return _createClass(Vector2, [{
            key: "width",
            get: function get() {
              return this.x;
            },
            set: function set(value) {
              this.x = value;
            }
          }, {
            key: "height",
            get: function get() {
              return this.y;
            },
            set: function set(value) {
              this.y = value;
            }
          }, {
            key: "set",
            value: function set(x, y) {
              this.x = x;
              this.y = y;
              return this;
            }
          }, {
            key: "setScalar",
            value: function setScalar(scalar) {
              this.x = scalar;
              this.y = scalar;
              return this;
            }
          }, {
            key: "setX",
            value: function setX(x) {
              this.x = x;
              return this;
            }
          }, {
            key: "setY",
            value: function setY(y) {
              this.y = y;
              return this;
            }
          }, {
            key: "setComponent",
            value: function setComponent(index, value) {
              switch (index) {
                case 0:
                  this.x = value;
                  break;
                case 1:
                  this.y = value;
                  break;
                default:
                  throw new Error('index is out of range: ' + index);
              }
              return this;
            }
          }, {
            key: "getComponent",
            value: function getComponent(index) {
              switch (index) {
                case 0:
                  return this.x;
                case 1:
                  return this.y;
                default:
                  throw new Error('index is out of range: ' + index);
              }
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor(this.x, this.y);
            }
          }, {
            key: "copy",
            value: function copy(v) {
              this.x = v.x;
              this.y = v.y;
              return this;
            }
          }, {
            key: "add",
            value: function add(v) {
              this.x += v.x;
              this.y += v.y;
              return this;
            }
          }, {
            key: "addScalar",
            value: function addScalar(s) {
              this.x += s;
              this.y += s;
              return this;
            }
          }, {
            key: "addVectors",
            value: function addVectors(a, b) {
              this.x = a.x + b.x;
              this.y = a.y + b.y;
              return this;
            }
          }, {
            key: "addScaledVector",
            value: function addScaledVector(v, s) {
              this.x += v.x * s;
              this.y += v.y * s;
              return this;
            }
          }, {
            key: "sub",
            value: function sub(v) {
              this.x -= v.x;
              this.y -= v.y;
              return this;
            }
          }, {
            key: "subScalar",
            value: function subScalar(s) {
              this.x -= s;
              this.y -= s;
              return this;
            }
          }, {
            key: "subVectors",
            value: function subVectors(a, b) {
              this.x = a.x - b.x;
              this.y = a.y - b.y;
              return this;
            }
          }, {
            key: "multiply",
            value: function multiply(v) {
              this.x *= v.x;
              this.y *= v.y;
              return this;
            }
          }, {
            key: "multiplyScalar",
            value: function multiplyScalar(scalar) {
              this.x *= scalar;
              this.y *= scalar;
              return this;
            }
          }, {
            key: "divide",
            value: function divide(v) {
              this.x /= v.x;
              this.y /= v.y;
              return this;
            }
          }, {
            key: "divideScalar",
            value: function divideScalar(scalar) {
              return this.multiplyScalar(1 / scalar);
            }
          }, {
            key: "applyMatrix3",
            value: function applyMatrix3(m) {
              var x = this.x,
                y = this.y;
              var e = m.elements;
              this.x = e[0] * x + e[3] * y + e[6];
              this.y = e[1] * x + e[4] * y + e[7];
              return this;
            }
          }, {
            key: "min",
            value: function min(v) {
              this.x = Math.min(this.x, v.x);
              this.y = Math.min(this.y, v.y);
              return this;
            }
          }, {
            key: "max",
            value: function max(v) {
              this.x = Math.max(this.x, v.x);
              this.y = Math.max(this.y, v.y);
              return this;
            }
          }, {
            key: "clamp",
            value: function clamp(min, max) {
              // assumes min < max, componentwise

              this.x = Math.max(min.x, Math.min(max.x, this.x));
              this.y = Math.max(min.y, Math.min(max.y, this.y));
              return this;
            }
          }, {
            key: "clampScalar",
            value: function clampScalar(minVal, maxVal) {
              this.x = Math.max(minVal, Math.min(maxVal, this.x));
              this.y = Math.max(minVal, Math.min(maxVal, this.y));
              return this;
            }
          }, {
            key: "clampLength",
            value: function clampLength(min, max) {
              var length = this.length();
              return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
            }
          }, {
            key: "floor",
            value: function floor() {
              this.x = Math.floor(this.x);
              this.y = Math.floor(this.y);
              return this;
            }
          }, {
            key: "ceil",
            value: function ceil() {
              this.x = Math.ceil(this.x);
              this.y = Math.ceil(this.y);
              return this;
            }
          }, {
            key: "round",
            value: function round() {
              this.x = Math.round(this.x);
              this.y = Math.round(this.y);
              return this;
            }
          }, {
            key: "roundToZero",
            value: function roundToZero() {
              this.x = Math.trunc(this.x);
              this.y = Math.trunc(this.y);
              return this;
            }
          }, {
            key: "negate",
            value: function negate() {
              this.x = -this.x;
              this.y = -this.y;
              return this;
            }
          }, {
            key: "dot",
            value: function dot(v) {
              return this.x * v.x + this.y * v.y;
            }
          }, {
            key: "cross",
            value: function cross(v) {
              return this.x * v.y - this.y * v.x;
            }
          }, {
            key: "lengthSq",
            value: function lengthSq() {
              return this.x * this.x + this.y * this.y;
            }
          }, {
            key: "length",
            value: function length() {
              return Math.sqrt(this.x * this.x + this.y * this.y);
            }
          }, {
            key: "manhattanLength",
            value: function manhattanLength() {
              return Math.abs(this.x) + Math.abs(this.y);
            }
          }, {
            key: "normalize",
            value: function normalize() {
              return this.divideScalar(this.length() || 1);
            }
          }, {
            key: "angle",
            value: function angle() {
              // computes the angle in radians with respect to the positive x-axis

              var angle = Math.atan2(-this.y, -this.x) + Math.PI;
              return angle;
            }
          }, {
            key: "angleTo",
            value: function angleTo(v) {
              var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
              if (denominator === 0) return Math.PI / 2;
              var theta = this.dot(v) / denominator;

              // clamp, to handle numerical problems

              return Math.acos(clamp(theta, -1, 1));
            }
          }, {
            key: "distanceTo",
            value: function distanceTo(v) {
              return Math.sqrt(this.distanceToSquared(v));
            }
          }, {
            key: "distanceToSquared",
            value: function distanceToSquared(v) {
              var dx = this.x - v.x,
                dy = this.y - v.y;
              return dx * dx + dy * dy;
            }
          }, {
            key: "manhattanDistanceTo",
            value: function manhattanDistanceTo(v) {
              return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
            }
          }, {
            key: "setLength",
            value: function setLength(length) {
              return this.normalize().multiplyScalar(length);
            }
          }, {
            key: "lerp",
            value: function lerp(v, alpha) {
              this.x += (v.x - this.x) * alpha;
              this.y += (v.y - this.y) * alpha;
              return this;
            }
          }, {
            key: "lerpVectors",
            value: function lerpVectors(v1, v2, alpha) {
              this.x = v1.x + (v2.x - v1.x) * alpha;
              this.y = v1.y + (v2.y - v1.y) * alpha;
              return this;
            }
          }, {
            key: "equals",
            value: function equals(v) {
              return v.x === this.x && v.y === this.y;
            }
          }, {
            key: "fromArray",
            value: function fromArray(array) {
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              this.x = array[offset];
              this.y = array[offset + 1];
              return this;
            }
          }, {
            key: "toArray",
            value: function toArray() {
              var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              array[offset] = this.x;
              array[offset + 1] = this.y;
              return array;
            }
          }, {
            key: "fromBufferAttribute",
            value: function fromBufferAttribute(attribute, index) {
              this.x = attribute.getX(index);
              this.y = attribute.getY(index);
              return this;
            }
          }, {
            key: "rotateAround",
            value: function rotateAround(center, angle) {
              var c = Math.cos(angle),
                s = Math.sin(angle);
              var x = this.x - center.x;
              var y = this.y - center.y;
              this.x = x * c - y * s + center.x;
              this.y = x * s + y * c + center.y;
              return this;
            }
          }, {
            key: "random",
            value: function random() {
              this.x = Math.random();
              this.y = Math.random();
              return this;
            }
          }, {
            key: Symbol.iterator,
            value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
              return _regeneratorRuntime().wrap(function value$(_context8) {
                while (1) switch (_context8.prev = _context8.next) {
                  case 0:
                    _context8.next = 2;
                    return this.x;
                  case 2:
                    _context8.next = 4;
                    return this.y;
                  case 4:
                  case "end":
                    return _context8.stop();
                }
              }, value, this);
            })
          }]);
        }();
        var Matrix3 = /*#__PURE__*/function () {
          function Matrix3(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            _classCallCheck2(this, Matrix3);
            Matrix3.prototype.isMatrix3 = true;
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            if (n11 !== undefined) {
              this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
            }
          }
          return _createClass(Matrix3, [{
            key: "set",
            value: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
              var te = this.elements;
              te[0] = n11;
              te[1] = n21;
              te[2] = n31;
              te[3] = n12;
              te[4] = n22;
              te[5] = n32;
              te[6] = n13;
              te[7] = n23;
              te[8] = n33;
              return this;
            }
          }, {
            key: "identity",
            value: function identity() {
              this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
              return this;
            }
          }, {
            key: "copy",
            value: function copy(m) {
              var te = this.elements;
              var me = m.elements;
              te[0] = me[0];
              te[1] = me[1];
              te[2] = me[2];
              te[3] = me[3];
              te[4] = me[4];
              te[5] = me[5];
              te[6] = me[6];
              te[7] = me[7];
              te[8] = me[8];
              return this;
            }
          }, {
            key: "extractBasis",
            value: function extractBasis(xAxis, yAxis, zAxis) {
              xAxis.setFromMatrix3Column(this, 0);
              yAxis.setFromMatrix3Column(this, 1);
              zAxis.setFromMatrix3Column(this, 2);
              return this;
            }
          }, {
            key: "setFromMatrix4",
            value: function setFromMatrix4(m) {
              var me = m.elements;
              this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
              return this;
            }
          }, {
            key: "multiply",
            value: function multiply(m) {
              return this.multiplyMatrices(this, m);
            }
          }, {
            key: "premultiply",
            value: function premultiply(m) {
              return this.multiplyMatrices(m, this);
            }
          }, {
            key: "multiplyMatrices",
            value: function multiplyMatrices(a, b) {
              var ae = a.elements;
              var be = b.elements;
              var te = this.elements;
              var a11 = ae[0],
                a12 = ae[3],
                a13 = ae[6];
              var a21 = ae[1],
                a22 = ae[4],
                a23 = ae[7];
              var a31 = ae[2],
                a32 = ae[5],
                a33 = ae[8];
              var b11 = be[0],
                b12 = be[3],
                b13 = be[6];
              var b21 = be[1],
                b22 = be[4],
                b23 = be[7];
              var b31 = be[2],
                b32 = be[5],
                b33 = be[8];
              te[0] = a11 * b11 + a12 * b21 + a13 * b31;
              te[3] = a11 * b12 + a12 * b22 + a13 * b32;
              te[6] = a11 * b13 + a12 * b23 + a13 * b33;
              te[1] = a21 * b11 + a22 * b21 + a23 * b31;
              te[4] = a21 * b12 + a22 * b22 + a23 * b32;
              te[7] = a21 * b13 + a22 * b23 + a23 * b33;
              te[2] = a31 * b11 + a32 * b21 + a33 * b31;
              te[5] = a31 * b12 + a32 * b22 + a33 * b32;
              te[8] = a31 * b13 + a32 * b23 + a33 * b33;
              return this;
            }
          }, {
            key: "multiplyScalar",
            value: function multiplyScalar(s) {
              var te = this.elements;
              te[0] *= s;
              te[3] *= s;
              te[6] *= s;
              te[1] *= s;
              te[4] *= s;
              te[7] *= s;
              te[2] *= s;
              te[5] *= s;
              te[8] *= s;
              return this;
            }
          }, {
            key: "determinant",
            value: function determinant() {
              var te = this.elements;
              var a = te[0],
                b = te[1],
                c = te[2],
                d = te[3],
                e = te[4],
                f = te[5],
                g = te[6],
                h = te[7],
                i = te[8];
              return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
            }
          }, {
            key: "invert",
            value: function invert() {
              var te = this.elements,
                n11 = te[0],
                n21 = te[1],
                n31 = te[2],
                n12 = te[3],
                n22 = te[4],
                n32 = te[5],
                n13 = te[6],
                n23 = te[7],
                n33 = te[8],
                t11 = n33 * n22 - n32 * n23,
                t12 = n32 * n13 - n33 * n12,
                t13 = n23 * n12 - n22 * n13,
                det = n11 * t11 + n21 * t12 + n31 * t13;
              if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
              var detInv = 1 / det;
              te[0] = t11 * detInv;
              te[1] = (n31 * n23 - n33 * n21) * detInv;
              te[2] = (n32 * n21 - n31 * n22) * detInv;
              te[3] = t12 * detInv;
              te[4] = (n33 * n11 - n31 * n13) * detInv;
              te[5] = (n31 * n12 - n32 * n11) * detInv;
              te[6] = t13 * detInv;
              te[7] = (n21 * n13 - n23 * n11) * detInv;
              te[8] = (n22 * n11 - n21 * n12) * detInv;
              return this;
            }
          }, {
            key: "transpose",
            value: function transpose() {
              var tmp;
              var m = this.elements;
              tmp = m[1];
              m[1] = m[3];
              m[3] = tmp;
              tmp = m[2];
              m[2] = m[6];
              m[6] = tmp;
              tmp = m[5];
              m[5] = m[7];
              m[7] = tmp;
              return this;
            }
          }, {
            key: "getNormalMatrix",
            value: function getNormalMatrix(matrix4) {
              return this.setFromMatrix4(matrix4).invert().transpose();
            }
          }, {
            key: "transposeIntoArray",
            value: function transposeIntoArray(r) {
              var m = this.elements;
              r[0] = m[0];
              r[1] = m[3];
              r[2] = m[6];
              r[3] = m[1];
              r[4] = m[4];
              r[5] = m[7];
              r[6] = m[2];
              r[7] = m[5];
              r[8] = m[8];
              return this;
            }
          }, {
            key: "setUvTransform",
            value: function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
              var c = Math.cos(rotation);
              var s = Math.sin(rotation);
              this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
              return this;
            }

            //
          }, {
            key: "scale",
            value: function scale(sx, sy) {
              this.premultiply(_m3.makeScale(sx, sy));
              return this;
            }
          }, {
            key: "rotate",
            value: function rotate(theta) {
              this.premultiply(_m3.makeRotation(-theta));
              return this;
            }
          }, {
            key: "translate",
            value: function translate(tx, ty) {
              this.premultiply(_m3.makeTranslation(tx, ty));
              return this;
            }

            // for 2D Transforms
          }, {
            key: "makeTranslation",
            value: function makeTranslation(x, y) {
              if (x.isVector2) {
                this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
              } else {
                this.set(1, 0, x, 0, 1, y, 0, 0, 1);
              }
              return this;
            }
          }, {
            key: "makeRotation",
            value: function makeRotation(theta) {
              // counterclockwise

              var c = Math.cos(theta);
              var s = Math.sin(theta);
              this.set(c, -s, 0, s, c, 0, 0, 0, 1);
              return this;
            }
          }, {
            key: "makeScale",
            value: function makeScale(x, y) {
              this.set(x, 0, 0, 0, y, 0, 0, 0, 1);
              return this;
            }

            //
          }, {
            key: "equals",
            value: function equals(matrix) {
              var te = this.elements;
              var me = matrix.elements;
              for (var i = 0; i < 9; i++) {
                if (te[i] !== me[i]) return false;
              }
              return true;
            }
          }, {
            key: "fromArray",
            value: function fromArray(array) {
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              for (var i = 0; i < 9; i++) {
                this.elements[i] = array[i + offset];
              }
              return this;
            }
          }, {
            key: "toArray",
            value: function toArray() {
              var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var te = this.elements;
              array[offset] = te[0];
              array[offset + 1] = te[1];
              array[offset + 2] = te[2];
              array[offset + 3] = te[3];
              array[offset + 4] = te[4];
              array[offset + 5] = te[5];
              array[offset + 6] = te[6];
              array[offset + 7] = te[7];
              array[offset + 8] = te[8];
              return array;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().fromArray(this.elements);
            }
          }]);
        }();
        var _m3 = /*@__PURE__*/new Matrix3();
        function arrayNeedsUint32(array) {
          // assumes larger values usually on last

          for (var i = array.length - 1; i >= 0; --i) {
            if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
          }
          return false;
        }
        var TYPED_ARRAYS = {
          Int8Array: Int8Array,
          Uint8Array: Uint8Array,
          Uint8ClampedArray: Uint8ClampedArray,
          Int16Array: Int16Array,
          Uint16Array: Uint16Array,
          Int32Array: Int32Array,
          Uint32Array: Uint32Array,
          Float32Array: Float32Array,
          Float64Array: Float64Array
        };
        function getTypedArray(type, buffer) {
          return new TYPED_ARRAYS[type](buffer);
        }
        function createElementNS(name) {
          return document.createElementNS('http://www.w3.org/1999/xhtml', name);
        }
        function createCanvasElement() {
          var canvas = createElementNS('canvas');
          canvas.style.display = 'block';
          return canvas;
        }
        var _cache = {};
        function warnOnce(message) {
          if (message in _cache) return;
          _cache[message] = true;
          console.warn(message);
        }
        function probeAsync(gl, sync, interval) {
          return new Promise(function (resolve, reject) {
            function probe() {
              switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                case gl.WAIT_FAILED:
                  reject();
                  break;
                case gl.TIMEOUT_EXPIRED:
                  setTimeout(probe, interval);
                  break;
                default:
                  resolve();
              }
            }
            setTimeout(probe, interval);
          });
        }

        /**
         * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping
         * or clipping. Based on W3C specifications for sRGB and Display P3,
         * and ICC specifications for the D50 connection space. Values in/out
         * are _linear_ sRGB and _linear_ Display P3.
         *
         * Note that both sRGB and Display P3 use the sRGB transfer functions.
         *
         * Reference:
         * - http://www.russellcottrell.com/photo/matrixCalculator.htm
         */

        var LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/new Matrix3().set(0.8224621, 0.177538, 0.0, 0.0331941, 0.9668058, 0.0, 0.0170827, 0.0723974, 0.9105199);
        var LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/new Matrix3().set(1.2249401, -0.2249404, 0.0, -0.0420569, 1.0420571, 0.0, -0.0196376, -0.0786361, 1.0982735);

        /**
         * Defines supported color spaces by transfer function and primaries,
         * and provides conversions to/from the Linear-sRGB reference space.
         */
        var COLOR_SPACES = _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, LinearSRGBColorSpace, {
          transfer: LinearTransfer,
          primaries: Rec709Primaries,
          toReference: function toReference(color) {
            return color;
          },
          fromReference: function fromReference(color) {
            return color;
          }
        }), SRGBColorSpace, {
          transfer: SRGBTransfer,
          primaries: Rec709Primaries,
          toReference: function toReference(color) {
            return color.convertSRGBToLinear();
          },
          fromReference: function fromReference(color) {
            return color.convertLinearToSRGB();
          }
        }), LinearDisplayP3ColorSpace, {
          transfer: LinearTransfer,
          primaries: P3Primaries,
          toReference: function toReference(color) {
            return color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB);
          },
          fromReference: function fromReference(color) {
            return color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3);
          }
        }), DisplayP3ColorSpace, {
          transfer: SRGBTransfer,
          primaries: P3Primaries,
          toReference: function toReference(color) {
            return color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB);
          },
          fromReference: function fromReference(color) {
            return color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB();
          }
        });
        var SUPPORTED_WORKING_COLOR_SPACES = new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace]);
        var ColorManagement = {
          enabled: true,
          _workingColorSpace: LinearSRGBColorSpace,
          get workingColorSpace() {
            return this._workingColorSpace;
          },
          set workingColorSpace(colorSpace) {
            if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
              throw new Error("Unsupported working color space, \"".concat(colorSpace, "\"."));
            }
            this._workingColorSpace = colorSpace;
          },
          convert: function convert(color, sourceColorSpace, targetColorSpace) {
            if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
              return color;
            }
            var sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
            var targetFromReference = COLOR_SPACES[targetColorSpace].fromReference;
            return targetFromReference(sourceToReference(color));
          },
          fromWorkingColorSpace: function fromWorkingColorSpace(color, targetColorSpace) {
            return this.convert(color, this._workingColorSpace, targetColorSpace);
          },
          toWorkingColorSpace: function toWorkingColorSpace(color, sourceColorSpace) {
            return this.convert(color, sourceColorSpace, this._workingColorSpace);
          },
          getPrimaries: function getPrimaries(colorSpace) {
            return COLOR_SPACES[colorSpace].primaries;
          },
          getTransfer: function getTransfer(colorSpace) {
            if (colorSpace === NoColorSpace) return LinearTransfer;
            return COLOR_SPACES[colorSpace].transfer;
          }
        };
        function SRGBToLinear(c) {
          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
        }
        function LinearToSRGB(c) {
          return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
        }
        var _canvas;
        var ImageUtils = /*#__PURE__*/function () {
          function ImageUtils() {
            _classCallCheck2(this, ImageUtils);
          }
          return _createClass(ImageUtils, null, [{
            key: "getDataURL",
            value: function getDataURL(image) {
              if (/^data:/i.test(image.src)) {
                return image.src;
              }
              if (typeof HTMLCanvasElement === 'undefined') {
                return image.src;
              }
              var canvas;
              if (image instanceof HTMLCanvasElement) {
                canvas = image;
              } else {
                if (_canvas === undefined) _canvas = createElementNS('canvas');
                _canvas.width = image.width;
                _canvas.height = image.height;
                var context = _canvas.getContext('2d');
                if (image instanceof ImageData) {
                  context.putImageData(image, 0, 0);
                } else {
                  context.drawImage(image, 0, 0, image.width, image.height);
                }
                canvas = _canvas;
              }
              if (canvas.width > 2048 || canvas.height > 2048) {
                console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
                return canvas.toDataURL('image/jpeg', 0.6);
              } else {
                return canvas.toDataURL('image/png');
              }
            }
          }, {
            key: "sRGBToLinear",
            value: function sRGBToLinear(image) {
              if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
                var canvas = createElementNS('canvas');
                canvas.width = image.width;
                canvas.height = image.height;
                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, image.width, image.height);
                var imageData = context.getImageData(0, 0, image.width, image.height);
                var data = imageData.data;
                for (var i = 0; i < data.length; i++) {
                  data[i] = SRGBToLinear(data[i] / 255) * 255;
                }
                context.putImageData(imageData, 0, 0);
                return canvas;
              } else if (image.data) {
                var _data = image.data.slice(0);
                for (var _i10 = 0; _i10 < _data.length; _i10++) {
                  if (_data instanceof Uint8Array || _data instanceof Uint8ClampedArray) {
                    _data[_i10] = Math.floor(SRGBToLinear(_data[_i10] / 255) * 255);
                  } else {
                    // assuming float

                    _data[_i10] = SRGBToLinear(_data[_i10]);
                  }
                }
                return {
                  data: _data,
                  width: image.width,
                  height: image.height
                };
              } else {
                console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');
                return image;
              }
            }
          }]);
        }();
        var _sourceId = 0;
        var Source = /*#__PURE__*/function () {
          function Source() {
            var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            _classCallCheck2(this, Source);
            this.isSource = true;
            Object.defineProperty(this, 'id', {
              value: _sourceId++
            });
            this.uuid = generateUUID();
            this.data = data;
            this.dataReady = true;
            this.version = 0;
          }
          return _createClass(Source, [{
            key: "needsUpdate",
            set: function set(value) {
              if (value === true) this.version++;
            }
          }, {
            key: "toJSON",
            value: function toJSON(meta) {
              var isRootObject = meta === undefined || typeof meta === 'string';
              if (!isRootObject && meta.images[this.uuid] !== undefined) {
                return meta.images[this.uuid];
              }
              var output = {
                uuid: this.uuid,
                url: ''
              };
              var data = this.data;
              if (data !== null) {
                var url;
                if (Array.isArray(data)) {
                  // cube texture

                  url = [];
                  for (var i = 0, l = data.length; i < l; i++) {
                    if (data[i].isDataTexture) {
                      url.push(serializeImage(data[i].image));
                    } else {
                      url.push(serializeImage(data[i]));
                    }
                  }
                } else {
                  // texture

                  url = serializeImage(data);
                }
                output.url = url;
              }
              if (!isRootObject) {
                meta.images[this.uuid] = output;
              }
              return output;
            }
          }]);
        }();
        function serializeImage(image) {
          if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
            // default images

            return ImageUtils.getDataURL(image);
          } else {
            if (image.data) {
              // images of DataTexture

              return {
                data: Array.from(image.data),
                width: image.width,
                height: image.height,
                type: image.data.constructor.name
              };
            } else {
              console.warn('THREE.Texture: Unable to serialize Texture.');
              return {};
            }
          }
        }
        var _textureId = 0;
        var Texture = /*#__PURE__*/function (_EventDispatcher) {
          function Texture() {
            var _this15;
            var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Texture.DEFAULT_IMAGE;
            var mapping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Texture.DEFAULT_MAPPING;
            var wrapS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ClampToEdgeWrapping;
            var wrapT = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ClampToEdgeWrapping;
            var magFilter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : LinearFilter;
            var minFilter = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : LinearMipmapLinearFilter;
            var format = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : RGBAFormat;
            var type = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : UnsignedByteType;
            var anisotropy = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : Texture.DEFAULT_ANISOTROPY;
            var colorSpace = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : NoColorSpace;
            _classCallCheck2(this, Texture);
            _this15 = _callSuper(this, Texture);
            _this15.isTexture = true;
            Object.defineProperty(_this15, 'id', {
              value: _textureId++
            });
            _this15.uuid = generateUUID();
            _this15.name = '';
            _this15.source = new Source(image);
            _this15.mipmaps = [];
            _this15.mapping = mapping;
            _this15.channel = 0;
            _this15.wrapS = wrapS;
            _this15.wrapT = wrapT;
            _this15.magFilter = magFilter;
            _this15.minFilter = minFilter;
            _this15.anisotropy = anisotropy;
            _this15.format = format;
            _this15.internalFormat = null;
            _this15.type = type;
            _this15.offset = new Vector2(0, 0);
            _this15.repeat = new Vector2(1, 1);
            _this15.center = new Vector2(0, 0);
            _this15.rotation = 0;
            _this15.matrixAutoUpdate = true;
            _this15.matrix = new Matrix3();
            _this15.generateMipmaps = true;
            _this15.premultiplyAlpha = false;
            _this15.flipY = true;
            _this15.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

            _this15.colorSpace = colorSpace;
            _this15.userData = {};
            _this15.version = 0;
            _this15.onUpdate = null;
            _this15.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
            _this15.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)
            return _this15;
          }
          _inherits(Texture, _EventDispatcher);
          return _createClass(Texture, [{
            key: "image",
            get: function get() {
              return this.source.data;
            },
            set: function set() {
              var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
              this.source.data = value;
            }
          }, {
            key: "updateMatrix",
            value: function updateMatrix() {
              this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }, {
            key: "copy",
            value: function copy(source) {
              this.name = source.name;
              this.source = source.source;
              this.mipmaps = source.mipmaps.slice(0);
              this.mapping = source.mapping;
              this.channel = source.channel;
              this.wrapS = source.wrapS;
              this.wrapT = source.wrapT;
              this.magFilter = source.magFilter;
              this.minFilter = source.minFilter;
              this.anisotropy = source.anisotropy;
              this.format = source.format;
              this.internalFormat = source.internalFormat;
              this.type = source.type;
              this.offset.copy(source.offset);
              this.repeat.copy(source.repeat);
              this.center.copy(source.center);
              this.rotation = source.rotation;
              this.matrixAutoUpdate = source.matrixAutoUpdate;
              this.matrix.copy(source.matrix);
              this.generateMipmaps = source.generateMipmaps;
              this.premultiplyAlpha = source.premultiplyAlpha;
              this.flipY = source.flipY;
              this.unpackAlignment = source.unpackAlignment;
              this.colorSpace = source.colorSpace;
              this.userData = JSON.parse(JSON.stringify(source.userData));
              this.needsUpdate = true;
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON(meta) {
              var isRootObject = meta === undefined || typeof meta === 'string';
              if (!isRootObject && meta.textures[this.uuid] !== undefined) {
                return meta.textures[this.uuid];
              }
              var output = {
                metadata: {
                  version: 4.6,
                  type: 'Texture',
                  generator: 'Texture.toJSON'
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(meta).uuid,
                mapping: this.mapping,
                channel: this.channel,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                internalFormat: this.internalFormat,
                type: this.type,
                colorSpace: this.colorSpace,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                generateMipmaps: this.generateMipmaps,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
              };
              if (Object.keys(this.userData).length > 0) output.userData = this.userData;
              if (!isRootObject) {
                meta.textures[this.uuid] = output;
              }
              return output;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.dispatchEvent({
                type: 'dispose'
              });
            }
          }, {
            key: "transformUv",
            value: function transformUv(uv) {
              if (this.mapping !== UVMapping) return uv;
              uv.applyMatrix3(this.matrix);
              if (uv.x < 0 || uv.x > 1) {
                switch (this.wrapS) {
                  case RepeatWrapping:
                    uv.x = uv.x - Math.floor(uv.x);
                    break;
                  case ClampToEdgeWrapping:
                    uv.x = uv.x < 0 ? 0 : 1;
                    break;
                  case MirroredRepeatWrapping:
                    if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                      uv.x = Math.ceil(uv.x) - uv.x;
                    } else {
                      uv.x = uv.x - Math.floor(uv.x);
                    }
                    break;
                }
              }
              if (uv.y < 0 || uv.y > 1) {
                switch (this.wrapT) {
                  case RepeatWrapping:
                    uv.y = uv.y - Math.floor(uv.y);
                    break;
                  case ClampToEdgeWrapping:
                    uv.y = uv.y < 0 ? 0 : 1;
                    break;
                  case MirroredRepeatWrapping:
                    if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                      uv.y = Math.ceil(uv.y) - uv.y;
                    } else {
                      uv.y = uv.y - Math.floor(uv.y);
                    }
                    break;
                }
              }
              if (this.flipY) {
                uv.y = 1 - uv.y;
              }
              return uv;
            }
          }, {
            key: "needsUpdate",
            set: function set(value) {
              if (value === true) {
                this.version++;
                this.source.needsUpdate = true;
              }
            }
          }, {
            key: "needsPMREMUpdate",
            set: function set(value) {
              if (value === true) {
                this.pmremVersion++;
              }
            }
          }]);
        }(EventDispatcher);
        Texture.DEFAULT_IMAGE = null;
        Texture.DEFAULT_MAPPING = UVMapping;
        Texture.DEFAULT_ANISOTROPY = 1;
        var Vector4 = /*#__PURE__*/function () {
          function Vector4() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            _classCallCheck2(this, Vector4);
            Vector4.prototype.isVector4 = true;
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
          }
          return _createClass(Vector4, [{
            key: "width",
            get: function get() {
              return this.z;
            },
            set: function set(value) {
              this.z = value;
            }
          }, {
            key: "height",
            get: function get() {
              return this.w;
            },
            set: function set(value) {
              this.w = value;
            }
          }, {
            key: "set",
            value: function set(x, y, z, w) {
              this.x = x;
              this.y = y;
              this.z = z;
              this.w = w;
              return this;
            }
          }, {
            key: "setScalar",
            value: function setScalar(scalar) {
              this.x = scalar;
              this.y = scalar;
              this.z = scalar;
              this.w = scalar;
              return this;
            }
          }, {
            key: "setX",
            value: function setX(x) {
              this.x = x;
              return this;
            }
          }, {
            key: "setY",
            value: function setY(y) {
              this.y = y;
              return this;
            }
          }, {
            key: "setZ",
            value: function setZ(z) {
              this.z = z;
              return this;
            }
          }, {
            key: "setW",
            value: function setW(w) {
              this.w = w;
              return this;
            }
          }, {
            key: "setComponent",
            value: function setComponent(index, value) {
              switch (index) {
                case 0:
                  this.x = value;
                  break;
                case 1:
                  this.y = value;
                  break;
                case 2:
                  this.z = value;
                  break;
                case 3:
                  this.w = value;
                  break;
                default:
                  throw new Error('index is out of range: ' + index);
              }
              return this;
            }
          }, {
            key: "getComponent",
            value: function getComponent(index) {
              switch (index) {
                case 0:
                  return this.x;
                case 1:
                  return this.y;
                case 2:
                  return this.z;
                case 3:
                  return this.w;
                default:
                  throw new Error('index is out of range: ' + index);
              }
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor(this.x, this.y, this.z, this.w);
            }
          }, {
            key: "copy",
            value: function copy(v) {
              this.x = v.x;
              this.y = v.y;
              this.z = v.z;
              this.w = v.w !== undefined ? v.w : 1;
              return this;
            }
          }, {
            key: "add",
            value: function add(v) {
              this.x += v.x;
              this.y += v.y;
              this.z += v.z;
              this.w += v.w;
              return this;
            }
          }, {
            key: "addScalar",
            value: function addScalar(s) {
              this.x += s;
              this.y += s;
              this.z += s;
              this.w += s;
              return this;
            }
          }, {
            key: "addVectors",
            value: function addVectors(a, b) {
              this.x = a.x + b.x;
              this.y = a.y + b.y;
              this.z = a.z + b.z;
              this.w = a.w + b.w;
              return this;
            }
          }, {
            key: "addScaledVector",
            value: function addScaledVector(v, s) {
              this.x += v.x * s;
              this.y += v.y * s;
              this.z += v.z * s;
              this.w += v.w * s;
              return this;
            }
          }, {
            key: "sub",
            value: function sub(v) {
              this.x -= v.x;
              this.y -= v.y;
              this.z -= v.z;
              this.w -= v.w;
              return this;
            }
          }, {
            key: "subScalar",
            value: function subScalar(s) {
              this.x -= s;
              this.y -= s;
              this.z -= s;
              this.w -= s;
              return this;
            }
          }, {
            key: "subVectors",
            value: function subVectors(a, b) {
              this.x = a.x - b.x;
              this.y = a.y - b.y;
              this.z = a.z - b.z;
              this.w = a.w - b.w;
              return this;
            }
          }, {
            key: "multiply",
            value: function multiply(v) {
              this.x *= v.x;
              this.y *= v.y;
              this.z *= v.z;
              this.w *= v.w;
              return this;
            }
          }, {
            key: "multiplyScalar",
            value: function multiplyScalar(scalar) {
              this.x *= scalar;
              this.y *= scalar;
              this.z *= scalar;
              this.w *= scalar;
              return this;
            }
          }, {
            key: "applyMatrix4",
            value: function applyMatrix4(m) {
              var x = this.x,
                y = this.y,
                z = this.z,
                w = this.w;
              var e = m.elements;
              this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
              this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
              this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
              this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
              return this;
            }
          }, {
            key: "divideScalar",
            value: function divideScalar(scalar) {
              return this.multiplyScalar(1 / scalar);
            }
          }, {
            key: "setAxisAngleFromQuaternion",
            value: function setAxisAngleFromQuaternion(q) {
              // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

              // q is assumed to be normalized

              this.w = 2 * Math.acos(q.w);
              var s = Math.sqrt(1 - q.w * q.w);
              if (s < 0.0001) {
                this.x = 1;
                this.y = 0;
                this.z = 0;
              } else {
                this.x = q.x / s;
                this.y = q.y / s;
                this.z = q.z / s;
              }
              return this;
            }
          }, {
            key: "setAxisAngleFromRotationMatrix",
            value: function setAxisAngleFromRotationMatrix(m) {
              // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

              // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

              var angle, x, y, z; // variables for result
              var epsilon = 0.01,
                // margin to allow for rounding errors
                epsilon2 = 0.1,
                // margin to distinguish between 0 and 180 degrees

                te = m.elements,
                m11 = te[0],
                m12 = te[4],
                m13 = te[8],
                m21 = te[1],
                m22 = te[5],
                m23 = te[9],
                m31 = te[2],
                m32 = te[6],
                m33 = te[10];
              if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
                // singularity found
                // first check for identity matrix which must have +1 for all terms
                // in leading diagonal and zero in other terms

                if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                  // this singularity is identity matrix so angle = 0

                  this.set(1, 0, 0, 0);
                  return this; // zero angle, arbitrary axis
                }

                // otherwise this singularity is angle = 180

                angle = Math.PI;
                var xx = (m11 + 1) / 2;
                var yy = (m22 + 1) / 2;
                var zz = (m33 + 1) / 2;
                var xy = (m12 + m21) / 4;
                var xz = (m13 + m31) / 4;
                var yz = (m23 + m32) / 4;
                if (xx > yy && xx > zz) {
                  // m11 is the largest diagonal term

                  if (xx < epsilon) {
                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;
                  } else {
                    x = Math.sqrt(xx);
                    y = xy / x;
                    z = xz / x;
                  }
                } else if (yy > zz) {
                  // m22 is the largest diagonal term

                  if (yy < epsilon) {
                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;
                  } else {
                    y = Math.sqrt(yy);
                    x = xy / y;
                    z = yz / y;
                  }
                } else {
                  // m33 is the largest diagonal term so base result on this

                  if (zz < epsilon) {
                    x = 0.707106781;
                    y = 0.707106781;
                    z = 0;
                  } else {
                    z = Math.sqrt(zz);
                    x = xz / z;
                    y = yz / z;
                  }
                }
                this.set(x, y, z, angle);
                return this; // return 180 deg rotation
              }

              // as we have reached here there are no singularities so we can handle normally

              var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

              if (Math.abs(s) < 0.001) s = 1;

              // prevent divide by zero, should not happen if matrix is orthogonal and should be
              // caught by singularity test above, but I've left it in just in case

              this.x = (m32 - m23) / s;
              this.y = (m13 - m31) / s;
              this.z = (m21 - m12) / s;
              this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
              return this;
            }
          }, {
            key: "setFromMatrixPosition",
            value: function setFromMatrixPosition(m) {
              var e = m.elements;
              this.x = e[12];
              this.y = e[13];
              this.z = e[14];
              this.w = e[15];
              return this;
            }
          }, {
            key: "min",
            value: function min(v) {
              this.x = Math.min(this.x, v.x);
              this.y = Math.min(this.y, v.y);
              this.z = Math.min(this.z, v.z);
              this.w = Math.min(this.w, v.w);
              return this;
            }
          }, {
            key: "max",
            value: function max(v) {
              this.x = Math.max(this.x, v.x);
              this.y = Math.max(this.y, v.y);
              this.z = Math.max(this.z, v.z);
              this.w = Math.max(this.w, v.w);
              return this;
            }
          }, {
            key: "clamp",
            value: function clamp(min, max) {
              // assumes min < max, componentwise

              this.x = Math.max(min.x, Math.min(max.x, this.x));
              this.y = Math.max(min.y, Math.min(max.y, this.y));
              this.z = Math.max(min.z, Math.min(max.z, this.z));
              this.w = Math.max(min.w, Math.min(max.w, this.w));
              return this;
            }
          }, {
            key: "clampScalar",
            value: function clampScalar(minVal, maxVal) {
              this.x = Math.max(minVal, Math.min(maxVal, this.x));
              this.y = Math.max(minVal, Math.min(maxVal, this.y));
              this.z = Math.max(minVal, Math.min(maxVal, this.z));
              this.w = Math.max(minVal, Math.min(maxVal, this.w));
              return this;
            }
          }, {
            key: "clampLength",
            value: function clampLength(min, max) {
              var length = this.length();
              return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
            }
          }, {
            key: "floor",
            value: function floor() {
              this.x = Math.floor(this.x);
              this.y = Math.floor(this.y);
              this.z = Math.floor(this.z);
              this.w = Math.floor(this.w);
              return this;
            }
          }, {
            key: "ceil",
            value: function ceil() {
              this.x = Math.ceil(this.x);
              this.y = Math.ceil(this.y);
              this.z = Math.ceil(this.z);
              this.w = Math.ceil(this.w);
              return this;
            }
          }, {
            key: "round",
            value: function round() {
              this.x = Math.round(this.x);
              this.y = Math.round(this.y);
              this.z = Math.round(this.z);
              this.w = Math.round(this.w);
              return this;
            }
          }, {
            key: "roundToZero",
            value: function roundToZero() {
              this.x = Math.trunc(this.x);
              this.y = Math.trunc(this.y);
              this.z = Math.trunc(this.z);
              this.w = Math.trunc(this.w);
              return this;
            }
          }, {
            key: "negate",
            value: function negate() {
              this.x = -this.x;
              this.y = -this.y;
              this.z = -this.z;
              this.w = -this.w;
              return this;
            }
          }, {
            key: "dot",
            value: function dot(v) {
              return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
            }
          }, {
            key: "lengthSq",
            value: function lengthSq() {
              return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
          }, {
            key: "length",
            value: function length() {
              return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
          }, {
            key: "manhattanLength",
            value: function manhattanLength() {
              return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
            }
          }, {
            key: "normalize",
            value: function normalize() {
              return this.divideScalar(this.length() || 1);
            }
          }, {
            key: "setLength",
            value: function setLength(length) {
              return this.normalize().multiplyScalar(length);
            }
          }, {
            key: "lerp",
            value: function lerp(v, alpha) {
              this.x += (v.x - this.x) * alpha;
              this.y += (v.y - this.y) * alpha;
              this.z += (v.z - this.z) * alpha;
              this.w += (v.w - this.w) * alpha;
              return this;
            }
          }, {
            key: "lerpVectors",
            value: function lerpVectors(v1, v2, alpha) {
              this.x = v1.x + (v2.x - v1.x) * alpha;
              this.y = v1.y + (v2.y - v1.y) * alpha;
              this.z = v1.z + (v2.z - v1.z) * alpha;
              this.w = v1.w + (v2.w - v1.w) * alpha;
              return this;
            }
          }, {
            key: "equals",
            value: function equals(v) {
              return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
            }
          }, {
            key: "fromArray",
            value: function fromArray(array) {
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              this.x = array[offset];
              this.y = array[offset + 1];
              this.z = array[offset + 2];
              this.w = array[offset + 3];
              return this;
            }
          }, {
            key: "toArray",
            value: function toArray() {
              var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              array[offset] = this.x;
              array[offset + 1] = this.y;
              array[offset + 2] = this.z;
              array[offset + 3] = this.w;
              return array;
            }
          }, {
            key: "fromBufferAttribute",
            value: function fromBufferAttribute(attribute, index) {
              this.x = attribute.getX(index);
              this.y = attribute.getY(index);
              this.z = attribute.getZ(index);
              this.w = attribute.getW(index);
              return this;
            }
          }, {
            key: "random",
            value: function random() {
              this.x = Math.random();
              this.y = Math.random();
              this.z = Math.random();
              this.w = Math.random();
              return this;
            }
          }, {
            key: Symbol.iterator,
            value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
              return _regeneratorRuntime().wrap(function value$(_context9) {
                while (1) switch (_context9.prev = _context9.next) {
                  case 0:
                    _context9.next = 2;
                    return this.x;
                  case 2:
                    _context9.next = 4;
                    return this.y;
                  case 4:
                    _context9.next = 6;
                    return this.z;
                  case 6:
                    _context9.next = 8;
                    return this.w;
                  case 8:
                  case "end":
                    return _context9.stop();
                }
              }, value, this);
            })
          }]);
        }();
        /*
         In options, we can specify:
         * Texture parameters for an auto-generated target texture
         * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
        */
        var RenderTarget = /*#__PURE__*/function (_EventDispatcher2) {
          function RenderTarget() {
            var _this16;
            var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            _classCallCheck2(this, RenderTarget);
            _this16 = _callSuper(this, RenderTarget);
            _this16.isRenderTarget = true;
            _this16.width = width;
            _this16.height = height;
            _this16.depth = 1;
            _this16.scissor = new Vector4(0, 0, width, height);
            _this16.scissorTest = false;
            _this16.viewport = new Vector4(0, 0, width, height);
            var image = {
              width: width,
              height: height,
              depth: 1
            };
            options = Object.assign({
              generateMipmaps: false,
              internalFormat: null,
              minFilter: LinearFilter,
              depthBuffer: true,
              stencilBuffer: false,
              resolveDepthBuffer: true,
              resolveStencilBuffer: true,
              depthTexture: null,
              samples: 0,
              count: 1
            }, options);
            var texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
            texture.flipY = false;
            texture.generateMipmaps = options.generateMipmaps;
            texture.internalFormat = options.internalFormat;
            _this16.textures = [];
            var count = options.count;
            for (var i = 0; i < count; i++) {
              _this16.textures[i] = texture.clone();
              _this16.textures[i].isRenderTargetTexture = true;
            }
            _this16.depthBuffer = options.depthBuffer;
            _this16.stencilBuffer = options.stencilBuffer;
            _this16.resolveDepthBuffer = options.resolveDepthBuffer;
            _this16.resolveStencilBuffer = options.resolveStencilBuffer;
            _this16.depthTexture = options.depthTexture;
            _this16.samples = options.samples;
            return _this16;
          }
          _inherits(RenderTarget, _EventDispatcher2);
          return _createClass(RenderTarget, [{
            key: "texture",
            get: function get() {
              return this.textures[0];
            },
            set: function set(value) {
              this.textures[0] = value;
            }
          }, {
            key: "setSize",
            value: function setSize(width, height) {
              var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
              if (this.width !== width || this.height !== height || this.depth !== depth) {
                this.width = width;
                this.height = height;
                this.depth = depth;
                for (var i = 0, il = this.textures.length; i < il; i++) {
                  this.textures[i].image.width = width;
                  this.textures[i].image.height = height;
                  this.textures[i].image.depth = depth;
                }
                this.dispose();
              }
              this.viewport.set(0, 0, width, height);
              this.scissor.set(0, 0, width, height);
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }, {
            key: "copy",
            value: function copy(source) {
              this.width = source.width;
              this.height = source.height;
              this.depth = source.depth;
              this.scissor.copy(source.scissor);
              this.scissorTest = source.scissorTest;
              this.viewport.copy(source.viewport);
              this.textures.length = 0;
              for (var i = 0, il = source.textures.length; i < il; i++) {
                this.textures[i] = source.textures[i].clone();
                this.textures[i].isRenderTargetTexture = true;
              }

              // ensure image object is not shared, see #20328

              var image = Object.assign({}, source.texture.image);
              this.texture.source = new Source(image);
              this.depthBuffer = source.depthBuffer;
              this.stencilBuffer = source.stencilBuffer;
              this.resolveDepthBuffer = source.resolveDepthBuffer;
              this.resolveStencilBuffer = source.resolveStencilBuffer;
              if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
              this.samples = source.samples;
              return this;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.dispatchEvent({
                type: 'dispose'
              });
            }
          }]);
        }(EventDispatcher);
        var WebGLRenderTarget = /*#__PURE__*/function (_RenderTarget) {
          function WebGLRenderTarget() {
            var _this17;
            var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            _classCallCheck2(this, WebGLRenderTarget);
            _this17 = _callSuper(this, WebGLRenderTarget, [width, height, options]);
            _this17.isWebGLRenderTarget = true;
            return _this17;
          }
          _inherits(WebGLRenderTarget, _RenderTarget);
          return _createClass(WebGLRenderTarget);
        }(RenderTarget);
        var DataArrayTexture = /*#__PURE__*/function (_Texture) {
          function DataArrayTexture() {
            var _this18;
            var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            _classCallCheck2(this, DataArrayTexture);
            _this18 = _callSuper(this, DataArrayTexture, [null]);
            _this18.isDataArrayTexture = true;
            _this18.image = {
              data: data,
              width: width,
              height: height,
              depth: depth
            };
            _this18.magFilter = NearestFilter;
            _this18.minFilter = NearestFilter;
            _this18.wrapR = ClampToEdgeWrapping;
            _this18.generateMipmaps = false;
            _this18.flipY = false;
            _this18.unpackAlignment = 1;
            _this18.layerUpdates = new Set();
            return _this18;
          }
          _inherits(DataArrayTexture, _Texture);
          return _createClass(DataArrayTexture, [{
            key: "addLayerUpdate",
            value: function addLayerUpdate(layerIndex) {
              this.layerUpdates.add(layerIndex);
            }
          }, {
            key: "clearLayerUpdates",
            value: function clearLayerUpdates() {
              this.layerUpdates.clear();
            }
          }]);
        }(Texture);
        var WebGLArrayRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget) {
          function WebGLArrayRenderTarget() {
            var _this19;
            var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
            _classCallCheck2(this, WebGLArrayRenderTarget);
            _this19 = _callSuper(this, WebGLArrayRenderTarget, [width, height, options]);
            _this19.isWebGLArrayRenderTarget = true;
            _this19.depth = depth;
            _this19.texture = new DataArrayTexture(null, width, height, depth);
            _this19.texture.isRenderTargetTexture = true;
            return _this19;
          }
          _inherits(WebGLArrayRenderTarget, _WebGLRenderTarget);
          return _createClass(WebGLArrayRenderTarget);
        }(WebGLRenderTarget);
        var Data3DTexture = /*#__PURE__*/function (_Texture2) {
          function Data3DTexture() {
            var _this20;
            var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            _classCallCheck2(this, Data3DTexture);
            // We're going to add .setXXX() methods for setting properties later.
            // Users can still set in DataTexture3D directly.
            //
            //	const texture = new THREE.DataTexture3D( data, width, height, depth );
            // 	texture.anisotropy = 16;
            //
            // See #14839

            _this20 = _callSuper(this, Data3DTexture, [null]);
            _this20.isData3DTexture = true;
            _this20.image = {
              data: data,
              width: width,
              height: height,
              depth: depth
            };
            _this20.magFilter = NearestFilter;
            _this20.minFilter = NearestFilter;
            _this20.wrapR = ClampToEdgeWrapping;
            _this20.generateMipmaps = false;
            _this20.flipY = false;
            _this20.unpackAlignment = 1;
            return _this20;
          }
          _inherits(Data3DTexture, _Texture2);
          return _createClass(Data3DTexture);
        }(Texture);
        var WebGL3DRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget2) {
          function WebGL3DRenderTarget() {
            var _this21;
            var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
            _classCallCheck2(this, WebGL3DRenderTarget);
            _this21 = _callSuper(this, WebGL3DRenderTarget, [width, height, options]);
            _this21.isWebGL3DRenderTarget = true;
            _this21.depth = depth;
            _this21.texture = new Data3DTexture(null, width, height, depth);
            _this21.texture.isRenderTargetTexture = true;
            return _this21;
          }
          _inherits(WebGL3DRenderTarget, _WebGLRenderTarget2);
          return _createClass(WebGL3DRenderTarget);
        }(WebGLRenderTarget);
        var Quaternion = /*#__PURE__*/function () {
          function Quaternion() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            _classCallCheck2(this, Quaternion);
            this.isQuaternion = true;
            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;
          }
          return _createClass(Quaternion, [{
            key: "x",
            get: function get() {
              return this._x;
            },
            set: function set(value) {
              this._x = value;
              this._onChangeCallback();
            }
          }, {
            key: "y",
            get: function get() {
              return this._y;
            },
            set: function set(value) {
              this._y = value;
              this._onChangeCallback();
            }
          }, {
            key: "z",
            get: function get() {
              return this._z;
            },
            set: function set(value) {
              this._z = value;
              this._onChangeCallback();
            }
          }, {
            key: "w",
            get: function get() {
              return this._w;
            },
            set: function set(value) {
              this._w = value;
              this._onChangeCallback();
            }
          }, {
            key: "set",
            value: function set(x, y, z, w) {
              this._x = x;
              this._y = y;
              this._z = z;
              this._w = w;
              this._onChangeCallback();
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor(this._x, this._y, this._z, this._w);
            }
          }, {
            key: "copy",
            value: function copy(quaternion) {
              this._x = quaternion.x;
              this._y = quaternion.y;
              this._z = quaternion.z;
              this._w = quaternion.w;
              this._onChangeCallback();
              return this;
            }
          }, {
            key: "setFromEuler",
            value: function setFromEuler(euler) {
              var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
              var x = euler._x,
                y = euler._y,
                z = euler._z,
                order = euler._order;

              // http://www.mathworks.com/matlabcentral/fileexchange/
              // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
              //	content/SpinCalc.m

              var cos = Math.cos;
              var sin = Math.sin;
              var c1 = cos(x / 2);
              var c2 = cos(y / 2);
              var c3 = cos(z / 2);
              var s1 = sin(x / 2);
              var s2 = sin(y / 2);
              var s3 = sin(z / 2);
              switch (order) {
                case 'XYZ':
                  this._x = s1 * c2 * c3 + c1 * s2 * s3;
                  this._y = c1 * s2 * c3 - s1 * c2 * s3;
                  this._z = c1 * c2 * s3 + s1 * s2 * c3;
                  this._w = c1 * c2 * c3 - s1 * s2 * s3;
                  break;
                case 'YXZ':
                  this._x = s1 * c2 * c3 + c1 * s2 * s3;
                  this._y = c1 * s2 * c3 - s1 * c2 * s3;
                  this._z = c1 * c2 * s3 - s1 * s2 * c3;
                  this._w = c1 * c2 * c3 + s1 * s2 * s3;
                  break;
                case 'ZXY':
                  this._x = s1 * c2 * c3 - c1 * s2 * s3;
                  this._y = c1 * s2 * c3 + s1 * c2 * s3;
                  this._z = c1 * c2 * s3 + s1 * s2 * c3;
                  this._w = c1 * c2 * c3 - s1 * s2 * s3;
                  break;
                case 'ZYX':
                  this._x = s1 * c2 * c3 - c1 * s2 * s3;
                  this._y = c1 * s2 * c3 + s1 * c2 * s3;
                  this._z = c1 * c2 * s3 - s1 * s2 * c3;
                  this._w = c1 * c2 * c3 + s1 * s2 * s3;
                  break;
                case 'YZX':
                  this._x = s1 * c2 * c3 + c1 * s2 * s3;
                  this._y = c1 * s2 * c3 + s1 * c2 * s3;
                  this._z = c1 * c2 * s3 - s1 * s2 * c3;
                  this._w = c1 * c2 * c3 - s1 * s2 * s3;
                  break;
                case 'XZY':
                  this._x = s1 * c2 * c3 - c1 * s2 * s3;
                  this._y = c1 * s2 * c3 - s1 * c2 * s3;
                  this._z = c1 * c2 * s3 + s1 * s2 * c3;
                  this._w = c1 * c2 * c3 + s1 * s2 * s3;
                  break;
                default:
                  console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
              }
              if (update === true) this._onChangeCallback();
              return this;
            }
          }, {
            key: "setFromAxisAngle",
            value: function setFromAxisAngle(axis, angle) {
              // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

              // assumes axis is normalized

              var halfAngle = angle / 2,
                s = Math.sin(halfAngle);
              this._x = axis.x * s;
              this._y = axis.y * s;
              this._z = axis.z * s;
              this._w = Math.cos(halfAngle);
              this._onChangeCallback();
              return this;
            }
          }, {
            key: "setFromRotationMatrix",
            value: function setFromRotationMatrix(m) {
              // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

              // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

              var te = m.elements,
                m11 = te[0],
                m12 = te[4],
                m13 = te[8],
                m21 = te[1],
                m22 = te[5],
                m23 = te[9],
                m31 = te[2],
                m32 = te[6],
                m33 = te[10],
                trace = m11 + m22 + m33;
              if (trace > 0) {
                var s = 0.5 / Math.sqrt(trace + 1.0);
                this._w = 0.25 / s;
                this._x = (m32 - m23) * s;
                this._y = (m13 - m31) * s;
                this._z = (m21 - m12) * s;
              } else if (m11 > m22 && m11 > m33) {
                var _s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                this._w = (m32 - m23) / _s;
                this._x = 0.25 * _s;
                this._y = (m12 + m21) / _s;
                this._z = (m13 + m31) / _s;
              } else if (m22 > m33) {
                var _s2 = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                this._w = (m13 - m31) / _s2;
                this._x = (m12 + m21) / _s2;
                this._y = 0.25 * _s2;
                this._z = (m23 + m32) / _s2;
              } else {
                var _s3 = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                this._w = (m21 - m12) / _s3;
                this._x = (m13 + m31) / _s3;
                this._y = (m23 + m32) / _s3;
                this._z = 0.25 * _s3;
              }
              this._onChangeCallback();
              return this;
            }
          }, {
            key: "setFromUnitVectors",
            value: function setFromUnitVectors(vFrom, vTo) {
              // assumes direction vectors vFrom and vTo are normalized

              var r = vFrom.dot(vTo) + 1;
              if (r < Number.EPSILON) {
                // vFrom and vTo point in opposite directions

                r = 0;
                if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                  this._x = -vFrom.y;
                  this._y = vFrom.x;
                  this._z = 0;
                  this._w = r;
                } else {
                  this._x = 0;
                  this._y = -vFrom.z;
                  this._z = vFrom.y;
                  this._w = r;
                }
              } else {
                // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

                this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
                this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
                this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
                this._w = r;
              }
              return this.normalize();
            }
          }, {
            key: "angleTo",
            value: function angleTo(q) {
              return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
            }
          }, {
            key: "rotateTowards",
            value: function rotateTowards(q, step) {
              var angle = this.angleTo(q);
              if (angle === 0) return this;
              var t = Math.min(1, step / angle);
              this.slerp(q, t);
              return this;
            }
          }, {
            key: "identity",
            value: function identity() {
              return this.set(0, 0, 0, 1);
            }
          }, {
            key: "invert",
            value: function invert() {
              // quaternion is assumed to have unit length

              return this.conjugate();
            }
          }, {
            key: "conjugate",
            value: function conjugate() {
              this._x *= -1;
              this._y *= -1;
              this._z *= -1;
              this._onChangeCallback();
              return this;
            }
          }, {
            key: "dot",
            value: function dot(v) {
              return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
            }
          }, {
            key: "lengthSq",
            value: function lengthSq() {
              return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
            }
          }, {
            key: "length",
            value: function length() {
              return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
            }
          }, {
            key: "normalize",
            value: function normalize() {
              var l = this.length();
              if (l === 0) {
                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._w = 1;
              } else {
                l = 1 / l;
                this._x = this._x * l;
                this._y = this._y * l;
                this._z = this._z * l;
                this._w = this._w * l;
              }
              this._onChangeCallback();
              return this;
            }
          }, {
            key: "multiply",
            value: function multiply(q) {
              return this.multiplyQuaternions(this, q);
            }
          }, {
            key: "premultiply",
            value: function premultiply(q) {
              return this.multiplyQuaternions(q, this);
            }
          }, {
            key: "multiplyQuaternions",
            value: function multiplyQuaternions(a, b) {
              // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

              var qax = a._x,
                qay = a._y,
                qaz = a._z,
                qaw = a._w;
              var qbx = b._x,
                qby = b._y,
                qbz = b._z,
                qbw = b._w;
              this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
              this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
              this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
              this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
              this._onChangeCallback();
              return this;
            }
          }, {
            key: "slerp",
            value: function slerp(qb, t) {
              if (t === 0) return this;
              if (t === 1) return this.copy(qb);
              var x = this._x,
                y = this._y,
                z = this._z,
                w = this._w;

              // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

              var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
              if (cosHalfTheta < 0) {
                this._w = -qb._w;
                this._x = -qb._x;
                this._y = -qb._y;
                this._z = -qb._z;
                cosHalfTheta = -cosHalfTheta;
              } else {
                this.copy(qb);
              }
              if (cosHalfTheta >= 1.0) {
                this._w = w;
                this._x = x;
                this._y = y;
                this._z = z;
                return this;
              }
              var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
              if (sqrSinHalfTheta <= Number.EPSILON) {
                var s = 1 - t;
                this._w = s * w + t * this._w;
                this._x = s * x + t * this._x;
                this._y = s * y + t * this._y;
                this._z = s * z + t * this._z;
                this.normalize(); // normalize calls _onChangeCallback()

                return this;
              }
              var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
              var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
              var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
                ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
              this._w = w * ratioA + this._w * ratioB;
              this._x = x * ratioA + this._x * ratioB;
              this._y = y * ratioA + this._y * ratioB;
              this._z = z * ratioA + this._z * ratioB;
              this._onChangeCallback();
              return this;
            }
          }, {
            key: "slerpQuaternions",
            value: function slerpQuaternions(qa, qb, t) {
              return this.copy(qa).slerp(qb, t);
            }
          }, {
            key: "random",
            value: function random() {
              // sets this quaternion to a uniform random unit quaternnion

              // Ken Shoemake
              // Uniform random rotations
              // D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

              var theta1 = 2 * Math.PI * Math.random();
              var theta2 = 2 * Math.PI * Math.random();
              var x0 = Math.random();
              var r1 = Math.sqrt(1 - x0);
              var r2 = Math.sqrt(x0);
              return this.set(r1 * Math.sin(theta1), r1 * Math.cos(theta1), r2 * Math.sin(theta2), r2 * Math.cos(theta2));
            }
          }, {
            key: "equals",
            value: function equals(quaternion) {
              return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
            }
          }, {
            key: "fromArray",
            value: function fromArray(array) {
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              this._x = array[offset];
              this._y = array[offset + 1];
              this._z = array[offset + 2];
              this._w = array[offset + 3];
              this._onChangeCallback();
              return this;
            }
          }, {
            key: "toArray",
            value: function toArray() {
              var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              array[offset] = this._x;
              array[offset + 1] = this._y;
              array[offset + 2] = this._z;
              array[offset + 3] = this._w;
              return array;
            }
          }, {
            key: "fromBufferAttribute",
            value: function fromBufferAttribute(attribute, index) {
              this._x = attribute.getX(index);
              this._y = attribute.getY(index);
              this._z = attribute.getZ(index);
              this._w = attribute.getW(index);
              this._onChangeCallback();
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              return this.toArray();
            }
          }, {
            key: "_onChange",
            value: function _onChange(callback) {
              this._onChangeCallback = callback;
              return this;
            }
          }, {
            key: "_onChangeCallback",
            value: function _onChangeCallback() {}
          }, {
            key: Symbol.iterator,
            value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
              return _regeneratorRuntime().wrap(function value$(_context10) {
                while (1) switch (_context10.prev = _context10.next) {
                  case 0:
                    _context10.next = 2;
                    return this._x;
                  case 2:
                    _context10.next = 4;
                    return this._y;
                  case 4:
                    _context10.next = 6;
                    return this._z;
                  case 6:
                    _context10.next = 8;
                    return this._w;
                  case 8:
                  case "end":
                    return _context10.stop();
                }
              }, value, this);
            })
          }], [{
            key: "slerpFlat",
            value: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
              // fuzz-free, array-based Quaternion SLERP operation

              var x0 = src0[srcOffset0 + 0],
                y0 = src0[srcOffset0 + 1],
                z0 = src0[srcOffset0 + 2],
                w0 = src0[srcOffset0 + 3];
              var x1 = src1[srcOffset1 + 0],
                y1 = src1[srcOffset1 + 1],
                z1 = src1[srcOffset1 + 2],
                w1 = src1[srcOffset1 + 3];
              if (t === 0) {
                dst[dstOffset + 0] = x0;
                dst[dstOffset + 1] = y0;
                dst[dstOffset + 2] = z0;
                dst[dstOffset + 3] = w0;
                return;
              }
              if (t === 1) {
                dst[dstOffset + 0] = x1;
                dst[dstOffset + 1] = y1;
                dst[dstOffset + 2] = z1;
                dst[dstOffset + 3] = w1;
                return;
              }
              if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                var s = 1 - t;
                var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
                  dir = cos >= 0 ? 1 : -1,
                  sqrSin = 1 - cos * cos;

                // Skip the Slerp for tiny steps to avoid numeric problems:
                if (sqrSin > Number.EPSILON) {
                  var sin = Math.sqrt(sqrSin),
                    len = Math.atan2(sin, cos * dir);
                  s = Math.sin(s * len) / sin;
                  t = Math.sin(t * len) / sin;
                }
                var tDir = t * dir;
                x0 = x0 * s + x1 * tDir;
                y0 = y0 * s + y1 * tDir;
                z0 = z0 * s + z1 * tDir;
                w0 = w0 * s + w1 * tDir;

                // Normalize in case we just did a lerp:
                if (s === 1 - t) {
                  var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                  x0 *= f;
                  y0 *= f;
                  z0 *= f;
                  w0 *= f;
                }
              }
              dst[dstOffset] = x0;
              dst[dstOffset + 1] = y0;
              dst[dstOffset + 2] = z0;
              dst[dstOffset + 3] = w0;
            }
          }, {
            key: "multiplyQuaternionsFlat",
            value: function multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
              var x0 = src0[srcOffset0];
              var y0 = src0[srcOffset0 + 1];
              var z0 = src0[srcOffset0 + 2];
              var w0 = src0[srcOffset0 + 3];
              var x1 = src1[srcOffset1];
              var y1 = src1[srcOffset1 + 1];
              var z1 = src1[srcOffset1 + 2];
              var w1 = src1[srcOffset1 + 3];
              dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
              dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
              dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
              dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
              return dst;
            }
          }]);
        }();
        var Vector3 = /*#__PURE__*/function () {
          function Vector3() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            _classCallCheck2(this, Vector3);
            Vector3.prototype.isVector3 = true;
            this.x = x;
            this.y = y;
            this.z = z;
          }
          return _createClass(Vector3, [{
            key: "set",
            value: function set(x, y, z) {
              if (z === undefined) z = this.z; // sprite.scale.set(x,y)

              this.x = x;
              this.y = y;
              this.z = z;
              return this;
            }
          }, {
            key: "setScalar",
            value: function setScalar(scalar) {
              this.x = scalar;
              this.y = scalar;
              this.z = scalar;
              return this;
            }
          }, {
            key: "setX",
            value: function setX(x) {
              this.x = x;
              return this;
            }
          }, {
            key: "setY",
            value: function setY(y) {
              this.y = y;
              return this;
            }
          }, {
            key: "setZ",
            value: function setZ(z) {
              this.z = z;
              return this;
            }
          }, {
            key: "setComponent",
            value: function setComponent(index, value) {
              switch (index) {
                case 0:
                  this.x = value;
                  break;
                case 1:
                  this.y = value;
                  break;
                case 2:
                  this.z = value;
                  break;
                default:
                  throw new Error('index is out of range: ' + index);
              }
              return this;
            }
          }, {
            key: "getComponent",
            value: function getComponent(index) {
              switch (index) {
                case 0:
                  return this.x;
                case 1:
                  return this.y;
                case 2:
                  return this.z;
                default:
                  throw new Error('index is out of range: ' + index);
              }
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor(this.x, this.y, this.z);
            }
          }, {
            key: "copy",
            value: function copy(v) {
              this.x = v.x;
              this.y = v.y;
              this.z = v.z;
              return this;
            }
          }, {
            key: "add",
            value: function add(v) {
              this.x += v.x;
              this.y += v.y;
              this.z += v.z;
              return this;
            }
          }, {
            key: "addScalar",
            value: function addScalar(s) {
              this.x += s;
              this.y += s;
              this.z += s;
              return this;
            }
          }, {
            key: "addVectors",
            value: function addVectors(a, b) {
              this.x = a.x + b.x;
              this.y = a.y + b.y;
              this.z = a.z + b.z;
              return this;
            }
          }, {
            key: "addScaledVector",
            value: function addScaledVector(v, s) {
              this.x += v.x * s;
              this.y += v.y * s;
              this.z += v.z * s;
              return this;
            }
          }, {
            key: "sub",
            value: function sub(v) {
              this.x -= v.x;
              this.y -= v.y;
              this.z -= v.z;
              return this;
            }
          }, {
            key: "subScalar",
            value: function subScalar(s) {
              this.x -= s;
              this.y -= s;
              this.z -= s;
              return this;
            }
          }, {
            key: "subVectors",
            value: function subVectors(a, b) {
              this.x = a.x - b.x;
              this.y = a.y - b.y;
              this.z = a.z - b.z;
              return this;
            }
          }, {
            key: "multiply",
            value: function multiply(v) {
              this.x *= v.x;
              this.y *= v.y;
              this.z *= v.z;
              return this;
            }
          }, {
            key: "multiplyScalar",
            value: function multiplyScalar(scalar) {
              this.x *= scalar;
              this.y *= scalar;
              this.z *= scalar;
              return this;
            }
          }, {
            key: "multiplyVectors",
            value: function multiplyVectors(a, b) {
              this.x = a.x * b.x;
              this.y = a.y * b.y;
              this.z = a.z * b.z;
              return this;
            }
          }, {
            key: "applyEuler",
            value: function applyEuler(euler) {
              return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
            }
          }, {
            key: "applyAxisAngle",
            value: function applyAxisAngle(axis, angle) {
              return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
            }
          }, {
            key: "applyMatrix3",
            value: function applyMatrix3(m) {
              var x = this.x,
                y = this.y,
                z = this.z;
              var e = m.elements;
              this.x = e[0] * x + e[3] * y + e[6] * z;
              this.y = e[1] * x + e[4] * y + e[7] * z;
              this.z = e[2] * x + e[5] * y + e[8] * z;
              return this;
            }
          }, {
            key: "applyNormalMatrix",
            value: function applyNormalMatrix(m) {
              return this.applyMatrix3(m).normalize();
            }
          }, {
            key: "applyMatrix4",
            value: function applyMatrix4(m) {
              var x = this.x,
                y = this.y,
                z = this.z;
              var e = m.elements;
              var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
              this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
              this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
              this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
              return this;
            }
          }, {
            key: "applyQuaternion",
            value: function applyQuaternion(q) {
              // quaternion q is assumed to have unit length

              var vx = this.x,
                vy = this.y,
                vz = this.z;
              var qx = q.x,
                qy = q.y,
                qz = q.z,
                qw = q.w;

              // t = 2 * cross( q.xyz, v );
              var tx = 2 * (qy * vz - qz * vy);
              var ty = 2 * (qz * vx - qx * vz);
              var tz = 2 * (qx * vy - qy * vx);

              // v + q.w * t + cross( q.xyz, t );
              this.x = vx + qw * tx + qy * tz - qz * ty;
              this.y = vy + qw * ty + qz * tx - qx * tz;
              this.z = vz + qw * tz + qx * ty - qy * tx;
              return this;
            }
          }, {
            key: "project",
            value: function project(camera) {
              return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
            }
          }, {
            key: "unproject",
            value: function unproject(camera) {
              return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
            }
          }, {
            key: "transformDirection",
            value: function transformDirection(m) {
              // input: THREE.Matrix4 affine matrix
              // vector interpreted as a direction

              var x = this.x,
                y = this.y,
                z = this.z;
              var e = m.elements;
              this.x = e[0] * x + e[4] * y + e[8] * z;
              this.y = e[1] * x + e[5] * y + e[9] * z;
              this.z = e[2] * x + e[6] * y + e[10] * z;
              return this.normalize();
            }
          }, {
            key: "divide",
            value: function divide(v) {
              this.x /= v.x;
              this.y /= v.y;
              this.z /= v.z;
              return this;
            }
          }, {
            key: "divideScalar",
            value: function divideScalar(scalar) {
              return this.multiplyScalar(1 / scalar);
            }
          }, {
            key: "min",
            value: function min(v) {
              this.x = Math.min(this.x, v.x);
              this.y = Math.min(this.y, v.y);
              this.z = Math.min(this.z, v.z);
              return this;
            }
          }, {
            key: "max",
            value: function max(v) {
              this.x = Math.max(this.x, v.x);
              this.y = Math.max(this.y, v.y);
              this.z = Math.max(this.z, v.z);
              return this;
            }
          }, {
            key: "clamp",
            value: function clamp(min, max) {
              // assumes min < max, componentwise

              this.x = Math.max(min.x, Math.min(max.x, this.x));
              this.y = Math.max(min.y, Math.min(max.y, this.y));
              this.z = Math.max(min.z, Math.min(max.z, this.z));
              return this;
            }
          }, {
            key: "clampScalar",
            value: function clampScalar(minVal, maxVal) {
              this.x = Math.max(minVal, Math.min(maxVal, this.x));
              this.y = Math.max(minVal, Math.min(maxVal, this.y));
              this.z = Math.max(minVal, Math.min(maxVal, this.z));
              return this;
            }
          }, {
            key: "clampLength",
            value: function clampLength(min, max) {
              var length = this.length();
              return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
            }
          }, {
            key: "floor",
            value: function floor() {
              this.x = Math.floor(this.x);
              this.y = Math.floor(this.y);
              this.z = Math.floor(this.z);
              return this;
            }
          }, {
            key: "ceil",
            value: function ceil() {
              this.x = Math.ceil(this.x);
              this.y = Math.ceil(this.y);
              this.z = Math.ceil(this.z);
              return this;
            }
          }, {
            key: "round",
            value: function round() {
              this.x = Math.round(this.x);
              this.y = Math.round(this.y);
              this.z = Math.round(this.z);
              return this;
            }
          }, {
            key: "roundToZero",
            value: function roundToZero() {
              this.x = Math.trunc(this.x);
              this.y = Math.trunc(this.y);
              this.z = Math.trunc(this.z);
              return this;
            }
          }, {
            key: "negate",
            value: function negate() {
              this.x = -this.x;
              this.y = -this.y;
              this.z = -this.z;
              return this;
            }
          }, {
            key: "dot",
            value: function dot(v) {
              return this.x * v.x + this.y * v.y + this.z * v.z;
            }

            // TODO lengthSquared?
          }, {
            key: "lengthSq",
            value: function lengthSq() {
              return this.x * this.x + this.y * this.y + this.z * this.z;
            }
          }, {
            key: "length",
            value: function length() {
              return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }
          }, {
            key: "manhattanLength",
            value: function manhattanLength() {
              return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
            }
          }, {
            key: "normalize",
            value: function normalize() {
              return this.divideScalar(this.length() || 1);
            }
          }, {
            key: "setLength",
            value: function setLength(length) {
              return this.normalize().multiplyScalar(length);
            }
          }, {
            key: "lerp",
            value: function lerp(v, alpha) {
              this.x += (v.x - this.x) * alpha;
              this.y += (v.y - this.y) * alpha;
              this.z += (v.z - this.z) * alpha;
              return this;
            }
          }, {
            key: "lerpVectors",
            value: function lerpVectors(v1, v2, alpha) {
              this.x = v1.x + (v2.x - v1.x) * alpha;
              this.y = v1.y + (v2.y - v1.y) * alpha;
              this.z = v1.z + (v2.z - v1.z) * alpha;
              return this;
            }
          }, {
            key: "cross",
            value: function cross(v) {
              return this.crossVectors(this, v);
            }
          }, {
            key: "crossVectors",
            value: function crossVectors(a, b) {
              var ax = a.x,
                ay = a.y,
                az = a.z;
              var bx = b.x,
                by = b.y,
                bz = b.z;
              this.x = ay * bz - az * by;
              this.y = az * bx - ax * bz;
              this.z = ax * by - ay * bx;
              return this;
            }
          }, {
            key: "projectOnVector",
            value: function projectOnVector(v) {
              var denominator = v.lengthSq();
              if (denominator === 0) return this.set(0, 0, 0);
              var scalar = v.dot(this) / denominator;
              return this.copy(v).multiplyScalar(scalar);
            }
          }, {
            key: "projectOnPlane",
            value: function projectOnPlane(planeNormal) {
              _vector$c.copy(this).projectOnVector(planeNormal);
              return this.sub(_vector$c);
            }
          }, {
            key: "reflect",
            value: function reflect(normal) {
              // reflect incident vector off plane orthogonal to normal
              // normal is assumed to have unit length

              return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
            }
          }, {
            key: "angleTo",
            value: function angleTo(v) {
              var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
              if (denominator === 0) return Math.PI / 2;
              var theta = this.dot(v) / denominator;

              // clamp, to handle numerical problems

              return Math.acos(clamp(theta, -1, 1));
            }
          }, {
            key: "distanceTo",
            value: function distanceTo(v) {
              return Math.sqrt(this.distanceToSquared(v));
            }
          }, {
            key: "distanceToSquared",
            value: function distanceToSquared(v) {
              var dx = this.x - v.x,
                dy = this.y - v.y,
                dz = this.z - v.z;
              return dx * dx + dy * dy + dz * dz;
            }
          }, {
            key: "manhattanDistanceTo",
            value: function manhattanDistanceTo(v) {
              return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
            }
          }, {
            key: "setFromSpherical",
            value: function setFromSpherical(s) {
              return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
            }
          }, {
            key: "setFromSphericalCoords",
            value: function setFromSphericalCoords(radius, phi, theta) {
              var sinPhiRadius = Math.sin(phi) * radius;
              this.x = sinPhiRadius * Math.sin(theta);
              this.y = Math.cos(phi) * radius;
              this.z = sinPhiRadius * Math.cos(theta);
              return this;
            }
          }, {
            key: "setFromCylindrical",
            value: function setFromCylindrical(c) {
              return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
            }
          }, {
            key: "setFromCylindricalCoords",
            value: function setFromCylindricalCoords(radius, theta, y) {
              this.x = radius * Math.sin(theta);
              this.y = y;
              this.z = radius * Math.cos(theta);
              return this;
            }
          }, {
            key: "setFromMatrixPosition",
            value: function setFromMatrixPosition(m) {
              var e = m.elements;
              this.x = e[12];
              this.y = e[13];
              this.z = e[14];
              return this;
            }
          }, {
            key: "setFromMatrixScale",
            value: function setFromMatrixScale(m) {
              var sx = this.setFromMatrixColumn(m, 0).length();
              var sy = this.setFromMatrixColumn(m, 1).length();
              var sz = this.setFromMatrixColumn(m, 2).length();
              this.x = sx;
              this.y = sy;
              this.z = sz;
              return this;
            }
          }, {
            key: "setFromMatrixColumn",
            value: function setFromMatrixColumn(m, index) {
              return this.fromArray(m.elements, index * 4);
            }
          }, {
            key: "setFromMatrix3Column",
            value: function setFromMatrix3Column(m, index) {
              return this.fromArray(m.elements, index * 3);
            }
          }, {
            key: "setFromEuler",
            value: function setFromEuler(e) {
              this.x = e._x;
              this.y = e._y;
              this.z = e._z;
              return this;
            }
          }, {
            key: "setFromColor",
            value: function setFromColor(c) {
              this.x = c.r;
              this.y = c.g;
              this.z = c.b;
              return this;
            }
          }, {
            key: "equals",
            value: function equals(v) {
              return v.x === this.x && v.y === this.y && v.z === this.z;
            }
          }, {
            key: "fromArray",
            value: function fromArray(array) {
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              this.x = array[offset];
              this.y = array[offset + 1];
              this.z = array[offset + 2];
              return this;
            }
          }, {
            key: "toArray",
            value: function toArray() {
              var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              array[offset] = this.x;
              array[offset + 1] = this.y;
              array[offset + 2] = this.z;
              return array;
            }
          }, {
            key: "fromBufferAttribute",
            value: function fromBufferAttribute(attribute, index) {
              this.x = attribute.getX(index);
              this.y = attribute.getY(index);
              this.z = attribute.getZ(index);
              return this;
            }
          }, {
            key: "random",
            value: function random() {
              this.x = Math.random();
              this.y = Math.random();
              this.z = Math.random();
              return this;
            }
          }, {
            key: "randomDirection",
            value: function randomDirection() {
              // https://mathworld.wolfram.com/SpherePointPicking.html

              var theta = Math.random() * Math.PI * 2;
              var u = Math.random() * 2 - 1;
              var c = Math.sqrt(1 - u * u);
              this.x = c * Math.cos(theta);
              this.y = u;
              this.z = c * Math.sin(theta);
              return this;
            }
          }, {
            key: Symbol.iterator,
            value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
              return _regeneratorRuntime().wrap(function value$(_context11) {
                while (1) switch (_context11.prev = _context11.next) {
                  case 0:
                    _context11.next = 2;
                    return this.x;
                  case 2:
                    _context11.next = 4;
                    return this.y;
                  case 4:
                    _context11.next = 6;
                    return this.z;
                  case 6:
                  case "end":
                    return _context11.stop();
                }
              }, value, this);
            })
          }]);
        }();
        var _vector$c = /*@__PURE__*/new Vector3();
        var _quaternion$4 = /*@__PURE__*/new Quaternion();
        var Box3 = /*#__PURE__*/function () {
          function Box3() {
            var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(+Infinity, +Infinity, +Infinity);
            var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(-Infinity, -Infinity, -Infinity);
            _classCallCheck2(this, Box3);
            this.isBox3 = true;
            this.min = min;
            this.max = max;
          }
          return _createClass(Box3, [{
            key: "set",
            value: function set(min, max) {
              this.min.copy(min);
              this.max.copy(max);
              return this;
            }
          }, {
            key: "setFromArray",
            value: function setFromArray(array) {
              this.makeEmpty();
              for (var i = 0, il = array.length; i < il; i += 3) {
                this.expandByPoint(_vector$b.fromArray(array, i));
              }
              return this;
            }
          }, {
            key: "setFromBufferAttribute",
            value: function setFromBufferAttribute(attribute) {
              this.makeEmpty();
              for (var i = 0, il = attribute.count; i < il; i++) {
                this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));
              }
              return this;
            }
          }, {
            key: "setFromPoints",
            value: function setFromPoints(points) {
              this.makeEmpty();
              for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
              }
              return this;
            }
          }, {
            key: "setFromCenterAndSize",
            value: function setFromCenterAndSize(center, size) {
              var halfSize = _vector$b.copy(size).multiplyScalar(0.5);
              this.min.copy(center).sub(halfSize);
              this.max.copy(center).add(halfSize);
              return this;
            }
          }, {
            key: "setFromObject",
            value: function setFromObject(object) {
              var precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              this.makeEmpty();
              return this.expandByObject(object, precise);
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }, {
            key: "copy",
            value: function copy(box) {
              this.min.copy(box.min);
              this.max.copy(box.max);
              return this;
            }
          }, {
            key: "makeEmpty",
            value: function makeEmpty() {
              this.min.x = this.min.y = this.min.z = +Infinity;
              this.max.x = this.max.y = this.max.z = -Infinity;
              return this;
            }
          }, {
            key: "isEmpty",
            value: function isEmpty() {
              // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

              return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
            }
          }, {
            key: "getCenter",
            value: function getCenter(target) {
              return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
            }
          }, {
            key: "getSize",
            value: function getSize(target) {
              return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
            }
          }, {
            key: "expandByPoint",
            value: function expandByPoint(point) {
              this.min.min(point);
              this.max.max(point);
              return this;
            }
          }, {
            key: "expandByVector",
            value: function expandByVector(vector) {
              this.min.sub(vector);
              this.max.add(vector);
              return this;
            }
          }, {
            key: "expandByScalar",
            value: function expandByScalar(scalar) {
              this.min.addScalar(-scalar);
              this.max.addScalar(scalar);
              return this;
            }
          }, {
            key: "expandByObject",
            value: function expandByObject(object) {
              var precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              // Computes the world-axis-aligned bounding box of an object (including its children),
              // accounting for both the object's, and children's, world transforms

              object.updateWorldMatrix(false, false);
              var geometry = object.geometry;
              if (geometry !== undefined) {
                var positionAttribute = geometry.getAttribute('position');

                // precise AABB computation based on vertex data requires at least a position attribute.
                // instancing isn't supported so far and uses the normal (conservative) code path.

                if (precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true) {
                  for (var i = 0, l = positionAttribute.count; i < l; i++) {
                    if (object.isMesh === true) {
                      object.getVertexPosition(i, _vector$b);
                    } else {
                      _vector$b.fromBufferAttribute(positionAttribute, i);
                    }
                    _vector$b.applyMatrix4(object.matrixWorld);
                    this.expandByPoint(_vector$b);
                  }
                } else {
                  if (object.boundingBox !== undefined) {
                    // object-level bounding box

                    if (object.boundingBox === null) {
                      object.computeBoundingBox();
                    }
                    _box$4.copy(object.boundingBox);
                  } else {
                    // geometry-level bounding box

                    if (geometry.boundingBox === null) {
                      geometry.computeBoundingBox();
                    }
                    _box$4.copy(geometry.boundingBox);
                  }
                  _box$4.applyMatrix4(object.matrixWorld);
                  this.union(_box$4);
                }
              }
              var children = object.children;
              for (var _i11 = 0, _l2 = children.length; _i11 < _l2; _i11++) {
                this.expandByObject(children[_i11], precise);
              }
              return this;
            }
          }, {
            key: "containsPoint",
            value: function containsPoint(point) {
              return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
            }
          }, {
            key: "containsBox",
            value: function containsBox(box) {
              return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
            }
          }, {
            key: "getParameter",
            value: function getParameter(point, target) {
              // This can potentially have a divide by zero if the box
              // has a size dimension of 0.

              return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
            }
          }, {
            key: "intersectsBox",
            value: function intersectsBox(box) {
              // using 6 splitting planes to rule out intersections.
              return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
            }
          }, {
            key: "intersectsSphere",
            value: function intersectsSphere(sphere) {
              // Find the point on the AABB closest to the sphere center.
              this.clampPoint(sphere.center, _vector$b);

              // If that point is inside the sphere, the AABB and sphere intersect.
              return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
            }
          }, {
            key: "intersectsPlane",
            value: function intersectsPlane(plane) {
              // We compute the minimum and maximum dot product values. If those values
              // are on the same side (back or front) of the plane, then there is no intersection.

              var min, max;
              if (plane.normal.x > 0) {
                min = plane.normal.x * this.min.x;
                max = plane.normal.x * this.max.x;
              } else {
                min = plane.normal.x * this.max.x;
                max = plane.normal.x * this.min.x;
              }
              if (plane.normal.y > 0) {
                min += plane.normal.y * this.min.y;
                max += plane.normal.y * this.max.y;
              } else {
                min += plane.normal.y * this.max.y;
                max += plane.normal.y * this.min.y;
              }
              if (plane.normal.z > 0) {
                min += plane.normal.z * this.min.z;
                max += plane.normal.z * this.max.z;
              } else {
                min += plane.normal.z * this.max.z;
                max += plane.normal.z * this.min.z;
              }
              return min <= -plane.constant && max >= -plane.constant;
            }
          }, {
            key: "intersectsTriangle",
            value: function intersectsTriangle(triangle) {
              if (this.isEmpty()) {
                return false;
              }

              // compute box center and extents
              this.getCenter(_center);
              _extents.subVectors(this.max, _center);

              // translate triangle to aabb origin
              _v0$2.subVectors(triangle.a, _center);
              _v1$7.subVectors(triangle.b, _center);
              _v2$4.subVectors(triangle.c, _center);

              // compute edge vectors for triangle
              _f0.subVectors(_v1$7, _v0$2);
              _f1.subVectors(_v2$4, _v1$7);
              _f2.subVectors(_v0$2, _v2$4);

              // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
              // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
              // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
              var axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
              if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
                return false;
              }

              // test 3 face normals from the aabb
              axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
              if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
                return false;
              }

              // finally testing the face normal of the triangle
              // use already existing triangle edge vectors here
              _triangleNormal.crossVectors(_f0, _f1);
              axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
              return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
            }
          }, {
            key: "clampPoint",
            value: function clampPoint(point, target) {
              return target.copy(point).clamp(this.min, this.max);
            }
          }, {
            key: "distanceToPoint",
            value: function distanceToPoint(point) {
              return this.clampPoint(point, _vector$b).distanceTo(point);
            }
          }, {
            key: "getBoundingSphere",
            value: function getBoundingSphere(target) {
              if (this.isEmpty()) {
                target.makeEmpty();
              } else {
                this.getCenter(target.center);
                target.radius = this.getSize(_vector$b).length() * 0.5;
              }
              return target;
            }
          }, {
            key: "intersect",
            value: function intersect(box) {
              this.min.max(box.min);
              this.max.min(box.max);

              // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
              if (this.isEmpty()) this.makeEmpty();
              return this;
            }
          }, {
            key: "union",
            value: function union(box) {
              this.min.min(box.min);
              this.max.max(box.max);
              return this;
            }
          }, {
            key: "applyMatrix4",
            value: function applyMatrix4(matrix) {
              // transform of empty box is an empty box.
              if (this.isEmpty()) return this;

              // NOTE: I am using a binary pattern to specify all 2^3 combinations below
              _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
              _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
              _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
              _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
              _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
              _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
              _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
              _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

              this.setFromPoints(_points);
              return this;
            }
          }, {
            key: "translate",
            value: function translate(offset) {
              this.min.add(offset);
              this.max.add(offset);
              return this;
            }
          }, {
            key: "equals",
            value: function equals(box) {
              return box.min.equals(this.min) && box.max.equals(this.max);
            }
          }]);
        }();
        var _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];
        var _vector$b = /*@__PURE__*/new Vector3();
        var _box$4 = /*@__PURE__*/new Box3();

        // triangle centered vertices

        var _v0$2 = /*@__PURE__*/new Vector3();
        var _v1$7 = /*@__PURE__*/new Vector3();
        var _v2$4 = /*@__PURE__*/new Vector3();

        // triangle edge vectors

        var _f0 = /*@__PURE__*/new Vector3();
        var _f1 = /*@__PURE__*/new Vector3();
        var _f2 = /*@__PURE__*/new Vector3();
        var _center = /*@__PURE__*/new Vector3();
        var _extents = /*@__PURE__*/new Vector3();
        var _triangleNormal = /*@__PURE__*/new Vector3();
        var _testAxis = /*@__PURE__*/new Vector3();
        function satForAxes(axes, v0, v1, v2, extents) {
          for (var i = 0, j = axes.length - 3; i <= j; i += 3) {
            _testAxis.fromArray(axes, i);
            // project the aabb onto the separating axis
            var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
            // project all 3 vertices of the triangle onto the separating axis
            var p0 = v0.dot(_testAxis);
            var p1 = v1.dot(_testAxis);
            var p2 = v2.dot(_testAxis);
            // actual test, basically see if either of the most extreme of the triangle points intersects r
            if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
              // points of the projected triangle are outside the projected half-length of the aabb
              // the axis is separating and we can exit
              return false;
            }
          }
          return true;
        }
        var _box$3 = /*@__PURE__*/new Box3();
        var _v1$6 = /*@__PURE__*/new Vector3();
        var _v2$3 = /*@__PURE__*/new Vector3();
        var Sphere = /*#__PURE__*/function () {
          function Sphere() {
            var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
            var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
            _classCallCheck2(this, Sphere);
            this.isSphere = true;
            this.center = center;
            this.radius = radius;
          }
          return _createClass(Sphere, [{
            key: "set",
            value: function set(center, radius) {
              this.center.copy(center);
              this.radius = radius;
              return this;
            }
          }, {
            key: "setFromPoints",
            value: function setFromPoints(points, optionalCenter) {
              var center = this.center;
              if (optionalCenter !== undefined) {
                center.copy(optionalCenter);
              } else {
                _box$3.setFromPoints(points).getCenter(center);
              }
              var maxRadiusSq = 0;
              for (var i = 0, il = points.length; i < il; i++) {
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
              }
              this.radius = Math.sqrt(maxRadiusSq);
              return this;
            }
          }, {
            key: "copy",
            value: function copy(sphere) {
              this.center.copy(sphere.center);
              this.radius = sphere.radius;
              return this;
            }
          }, {
            key: "isEmpty",
            value: function isEmpty() {
              return this.radius < 0;
            }
          }, {
            key: "makeEmpty",
            value: function makeEmpty() {
              this.center.set(0, 0, 0);
              this.radius = -1;
              return this;
            }
          }, {
            key: "containsPoint",
            value: function containsPoint(point) {
              return point.distanceToSquared(this.center) <= this.radius * this.radius;
            }
          }, {
            key: "distanceToPoint",
            value: function distanceToPoint(point) {
              return point.distanceTo(this.center) - this.radius;
            }
          }, {
            key: "intersectsSphere",
            value: function intersectsSphere(sphere) {
              var radiusSum = this.radius + sphere.radius;
              return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
            }
          }, {
            key: "intersectsBox",
            value: function intersectsBox(box) {
              return box.intersectsSphere(this);
            }
          }, {
            key: "intersectsPlane",
            value: function intersectsPlane(plane) {
              return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
            }
          }, {
            key: "clampPoint",
            value: function clampPoint(point, target) {
              var deltaLengthSq = this.center.distanceToSquared(point);
              target.copy(point);
              if (deltaLengthSq > this.radius * this.radius) {
                target.sub(this.center).normalize();
                target.multiplyScalar(this.radius).add(this.center);
              }
              return target;
            }
          }, {
            key: "getBoundingBox",
            value: function getBoundingBox(target) {
              if (this.isEmpty()) {
                // Empty sphere produces empty bounding box
                target.makeEmpty();
                return target;
              }
              target.set(this.center, this.center);
              target.expandByScalar(this.radius);
              return target;
            }
          }, {
            key: "applyMatrix4",
            value: function applyMatrix4(matrix) {
              this.center.applyMatrix4(matrix);
              this.radius = this.radius * matrix.getMaxScaleOnAxis();
              return this;
            }
          }, {
            key: "translate",
            value: function translate(offset) {
              this.center.add(offset);
              return this;
            }
          }, {
            key: "expandByPoint",
            value: function expandByPoint(point) {
              if (this.isEmpty()) {
                this.center.copy(point);
                this.radius = 0;
                return this;
              }
              _v1$6.subVectors(point, this.center);
              var lengthSq = _v1$6.lengthSq();
              if (lengthSq > this.radius * this.radius) {
                // calculate the minimal sphere

                var length = Math.sqrt(lengthSq);
                var delta = (length - this.radius) * 0.5;
                this.center.addScaledVector(_v1$6, delta / length);
                this.radius += delta;
              }
              return this;
            }
          }, {
            key: "union",
            value: function union(sphere) {
              if (sphere.isEmpty()) {
                return this;
              }
              if (this.isEmpty()) {
                this.copy(sphere);
                return this;
              }
              if (this.center.equals(sphere.center) === true) {
                this.radius = Math.max(this.radius, sphere.radius);
              } else {
                _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
                this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
                this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
              }
              return this;
            }
          }, {
            key: "equals",
            value: function equals(sphere) {
              return sphere.center.equals(this.center) && sphere.radius === this.radius;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }]);
        }();
        var _vector$a = /*@__PURE__*/new Vector3();
        var _segCenter = /*@__PURE__*/new Vector3();
        var _segDir = /*@__PURE__*/new Vector3();
        var _diff = /*@__PURE__*/new Vector3();
        var _edge1 = /*@__PURE__*/new Vector3();
        var _edge2 = /*@__PURE__*/new Vector3();
        var _normal$1 = /*@__PURE__*/new Vector3();
        var Ray = /*#__PURE__*/function () {
          function Ray() {
            var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
            var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(0, 0, -1);
            _classCallCheck2(this, Ray);
            this.origin = origin;
            this.direction = direction;
          }
          return _createClass(Ray, [{
            key: "set",
            value: function set(origin, direction) {
              this.origin.copy(origin);
              this.direction.copy(direction);
              return this;
            }
          }, {
            key: "copy",
            value: function copy(ray) {
              this.origin.copy(ray.origin);
              this.direction.copy(ray.direction);
              return this;
            }
          }, {
            key: "at",
            value: function at(t, target) {
              return target.copy(this.origin).addScaledVector(this.direction, t);
            }
          }, {
            key: "lookAt",
            value: function lookAt(v) {
              this.direction.copy(v).sub(this.origin).normalize();
              return this;
            }
          }, {
            key: "recast",
            value: function recast(t) {
              this.origin.copy(this.at(t, _vector$a));
              return this;
            }
          }, {
            key: "closestPointToPoint",
            value: function closestPointToPoint(point, target) {
              target.subVectors(point, this.origin);
              var directionDistance = target.dot(this.direction);
              if (directionDistance < 0) {
                return target.copy(this.origin);
              }
              return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
            }
          }, {
            key: "distanceToPoint",
            value: function distanceToPoint(point) {
              return Math.sqrt(this.distanceSqToPoint(point));
            }
          }, {
            key: "distanceSqToPoint",
            value: function distanceSqToPoint(point) {
              var directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);

              // point behind the ray

              if (directionDistance < 0) {
                return this.origin.distanceToSquared(point);
              }
              _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
              return _vector$a.distanceToSquared(point);
            }
          }, {
            key: "distanceSqToSegment",
            value: function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
              // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
              // It returns the min distance between the ray and the segment
              // defined by v0 and v1
              // It can also set two optional targets :
              // - The closest point on the ray
              // - The closest point on the segment

              _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
              _segDir.copy(v1).sub(v0).normalize();
              _diff.copy(this.origin).sub(_segCenter);
              var segExtent = v0.distanceTo(v1) * 0.5;
              var a01 = -this.direction.dot(_segDir);
              var b0 = _diff.dot(this.direction);
              var b1 = -_diff.dot(_segDir);
              var c = _diff.lengthSq();
              var det = Math.abs(1 - a01 * a01);
              var s0, s1, sqrDist, extDet;
              if (det > 0) {
                // The ray and segment are not parallel.

                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;
                if (s0 >= 0) {
                  if (s1 >= -extDet) {
                    if (s1 <= extDet) {
                      // region 0
                      // Minimum at interior points of ray and segment.

                      var invDet = 1 / det;
                      s0 *= invDet;
                      s1 *= invDet;
                      sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                    } else {
                      // region 1

                      s1 = segExtent;
                      s0 = Math.max(0, -(a01 * s1 + b0));
                      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                  } else {
                    // region 5

                    s1 = -segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                  }
                } else {
                  if (s1 <= -extDet) {
                    // region 4

                    s0 = Math.max(0, -(-a01 * segExtent + b0));
                    s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                  } else if (s1 <= extDet) {
                    // region 3

                    s0 = 0;
                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = s1 * (s1 + 2 * b1) + c;
                  } else {
                    // region 2

                    s0 = Math.max(0, -(a01 * segExtent + b0));
                    s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                  }
                }
              } else {
                // Ray and segment are parallel.

                s1 = a01 > 0 ? -segExtent : segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
              if (optionalPointOnRay) {
                optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
              }
              if (optionalPointOnSegment) {
                optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
              }
              return sqrDist;
            }
          }, {
            key: "intersectSphere",
            value: function intersectSphere(sphere, target) {
              _vector$a.subVectors(sphere.center, this.origin);
              var tca = _vector$a.dot(this.direction);
              var d2 = _vector$a.dot(_vector$a) - tca * tca;
              var radius2 = sphere.radius * sphere.radius;
              if (d2 > radius2) return null;
              var thc = Math.sqrt(radius2 - d2);

              // t0 = first intersect point - entrance on front of sphere
              var t0 = tca - thc;

              // t1 = second intersect point - exit point on back of sphere
              var t1 = tca + thc;

              // test to see if t1 is behind the ray - if so, return null
              if (t1 < 0) return null;

              // test to see if t0 is behind the ray:
              // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
              // in order to always return an intersect point that is in front of the ray.
              if (t0 < 0) return this.at(t1, target);

              // else t0 is in front of the ray, so return the first collision point scaled by t0
              return this.at(t0, target);
            }
          }, {
            key: "intersectsSphere",
            value: function intersectsSphere(sphere) {
              return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
            }
          }, {
            key: "distanceToPlane",
            value: function distanceToPlane(plane) {
              var denominator = plane.normal.dot(this.direction);
              if (denominator === 0) {
                // line is coplanar, return origin
                if (plane.distanceToPoint(this.origin) === 0) {
                  return 0;
                }

                // Null is preferable to undefined since undefined means.... it is undefined

                return null;
              }
              var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

              // Return if the ray never intersects the plane

              return t >= 0 ? t : null;
            }
          }, {
            key: "intersectPlane",
            value: function intersectPlane(plane, target) {
              var t = this.distanceToPlane(plane);
              if (t === null) {
                return null;
              }
              return this.at(t, target);
            }
          }, {
            key: "intersectsPlane",
            value: function intersectsPlane(plane) {
              // check if the ray lies on the plane first

              var distToPoint = plane.distanceToPoint(this.origin);
              if (distToPoint === 0) {
                return true;
              }
              var denominator = plane.normal.dot(this.direction);
              if (denominator * distToPoint < 0) {
                return true;
              }

              // ray origin is behind the plane (and is pointing behind it)

              return false;
            }
          }, {
            key: "intersectBox",
            value: function intersectBox(box, target) {
              var tmin, tmax, tymin, tymax, tzmin, tzmax;
              var invdirx = 1 / this.direction.x,
                invdiry = 1 / this.direction.y,
                invdirz = 1 / this.direction.z;
              var origin = this.origin;
              if (invdirx >= 0) {
                tmin = (box.min.x - origin.x) * invdirx;
                tmax = (box.max.x - origin.x) * invdirx;
              } else {
                tmin = (box.max.x - origin.x) * invdirx;
                tmax = (box.min.x - origin.x) * invdirx;
              }
              if (invdiry >= 0) {
                tymin = (box.min.y - origin.y) * invdiry;
                tymax = (box.max.y - origin.y) * invdiry;
              } else {
                tymin = (box.max.y - origin.y) * invdiry;
                tymax = (box.min.y - origin.y) * invdiry;
              }
              if (tmin > tymax || tymin > tmax) return null;
              if (tymin > tmin || isNaN(tmin)) tmin = tymin;
              if (tymax < tmax || isNaN(tmax)) tmax = tymax;
              if (invdirz >= 0) {
                tzmin = (box.min.z - origin.z) * invdirz;
                tzmax = (box.max.z - origin.z) * invdirz;
              } else {
                tzmin = (box.max.z - origin.z) * invdirz;
                tzmax = (box.min.z - origin.z) * invdirz;
              }
              if (tmin > tzmax || tzmin > tmax) return null;
              if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
              if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

              //return point closest to the ray (positive side)

              if (tmax < 0) return null;
              return this.at(tmin >= 0 ? tmin : tmax, target);
            }
          }, {
            key: "intersectsBox",
            value: function intersectsBox(box) {
              return this.intersectBox(box, _vector$a) !== null;
            }
          }, {
            key: "intersectTriangle",
            value: function intersectTriangle(a, b, c, backfaceCulling, target) {
              // Compute the offset origin, edges, and normal.

              // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

              _edge1.subVectors(b, a);
              _edge2.subVectors(c, a);
              _normal$1.crossVectors(_edge1, _edge2);

              // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
              // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
              //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
              //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
              //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
              var DdN = this.direction.dot(_normal$1);
              var sign;
              if (DdN > 0) {
                if (backfaceCulling) return null;
                sign = 1;
              } else if (DdN < 0) {
                sign = -1;
                DdN = -DdN;
              } else {
                return null;
              }
              _diff.subVectors(this.origin, a);
              var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));

              // b1 < 0, no intersection
              if (DdQxE2 < 0) {
                return null;
              }
              var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));

              // b2 < 0, no intersection
              if (DdE1xQ < 0) {
                return null;
              }

              // b1+b2 > 1, no intersection
              if (DdQxE2 + DdE1xQ > DdN) {
                return null;
              }

              // Line intersects triangle, check if ray does.
              var QdN = -sign * _diff.dot(_normal$1);

              // t < 0, no intersection
              if (QdN < 0) {
                return null;
              }

              // Ray intersects triangle.
              return this.at(QdN / DdN, target);
            }
          }, {
            key: "applyMatrix4",
            value: function applyMatrix4(matrix4) {
              this.origin.applyMatrix4(matrix4);
              this.direction.transformDirection(matrix4);
              return this;
            }
          }, {
            key: "equals",
            value: function equals(ray) {
              return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }]);
        }();
        var Matrix4 = /*#__PURE__*/function () {
          function Matrix4(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            _classCallCheck2(this, Matrix4);
            Matrix4.prototype.isMatrix4 = true;
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            if (n11 !== undefined) {
              this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
            }
          }
          return _createClass(Matrix4, [{
            key: "set",
            value: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
              var te = this.elements;
              te[0] = n11;
              te[4] = n12;
              te[8] = n13;
              te[12] = n14;
              te[1] = n21;
              te[5] = n22;
              te[9] = n23;
              te[13] = n24;
              te[2] = n31;
              te[6] = n32;
              te[10] = n33;
              te[14] = n34;
              te[3] = n41;
              te[7] = n42;
              te[11] = n43;
              te[15] = n44;
              return this;
            }
          }, {
            key: "identity",
            value: function identity() {
              this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new Matrix4().fromArray(this.elements);
            }
          }, {
            key: "copy",
            value: function copy(m) {
              var te = this.elements;
              var me = m.elements;
              te[0] = me[0];
              te[1] = me[1];
              te[2] = me[2];
              te[3] = me[3];
              te[4] = me[4];
              te[5] = me[5];
              te[6] = me[6];
              te[7] = me[7];
              te[8] = me[8];
              te[9] = me[9];
              te[10] = me[10];
              te[11] = me[11];
              te[12] = me[12];
              te[13] = me[13];
              te[14] = me[14];
              te[15] = me[15];
              return this;
            }
          }, {
            key: "copyPosition",
            value: function copyPosition(m) {
              var te = this.elements,
                me = m.elements;
              te[12] = me[12];
              te[13] = me[13];
              te[14] = me[14];
              return this;
            }
          }, {
            key: "setFromMatrix3",
            value: function setFromMatrix3(m) {
              var me = m.elements;
              this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
              return this;
            }
          }, {
            key: "extractBasis",
            value: function extractBasis(xAxis, yAxis, zAxis) {
              xAxis.setFromMatrixColumn(this, 0);
              yAxis.setFromMatrixColumn(this, 1);
              zAxis.setFromMatrixColumn(this, 2);
              return this;
            }
          }, {
            key: "makeBasis",
            value: function makeBasis(xAxis, yAxis, zAxis) {
              this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
              return this;
            }
          }, {
            key: "extractRotation",
            value: function extractRotation(m) {
              // this method does not support reflection matrices

              var te = this.elements;
              var me = m.elements;
              var scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
              var scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
              var scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
              te[0] = me[0] * scaleX;
              te[1] = me[1] * scaleX;
              te[2] = me[2] * scaleX;
              te[3] = 0;
              te[4] = me[4] * scaleY;
              te[5] = me[5] * scaleY;
              te[6] = me[6] * scaleY;
              te[7] = 0;
              te[8] = me[8] * scaleZ;
              te[9] = me[9] * scaleZ;
              te[10] = me[10] * scaleZ;
              te[11] = 0;
              te[12] = 0;
              te[13] = 0;
              te[14] = 0;
              te[15] = 1;
              return this;
            }
          }, {
            key: "makeRotationFromEuler",
            value: function makeRotationFromEuler(euler) {
              var te = this.elements;
              var x = euler.x,
                y = euler.y,
                z = euler.z;
              var a = Math.cos(x),
                b = Math.sin(x);
              var c = Math.cos(y),
                d = Math.sin(y);
              var e = Math.cos(z),
                f = Math.sin(z);
              if (euler.order === 'XYZ') {
                var ae = a * e,
                  af = a * f,
                  be = b * e,
                  bf = b * f;
                te[0] = c * e;
                te[4] = -c * f;
                te[8] = d;
                te[1] = af + be * d;
                te[5] = ae - bf * d;
                te[9] = -b * c;
                te[2] = bf - ae * d;
                te[6] = be + af * d;
                te[10] = a * c;
              } else if (euler.order === 'YXZ') {
                var ce = c * e,
                  cf = c * f,
                  de = d * e,
                  df = d * f;
                te[0] = ce + df * b;
                te[4] = de * b - cf;
                te[8] = a * d;
                te[1] = a * f;
                te[5] = a * e;
                te[9] = -b;
                te[2] = cf * b - de;
                te[6] = df + ce * b;
                te[10] = a * c;
              } else if (euler.order === 'ZXY') {
                var _ce = c * e,
                  _cf = c * f,
                  _de = d * e,
                  _df = d * f;
                te[0] = _ce - _df * b;
                te[4] = -a * f;
                te[8] = _de + _cf * b;
                te[1] = _cf + _de * b;
                te[5] = a * e;
                te[9] = _df - _ce * b;
                te[2] = -a * d;
                te[6] = b;
                te[10] = a * c;
              } else if (euler.order === 'ZYX') {
                var _ae = a * e,
                  _af = a * f,
                  _be = b * e,
                  _bf = b * f;
                te[0] = c * e;
                te[4] = _be * d - _af;
                te[8] = _ae * d + _bf;
                te[1] = c * f;
                te[5] = _bf * d + _ae;
                te[9] = _af * d - _be;
                te[2] = -d;
                te[6] = b * c;
                te[10] = a * c;
              } else if (euler.order === 'YZX') {
                var ac = a * c,
                  ad = a * d,
                  bc = b * c,
                  bd = b * d;
                te[0] = c * e;
                te[4] = bd - ac * f;
                te[8] = bc * f + ad;
                te[1] = f;
                te[5] = a * e;
                te[9] = -b * e;
                te[2] = -d * e;
                te[6] = ad * f + bc;
                te[10] = ac - bd * f;
              } else if (euler.order === 'XZY') {
                var _ac = a * c,
                  _ad = a * d,
                  _bc = b * c,
                  _bd = b * d;
                te[0] = c * e;
                te[4] = -f;
                te[8] = d * e;
                te[1] = _ac * f + _bd;
                te[5] = a * e;
                te[9] = _ad * f - _bc;
                te[2] = _bc * f - _ad;
                te[6] = b * e;
                te[10] = _bd * f + _ac;
              }

              // bottom row
              te[3] = 0;
              te[7] = 0;
              te[11] = 0;

              // last column
              te[12] = 0;
              te[13] = 0;
              te[14] = 0;
              te[15] = 1;
              return this;
            }
          }, {
            key: "makeRotationFromQuaternion",
            value: function makeRotationFromQuaternion(q) {
              return this.compose(_zero, q, _one);
            }
          }, {
            key: "lookAt",
            value: function lookAt(eye, target, up) {
              var te = this.elements;
              _z.subVectors(eye, target);
              if (_z.lengthSq() === 0) {
                // eye and target are in the same position

                _z.z = 1;
              }
              _z.normalize();
              _x.crossVectors(up, _z);
              if (_x.lengthSq() === 0) {
                // up and z are parallel

                if (Math.abs(up.z) === 1) {
                  _z.x += 0.0001;
                } else {
                  _z.z += 0.0001;
                }
                _z.normalize();
                _x.crossVectors(up, _z);
              }
              _x.normalize();
              _y.crossVectors(_z, _x);
              te[0] = _x.x;
              te[4] = _y.x;
              te[8] = _z.x;
              te[1] = _x.y;
              te[5] = _y.y;
              te[9] = _z.y;
              te[2] = _x.z;
              te[6] = _y.z;
              te[10] = _z.z;
              return this;
            }
          }, {
            key: "multiply",
            value: function multiply(m) {
              return this.multiplyMatrices(this, m);
            }
          }, {
            key: "premultiply",
            value: function premultiply(m) {
              return this.multiplyMatrices(m, this);
            }
          }, {
            key: "multiplyMatrices",
            value: function multiplyMatrices(a, b) {
              var ae = a.elements;
              var be = b.elements;
              var te = this.elements;
              var a11 = ae[0],
                a12 = ae[4],
                a13 = ae[8],
                a14 = ae[12];
              var a21 = ae[1],
                a22 = ae[5],
                a23 = ae[9],
                a24 = ae[13];
              var a31 = ae[2],
                a32 = ae[6],
                a33 = ae[10],
                a34 = ae[14];
              var a41 = ae[3],
                a42 = ae[7],
                a43 = ae[11],
                a44 = ae[15];
              var b11 = be[0],
                b12 = be[4],
                b13 = be[8],
                b14 = be[12];
              var b21 = be[1],
                b22 = be[5],
                b23 = be[9],
                b24 = be[13];
              var b31 = be[2],
                b32 = be[6],
                b33 = be[10],
                b34 = be[14];
              var b41 = be[3],
                b42 = be[7],
                b43 = be[11],
                b44 = be[15];
              te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
              te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
              te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
              te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
              te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
              te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
              te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
              te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
              te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
              te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
              te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
              te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
              te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
              te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
              te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
              te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
              return this;
            }
          }, {
            key: "multiplyScalar",
            value: function multiplyScalar(s) {
              var te = this.elements;
              te[0] *= s;
              te[4] *= s;
              te[8] *= s;
              te[12] *= s;
              te[1] *= s;
              te[5] *= s;
              te[9] *= s;
              te[13] *= s;
              te[2] *= s;
              te[6] *= s;
              te[10] *= s;
              te[14] *= s;
              te[3] *= s;
              te[7] *= s;
              te[11] *= s;
              te[15] *= s;
              return this;
            }
          }, {
            key: "determinant",
            value: function determinant() {
              var te = this.elements;
              var n11 = te[0],
                n12 = te[4],
                n13 = te[8],
                n14 = te[12];
              var n21 = te[1],
                n22 = te[5],
                n23 = te[9],
                n24 = te[13];
              var n31 = te[2],
                n32 = te[6],
                n33 = te[10],
                n34 = te[14];
              var n41 = te[3],
                n42 = te[7],
                n43 = te[11],
                n44 = te[15];

              //TODO: make this more efficient
              //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

              return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
            }
          }, {
            key: "transpose",
            value: function transpose() {
              var te = this.elements;
              var tmp;
              tmp = te[1];
              te[1] = te[4];
              te[4] = tmp;
              tmp = te[2];
              te[2] = te[8];
              te[8] = tmp;
              tmp = te[6];
              te[6] = te[9];
              te[9] = tmp;
              tmp = te[3];
              te[3] = te[12];
              te[12] = tmp;
              tmp = te[7];
              te[7] = te[13];
              te[13] = tmp;
              tmp = te[11];
              te[11] = te[14];
              te[14] = tmp;
              return this;
            }
          }, {
            key: "setPosition",
            value: function setPosition(x, y, z) {
              var te = this.elements;
              if (x.isVector3) {
                te[12] = x.x;
                te[13] = x.y;
                te[14] = x.z;
              } else {
                te[12] = x;
                te[13] = y;
                te[14] = z;
              }
              return this;
            }
          }, {
            key: "invert",
            value: function invert() {
              // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
              var te = this.elements,
                n11 = te[0],
                n21 = te[1],
                n31 = te[2],
                n41 = te[3],
                n12 = te[4],
                n22 = te[5],
                n32 = te[6],
                n42 = te[7],
                n13 = te[8],
                n23 = te[9],
                n33 = te[10],
                n43 = te[11],
                n14 = te[12],
                n24 = te[13],
                n34 = te[14],
                n44 = te[15],
                t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
                t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
                t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
                t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
              var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
              if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
              var detInv = 1 / det;
              te[0] = t11 * detInv;
              te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
              te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
              te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
              te[4] = t12 * detInv;
              te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
              te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
              te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
              te[8] = t13 * detInv;
              te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
              te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
              te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
              te[12] = t14 * detInv;
              te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
              te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
              te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
              return this;
            }
          }, {
            key: "scale",
            value: function scale(v) {
              var te = this.elements;
              var x = v.x,
                y = v.y,
                z = v.z;
              te[0] *= x;
              te[4] *= y;
              te[8] *= z;
              te[1] *= x;
              te[5] *= y;
              te[9] *= z;
              te[2] *= x;
              te[6] *= y;
              te[10] *= z;
              te[3] *= x;
              te[7] *= y;
              te[11] *= z;
              return this;
            }
          }, {
            key: "getMaxScaleOnAxis",
            value: function getMaxScaleOnAxis() {
              var te = this.elements;
              var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
              var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
              var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
              return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
            }
          }, {
            key: "makeTranslation",
            value: function makeTranslation(x, y, z) {
              if (x.isVector3) {
                this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
              } else {
                this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
              }
              return this;
            }
          }, {
            key: "makeRotationX",
            value: function makeRotationX(theta) {
              var c = Math.cos(theta),
                s = Math.sin(theta);
              this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
              return this;
            }
          }, {
            key: "makeRotationY",
            value: function makeRotationY(theta) {
              var c = Math.cos(theta),
                s = Math.sin(theta);
              this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
              return this;
            }
          }, {
            key: "makeRotationZ",
            value: function makeRotationZ(theta) {
              var c = Math.cos(theta),
                s = Math.sin(theta);
              this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
              return this;
            }
          }, {
            key: "makeRotationAxis",
            value: function makeRotationAxis(axis, angle) {
              // Based on http://www.gamedev.net/reference/articles/article1199.asp

              var c = Math.cos(angle);
              var s = Math.sin(angle);
              var t = 1 - c;
              var x = axis.x,
                y = axis.y,
                z = axis.z;
              var tx = t * x,
                ty = t * y;
              this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
              return this;
            }
          }, {
            key: "makeScale",
            value: function makeScale(x, y, z) {
              this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
              return this;
            }
          }, {
            key: "makeShear",
            value: function makeShear(xy, xz, yx, yz, zx, zy) {
              this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
              return this;
            }
          }, {
            key: "compose",
            value: function compose(position, quaternion, scale) {
              var te = this.elements;
              var x = quaternion._x,
                y = quaternion._y,
                z = quaternion._z,
                w = quaternion._w;
              var x2 = x + x,
                y2 = y + y,
                z2 = z + z;
              var xx = x * x2,
                xy = x * y2,
                xz = x * z2;
              var yy = y * y2,
                yz = y * z2,
                zz = z * z2;
              var wx = w * x2,
                wy = w * y2,
                wz = w * z2;
              var sx = scale.x,
                sy = scale.y,
                sz = scale.z;
              te[0] = (1 - (yy + zz)) * sx;
              te[1] = (xy + wz) * sx;
              te[2] = (xz - wy) * sx;
              te[3] = 0;
              te[4] = (xy - wz) * sy;
              te[5] = (1 - (xx + zz)) * sy;
              te[6] = (yz + wx) * sy;
              te[7] = 0;
              te[8] = (xz + wy) * sz;
              te[9] = (yz - wx) * sz;
              te[10] = (1 - (xx + yy)) * sz;
              te[11] = 0;
              te[12] = position.x;
              te[13] = position.y;
              te[14] = position.z;
              te[15] = 1;
              return this;
            }
          }, {
            key: "decompose",
            value: function decompose(position, quaternion, scale) {
              var te = this.elements;
              var sx = _v1$5.set(te[0], te[1], te[2]).length();
              var sy = _v1$5.set(te[4], te[5], te[6]).length();
              var sz = _v1$5.set(te[8], te[9], te[10]).length();

              // if determine is negative, we need to invert one scale
              var det = this.determinant();
              if (det < 0) sx = -sx;
              position.x = te[12];
              position.y = te[13];
              position.z = te[14];

              // scale the rotation part
              _m1$4.copy(this);
              var invSX = 1 / sx;
              var invSY = 1 / sy;
              var invSZ = 1 / sz;
              _m1$4.elements[0] *= invSX;
              _m1$4.elements[1] *= invSX;
              _m1$4.elements[2] *= invSX;
              _m1$4.elements[4] *= invSY;
              _m1$4.elements[5] *= invSY;
              _m1$4.elements[6] *= invSY;
              _m1$4.elements[8] *= invSZ;
              _m1$4.elements[9] *= invSZ;
              _m1$4.elements[10] *= invSZ;
              quaternion.setFromRotationMatrix(_m1$4);
              scale.x = sx;
              scale.y = sy;
              scale.z = sz;
              return this;
            }
          }, {
            key: "makePerspective",
            value: function makePerspective(left, right, top, bottom, near, far) {
              var coordinateSystem = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : WebGLCoordinateSystem;
              var te = this.elements;
              var x = 2 * near / (right - left);
              var y = 2 * near / (top - bottom);
              var a = (right + left) / (right - left);
              var b = (top + bottom) / (top - bottom);
              var c, d;
              if (coordinateSystem === WebGLCoordinateSystem) {
                c = -(far + near) / (far - near);
                d = -2 * far * near / (far - near);
              } else if (coordinateSystem === WebGPUCoordinateSystem) {
                c = -far / (far - near);
                d = -far * near / (far - near);
              } else {
                throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem);
              }
              te[0] = x;
              te[4] = 0;
              te[8] = a;
              te[12] = 0;
              te[1] = 0;
              te[5] = y;
              te[9] = b;
              te[13] = 0;
              te[2] = 0;
              te[6] = 0;
              te[10] = c;
              te[14] = d;
              te[3] = 0;
              te[7] = 0;
              te[11] = -1;
              te[15] = 0;
              return this;
            }
          }, {
            key: "makeOrthographic",
            value: function makeOrthographic(left, right, top, bottom, near, far) {
              var coordinateSystem = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : WebGLCoordinateSystem;
              var te = this.elements;
              var w = 1.0 / (right - left);
              var h = 1.0 / (top - bottom);
              var p = 1.0 / (far - near);
              var x = (right + left) * w;
              var y = (top + bottom) * h;
              var z, zInv;
              if (coordinateSystem === WebGLCoordinateSystem) {
                z = (far + near) * p;
                zInv = -2 * p;
              } else if (coordinateSystem === WebGPUCoordinateSystem) {
                z = near * p;
                zInv = -1 * p;
              } else {
                throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem);
              }
              te[0] = 2 * w;
              te[4] = 0;
              te[8] = 0;
              te[12] = -x;
              te[1] = 0;
              te[5] = 2 * h;
              te[9] = 0;
              te[13] = -y;
              te[2] = 0;
              te[6] = 0;
              te[10] = zInv;
              te[14] = -z;
              te[3] = 0;
              te[7] = 0;
              te[11] = 0;
              te[15] = 1;
              return this;
            }
          }, {
            key: "equals",
            value: function equals(matrix) {
              var te = this.elements;
              var me = matrix.elements;
              for (var i = 0; i < 16; i++) {
                if (te[i] !== me[i]) return false;
              }
              return true;
            }
          }, {
            key: "fromArray",
            value: function fromArray(array) {
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              for (var i = 0; i < 16; i++) {
                this.elements[i] = array[i + offset];
              }
              return this;
            }
          }, {
            key: "toArray",
            value: function toArray() {
              var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var te = this.elements;
              array[offset] = te[0];
              array[offset + 1] = te[1];
              array[offset + 2] = te[2];
              array[offset + 3] = te[3];
              array[offset + 4] = te[4];
              array[offset + 5] = te[5];
              array[offset + 6] = te[6];
              array[offset + 7] = te[7];
              array[offset + 8] = te[8];
              array[offset + 9] = te[9];
              array[offset + 10] = te[10];
              array[offset + 11] = te[11];
              array[offset + 12] = te[12];
              array[offset + 13] = te[13];
              array[offset + 14] = te[14];
              array[offset + 15] = te[15];
              return array;
            }
          }]);
        }();
        var _v1$5 = /*@__PURE__*/new Vector3();
        var _m1$4 = /*@__PURE__*/new Matrix4();
        var _zero = /*@__PURE__*/new Vector3(0, 0, 0);
        var _one = /*@__PURE__*/new Vector3(1, 1, 1);
        var _x = /*@__PURE__*/new Vector3();
        var _y = /*@__PURE__*/new Vector3();
        var _z = /*@__PURE__*/new Vector3();
        var _matrix$2 = /*@__PURE__*/new Matrix4();
        var _quaternion$3 = /*@__PURE__*/new Quaternion();
        var Euler = /*#__PURE__*/function () {
          function Euler() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Euler.DEFAULT_ORDER;
            _classCallCheck2(this, Euler);
            this.isEuler = true;
            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order;
          }
          return _createClass(Euler, [{
            key: "x",
            get: function get() {
              return this._x;
            },
            set: function set(value) {
              this._x = value;
              this._onChangeCallback();
            }
          }, {
            key: "y",
            get: function get() {
              return this._y;
            },
            set: function set(value) {
              this._y = value;
              this._onChangeCallback();
            }
          }, {
            key: "z",
            get: function get() {
              return this._z;
            },
            set: function set(value) {
              this._z = value;
              this._onChangeCallback();
            }
          }, {
            key: "order",
            get: function get() {
              return this._order;
            },
            set: function set(value) {
              this._order = value;
              this._onChangeCallback();
            }
          }, {
            key: "set",
            value: function set(x, y, z) {
              var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._order;
              this._x = x;
              this._y = y;
              this._z = z;
              this._order = order;
              this._onChangeCallback();
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor(this._x, this._y, this._z, this._order);
            }
          }, {
            key: "copy",
            value: function copy(euler) {
              this._x = euler._x;
              this._y = euler._y;
              this._z = euler._z;
              this._order = euler._order;
              this._onChangeCallback();
              return this;
            }
          }, {
            key: "setFromRotationMatrix",
            value: function setFromRotationMatrix(m) {
              var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;
              var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
              // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

              var te = m.elements;
              var m11 = te[0],
                m12 = te[4],
                m13 = te[8];
              var m21 = te[1],
                m22 = te[5],
                m23 = te[9];
              var m31 = te[2],
                m32 = te[6],
                m33 = te[10];
              switch (order) {
                case 'XYZ':
                  this._y = Math.asin(clamp(m13, -1, 1));
                  if (Math.abs(m13) < 0.9999999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                  } else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                  }
                  break;
                case 'YXZ':
                  this._x = Math.asin(-clamp(m23, -1, 1));
                  if (Math.abs(m23) < 0.9999999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                  } else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                  }
                  break;
                case 'ZXY':
                  this._x = Math.asin(clamp(m32, -1, 1));
                  if (Math.abs(m32) < 0.9999999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                  } else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                  }
                  break;
                case 'ZYX':
                  this._y = Math.asin(-clamp(m31, -1, 1));
                  if (Math.abs(m31) < 0.9999999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                  } else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                  }
                  break;
                case 'YZX':
                  this._z = Math.asin(clamp(m21, -1, 1));
                  if (Math.abs(m21) < 0.9999999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                  } else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                  }
                  break;
                case 'XZY':
                  this._z = Math.asin(-clamp(m12, -1, 1));
                  if (Math.abs(m12) < 0.9999999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                  } else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                  }
                  break;
                default:
                  console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
              }
              this._order = order;
              if (update === true) this._onChangeCallback();
              return this;
            }
          }, {
            key: "setFromQuaternion",
            value: function setFromQuaternion(q, order, update) {
              _matrix$2.makeRotationFromQuaternion(q);
              return this.setFromRotationMatrix(_matrix$2, order, update);
            }
          }, {
            key: "setFromVector3",
            value: function setFromVector3(v) {
              var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;
              return this.set(v.x, v.y, v.z, order);
            }
          }, {
            key: "reorder",
            value: function reorder(newOrder) {
              // WARNING: this discards revolution information -bhouston

              _quaternion$3.setFromEuler(this);
              return this.setFromQuaternion(_quaternion$3, newOrder);
            }
          }, {
            key: "equals",
            value: function equals(euler) {
              return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
            }
          }, {
            key: "fromArray",
            value: function fromArray(array) {
              this._x = array[0];
              this._y = array[1];
              this._z = array[2];
              if (array[3] !== undefined) this._order = array[3];
              this._onChangeCallback();
              return this;
            }
          }, {
            key: "toArray",
            value: function toArray() {
              var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              array[offset] = this._x;
              array[offset + 1] = this._y;
              array[offset + 2] = this._z;
              array[offset + 3] = this._order;
              return array;
            }
          }, {
            key: "_onChange",
            value: function _onChange(callback) {
              this._onChangeCallback = callback;
              return this;
            }
          }, {
            key: "_onChangeCallback",
            value: function _onChangeCallback() {}
          }, {
            key: Symbol.iterator,
            value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
              return _regeneratorRuntime().wrap(function value$(_context12) {
                while (1) switch (_context12.prev = _context12.next) {
                  case 0:
                    _context12.next = 2;
                    return this._x;
                  case 2:
                    _context12.next = 4;
                    return this._y;
                  case 4:
                    _context12.next = 6;
                    return this._z;
                  case 6:
                    _context12.next = 8;
                    return this._order;
                  case 8:
                  case "end":
                    return _context12.stop();
                }
              }, value, this);
            })
          }]);
        }();
        Euler.DEFAULT_ORDER = 'XYZ';
        var Layers = /*#__PURE__*/function () {
          function Layers() {
            _classCallCheck2(this, Layers);
            this.mask = 1 | 0;
          }
          return _createClass(Layers, [{
            key: "set",
            value: function set(channel) {
              this.mask = (1 << channel | 0) >>> 0;
            }
          }, {
            key: "enable",
            value: function enable(channel) {
              this.mask |= 1 << channel | 0;
            }
          }, {
            key: "enableAll",
            value: function enableAll() {
              this.mask = 0xffffffff | 0;
            }
          }, {
            key: "toggle",
            value: function toggle(channel) {
              this.mask ^= 1 << channel | 0;
            }
          }, {
            key: "disable",
            value: function disable(channel) {
              this.mask &= ~(1 << channel | 0);
            }
          }, {
            key: "disableAll",
            value: function disableAll() {
              this.mask = 0;
            }
          }, {
            key: "test",
            value: function test(layers) {
              return (this.mask & layers.mask) !== 0;
            }
          }, {
            key: "isEnabled",
            value: function isEnabled(channel) {
              return (this.mask & (1 << channel | 0)) !== 0;
            }
          }]);
        }();
        var _object3DId = 0;
        var _v1$4 = /*@__PURE__*/new Vector3();
        var _q1 = /*@__PURE__*/new Quaternion();
        var _m1$3 = /*@__PURE__*/new Matrix4();
        var _target = /*@__PURE__*/new Vector3();
        var _position$3 = /*@__PURE__*/new Vector3();
        var _scale$2 = /*@__PURE__*/new Vector3();
        var _quaternion$2 = /*@__PURE__*/new Quaternion();
        var _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);
        var _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);
        var _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);
        var _addedEvent = {
          type: 'added'
        };
        var _removedEvent = {
          type: 'removed'
        };
        var _childaddedEvent = {
          type: 'childadded',
          child: null
        };
        var _childremovedEvent = {
          type: 'childremoved',
          child: null
        };
        var Object3D = /*#__PURE__*/function (_EventDispatcher3) {
          function Object3D() {
            var _this22;
            _classCallCheck2(this, Object3D);
            _this22 = _callSuper(this, Object3D);
            _this22.isObject3D = true;
            Object.defineProperty(_this22, 'id', {
              value: _object3DId++
            });
            _this22.uuid = generateUUID();
            _this22.name = '';
            _this22.type = 'Object3D';
            _this22.parent = null;
            _this22.children = [];
            _this22.up = Object3D.DEFAULT_UP.clone();
            var position = new Vector3();
            var rotation = new Euler();
            var quaternion = new Quaternion();
            var scale = new Vector3(1, 1, 1);
            function onRotationChange() {
              quaternion.setFromEuler(rotation, false);
            }
            function onQuaternionChange() {
              rotation.setFromQuaternion(quaternion, undefined, false);
            }
            rotation._onChange(onRotationChange);
            quaternion._onChange(onQuaternionChange);
            Object.defineProperties(_this22, {
              position: {
                configurable: true,
                enumerable: true,
                value: position
              },
              rotation: {
                configurable: true,
                enumerable: true,
                value: rotation
              },
              quaternion: {
                configurable: true,
                enumerable: true,
                value: quaternion
              },
              scale: {
                configurable: true,
                enumerable: true,
                value: scale
              },
              modelViewMatrix: {
                value: new Matrix4()
              },
              normalMatrix: {
                value: new Matrix3()
              }
            });
            _this22.matrix = new Matrix4();
            _this22.matrixWorld = new Matrix4();
            _this22.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
            _this22.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer
            _this22.matrixWorldNeedsUpdate = false;
            _this22.layers = new Layers();
            _this22.visible = true;
            _this22.castShadow = false;
            _this22.receiveShadow = false;
            _this22.frustumCulled = true;
            _this22.renderOrder = 0;
            _this22.animations = [];
            _this22.userData = {};
            return _this22;
          }
          _inherits(Object3D, _EventDispatcher3);
          return _createClass(Object3D, [{
            key: "onBeforeShadow",
            value: function onBeforeShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}
          }, {
            key: "onAfterShadow",
            value: function onAfterShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}
          }, {
            key: "onBeforeRender",
            value: function onBeforeRender(/* renderer, scene, camera, geometry, material, group */) {}
          }, {
            key: "onAfterRender",
            value: function onAfterRender(/* renderer, scene, camera, geometry, material, group */) {}
          }, {
            key: "applyMatrix4",
            value: function applyMatrix4(matrix) {
              if (this.matrixAutoUpdate) this.updateMatrix();
              this.matrix.premultiply(matrix);
              this.matrix.decompose(this.position, this.quaternion, this.scale);
            }
          }, {
            key: "applyQuaternion",
            value: function applyQuaternion(q) {
              this.quaternion.premultiply(q);
              return this;
            }
          }, {
            key: "setRotationFromAxisAngle",
            value: function setRotationFromAxisAngle(axis, angle) {
              // assumes axis is normalized

              this.quaternion.setFromAxisAngle(axis, angle);
            }
          }, {
            key: "setRotationFromEuler",
            value: function setRotationFromEuler(euler) {
              this.quaternion.setFromEuler(euler, true);
            }
          }, {
            key: "setRotationFromMatrix",
            value: function setRotationFromMatrix(m) {
              // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

              this.quaternion.setFromRotationMatrix(m);
            }
          }, {
            key: "setRotationFromQuaternion",
            value: function setRotationFromQuaternion(q) {
              // assumes q is normalized

              this.quaternion.copy(q);
            }
          }, {
            key: "rotateOnAxis",
            value: function rotateOnAxis(axis, angle) {
              // rotate object on axis in object space
              // axis is assumed to be normalized

              _q1.setFromAxisAngle(axis, angle);
              this.quaternion.multiply(_q1);
              return this;
            }
          }, {
            key: "rotateOnWorldAxis",
            value: function rotateOnWorldAxis(axis, angle) {
              // rotate object on axis in world space
              // axis is assumed to be normalized
              // method assumes no rotated parent

              _q1.setFromAxisAngle(axis, angle);
              this.quaternion.premultiply(_q1);
              return this;
            }
          }, {
            key: "rotateX",
            value: function rotateX(angle) {
              return this.rotateOnAxis(_xAxis, angle);
            }
          }, {
            key: "rotateY",
            value: function rotateY(angle) {
              return this.rotateOnAxis(_yAxis, angle);
            }
          }, {
            key: "rotateZ",
            value: function rotateZ(angle) {
              return this.rotateOnAxis(_zAxis, angle);
            }
          }, {
            key: "translateOnAxis",
            value: function translateOnAxis(axis, distance) {
              // translate object by distance along axis in object space
              // axis is assumed to be normalized

              _v1$4.copy(axis).applyQuaternion(this.quaternion);
              this.position.add(_v1$4.multiplyScalar(distance));
              return this;
            }
          }, {
            key: "translateX",
            value: function translateX(distance) {
              return this.translateOnAxis(_xAxis, distance);
            }
          }, {
            key: "translateY",
            value: function translateY(distance) {
              return this.translateOnAxis(_yAxis, distance);
            }
          }, {
            key: "translateZ",
            value: function translateZ(distance) {
              return this.translateOnAxis(_zAxis, distance);
            }
          }, {
            key: "localToWorld",
            value: function localToWorld(vector) {
              this.updateWorldMatrix(true, false);
              return vector.applyMatrix4(this.matrixWorld);
            }
          }, {
            key: "worldToLocal",
            value: function worldToLocal(vector) {
              this.updateWorldMatrix(true, false);
              return vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert());
            }
          }, {
            key: "lookAt",
            value: function lookAt(x, y, z) {
              // This method does not support objects having non-uniformly-scaled parent(s)

              if (x.isVector3) {
                _target.copy(x);
              } else {
                _target.set(x, y, z);
              }
              var parent = this.parent;
              this.updateWorldMatrix(true, false);
              _position$3.setFromMatrixPosition(this.matrixWorld);
              if (this.isCamera || this.isLight) {
                _m1$3.lookAt(_position$3, _target, this.up);
              } else {
                _m1$3.lookAt(_target, _position$3, this.up);
              }
              this.quaternion.setFromRotationMatrix(_m1$3);
              if (parent) {
                _m1$3.extractRotation(parent.matrixWorld);
                _q1.setFromRotationMatrix(_m1$3);
                this.quaternion.premultiply(_q1.invert());
              }
            }
          }, {
            key: "add",
            value: function add(object) {
              if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                  this.add(arguments[i]);
                }
                return this;
              }
              if (object === this) {
                console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
                return this;
              }
              if (object && object.isObject3D) {
                object.removeFromParent();
                object.parent = this;
                this.children.push(object);
                object.dispatchEvent(_addedEvent);
                _childaddedEvent.child = object;
                this.dispatchEvent(_childaddedEvent);
                _childaddedEvent.child = null;
              } else {
                console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
              }
              return this;
            }
          }, {
            key: "remove",
            value: function remove(object) {
              if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                  this.remove(arguments[i]);
                }
                return this;
              }
              var index = this.children.indexOf(object);
              if (index !== -1) {
                object.parent = null;
                this.children.splice(index, 1);
                object.dispatchEvent(_removedEvent);
                _childremovedEvent.child = object;
                this.dispatchEvent(_childremovedEvent);
                _childremovedEvent.child = null;
              }
              return this;
            }
          }, {
            key: "removeFromParent",
            value: function removeFromParent() {
              var parent = this.parent;
              if (parent !== null) {
                parent.remove(this);
              }
              return this;
            }
          }, {
            key: "clear",
            value: function clear() {
              return this.remove.apply(this, _toConsumableArray(this.children));
            }
          }, {
            key: "attach",
            value: function attach(object) {
              // adds object as a child of this, while maintaining the object's world transform

              // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

              this.updateWorldMatrix(true, false);
              _m1$3.copy(this.matrixWorld).invert();
              if (object.parent !== null) {
                object.parent.updateWorldMatrix(true, false);
                _m1$3.multiply(object.parent.matrixWorld);
              }
              object.applyMatrix4(_m1$3);
              object.removeFromParent();
              object.parent = this;
              this.children.push(object);
              object.updateWorldMatrix(false, true);
              object.dispatchEvent(_addedEvent);
              _childaddedEvent.child = object;
              this.dispatchEvent(_childaddedEvent);
              _childaddedEvent.child = null;
              return this;
            }
          }, {
            key: "getObjectById",
            value: function getObjectById(id) {
              return this.getObjectByProperty('id', id);
            }
          }, {
            key: "getObjectByName",
            value: function getObjectByName(name) {
              return this.getObjectByProperty('name', name);
            }
          }, {
            key: "getObjectByProperty",
            value: function getObjectByProperty(name, value) {
              if (this[name] === value) return this;
              for (var i = 0, l = this.children.length; i < l; i++) {
                var child = this.children[i];
                var object = child.getObjectByProperty(name, value);
                if (object !== undefined) {
                  return object;
                }
              }
              return undefined;
            }
          }, {
            key: "getObjectsByProperty",
            value: function getObjectsByProperty(name, value) {
              var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
              if (this[name] === value) result.push(this);
              var children = this.children;
              for (var i = 0, l = children.length; i < l; i++) {
                children[i].getObjectsByProperty(name, value, result);
              }
              return result;
            }
          }, {
            key: "getWorldPosition",
            value: function getWorldPosition(target) {
              this.updateWorldMatrix(true, false);
              return target.setFromMatrixPosition(this.matrixWorld);
            }
          }, {
            key: "getWorldQuaternion",
            value: function getWorldQuaternion(target) {
              this.updateWorldMatrix(true, false);
              this.matrixWorld.decompose(_position$3, target, _scale$2);
              return target;
            }
          }, {
            key: "getWorldScale",
            value: function getWorldScale(target) {
              this.updateWorldMatrix(true, false);
              this.matrixWorld.decompose(_position$3, _quaternion$2, target);
              return target;
            }
          }, {
            key: "getWorldDirection",
            value: function getWorldDirection(target) {
              this.updateWorldMatrix(true, false);
              var e = this.matrixWorld.elements;
              return target.set(e[8], e[9], e[10]).normalize();
            }
          }, {
            key: "raycast",
            value: function raycast(/* raycaster, intersects */) {}
          }, {
            key: "traverse",
            value: function traverse(callback) {
              callback(this);
              var children = this.children;
              for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverse(callback);
              }
            }
          }, {
            key: "traverseVisible",
            value: function traverseVisible(callback) {
              if (this.visible === false) return;
              callback(this);
              var children = this.children;
              for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverseVisible(callback);
              }
            }
          }, {
            key: "traverseAncestors",
            value: function traverseAncestors(callback) {
              var parent = this.parent;
              if (parent !== null) {
                callback(parent);
                parent.traverseAncestors(callback);
              }
            }
          }, {
            key: "updateMatrix",
            value: function updateMatrix() {
              this.matrix.compose(this.position, this.quaternion, this.scale);
              this.matrixWorldNeedsUpdate = true;
            }
          }, {
            key: "updateMatrixWorld",
            value: function updateMatrixWorld(force) {
              if (this.matrixAutoUpdate) this.updateMatrix();
              if (this.matrixWorldNeedsUpdate || force) {
                if (this.matrixWorldAutoUpdate === true) {
                  if (this.parent === null) {
                    this.matrixWorld.copy(this.matrix);
                  } else {
                    this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                  }
                }
                this.matrixWorldNeedsUpdate = false;
                force = true;
              }

              // make sure descendants are updated if required

              var children = this.children;
              for (var i = 0, l = children.length; i < l; i++) {
                var child = children[i];
                child.updateMatrixWorld(force);
              }
            }
          }, {
            key: "updateWorldMatrix",
            value: function updateWorldMatrix(updateParents, updateChildren) {
              var parent = this.parent;
              if (updateParents === true && parent !== null) {
                parent.updateWorldMatrix(true, false);
              }
              if (this.matrixAutoUpdate) this.updateMatrix();
              if (this.matrixWorldAutoUpdate === true) {
                if (this.parent === null) {
                  this.matrixWorld.copy(this.matrix);
                } else {
                  this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                }
              }

              // make sure descendants are updated

              if (updateChildren === true) {
                var children = this.children;
                for (var i = 0, l = children.length; i < l; i++) {
                  var child = children[i];
                  child.updateWorldMatrix(false, true);
                }
              }
            }
          }, {
            key: "toJSON",
            value: function toJSON(meta) {
              // meta is a string when called from JSON.stringify
              var isRootObject = meta === undefined || typeof meta === 'string';
              var output = {};

              // meta is a hash used to collect geometries, materials.
              // not providing it implies that this is the root object
              // being serialized.
              if (isRootObject) {
                // initialize meta obj
                meta = {
                  geometries: {},
                  materials: {},
                  textures: {},
                  images: {},
                  shapes: {},
                  skeletons: {},
                  animations: {},
                  nodes: {}
                };
                output.metadata = {
                  version: 4.6,
                  type: 'Object',
                  generator: 'Object3D.toJSON'
                };
              }

              // standard Object3D serialization

              var object = {};
              object.uuid = this.uuid;
              object.type = this.type;
              if (this.name !== '') object.name = this.name;
              if (this.castShadow === true) object.castShadow = true;
              if (this.receiveShadow === true) object.receiveShadow = true;
              if (this.visible === false) object.visible = false;
              if (this.frustumCulled === false) object.frustumCulled = false;
              if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
              if (Object.keys(this.userData).length > 0) object.userData = this.userData;
              object.layers = this.layers.mask;
              object.matrix = this.matrix.toArray();
              object.up = this.up.toArray();
              if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

              // object specific properties

              if (this.isInstancedMesh) {
                object.type = 'InstancedMesh';
                object.count = this.count;
                object.instanceMatrix = this.instanceMatrix.toJSON();
                if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
              }
              if (this.isBatchedMesh) {
                object.type = 'BatchedMesh';
                object.perObjectFrustumCulled = this.perObjectFrustumCulled;
                object.sortObjects = this.sortObjects;
                object.drawRanges = this._drawRanges;
                object.reservedRanges = this._reservedRanges;
                object.visibility = this._visibility;
                object.active = this._active;
                object.bounds = this._bounds.map(function (bound) {
                  return {
                    boxInitialized: bound.boxInitialized,
                    boxMin: bound.box.min.toArray(),
                    boxMax: bound.box.max.toArray(),
                    sphereInitialized: bound.sphereInitialized,
                    sphereRadius: bound.sphere.radius,
                    sphereCenter: bound.sphere.center.toArray()
                  };
                });
                object.maxInstanceCount = this._maxInstanceCount;
                object.maxVertexCount = this._maxVertexCount;
                object.maxIndexCount = this._maxIndexCount;
                object.geometryInitialized = this._geometryInitialized;
                object.geometryCount = this._geometryCount;
                object.matricesTexture = this._matricesTexture.toJSON(meta);
                if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);
                if (this.boundingSphere !== null) {
                  object.boundingSphere = {
                    center: object.boundingSphere.center.toArray(),
                    radius: object.boundingSphere.radius
                  };
                }
                if (this.boundingBox !== null) {
                  object.boundingBox = {
                    min: object.boundingBox.min.toArray(),
                    max: object.boundingBox.max.toArray()
                  };
                }
              }

              //

              function serialize(library, element) {
                if (library[element.uuid] === undefined) {
                  library[element.uuid] = element.toJSON(meta);
                }
                return element.uuid;
              }
              if (this.isScene) {
                if (this.background) {
                  if (this.background.isColor) {
                    object.background = this.background.toJSON();
                  } else if (this.background.isTexture) {
                    object.background = this.background.toJSON(meta).uuid;
                  }
                }
                if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
                  object.environment = this.environment.toJSON(meta).uuid;
                }
              } else if (this.isMesh || this.isLine || this.isPoints) {
                object.geometry = serialize(meta.geometries, this.geometry);
                var parameters = this.geometry.parameters;
                if (parameters !== undefined && parameters.shapes !== undefined) {
                  var shapes = parameters.shapes;
                  if (Array.isArray(shapes)) {
                    for (var i = 0, l = shapes.length; i < l; i++) {
                      var shape = shapes[i];
                      serialize(meta.shapes, shape);
                    }
                  } else {
                    serialize(meta.shapes, shapes);
                  }
                }
              }
              if (this.isSkinnedMesh) {
                object.bindMode = this.bindMode;
                object.bindMatrix = this.bindMatrix.toArray();
                if (this.skeleton !== undefined) {
                  serialize(meta.skeletons, this.skeleton);
                  object.skeleton = this.skeleton.uuid;
                }
              }
              if (this.material !== undefined) {
                if (Array.isArray(this.material)) {
                  var uuids = [];
                  for (var _i12 = 0, _l3 = this.material.length; _i12 < _l3; _i12++) {
                    uuids.push(serialize(meta.materials, this.material[_i12]));
                  }
                  object.material = uuids;
                } else {
                  object.material = serialize(meta.materials, this.material);
                }
              }

              //

              if (this.children.length > 0) {
                object.children = [];
                for (var _i13 = 0; _i13 < this.children.length; _i13++) {
                  object.children.push(this.children[_i13].toJSON(meta).object);
                }
              }

              //

              if (this.animations.length > 0) {
                object.animations = [];
                for (var _i14 = 0; _i14 < this.animations.length; _i14++) {
                  var animation = this.animations[_i14];
                  object.animations.push(serialize(meta.animations, animation));
                }
              }
              if (isRootObject) {
                var geometries = extractFromCache(meta.geometries);
                var materials = extractFromCache(meta.materials);
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                var _shapes = extractFromCache(meta.shapes);
                var skeletons = extractFromCache(meta.skeletons);
                var animations = extractFromCache(meta.animations);
                var nodes = extractFromCache(meta.nodes);
                if (geometries.length > 0) output.geometries = geometries;
                if (materials.length > 0) output.materials = materials;
                if (textures.length > 0) output.textures = textures;
                if (images.length > 0) output.images = images;
                if (_shapes.length > 0) output.shapes = _shapes;
                if (skeletons.length > 0) output.skeletons = skeletons;
                if (animations.length > 0) output.animations = animations;
                if (nodes.length > 0) output.nodes = nodes;
              }
              output.object = object;
              return output;

              // extract data from the cache hash
              // remove metadata on each item
              // and return as array
              function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                  var data = cache[key];
                  delete data.metadata;
                  values.push(data);
                }
                return values;
              }
            }
          }, {
            key: "clone",
            value: function clone(recursive) {
              return new this.constructor().copy(this, recursive);
            }
          }, {
            key: "copy",
            value: function copy(source) {
              var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
              this.name = source.name;
              this.up.copy(source.up);
              this.position.copy(source.position);
              this.rotation.order = source.rotation.order;
              this.quaternion.copy(source.quaternion);
              this.scale.copy(source.scale);
              this.matrix.copy(source.matrix);
              this.matrixWorld.copy(source.matrixWorld);
              this.matrixAutoUpdate = source.matrixAutoUpdate;
              this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
              this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
              this.layers.mask = source.layers.mask;
              this.visible = source.visible;
              this.castShadow = source.castShadow;
              this.receiveShadow = source.receiveShadow;
              this.frustumCulled = source.frustumCulled;
              this.renderOrder = source.renderOrder;
              this.animations = source.animations.slice();
              this.userData = JSON.parse(JSON.stringify(source.userData));
              if (recursive === true) {
                for (var i = 0; i < source.children.length; i++) {
                  var child = source.children[i];
                  this.add(child.clone());
                }
              }
              return this;
            }
          }]);
        }(EventDispatcher);
        Object3D.DEFAULT_UP = /*@__PURE__*/new Vector3(0, 1, 0);
        Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
        Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
        var _v0$1 = /*@__PURE__*/new Vector3();
        var _v1$3 = /*@__PURE__*/new Vector3();
        var _v2$2 = /*@__PURE__*/new Vector3();
        var _v3$2 = /*@__PURE__*/new Vector3();
        var _vab = /*@__PURE__*/new Vector3();
        var _vac = /*@__PURE__*/new Vector3();
        var _vbc = /*@__PURE__*/new Vector3();
        var _vap = /*@__PURE__*/new Vector3();
        var _vbp = /*@__PURE__*/new Vector3();
        var _vcp = /*@__PURE__*/new Vector3();
        var Triangle = /*#__PURE__*/function () {
          function Triangle() {
            var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
            var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
            var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();
            _classCallCheck2(this, Triangle);
            this.a = a;
            this.b = b;
            this.c = c;
          }
          return _createClass(Triangle, [{
            key: "set",
            value: function set(a, b, c) {
              this.a.copy(a);
              this.b.copy(b);
              this.c.copy(c);
              return this;
            }
          }, {
            key: "setFromPointsAndIndices",
            value: function setFromPointsAndIndices(points, i0, i1, i2) {
              this.a.copy(points[i0]);
              this.b.copy(points[i1]);
              this.c.copy(points[i2]);
              return this;
            }
          }, {
            key: "setFromAttributeAndIndices",
            value: function setFromAttributeAndIndices(attribute, i0, i1, i2) {
              this.a.fromBufferAttribute(attribute, i0);
              this.b.fromBufferAttribute(attribute, i1);
              this.c.fromBufferAttribute(attribute, i2);
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }, {
            key: "copy",
            value: function copy(triangle) {
              this.a.copy(triangle.a);
              this.b.copy(triangle.b);
              this.c.copy(triangle.c);
              return this;
            }
          }, {
            key: "getArea",
            value: function getArea() {
              _v0$1.subVectors(this.c, this.b);
              _v1$3.subVectors(this.a, this.b);
              return _v0$1.cross(_v1$3).length() * 0.5;
            }
          }, {
            key: "getMidpoint",
            value: function getMidpoint(target) {
              return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
            }
          }, {
            key: "getNormal",
            value: function getNormal(target) {
              return Triangle.getNormal(this.a, this.b, this.c, target);
            }
          }, {
            key: "getPlane",
            value: function getPlane(target) {
              return target.setFromCoplanarPoints(this.a, this.b, this.c);
            }
          }, {
            key: "getBarycoord",
            value: function getBarycoord(point, target) {
              return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
            }
          }, {
            key: "getInterpolation",
            value: function getInterpolation(point, v1, v2, v3, target) {
              return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
            }
          }, {
            key: "containsPoint",
            value: function containsPoint(point) {
              return Triangle.containsPoint(point, this.a, this.b, this.c);
            }
          }, {
            key: "isFrontFacing",
            value: function isFrontFacing(direction) {
              return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
            }
          }, {
            key: "intersectsBox",
            value: function intersectsBox(box) {
              return box.intersectsTriangle(this);
            }
          }, {
            key: "closestPointToPoint",
            value: function closestPointToPoint(p, target) {
              var a = this.a,
                b = this.b,
                c = this.c;
              var v, w;

              // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
              // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
              // under the accompanying license; see chapter 5.1.5 for detailed explanation.
              // basically, we're distinguishing which of the voronoi regions of the triangle
              // the point lies in with the minimum amount of redundant computation.

              _vab.subVectors(b, a);
              _vac.subVectors(c, a);
              _vap.subVectors(p, a);
              var d1 = _vab.dot(_vap);
              var d2 = _vac.dot(_vap);
              if (d1 <= 0 && d2 <= 0) {
                // vertex region of A; barycentric coords (1, 0, 0)
                return target.copy(a);
              }
              _vbp.subVectors(p, b);
              var d3 = _vab.dot(_vbp);
              var d4 = _vac.dot(_vbp);
              if (d3 >= 0 && d4 <= d3) {
                // vertex region of B; barycentric coords (0, 1, 0)
                return target.copy(b);
              }
              var vc = d1 * d4 - d3 * d2;
              if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                v = d1 / (d1 - d3);
                // edge region of AB; barycentric coords (1-v, v, 0)
                return target.copy(a).addScaledVector(_vab, v);
              }
              _vcp.subVectors(p, c);
              var d5 = _vab.dot(_vcp);
              var d6 = _vac.dot(_vcp);
              if (d6 >= 0 && d5 <= d6) {
                // vertex region of C; barycentric coords (0, 0, 1)
                return target.copy(c);
              }
              var vb = d5 * d2 - d1 * d6;
              if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                w = d2 / (d2 - d6);
                // edge region of AC; barycentric coords (1-w, 0, w)
                return target.copy(a).addScaledVector(_vac, w);
              }
              var va = d3 * d6 - d5 * d4;
              if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
                _vbc.subVectors(c, b);
                w = (d4 - d3) / (d4 - d3 + (d5 - d6));
                // edge region of BC; barycentric coords (0, 1-w, w)
                return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
              }

              // face region
              var denom = 1 / (va + vb + vc);
              // u = va * denom
              v = vb * denom;
              w = vc * denom;
              return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
            }
          }, {
            key: "equals",
            value: function equals(triangle) {
              return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
            }
          }], [{
            key: "getNormal",
            value: function getNormal(a, b, c, target) {
              target.subVectors(c, b);
              _v0$1.subVectors(a, b);
              target.cross(_v0$1);
              var targetLengthSq = target.lengthSq();
              if (targetLengthSq > 0) {
                return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
              }
              return target.set(0, 0, 0);
            }

            // static/instance method to calculate barycentric coordinates
            // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
          }, {
            key: "getBarycoord",
            value: function getBarycoord(point, a, b, c, target) {
              _v0$1.subVectors(c, a);
              _v1$3.subVectors(b, a);
              _v2$2.subVectors(point, a);
              var dot00 = _v0$1.dot(_v0$1);
              var dot01 = _v0$1.dot(_v1$3);
              var dot02 = _v0$1.dot(_v2$2);
              var dot11 = _v1$3.dot(_v1$3);
              var dot12 = _v1$3.dot(_v2$2);
              var denom = dot00 * dot11 - dot01 * dot01;

              // collinear or singular triangle
              if (denom === 0) {
                target.set(0, 0, 0);
                return null;
              }
              var invDenom = 1 / denom;
              var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
              var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

              // barycentric coordinates must always sum to 1
              return target.set(1 - u - v, v, u);
            }
          }, {
            key: "containsPoint",
            value: function containsPoint(point, a, b, c) {
              // if the triangle is degenerate then we can't contain a point
              if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
                return false;
              }
              return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
            }
          }, {
            key: "getInterpolation",
            value: function getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
              if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
                target.x = 0;
                target.y = 0;
                if ('z' in target) target.z = 0;
                if ('w' in target) target.w = 0;
                return null;
              }
              target.setScalar(0);
              target.addScaledVector(v1, _v3$2.x);
              target.addScaledVector(v2, _v3$2.y);
              target.addScaledVector(v3, _v3$2.z);
              return target;
            }
          }, {
            key: "isFrontFacing",
            value: function isFrontFacing(a, b, c, direction) {
              _v0$1.subVectors(c, b);
              _v1$3.subVectors(a, b);

              // strictly front facing
              return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
            }
          }]);
        }();
        var _colorKeywords = {
          'aliceblue': 0xF0F8FF,
          'antiquewhite': 0xFAEBD7,
          'aqua': 0x00FFFF,
          'aquamarine': 0x7FFFD4,
          'azure': 0xF0FFFF,
          'beige': 0xF5F5DC,
          'bisque': 0xFFE4C4,
          'black': 0x000000,
          'blanchedalmond': 0xFFEBCD,
          'blue': 0x0000FF,
          'blueviolet': 0x8A2BE2,
          'brown': 0xA52A2A,
          'burlywood': 0xDEB887,
          'cadetblue': 0x5F9EA0,
          'chartreuse': 0x7FFF00,
          'chocolate': 0xD2691E,
          'coral': 0xFF7F50,
          'cornflowerblue': 0x6495ED,
          'cornsilk': 0xFFF8DC,
          'crimson': 0xDC143C,
          'cyan': 0x00FFFF,
          'darkblue': 0x00008B,
          'darkcyan': 0x008B8B,
          'darkgoldenrod': 0xB8860B,
          'darkgray': 0xA9A9A9,
          'darkgreen': 0x006400,
          'darkgrey': 0xA9A9A9,
          'darkkhaki': 0xBDB76B,
          'darkmagenta': 0x8B008B,
          'darkolivegreen': 0x556B2F,
          'darkorange': 0xFF8C00,
          'darkorchid': 0x9932CC,
          'darkred': 0x8B0000,
          'darksalmon': 0xE9967A,
          'darkseagreen': 0x8FBC8F,
          'darkslateblue': 0x483D8B,
          'darkslategray': 0x2F4F4F,
          'darkslategrey': 0x2F4F4F,
          'darkturquoise': 0x00CED1,
          'darkviolet': 0x9400D3,
          'deeppink': 0xFF1493,
          'deepskyblue': 0x00BFFF,
          'dimgray': 0x696969,
          'dimgrey': 0x696969,
          'dodgerblue': 0x1E90FF,
          'firebrick': 0xB22222,
          'floralwhite': 0xFFFAF0,
          'forestgreen': 0x228B22,
          'fuchsia': 0xFF00FF,
          'gainsboro': 0xDCDCDC,
          'ghostwhite': 0xF8F8FF,
          'gold': 0xFFD700,
          'goldenrod': 0xDAA520,
          'gray': 0x808080,
          'green': 0x008000,
          'greenyellow': 0xADFF2F,
          'grey': 0x808080,
          'honeydew': 0xF0FFF0,
          'hotpink': 0xFF69B4,
          'indianred': 0xCD5C5C,
          'indigo': 0x4B0082,
          'ivory': 0xFFFFF0,
          'khaki': 0xF0E68C,
          'lavender': 0xE6E6FA,
          'lavenderblush': 0xFFF0F5,
          'lawngreen': 0x7CFC00,
          'lemonchiffon': 0xFFFACD,
          'lightblue': 0xADD8E6,
          'lightcoral': 0xF08080,
          'lightcyan': 0xE0FFFF,
          'lightgoldenrodyellow': 0xFAFAD2,
          'lightgray': 0xD3D3D3,
          'lightgreen': 0x90EE90,
          'lightgrey': 0xD3D3D3,
          'lightpink': 0xFFB6C1,
          'lightsalmon': 0xFFA07A,
          'lightseagreen': 0x20B2AA,
          'lightskyblue': 0x87CEFA,
          'lightslategray': 0x778899,
          'lightslategrey': 0x778899,
          'lightsteelblue': 0xB0C4DE,
          'lightyellow': 0xFFFFE0,
          'lime': 0x00FF00,
          'limegreen': 0x32CD32,
          'linen': 0xFAF0E6,
          'magenta': 0xFF00FF,
          'maroon': 0x800000,
          'mediumaquamarine': 0x66CDAA,
          'mediumblue': 0x0000CD,
          'mediumorchid': 0xBA55D3,
          'mediumpurple': 0x9370DB,
          'mediumseagreen': 0x3CB371,
          'mediumslateblue': 0x7B68EE,
          'mediumspringgreen': 0x00FA9A,
          'mediumturquoise': 0x48D1CC,
          'mediumvioletred': 0xC71585,
          'midnightblue': 0x191970,
          'mintcream': 0xF5FFFA,
          'mistyrose': 0xFFE4E1,
          'moccasin': 0xFFE4B5,
          'navajowhite': 0xFFDEAD,
          'navy': 0x000080,
          'oldlace': 0xFDF5E6,
          'olive': 0x808000,
          'olivedrab': 0x6B8E23,
          'orange': 0xFFA500,
          'orangered': 0xFF4500,
          'orchid': 0xDA70D6,
          'palegoldenrod': 0xEEE8AA,
          'palegreen': 0x98FB98,
          'paleturquoise': 0xAFEEEE,
          'palevioletred': 0xDB7093,
          'papayawhip': 0xFFEFD5,
          'peachpuff': 0xFFDAB9,
          'peru': 0xCD853F,
          'pink': 0xFFC0CB,
          'plum': 0xDDA0DD,
          'powderblue': 0xB0E0E6,
          'purple': 0x800080,
          'rebeccapurple': 0x663399,
          'red': 0xFF0000,
          'rosybrown': 0xBC8F8F,
          'royalblue': 0x4169E1,
          'saddlebrown': 0x8B4513,
          'salmon': 0xFA8072,
          'sandybrown': 0xF4A460,
          'seagreen': 0x2E8B57,
          'seashell': 0xFFF5EE,
          'sienna': 0xA0522D,
          'silver': 0xC0C0C0,
          'skyblue': 0x87CEEB,
          'slateblue': 0x6A5ACD,
          'slategray': 0x708090,
          'slategrey': 0x708090,
          'snow': 0xFFFAFA,
          'springgreen': 0x00FF7F,
          'steelblue': 0x4682B4,
          'tan': 0xD2B48C,
          'teal': 0x008080,
          'thistle': 0xD8BFD8,
          'tomato': 0xFF6347,
          'turquoise': 0x40E0D0,
          'violet': 0xEE82EE,
          'wheat': 0xF5DEB3,
          'white': 0xFFFFFF,
          'whitesmoke': 0xF5F5F5,
          'yellow': 0xFFFF00,
          'yellowgreen': 0x9ACD32
        };
        var _hslA = {
          h: 0,
          s: 0,
          l: 0
        };
        var _hslB = {
          h: 0,
          s: 0,
          l: 0
        };
        function hue2rgb(p, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
          return p;
        }
        var Color = /*#__PURE__*/function () {
          function Color(r, g, b) {
            _classCallCheck2(this, Color);
            this.isColor = true;
            this.r = 1;
            this.g = 1;
            this.b = 1;
            return this.set(r, g, b);
          }
          return _createClass(Color, [{
            key: "set",
            value: function set(r, g, b) {
              if (g === undefined && b === undefined) {
                // r is THREE.Color, hex or string

                var value = r;
                if (value && value.isColor) {
                  this.copy(value);
                } else if (typeof value === 'number') {
                  this.setHex(value);
                } else if (typeof value === 'string') {
                  this.setStyle(value);
                }
              } else {
                this.setRGB(r, g, b);
              }
              return this;
            }
          }, {
            key: "setScalar",
            value: function setScalar(scalar) {
              this.r = scalar;
              this.g = scalar;
              this.b = scalar;
              return this;
            }
          }, {
            key: "setHex",
            value: function setHex(hex) {
              var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;
              hex = Math.floor(hex);
              this.r = (hex >> 16 & 255) / 255;
              this.g = (hex >> 8 & 255) / 255;
              this.b = (hex & 255) / 255;
              ColorManagement.toWorkingColorSpace(this, colorSpace);
              return this;
            }
          }, {
            key: "setRGB",
            value: function setRGB(r, g, b) {
              var colorSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ColorManagement.workingColorSpace;
              this.r = r;
              this.g = g;
              this.b = b;
              ColorManagement.toWorkingColorSpace(this, colorSpace);
              return this;
            }
          }, {
            key: "setHSL",
            value: function setHSL(h, s, l) {
              var colorSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ColorManagement.workingColorSpace;
              // h,s,l ranges are in 0.0 - 1.0
              h = euclideanModulo(h, 1);
              s = clamp(s, 0, 1);
              l = clamp(l, 0, 1);
              if (s === 0) {
                this.r = this.g = this.b = l;
              } else {
                var _p2 = l <= 0.5 ? l * (1 + s) : l + s - l * s;
                var q = 2 * l - _p2;
                this.r = hue2rgb(q, _p2, h + 1 / 3);
                this.g = hue2rgb(q, _p2, h);
                this.b = hue2rgb(q, _p2, h - 1 / 3);
              }
              ColorManagement.toWorkingColorSpace(this, colorSpace);
              return this;
            }
          }, {
            key: "setStyle",
            value: function setStyle(style) {
              var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;
              function handleAlpha(string) {
                if (string === undefined) return;
                if (parseFloat(string) < 1) {
                  console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
                }
              }
              var m;
              if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
                // rgb / hsl

                var color;
                var name = m[1];
                var components = m[2];
                switch (name) {
                  case 'rgb':
                  case 'rgba':
                    if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                      // rgb(255,0,0) rgba(255,0,0,0.5)

                      handleAlpha(color[4]);
                      return this.setRGB(Math.min(255, parseInt(color[1], 10)) / 255, Math.min(255, parseInt(color[2], 10)) / 255, Math.min(255, parseInt(color[3], 10)) / 255, colorSpace);
                    }
                    if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                      // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

                      handleAlpha(color[4]);
                      return this.setRGB(Math.min(100, parseInt(color[1], 10)) / 100, Math.min(100, parseInt(color[2], 10)) / 100, Math.min(100, parseInt(color[3], 10)) / 100, colorSpace);
                    }
                    break;
                  case 'hsl':
                  case 'hsla':
                    if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                      // hsl(120,50%,50%) hsla(120,50%,50%,0.5)

                      handleAlpha(color[4]);
                      return this.setHSL(parseFloat(color[1]) / 360, parseFloat(color[2]) / 100, parseFloat(color[3]) / 100, colorSpace);
                    }
                    break;
                  default:
                    console.warn('THREE.Color: Unknown color model ' + style);
                }
              } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
                // hex color

                var hex = m[1];
                var size = hex.length;
                if (size === 3) {
                  // #ff0
                  return this.setRGB(parseInt(hex.charAt(0), 16) / 15, parseInt(hex.charAt(1), 16) / 15, parseInt(hex.charAt(2), 16) / 15, colorSpace);
                } else if (size === 6) {
                  // #ff0000
                  return this.setHex(parseInt(hex, 16), colorSpace);
                } else {
                  console.warn('THREE.Color: Invalid hex color ' + style);
                }
              } else if (style && style.length > 0) {
                return this.setColorName(style, colorSpace);
              }
              return this;
            }
          }, {
            key: "setColorName",
            value: function setColorName(style) {
              var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;
              // color keywords
              var hex = _colorKeywords[style.toLowerCase()];
              if (hex !== undefined) {
                // red
                this.setHex(hex, colorSpace);
              } else {
                // unknown color
                console.warn('THREE.Color: Unknown color ' + style);
              }
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor(this.r, this.g, this.b);
            }
          }, {
            key: "copy",
            value: function copy(color) {
              this.r = color.r;
              this.g = color.g;
              this.b = color.b;
              return this;
            }
          }, {
            key: "copySRGBToLinear",
            value: function copySRGBToLinear(color) {
              this.r = SRGBToLinear(color.r);
              this.g = SRGBToLinear(color.g);
              this.b = SRGBToLinear(color.b);
              return this;
            }
          }, {
            key: "copyLinearToSRGB",
            value: function copyLinearToSRGB(color) {
              this.r = LinearToSRGB(color.r);
              this.g = LinearToSRGB(color.g);
              this.b = LinearToSRGB(color.b);
              return this;
            }
          }, {
            key: "convertSRGBToLinear",
            value: function convertSRGBToLinear() {
              this.copySRGBToLinear(this);
              return this;
            }
          }, {
            key: "convertLinearToSRGB",
            value: function convertLinearToSRGB() {
              this.copyLinearToSRGB(this);
              return this;
            }
          }, {
            key: "getHex",
            value: function getHex() {
              var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;
              ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
              return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
            }
          }, {
            key: "getHexString",
            value: function getHexString() {
              var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;
              return ('000000' + this.getHex(colorSpace).toString(16)).slice(-6);
            }
          }, {
            key: "getHSL",
            value: function getHSL(target) {
              var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ColorManagement.workingColorSpace;
              // h,s,l ranges are in 0.0 - 1.0

              ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
              var r = _color.r,
                g = _color.g,
                b = _color.b;
              var max = Math.max(r, g, b);
              var min = Math.min(r, g, b);
              var hue, saturation;
              var lightness = (min + max) / 2.0;
              if (min === max) {
                hue = 0;
                saturation = 0;
              } else {
                var delta = max - min;
                saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
                switch (max) {
                  case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;
                  case g:
                    hue = (b - r) / delta + 2;
                    break;
                  case b:
                    hue = (r - g) / delta + 4;
                    break;
                }
                hue /= 6;
              }
              target.h = hue;
              target.s = saturation;
              target.l = lightness;
              return target;
            }
          }, {
            key: "getRGB",
            value: function getRGB(target) {
              var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ColorManagement.workingColorSpace;
              ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
              target.r = _color.r;
              target.g = _color.g;
              target.b = _color.b;
              return target;
            }
          }, {
            key: "getStyle",
            value: function getStyle() {
              var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;
              ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
              var r = _color.r,
                g = _color.g,
                b = _color.b;
              if (colorSpace !== SRGBColorSpace) {
                // Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
                return "color(".concat(colorSpace, " ").concat(r.toFixed(3), " ").concat(g.toFixed(3), " ").concat(b.toFixed(3), ")");
              }
              return "rgb(".concat(Math.round(r * 255), ",").concat(Math.round(g * 255), ",").concat(Math.round(b * 255), ")");
            }
          }, {
            key: "offsetHSL",
            value: function offsetHSL(h, s, l) {
              this.getHSL(_hslA);
              return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
            }
          }, {
            key: "add",
            value: function add(color) {
              this.r += color.r;
              this.g += color.g;
              this.b += color.b;
              return this;
            }
          }, {
            key: "addColors",
            value: function addColors(color1, color2) {
              this.r = color1.r + color2.r;
              this.g = color1.g + color2.g;
              this.b = color1.b + color2.b;
              return this;
            }
          }, {
            key: "addScalar",
            value: function addScalar(s) {
              this.r += s;
              this.g += s;
              this.b += s;
              return this;
            }
          }, {
            key: "sub",
            value: function sub(color) {
              this.r = Math.max(0, this.r - color.r);
              this.g = Math.max(0, this.g - color.g);
              this.b = Math.max(0, this.b - color.b);
              return this;
            }
          }, {
            key: "multiply",
            value: function multiply(color) {
              this.r *= color.r;
              this.g *= color.g;
              this.b *= color.b;
              return this;
            }
          }, {
            key: "multiplyScalar",
            value: function multiplyScalar(s) {
              this.r *= s;
              this.g *= s;
              this.b *= s;
              return this;
            }
          }, {
            key: "lerp",
            value: function lerp(color, alpha) {
              this.r += (color.r - this.r) * alpha;
              this.g += (color.g - this.g) * alpha;
              this.b += (color.b - this.b) * alpha;
              return this;
            }
          }, {
            key: "lerpColors",
            value: function lerpColors(color1, color2, alpha) {
              this.r = color1.r + (color2.r - color1.r) * alpha;
              this.g = color1.g + (color2.g - color1.g) * alpha;
              this.b = color1.b + (color2.b - color1.b) * alpha;
              return this;
            }
          }, {
            key: "lerpHSL",
            value: function lerpHSL(color, alpha) {
              this.getHSL(_hslA);
              color.getHSL(_hslB);
              var h = lerp(_hslA.h, _hslB.h, alpha);
              var s = lerp(_hslA.s, _hslB.s, alpha);
              var l = lerp(_hslA.l, _hslB.l, alpha);
              this.setHSL(h, s, l);
              return this;
            }
          }, {
            key: "setFromVector3",
            value: function setFromVector3(v) {
              this.r = v.x;
              this.g = v.y;
              this.b = v.z;
              return this;
            }
          }, {
            key: "applyMatrix3",
            value: function applyMatrix3(m) {
              var r = this.r,
                g = this.g,
                b = this.b;
              var e = m.elements;
              this.r = e[0] * r + e[3] * g + e[6] * b;
              this.g = e[1] * r + e[4] * g + e[7] * b;
              this.b = e[2] * r + e[5] * g + e[8] * b;
              return this;
            }
          }, {
            key: "equals",
            value: function equals(c) {
              return c.r === this.r && c.g === this.g && c.b === this.b;
            }
          }, {
            key: "fromArray",
            value: function fromArray(array) {
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              this.r = array[offset];
              this.g = array[offset + 1];
              this.b = array[offset + 2];
              return this;
            }
          }, {
            key: "toArray",
            value: function toArray() {
              var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              array[offset] = this.r;
              array[offset + 1] = this.g;
              array[offset + 2] = this.b;
              return array;
            }
          }, {
            key: "fromBufferAttribute",
            value: function fromBufferAttribute(attribute, index) {
              this.r = attribute.getX(index);
              this.g = attribute.getY(index);
              this.b = attribute.getZ(index);
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              return this.getHex();
            }
          }, {
            key: Symbol.iterator,
            value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
              return _regeneratorRuntime().wrap(function value$(_context13) {
                while (1) switch (_context13.prev = _context13.next) {
                  case 0:
                    _context13.next = 2;
                    return this.r;
                  case 2:
                    _context13.next = 4;
                    return this.g;
                  case 4:
                    _context13.next = 6;
                    return this.b;
                  case 6:
                  case "end":
                    return _context13.stop();
                }
              }, value, this);
            })
          }]);
        }();
        var _color = /*@__PURE__*/new Color();
        Color.NAMES = _colorKeywords;
        var _materialId = 0;
        var Material = /*#__PURE__*/function (_EventDispatcher4) {
          function Material() {
            var _this23;
            _classCallCheck2(this, Material);
            _this23 = _callSuper(this, Material);
            _this23.isMaterial = true;
            Object.defineProperty(_this23, 'id', {
              value: _materialId++
            });
            _this23.uuid = generateUUID();
            _this23.name = '';
            _this23.type = 'Material';
            _this23.blending = NormalBlending;
            _this23.side = FrontSide;
            _this23.vertexColors = false;
            _this23.opacity = 1;
            _this23.transparent = false;
            _this23.alphaHash = false;
            _this23.blendSrc = SrcAlphaFactor;
            _this23.blendDst = OneMinusSrcAlphaFactor;
            _this23.blendEquation = AddEquation;
            _this23.blendSrcAlpha = null;
            _this23.blendDstAlpha = null;
            _this23.blendEquationAlpha = null;
            _this23.blendColor = new Color(0, 0, 0);
            _this23.blendAlpha = 0;
            _this23.depthFunc = LessEqualDepth;
            _this23.depthTest = true;
            _this23.depthWrite = true;
            _this23.stencilWriteMask = 0xff;
            _this23.stencilFunc = AlwaysStencilFunc;
            _this23.stencilRef = 0;
            _this23.stencilFuncMask = 0xff;
            _this23.stencilFail = KeepStencilOp;
            _this23.stencilZFail = KeepStencilOp;
            _this23.stencilZPass = KeepStencilOp;
            _this23.stencilWrite = false;
            _this23.clippingPlanes = null;
            _this23.clipIntersection = false;
            _this23.clipShadows = false;
            _this23.shadowSide = null;
            _this23.colorWrite = true;
            _this23.precision = null; // override the renderer's default precision for this material

            _this23.polygonOffset = false;
            _this23.polygonOffsetFactor = 0;
            _this23.polygonOffsetUnits = 0;
            _this23.dithering = false;
            _this23.alphaToCoverage = false;
            _this23.premultipliedAlpha = false;
            _this23.forceSinglePass = false;
            _this23.visible = true;
            _this23.toneMapped = true;
            _this23.userData = {};
            _this23.version = 0;
            _this23._alphaTest = 0;
            return _this23;
          }
          _inherits(Material, _EventDispatcher4);
          return _createClass(Material, [{
            key: "alphaTest",
            get: function get() {
              return this._alphaTest;
            },
            set: function set(value) {
              if (this._alphaTest > 0 !== value > 0) {
                this.version++;
              }
              this._alphaTest = value;
            }
          }, {
            key: "onBeforeCompile",
            value: function onBeforeCompile(/* shaderobject, renderer */) {}
          }, {
            key: "customProgramCacheKey",
            value: function customProgramCacheKey() {
              return this.onBeforeCompile.toString();
            }
          }, {
            key: "setValues",
            value: function setValues(values) {
              if (values === undefined) return;
              for (var key in values) {
                var newValue = values[key];
                if (newValue === undefined) {
                  console.warn("THREE.Material: parameter '".concat(key, "' has value of undefined."));
                  continue;
                }
                var currentValue = this[key];
                if (currentValue === undefined) {
                  console.warn("THREE.Material: '".concat(key, "' is not a property of THREE.").concat(this.type, "."));
                  continue;
                }
                if (currentValue && currentValue.isColor) {
                  currentValue.set(newValue);
                } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
                  currentValue.copy(newValue);
                } else {
                  this[key] = newValue;
                }
              }
            }
          }, {
            key: "toJSON",
            value: function toJSON(meta) {
              var isRootObject = meta === undefined || typeof meta === 'string';
              if (isRootObject) {
                meta = {
                  textures: {},
                  images: {}
                };
              }
              var data = {
                metadata: {
                  version: 4.6,
                  type: 'Material',
                  generator: 'Material.toJSON'
                }
              };

              // standard Material serialization
              data.uuid = this.uuid;
              data.type = this.type;
              if (this.name !== '') data.name = this.name;
              if (this.color && this.color.isColor) data.color = this.color.getHex();
              if (this.roughness !== undefined) data.roughness = this.roughness;
              if (this.metalness !== undefined) data.metalness = this.metalness;
              if (this.sheen !== undefined) data.sheen = this.sheen;
              if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
              if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;
              if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
              if (this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
              if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
              if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
              if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
              if (this.shininess !== undefined) data.shininess = this.shininess;
              if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
              if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
              if (this.clearcoatMap && this.clearcoatMap.isTexture) {
                data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
              }
              if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
                data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
              }
              if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
                data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
                data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
              }
              if (this.dispersion !== undefined) data.dispersion = this.dispersion;
              if (this.iridescence !== undefined) data.iridescence = this.iridescence;
              if (this.iridescenceIOR !== undefined) data.iridescenceIOR = this.iridescenceIOR;
              if (this.iridescenceThicknessRange !== undefined) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
              if (this.iridescenceMap && this.iridescenceMap.isTexture) {
                data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
              }
              if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
                data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
              }
              if (this.anisotropy !== undefined) data.anisotropy = this.anisotropy;
              if (this.anisotropyRotation !== undefined) data.anisotropyRotation = this.anisotropyRotation;
              if (this.anisotropyMap && this.anisotropyMap.isTexture) {
                data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
              }
              if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
              if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
              if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
              if (this.lightMap && this.lightMap.isTexture) {
                data.lightMap = this.lightMap.toJSON(meta).uuid;
                data.lightMapIntensity = this.lightMapIntensity;
              }
              if (this.aoMap && this.aoMap.isTexture) {
                data.aoMap = this.aoMap.toJSON(meta).uuid;
                data.aoMapIntensity = this.aoMapIntensity;
              }
              if (this.bumpMap && this.bumpMap.isTexture) {
                data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                data.bumpScale = this.bumpScale;
              }
              if (this.normalMap && this.normalMap.isTexture) {
                data.normalMap = this.normalMap.toJSON(meta).uuid;
                data.normalMapType = this.normalMapType;
                data.normalScale = this.normalScale.toArray();
              }
              if (this.displacementMap && this.displacementMap.isTexture) {
                data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                data.displacementScale = this.displacementScale;
                data.displacementBias = this.displacementBias;
              }
              if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
              if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
              if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
              if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
              if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
              if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
              if (this.envMap && this.envMap.isTexture) {
                data.envMap = this.envMap.toJSON(meta).uuid;
                if (this.combine !== undefined) data.combine = this.combine;
              }
              if (this.envMapRotation !== undefined) data.envMapRotation = this.envMapRotation.toArray();
              if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
              if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
              if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;
              if (this.gradientMap && this.gradientMap.isTexture) {
                data.gradientMap = this.gradientMap.toJSON(meta).uuid;
              }
              if (this.transmission !== undefined) data.transmission = this.transmission;
              if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
              if (this.thickness !== undefined) data.thickness = this.thickness;
              if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
              if (this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
              if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();
              if (this.size !== undefined) data.size = this.size;
              if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
              if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
              if (this.blending !== NormalBlending) data.blending = this.blending;
              if (this.side !== FrontSide) data.side = this.side;
              if (this.vertexColors === true) data.vertexColors = true;
              if (this.opacity < 1) data.opacity = this.opacity;
              if (this.transparent === true) data.transparent = true;
              if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
              if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
              if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
              if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
              if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
              if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
              if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
              if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
              if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
              if (this.depthTest === false) data.depthTest = this.depthTest;
              if (this.depthWrite === false) data.depthWrite = this.depthWrite;
              if (this.colorWrite === false) data.colorWrite = this.colorWrite;
              if (this.stencilWriteMask !== 0xff) data.stencilWriteMask = this.stencilWriteMask;
              if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
              if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
              if (this.stencilFuncMask !== 0xff) data.stencilFuncMask = this.stencilFuncMask;
              if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
              if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
              if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
              if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;

              // rotation (SpriteMaterial)
              if (this.rotation !== undefined && this.rotation !== 0) data.rotation = this.rotation;
              if (this.polygonOffset === true) data.polygonOffset = true;
              if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
              if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
              if (this.linewidth !== undefined && this.linewidth !== 1) data.linewidth = this.linewidth;
              if (this.dashSize !== undefined) data.dashSize = this.dashSize;
              if (this.gapSize !== undefined) data.gapSize = this.gapSize;
              if (this.scale !== undefined) data.scale = this.scale;
              if (this.dithering === true) data.dithering = true;
              if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
              if (this.alphaHash === true) data.alphaHash = true;
              if (this.alphaToCoverage === true) data.alphaToCoverage = true;
              if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
              if (this.forceSinglePass === true) data.forceSinglePass = true;
              if (this.wireframe === true) data.wireframe = true;
              if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
              if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
              if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
              if (this.flatShading === true) data.flatShading = true;
              if (this.visible === false) data.visible = false;
              if (this.toneMapped === false) data.toneMapped = false;
              if (this.fog === false) data.fog = false;
              if (Object.keys(this.userData).length > 0) data.userData = this.userData;

              // TODO: Copied from Object3D.toJSON

              function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                  var _data2 = cache[key];
                  delete _data2.metadata;
                  values.push(_data2);
                }
                return values;
              }
              if (isRootObject) {
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                if (textures.length > 0) data.textures = textures;
                if (images.length > 0) data.images = images;
              }
              return data;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }, {
            key: "copy",
            value: function copy(source) {
              this.name = source.name;
              this.blending = source.blending;
              this.side = source.side;
              this.vertexColors = source.vertexColors;
              this.opacity = source.opacity;
              this.transparent = source.transparent;
              this.blendSrc = source.blendSrc;
              this.blendDst = source.blendDst;
              this.blendEquation = source.blendEquation;
              this.blendSrcAlpha = source.blendSrcAlpha;
              this.blendDstAlpha = source.blendDstAlpha;
              this.blendEquationAlpha = source.blendEquationAlpha;
              this.blendColor.copy(source.blendColor);
              this.blendAlpha = source.blendAlpha;
              this.depthFunc = source.depthFunc;
              this.depthTest = source.depthTest;
              this.depthWrite = source.depthWrite;
              this.stencilWriteMask = source.stencilWriteMask;
              this.stencilFunc = source.stencilFunc;
              this.stencilRef = source.stencilRef;
              this.stencilFuncMask = source.stencilFuncMask;
              this.stencilFail = source.stencilFail;
              this.stencilZFail = source.stencilZFail;
              this.stencilZPass = source.stencilZPass;
              this.stencilWrite = source.stencilWrite;
              var srcPlanes = source.clippingPlanes;
              var dstPlanes = null;
              if (srcPlanes !== null) {
                var n = srcPlanes.length;
                dstPlanes = new Array(n);
                for (var i = 0; i !== n; ++i) {
                  dstPlanes[i] = srcPlanes[i].clone();
                }
              }
              this.clippingPlanes = dstPlanes;
              this.clipIntersection = source.clipIntersection;
              this.clipShadows = source.clipShadows;
              this.shadowSide = source.shadowSide;
              this.colorWrite = source.colorWrite;
              this.precision = source.precision;
              this.polygonOffset = source.polygonOffset;
              this.polygonOffsetFactor = source.polygonOffsetFactor;
              this.polygonOffsetUnits = source.polygonOffsetUnits;
              this.dithering = source.dithering;
              this.alphaTest = source.alphaTest;
              this.alphaHash = source.alphaHash;
              this.alphaToCoverage = source.alphaToCoverage;
              this.premultipliedAlpha = source.premultipliedAlpha;
              this.forceSinglePass = source.forceSinglePass;
              this.visible = source.visible;
              this.toneMapped = source.toneMapped;
              this.userData = JSON.parse(JSON.stringify(source.userData));
              return this;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.dispatchEvent({
                type: 'dispose'
              });
            }
          }, {
            key: "needsUpdate",
            set: function set(value) {
              if (value === true) this.version++;
            }
          }, {
            key: "onBuild",
            value: function onBuild(/* shaderobject, renderer */
            ) {
              console.warn('Material: onBuild() has been removed.'); // @deprecated, r166
            }
          }, {
            key: "onBeforeRender",
            value: function onBeforeRender(/* renderer, scene, camera, geometry, object, group */
            ) {
              console.warn('Material: onBeforeRender() has been removed.'); // @deprecated, r166
            }
          }]);
        }(EventDispatcher);
        var MeshBasicMaterial = /*#__PURE__*/function (_Material) {
          function MeshBasicMaterial(parameters) {
            var _this24;
            _classCallCheck2(this, MeshBasicMaterial);
            _this24 = _callSuper(this, MeshBasicMaterial);
            _this24.isMeshBasicMaterial = true;
            _this24.type = 'MeshBasicMaterial';
            _this24.color = new Color(0xffffff); // emissive

            _this24.map = null;
            _this24.lightMap = null;
            _this24.lightMapIntensity = 1.0;
            _this24.aoMap = null;
            _this24.aoMapIntensity = 1.0;
            _this24.specularMap = null;
            _this24.alphaMap = null;
            _this24.envMap = null;
            _this24.envMapRotation = new Euler();
            _this24.combine = MultiplyOperation;
            _this24.reflectivity = 1;
            _this24.refractionRatio = 0.98;
            _this24.wireframe = false;
            _this24.wireframeLinewidth = 1;
            _this24.wireframeLinecap = 'round';
            _this24.wireframeLinejoin = 'round';
            _this24.fog = true;
            _this24.setValues(parameters);
            return _this24;
          }
          _inherits(MeshBasicMaterial, _Material);
          return _createClass(MeshBasicMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(MeshBasicMaterial, "copy", this, 3)([source]);
              this.color.copy(source.color);
              this.map = source.map;
              this.lightMap = source.lightMap;
              this.lightMapIntensity = source.lightMapIntensity;
              this.aoMap = source.aoMap;
              this.aoMapIntensity = source.aoMapIntensity;
              this.specularMap = source.specularMap;
              this.alphaMap = source.alphaMap;
              this.envMap = source.envMap;
              this.envMapRotation.copy(source.envMapRotation);
              this.combine = source.combine;
              this.reflectivity = source.reflectivity;
              this.refractionRatio = source.refractionRatio;
              this.wireframe = source.wireframe;
              this.wireframeLinewidth = source.wireframeLinewidth;
              this.wireframeLinecap = source.wireframeLinecap;
              this.wireframeLinejoin = source.wireframeLinejoin;
              this.fog = source.fog;
              return this;
            }
          }]);
        }(Material); // Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
        var _tables = /*@__PURE__*/_generateTables();
        function _generateTables() {
          // float32 to float16 helpers

          var buffer = new ArrayBuffer(4);
          var floatView = new Float32Array(buffer);
          var uint32View = new Uint32Array(buffer);
          var baseTable = new Uint32Array(512);
          var shiftTable = new Uint32Array(512);
          for (var i = 0; i < 256; ++i) {
            var e = i - 127;

            // very small number (0, -0)

            if (e < -27) {
              baseTable[i] = 0x0000;
              baseTable[i | 0x100] = 0x8000;
              shiftTable[i] = 24;
              shiftTable[i | 0x100] = 24;

              // small number (denorm)
            } else if (e < -14) {
              baseTable[i] = 0x0400 >> -e - 14;
              baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;
              shiftTable[i] = -e - 1;
              shiftTable[i | 0x100] = -e - 1;

              // normal number
            } else if (e <= 15) {
              baseTable[i] = e + 15 << 10;
              baseTable[i | 0x100] = e + 15 << 10 | 0x8000;
              shiftTable[i] = 13;
              shiftTable[i | 0x100] = 13;

              // large number (Infinity, -Infinity)
            } else if (e < 128) {
              baseTable[i] = 0x7c00;
              baseTable[i | 0x100] = 0xfc00;
              shiftTable[i] = 24;
              shiftTable[i | 0x100] = 24;

              // stay (NaN, Infinity, -Infinity)
            } else {
              baseTable[i] = 0x7c00;
              baseTable[i | 0x100] = 0xfc00;
              shiftTable[i] = 13;
              shiftTable[i | 0x100] = 13;
            }
          }

          // float16 to float32 helpers

          var mantissaTable = new Uint32Array(2048);
          var exponentTable = new Uint32Array(64);
          var offsetTable = new Uint32Array(64);
          for (var _i15 = 1; _i15 < 1024; ++_i15) {
            var _m5 = _i15 << 13; // zero pad mantissa bits
            var _e2 = 0; // zero exponent

            // normalized
            while ((_m5 & 0x00800000) === 0) {
              _m5 <<= 1;
              _e2 -= 0x00800000; // decrement exponent
            }
            _m5 &= ~0x00800000; // clear leading 1 bit
            _e2 += 0x38800000; // adjust bias

            mantissaTable[_i15] = _m5 | _e2;
          }
          for (var _i16 = 1024; _i16 < 2048; ++_i16) {
            mantissaTable[_i16] = 0x38000000 + (_i16 - 1024 << 13);
          }
          for (var _i17 = 1; _i17 < 31; ++_i17) {
            exponentTable[_i17] = _i17 << 23;
          }
          exponentTable[31] = 0x47800000;
          exponentTable[32] = 0x80000000;
          for (var _i18 = 33; _i18 < 63; ++_i18) {
            exponentTable[_i18] = 0x80000000 + (_i18 - 32 << 23);
          }
          exponentTable[63] = 0xc7800000;
          for (var _i19 = 1; _i19 < 64; ++_i19) {
            if (_i19 !== 32) {
              offsetTable[_i19] = 1024;
            }
          }
          return {
            floatView: floatView,
            uint32View: uint32View,
            baseTable: baseTable,
            shiftTable: shiftTable,
            mantissaTable: mantissaTable,
            exponentTable: exponentTable,
            offsetTable: offsetTable
          };
        }

        // float32 to float16

        function toHalfFloat(val) {
          if (Math.abs(val) > 65504) console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');
          val = clamp(val, -65504, 65504);
          _tables.floatView[0] = val;
          var f = _tables.uint32View[0];
          var e = f >> 23 & 0x1ff;
          return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);
        }

        // float16 to float32

        function fromHalfFloat(val) {
          var m = val >> 10;
          _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m];
          return _tables.floatView[0];
        }
        var DataUtils = {
          toHalfFloat: toHalfFloat,
          fromHalfFloat: fromHalfFloat
        };
        var _vector$9 = /*@__PURE__*/new Vector3();
        var _vector2$1 = /*@__PURE__*/new Vector2();
        var BufferAttribute = /*#__PURE__*/function () {
          function BufferAttribute(array, itemSize) {
            var normalized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            _classCallCheck2(this, BufferAttribute);
            if (Array.isArray(array)) {
              throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            }
            this.isBufferAttribute = true;
            this.name = '';
            this.array = array;
            this.itemSize = itemSize;
            this.count = array !== undefined ? array.length / itemSize : 0;
            this.normalized = normalized;
            this.usage = StaticDrawUsage;
            this._updateRange = {
              offset: 0,
              count: -1
            };
            this.updateRanges = [];
            this.gpuType = FloatType;
            this.version = 0;
          }
          return _createClass(BufferAttribute, [{
            key: "onUploadCallback",
            value: function onUploadCallback() {}
          }, {
            key: "needsUpdate",
            set: function set(value) {
              if (value === true) this.version++;
            }
          }, {
            key: "updateRange",
            get: function get() {
              warnOnce('THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.'); // @deprecated, r159
              return this._updateRange;
            }
          }, {
            key: "setUsage",
            value: function setUsage(value) {
              this.usage = value;
              return this;
            }
          }, {
            key: "addUpdateRange",
            value: function addUpdateRange(start, count) {
              this.updateRanges.push({
                start: start,
                count: count
              });
            }
          }, {
            key: "clearUpdateRanges",
            value: function clearUpdateRanges() {
              this.updateRanges.length = 0;
            }
          }, {
            key: "copy",
            value: function copy(source) {
              this.name = source.name;
              this.array = new source.array.constructor(source.array);
              this.itemSize = source.itemSize;
              this.count = source.count;
              this.normalized = source.normalized;
              this.usage = source.usage;
              this.gpuType = source.gpuType;
              return this;
            }
          }, {
            key: "copyAt",
            value: function copyAt(index1, attribute, index2) {
              index1 *= this.itemSize;
              index2 *= attribute.itemSize;
              for (var i = 0, l = this.itemSize; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
              }
              return this;
            }
          }, {
            key: "copyArray",
            value: function copyArray(array) {
              this.array.set(array);
              return this;
            }
          }, {
            key: "applyMatrix3",
            value: function applyMatrix3(m) {
              if (this.itemSize === 2) {
                for (var i = 0, l = this.count; i < l; i++) {
                  _vector2$1.fromBufferAttribute(this, i);
                  _vector2$1.applyMatrix3(m);
                  this.setXY(i, _vector2$1.x, _vector2$1.y);
                }
              } else if (this.itemSize === 3) {
                for (var _i20 = 0, _l4 = this.count; _i20 < _l4; _i20++) {
                  _vector$9.fromBufferAttribute(this, _i20);
                  _vector$9.applyMatrix3(m);
                  this.setXYZ(_i20, _vector$9.x, _vector$9.y, _vector$9.z);
                }
              }
              return this;
            }
          }, {
            key: "applyMatrix4",
            value: function applyMatrix4(m) {
              for (var i = 0, l = this.count; i < l; i++) {
                _vector$9.fromBufferAttribute(this, i);
                _vector$9.applyMatrix4(m);
                this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
              }
              return this;
            }
          }, {
            key: "applyNormalMatrix",
            value: function applyNormalMatrix(m) {
              for (var i = 0, l = this.count; i < l; i++) {
                _vector$9.fromBufferAttribute(this, i);
                _vector$9.applyNormalMatrix(m);
                this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
              }
              return this;
            }
          }, {
            key: "transformDirection",
            value: function transformDirection(m) {
              for (var i = 0, l = this.count; i < l; i++) {
                _vector$9.fromBufferAttribute(this, i);
                _vector$9.transformDirection(m);
                this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
              }
              return this;
            }
          }, {
            key: "set",
            value: function set(value) {
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              // Matching BufferAttribute constructor, do not normalize the array.
              this.array.set(value, offset);
              return this;
            }
          }, {
            key: "getComponent",
            value: function getComponent(index, component) {
              var value = this.array[index * this.itemSize + component];
              if (this.normalized) value = denormalize(value, this.array);
              return value;
            }
          }, {
            key: "setComponent",
            value: function setComponent(index, component, value) {
              if (this.normalized) value = normalize(value, this.array);
              this.array[index * this.itemSize + component] = value;
              return this;
            }
          }, {
            key: "getX",
            value: function getX(index) {
              var x = this.array[index * this.itemSize];
              if (this.normalized) x = denormalize(x, this.array);
              return x;
            }
          }, {
            key: "setX",
            value: function setX(index, x) {
              if (this.normalized) x = normalize(x, this.array);
              this.array[index * this.itemSize] = x;
              return this;
            }
          }, {
            key: "getY",
            value: function getY(index) {
              var y = this.array[index * this.itemSize + 1];
              if (this.normalized) y = denormalize(y, this.array);
              return y;
            }
          }, {
            key: "setY",
            value: function setY(index, y) {
              if (this.normalized) y = normalize(y, this.array);
              this.array[index * this.itemSize + 1] = y;
              return this;
            }
          }, {
            key: "getZ",
            value: function getZ(index) {
              var z = this.array[index * this.itemSize + 2];
              if (this.normalized) z = denormalize(z, this.array);
              return z;
            }
          }, {
            key: "setZ",
            value: function setZ(index, z) {
              if (this.normalized) z = normalize(z, this.array);
              this.array[index * this.itemSize + 2] = z;
              return this;
            }
          }, {
            key: "getW",
            value: function getW(index) {
              var w = this.array[index * this.itemSize + 3];
              if (this.normalized) w = denormalize(w, this.array);
              return w;
            }
          }, {
            key: "setW",
            value: function setW(index, w) {
              if (this.normalized) w = normalize(w, this.array);
              this.array[index * this.itemSize + 3] = w;
              return this;
            }
          }, {
            key: "setXY",
            value: function setXY(index, x, y) {
              index *= this.itemSize;
              if (this.normalized) {
                x = normalize(x, this.array);
                y = normalize(y, this.array);
              }
              this.array[index + 0] = x;
              this.array[index + 1] = y;
              return this;
            }
          }, {
            key: "setXYZ",
            value: function setXYZ(index, x, y, z) {
              index *= this.itemSize;
              if (this.normalized) {
                x = normalize(x, this.array);
                y = normalize(y, this.array);
                z = normalize(z, this.array);
              }
              this.array[index + 0] = x;
              this.array[index + 1] = y;
              this.array[index + 2] = z;
              return this;
            }
          }, {
            key: "setXYZW",
            value: function setXYZW(index, x, y, z, w) {
              index *= this.itemSize;
              if (this.normalized) {
                x = normalize(x, this.array);
                y = normalize(y, this.array);
                z = normalize(z, this.array);
                w = normalize(w, this.array);
              }
              this.array[index + 0] = x;
              this.array[index + 1] = y;
              this.array[index + 2] = z;
              this.array[index + 3] = w;
              return this;
            }
          }, {
            key: "onUpload",
            value: function onUpload(callback) {
              this.onUploadCallback = callback;
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor(this.array, this.itemSize).copy(this);
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.from(this.array),
                normalized: this.normalized
              };
              if (this.name !== '') data.name = this.name;
              if (this.usage !== StaticDrawUsage) data.usage = this.usage;
              return data;
            }
          }]);
        }(); //
        var Int8BufferAttribute = /*#__PURE__*/function (_BufferAttribute) {
          function Int8BufferAttribute(array, itemSize, normalized) {
            _classCallCheck2(this, Int8BufferAttribute);
            return _callSuper(this, Int8BufferAttribute, [new Int8Array(array), itemSize, normalized]);
          }
          _inherits(Int8BufferAttribute, _BufferAttribute);
          return _createClass(Int8BufferAttribute);
        }(BufferAttribute);
        var Uint8BufferAttribute = /*#__PURE__*/function (_BufferAttribute2) {
          function Uint8BufferAttribute(array, itemSize, normalized) {
            _classCallCheck2(this, Uint8BufferAttribute);
            return _callSuper(this, Uint8BufferAttribute, [new Uint8Array(array), itemSize, normalized]);
          }
          _inherits(Uint8BufferAttribute, _BufferAttribute2);
          return _createClass(Uint8BufferAttribute);
        }(BufferAttribute);
        var Uint8ClampedBufferAttribute = /*#__PURE__*/function (_BufferAttribute3) {
          function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
            _classCallCheck2(this, Uint8ClampedBufferAttribute);
            return _callSuper(this, Uint8ClampedBufferAttribute, [new Uint8ClampedArray(array), itemSize, normalized]);
          }
          _inherits(Uint8ClampedBufferAttribute, _BufferAttribute3);
          return _createClass(Uint8ClampedBufferAttribute);
        }(BufferAttribute);
        var Int16BufferAttribute = /*#__PURE__*/function (_BufferAttribute4) {
          function Int16BufferAttribute(array, itemSize, normalized) {
            _classCallCheck2(this, Int16BufferAttribute);
            return _callSuper(this, Int16BufferAttribute, [new Int16Array(array), itemSize, normalized]);
          }
          _inherits(Int16BufferAttribute, _BufferAttribute4);
          return _createClass(Int16BufferAttribute);
        }(BufferAttribute);
        var Uint16BufferAttribute = /*#__PURE__*/function (_BufferAttribute5) {
          function Uint16BufferAttribute(array, itemSize, normalized) {
            _classCallCheck2(this, Uint16BufferAttribute);
            return _callSuper(this, Uint16BufferAttribute, [new Uint16Array(array), itemSize, normalized]);
          }
          _inherits(Uint16BufferAttribute, _BufferAttribute5);
          return _createClass(Uint16BufferAttribute);
        }(BufferAttribute);
        var Int32BufferAttribute = /*#__PURE__*/function (_BufferAttribute6) {
          function Int32BufferAttribute(array, itemSize, normalized) {
            _classCallCheck2(this, Int32BufferAttribute);
            return _callSuper(this, Int32BufferAttribute, [new Int32Array(array), itemSize, normalized]);
          }
          _inherits(Int32BufferAttribute, _BufferAttribute6);
          return _createClass(Int32BufferAttribute);
        }(BufferAttribute);
        var Uint32BufferAttribute = /*#__PURE__*/function (_BufferAttribute7) {
          function Uint32BufferAttribute(array, itemSize, normalized) {
            _classCallCheck2(this, Uint32BufferAttribute);
            return _callSuper(this, Uint32BufferAttribute, [new Uint32Array(array), itemSize, normalized]);
          }
          _inherits(Uint32BufferAttribute, _BufferAttribute7);
          return _createClass(Uint32BufferAttribute);
        }(BufferAttribute);
        var Float16BufferAttribute = /*#__PURE__*/function (_BufferAttribute8) {
          function Float16BufferAttribute(array, itemSize, normalized) {
            var _this25;
            _classCallCheck2(this, Float16BufferAttribute);
            _this25 = _callSuper(this, Float16BufferAttribute, [new Uint16Array(array), itemSize, normalized]);
            _this25.isFloat16BufferAttribute = true;
            return _this25;
          }
          _inherits(Float16BufferAttribute, _BufferAttribute8);
          return _createClass(Float16BufferAttribute, [{
            key: "getX",
            value: function getX(index) {
              var x = fromHalfFloat(this.array[index * this.itemSize]);
              if (this.normalized) x = denormalize(x, this.array);
              return x;
            }
          }, {
            key: "setX",
            value: function setX(index, x) {
              if (this.normalized) x = normalize(x, this.array);
              this.array[index * this.itemSize] = toHalfFloat(x);
              return this;
            }
          }, {
            key: "getY",
            value: function getY(index) {
              var y = fromHalfFloat(this.array[index * this.itemSize + 1]);
              if (this.normalized) y = denormalize(y, this.array);
              return y;
            }
          }, {
            key: "setY",
            value: function setY(index, y) {
              if (this.normalized) y = normalize(y, this.array);
              this.array[index * this.itemSize + 1] = toHalfFloat(y);
              return this;
            }
          }, {
            key: "getZ",
            value: function getZ(index) {
              var z = fromHalfFloat(this.array[index * this.itemSize + 2]);
              if (this.normalized) z = denormalize(z, this.array);
              return z;
            }
          }, {
            key: "setZ",
            value: function setZ(index, z) {
              if (this.normalized) z = normalize(z, this.array);
              this.array[index * this.itemSize + 2] = toHalfFloat(z);
              return this;
            }
          }, {
            key: "getW",
            value: function getW(index) {
              var w = fromHalfFloat(this.array[index * this.itemSize + 3]);
              if (this.normalized) w = denormalize(w, this.array);
              return w;
            }
          }, {
            key: "setW",
            value: function setW(index, w) {
              if (this.normalized) w = normalize(w, this.array);
              this.array[index * this.itemSize + 3] = toHalfFloat(w);
              return this;
            }
          }, {
            key: "setXY",
            value: function setXY(index, x, y) {
              index *= this.itemSize;
              if (this.normalized) {
                x = normalize(x, this.array);
                y = normalize(y, this.array);
              }
              this.array[index + 0] = toHalfFloat(x);
              this.array[index + 1] = toHalfFloat(y);
              return this;
            }
          }, {
            key: "setXYZ",
            value: function setXYZ(index, x, y, z) {
              index *= this.itemSize;
              if (this.normalized) {
                x = normalize(x, this.array);
                y = normalize(y, this.array);
                z = normalize(z, this.array);
              }
              this.array[index + 0] = toHalfFloat(x);
              this.array[index + 1] = toHalfFloat(y);
              this.array[index + 2] = toHalfFloat(z);
              return this;
            }
          }, {
            key: "setXYZW",
            value: function setXYZW(index, x, y, z, w) {
              index *= this.itemSize;
              if (this.normalized) {
                x = normalize(x, this.array);
                y = normalize(y, this.array);
                z = normalize(z, this.array);
                w = normalize(w, this.array);
              }
              this.array[index + 0] = toHalfFloat(x);
              this.array[index + 1] = toHalfFloat(y);
              this.array[index + 2] = toHalfFloat(z);
              this.array[index + 3] = toHalfFloat(w);
              return this;
            }
          }]);
        }(BufferAttribute);
        var Float32BufferAttribute = /*#__PURE__*/function (_BufferAttribute9) {
          function Float32BufferAttribute(array, itemSize, normalized) {
            _classCallCheck2(this, Float32BufferAttribute);
            return _callSuper(this, Float32BufferAttribute, [new Float32Array(array), itemSize, normalized]);
          }
          _inherits(Float32BufferAttribute, _BufferAttribute9);
          return _createClass(Float32BufferAttribute);
        }(BufferAttribute);
        var _id$2 = 0;
        var _m1$2 = /*@__PURE__*/new Matrix4();
        var _obj = /*@__PURE__*/new Object3D();
        var _offset = /*@__PURE__*/new Vector3();
        var _box$2 = /*@__PURE__*/new Box3();
        var _boxMorphTargets = /*@__PURE__*/new Box3();
        var _vector$8 = /*@__PURE__*/new Vector3();
        var BufferGeometry = /*#__PURE__*/function (_EventDispatcher5) {
          function BufferGeometry() {
            var _this26;
            _classCallCheck2(this, BufferGeometry);
            _this26 = _callSuper(this, BufferGeometry);
            _this26.isBufferGeometry = true;
            Object.defineProperty(_this26, 'id', {
              value: _id$2++
            });
            _this26.uuid = generateUUID();
            _this26.name = '';
            _this26.type = 'BufferGeometry';
            _this26.index = null;
            _this26.attributes = {};
            _this26.morphAttributes = {};
            _this26.morphTargetsRelative = false;
            _this26.groups = [];
            _this26.boundingBox = null;
            _this26.boundingSphere = null;
            _this26.drawRange = {
              start: 0,
              count: Infinity
            };
            _this26.userData = {};
            return _this26;
          }
          _inherits(BufferGeometry, _EventDispatcher5);
          return _createClass(BufferGeometry, [{
            key: "getIndex",
            value: function getIndex() {
              return this.index;
            }
          }, {
            key: "setIndex",
            value: function setIndex(index) {
              if (Array.isArray(index)) {
                this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
              } else {
                this.index = index;
              }
              return this;
            }
          }, {
            key: "getAttribute",
            value: function getAttribute(name) {
              return this.attributes[name];
            }
          }, {
            key: "setAttribute",
            value: function setAttribute(name, attribute) {
              this.attributes[name] = attribute;
              return this;
            }
          }, {
            key: "deleteAttribute",
            value: function deleteAttribute(name) {
              delete this.attributes[name];
              return this;
            }
          }, {
            key: "hasAttribute",
            value: function hasAttribute(name) {
              return this.attributes[name] !== undefined;
            }
          }, {
            key: "addGroup",
            value: function addGroup(start, count) {
              var materialIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              this.groups.push({
                start: start,
                count: count,
                materialIndex: materialIndex
              });
            }
          }, {
            key: "clearGroups",
            value: function clearGroups() {
              this.groups = [];
            }
          }, {
            key: "setDrawRange",
            value: function setDrawRange(start, count) {
              this.drawRange.start = start;
              this.drawRange.count = count;
            }
          }, {
            key: "applyMatrix4",
            value: function applyMatrix4(matrix) {
              var position = this.attributes.position;
              if (position !== undefined) {
                position.applyMatrix4(matrix);
                position.needsUpdate = true;
              }
              var normal = this.attributes.normal;
              if (normal !== undefined) {
                var normalMatrix = new Matrix3().getNormalMatrix(matrix);
                normal.applyNormalMatrix(normalMatrix);
                normal.needsUpdate = true;
              }
              var tangent = this.attributes.tangent;
              if (tangent !== undefined) {
                tangent.transformDirection(matrix);
                tangent.needsUpdate = true;
              }
              if (this.boundingBox !== null) {
                this.computeBoundingBox();
              }
              if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
              }
              return this;
            }
          }, {
            key: "applyQuaternion",
            value: function applyQuaternion(q) {
              _m1$2.makeRotationFromQuaternion(q);
              this.applyMatrix4(_m1$2);
              return this;
            }
          }, {
            key: "rotateX",
            value: function rotateX(angle) {
              // rotate geometry around world x-axis

              _m1$2.makeRotationX(angle);
              this.applyMatrix4(_m1$2);
              return this;
            }
          }, {
            key: "rotateY",
            value: function rotateY(angle) {
              // rotate geometry around world y-axis

              _m1$2.makeRotationY(angle);
              this.applyMatrix4(_m1$2);
              return this;
            }
          }, {
            key: "rotateZ",
            value: function rotateZ(angle) {
              // rotate geometry around world z-axis

              _m1$2.makeRotationZ(angle);
              this.applyMatrix4(_m1$2);
              return this;
            }
          }, {
            key: "translate",
            value: function translate(x, y, z) {
              // translate geometry

              _m1$2.makeTranslation(x, y, z);
              this.applyMatrix4(_m1$2);
              return this;
            }
          }, {
            key: "scale",
            value: function scale(x, y, z) {
              // scale geometry

              _m1$2.makeScale(x, y, z);
              this.applyMatrix4(_m1$2);
              return this;
            }
          }, {
            key: "lookAt",
            value: function lookAt(vector) {
              _obj.lookAt(vector);
              _obj.updateMatrix();
              this.applyMatrix4(_obj.matrix);
              return this;
            }
          }, {
            key: "center",
            value: function center() {
              this.computeBoundingBox();
              this.boundingBox.getCenter(_offset).negate();
              this.translate(_offset.x, _offset.y, _offset.z);
              return this;
            }
          }, {
            key: "setFromPoints",
            value: function setFromPoints(points) {
              var position = [];
              for (var i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                position.push(point.x, point.y, point.z || 0);
              }
              this.setAttribute('position', new Float32BufferAttribute(position, 3));
              return this;
            }
          }, {
            key: "computeBoundingBox",
            value: function computeBoundingBox() {
              if (this.boundingBox === null) {
                this.boundingBox = new Box3();
              }
              var position = this.attributes.position;
              var morphAttributesPosition = this.morphAttributes.position;
              if (position && position.isGLBufferAttribute) {
                console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this);
                this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
                return;
              }
              if (position !== undefined) {
                this.boundingBox.setFromBufferAttribute(position);

                // process morph attributes if present

                if (morphAttributesPosition) {
                  for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
                    var morphAttribute = morphAttributesPosition[i];
                    _box$2.setFromBufferAttribute(morphAttribute);
                    if (this.morphTargetsRelative) {
                      _vector$8.addVectors(this.boundingBox.min, _box$2.min);
                      this.boundingBox.expandByPoint(_vector$8);
                      _vector$8.addVectors(this.boundingBox.max, _box$2.max);
                      this.boundingBox.expandByPoint(_vector$8);
                    } else {
                      this.boundingBox.expandByPoint(_box$2.min);
                      this.boundingBox.expandByPoint(_box$2.max);
                    }
                  }
                }
              } else {
                this.boundingBox.makeEmpty();
              }
              if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
                console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
              }
            }
          }, {
            key: "computeBoundingSphere",
            value: function computeBoundingSphere() {
              if (this.boundingSphere === null) {
                this.boundingSphere = new Sphere();
              }
              var position = this.attributes.position;
              var morphAttributesPosition = this.morphAttributes.position;
              if (position && position.isGLBufferAttribute) {
                console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this);
                this.boundingSphere.set(new Vector3(), Infinity);
                return;
              }
              if (position) {
                // first, find the center of the bounding sphere

                var center = this.boundingSphere.center;
                _box$2.setFromBufferAttribute(position);

                // process morph attributes if present

                if (morphAttributesPosition) {
                  for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
                    var morphAttribute = morphAttributesPosition[i];
                    _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                    if (this.morphTargetsRelative) {
                      _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
                      _box$2.expandByPoint(_vector$8);
                      _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
                      _box$2.expandByPoint(_vector$8);
                    } else {
                      _box$2.expandByPoint(_boxMorphTargets.min);
                      _box$2.expandByPoint(_boxMorphTargets.max);
                    }
                  }
                }
                _box$2.getCenter(center);

                // second, try to find a boundingSphere with a radius smaller than the
                // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

                var maxRadiusSq = 0;
                for (var _i21 = 0, _il = position.count; _i21 < _il; _i21++) {
                  _vector$8.fromBufferAttribute(position, _i21);
                  maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                }

                // process morph attributes if present

                if (morphAttributesPosition) {
                  for (var _i22 = 0, _il2 = morphAttributesPosition.length; _i22 < _il2; _i22++) {
                    var _morphAttribute = morphAttributesPosition[_i22];
                    var morphTargetsRelative = this.morphTargetsRelative;
                    for (var j = 0, jl = _morphAttribute.count; j < jl; j++) {
                      _vector$8.fromBufferAttribute(_morphAttribute, j);
                      if (morphTargetsRelative) {
                        _offset.fromBufferAttribute(position, j);
                        _vector$8.add(_offset);
                      }
                      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                    }
                  }
                }
                this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                if (isNaN(this.boundingSphere.radius)) {
                  console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                }
              }
            }
          }, {
            key: "computeTangents",
            value: function computeTangents() {
              var index = this.index;
              var attributes = this.attributes;

              // based on http://www.terathon.com/code/tangent.html
              // (per vertex tangents)

              if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
                console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
                return;
              }
              var positionAttribute = attributes.position;
              var normalAttribute = attributes.normal;
              var uvAttribute = attributes.uv;
              if (this.hasAttribute('tangent') === false) {
                this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
              }
              var tangentAttribute = this.getAttribute('tangent');
              var tan1 = [],
                tan2 = [];
              for (var i = 0; i < positionAttribute.count; i++) {
                tan1[i] = new Vector3();
                tan2[i] = new Vector3();
              }
              var vA = new Vector3(),
                vB = new Vector3(),
                vC = new Vector3(),
                uvA = new Vector2(),
                uvB = new Vector2(),
                uvC = new Vector2(),
                sdir = new Vector3(),
                tdir = new Vector3();
              function handleTriangle(a, b, c) {
                vA.fromBufferAttribute(positionAttribute, a);
                vB.fromBufferAttribute(positionAttribute, b);
                vC.fromBufferAttribute(positionAttribute, c);
                uvA.fromBufferAttribute(uvAttribute, a);
                uvB.fromBufferAttribute(uvAttribute, b);
                uvC.fromBufferAttribute(uvAttribute, c);
                vB.sub(vA);
                vC.sub(vA);
                uvB.sub(uvA);
                uvC.sub(uvA);
                var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);

                // silently ignore degenerate uv triangles having coincident or colinear vertices

                if (!isFinite(r)) return;
                sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
                tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
                tan1[a].add(sdir);
                tan1[b].add(sdir);
                tan1[c].add(sdir);
                tan2[a].add(tdir);
                tan2[b].add(tdir);
                tan2[c].add(tdir);
              }
              var groups = this.groups;
              if (groups.length === 0) {
                groups = [{
                  start: 0,
                  count: index.count
                }];
              }
              for (var _i23 = 0, il = groups.length; _i23 < il; ++_i23) {
                var group = groups[_i23];
                var start = group.start;
                var count = group.count;
                for (var j = start, jl = start + count; j < jl; j += 3) {
                  handleTriangle(index.getX(j + 0), index.getX(j + 1), index.getX(j + 2));
                }
              }
              var tmp = new Vector3(),
                tmp2 = new Vector3();
              var n = new Vector3(),
                n2 = new Vector3();
              function handleVertex(v) {
                n.fromBufferAttribute(normalAttribute, v);
                n2.copy(n);
                var t = tan1[v];

                // Gram-Schmidt orthogonalize

                tmp.copy(t);
                tmp.sub(n.multiplyScalar(n.dot(t))).normalize();

                // Calculate handedness

                tmp2.crossVectors(n2, t);
                var test = tmp2.dot(tan2[v]);
                var w = test < 0.0 ? -1.0 : 1.0;
                tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);
              }
              for (var _i24 = 0, _il3 = groups.length; _i24 < _il3; ++_i24) {
                var _group2 = groups[_i24];
                var _start2 = _group2.start;
                var _count = _group2.count;
                for (var _j = _start2, _jl = _start2 + _count; _j < _jl; _j += 3) {
                  handleVertex(index.getX(_j + 0));
                  handleVertex(index.getX(_j + 1));
                  handleVertex(index.getX(_j + 2));
                }
              }
            }
          }, {
            key: "computeVertexNormals",
            value: function computeVertexNormals() {
              var index = this.index;
              var positionAttribute = this.getAttribute('position');
              if (positionAttribute !== undefined) {
                var normalAttribute = this.getAttribute('normal');
                if (normalAttribute === undefined) {
                  normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
                  this.setAttribute('normal', normalAttribute);
                } else {
                  // reset existing normals to zero

                  for (var i = 0, il = normalAttribute.count; i < il; i++) {
                    normalAttribute.setXYZ(i, 0, 0, 0);
                  }
                }
                var pA = new Vector3(),
                  pB = new Vector3(),
                  pC = new Vector3();
                var nA = new Vector3(),
                  nB = new Vector3(),
                  nC = new Vector3();
                var cb = new Vector3(),
                  ab = new Vector3();

                // indexed elements

                if (index) {
                  for (var _i25 = 0, _il4 = index.count; _i25 < _il4; _i25 += 3) {
                    var vA = index.getX(_i25 + 0);
                    var vB = index.getX(_i25 + 1);
                    var vC = index.getX(_i25 + 2);
                    pA.fromBufferAttribute(positionAttribute, vA);
                    pB.fromBufferAttribute(positionAttribute, vB);
                    pC.fromBufferAttribute(positionAttribute, vC);
                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);
                    nA.fromBufferAttribute(normalAttribute, vA);
                    nB.fromBufferAttribute(normalAttribute, vB);
                    nC.fromBufferAttribute(normalAttribute, vC);
                    nA.add(cb);
                    nB.add(cb);
                    nC.add(cb);
                    normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                    normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                    normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
                  }
                } else {
                  // non-indexed elements (unconnected triangle soup)

                  for (var _i26 = 0, _il5 = positionAttribute.count; _i26 < _il5; _i26 += 3) {
                    pA.fromBufferAttribute(positionAttribute, _i26 + 0);
                    pB.fromBufferAttribute(positionAttribute, _i26 + 1);
                    pC.fromBufferAttribute(positionAttribute, _i26 + 2);
                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);
                    normalAttribute.setXYZ(_i26 + 0, cb.x, cb.y, cb.z);
                    normalAttribute.setXYZ(_i26 + 1, cb.x, cb.y, cb.z);
                    normalAttribute.setXYZ(_i26 + 2, cb.x, cb.y, cb.z);
                  }
                }
                this.normalizeNormals();
                normalAttribute.needsUpdate = true;
              }
            }
          }, {
            key: "normalizeNormals",
            value: function normalizeNormals() {
              var normals = this.attributes.normal;
              for (var i = 0, il = normals.count; i < il; i++) {
                _vector$8.fromBufferAttribute(normals, i);
                _vector$8.normalize();
                normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
              }
            }
          }, {
            key: "toNonIndexed",
            value: function toNonIndexed() {
              function convertBufferAttribute(attribute, indices) {
                var array = attribute.array;
                var itemSize = attribute.itemSize;
                var normalized = attribute.normalized;
                var array2 = new array.constructor(indices.length * itemSize);
                var index = 0,
                  index2 = 0;
                for (var i = 0, l = indices.length; i < l; i++) {
                  if (attribute.isInterleavedBufferAttribute) {
                    index = indices[i] * attribute.data.stride + attribute.offset;
                  } else {
                    index = indices[i] * itemSize;
                  }
                  for (var j = 0; j < itemSize; j++) {
                    array2[index2++] = array[index++];
                  }
                }
                return new BufferAttribute(array2, itemSize, normalized);
              }

              //

              if (this.index === null) {
                console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
                return this;
              }
              var geometry2 = new BufferGeometry();
              var indices = this.index.array;
              var attributes = this.attributes;

              // attributes

              for (var name in attributes) {
                var attribute = attributes[name];
                var newAttribute = convertBufferAttribute(attribute, indices);
                geometry2.setAttribute(name, newAttribute);
              }

              // morph attributes

              var morphAttributes = this.morphAttributes;
              for (var _name2 in morphAttributes) {
                var morphArray = [];
                var morphAttribute = morphAttributes[_name2]; // morphAttribute: array of Float32BufferAttributes

                for (var i = 0, il = morphAttribute.length; i < il; i++) {
                  var _attribute = morphAttribute[i];
                  var _newAttribute = convertBufferAttribute(_attribute, indices);
                  morphArray.push(_newAttribute);
                }
                geometry2.morphAttributes[_name2] = morphArray;
              }
              geometry2.morphTargetsRelative = this.morphTargetsRelative;

              // groups

              var groups = this.groups;
              for (var _i27 = 0, l = groups.length; _i27 < l; _i27++) {
                var group = groups[_i27];
                geometry2.addGroup(group.start, group.count, group.materialIndex);
              }
              return geometry2;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = {
                metadata: {
                  version: 4.6,
                  type: 'BufferGeometry',
                  generator: 'BufferGeometry.toJSON'
                }
              };

              // standard BufferGeometry serialization

              data.uuid = this.uuid;
              data.type = this.type;
              if (this.name !== '') data.name = this.name;
              if (Object.keys(this.userData).length > 0) data.userData = this.userData;
              if (this.parameters !== undefined) {
                var parameters = this.parameters;
                for (var key in parameters) {
                  if (parameters[key] !== undefined) data[key] = parameters[key];
                }
                return data;
              }

              // for simplicity the code assumes attributes are not shared across geometries, see #15811

              data.data = {
                attributes: {}
              };
              var index = this.index;
              if (index !== null) {
                data.data.index = {
                  type: index.array.constructor.name,
                  array: Array.prototype.slice.call(index.array)
                };
              }
              var attributes = this.attributes;
              for (var _key56 in attributes) {
                var attribute = attributes[_key56];
                data.data.attributes[_key56] = attribute.toJSON(data.data);
              }
              var morphAttributes = {};
              var hasMorphAttributes = false;
              for (var _key57 in this.morphAttributes) {
                var attributeArray = this.morphAttributes[_key57];
                var array = [];
                for (var i = 0, il = attributeArray.length; i < il; i++) {
                  var _attribute2 = attributeArray[i];
                  array.push(_attribute2.toJSON(data.data));
                }
                if (array.length > 0) {
                  morphAttributes[_key57] = array;
                  hasMorphAttributes = true;
                }
              }
              if (hasMorphAttributes) {
                data.data.morphAttributes = morphAttributes;
                data.data.morphTargetsRelative = this.morphTargetsRelative;
              }
              var groups = this.groups;
              if (groups.length > 0) {
                data.data.groups = JSON.parse(JSON.stringify(groups));
              }
              var boundingSphere = this.boundingSphere;
              if (boundingSphere !== null) {
                data.data.boundingSphere = {
                  center: boundingSphere.center.toArray(),
                  radius: boundingSphere.radius
                };
              }
              return data;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }, {
            key: "copy",
            value: function copy(source) {
              // reset

              this.index = null;
              this.attributes = {};
              this.morphAttributes = {};
              this.groups = [];
              this.boundingBox = null;
              this.boundingSphere = null;

              // used for storing cloned, shared data

              var data = {};

              // name

              this.name = source.name;

              // index

              var index = source.index;
              if (index !== null) {
                this.setIndex(index.clone(data));
              }

              // attributes

              var attributes = source.attributes;
              for (var name in attributes) {
                var attribute = attributes[name];
                this.setAttribute(name, attribute.clone(data));
              }

              // morph attributes

              var morphAttributes = source.morphAttributes;
              for (var _name3 in morphAttributes) {
                var array = [];
                var morphAttribute = morphAttributes[_name3]; // morphAttribute: array of Float32BufferAttributes

                for (var i = 0, l = morphAttribute.length; i < l; i++) {
                  array.push(morphAttribute[i].clone(data));
                }
                this.morphAttributes[_name3] = array;
              }
              this.morphTargetsRelative = source.morphTargetsRelative;

              // groups

              var groups = source.groups;
              for (var _i28 = 0, _l5 = groups.length; _i28 < _l5; _i28++) {
                var group = groups[_i28];
                this.addGroup(group.start, group.count, group.materialIndex);
              }

              // bounding box

              var boundingBox = source.boundingBox;
              if (boundingBox !== null) {
                this.boundingBox = boundingBox.clone();
              }

              // bounding sphere

              var boundingSphere = source.boundingSphere;
              if (boundingSphere !== null) {
                this.boundingSphere = boundingSphere.clone();
              }

              // draw range

              this.drawRange.start = source.drawRange.start;
              this.drawRange.count = source.drawRange.count;

              // user data

              this.userData = source.userData;
              return this;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.dispatchEvent({
                type: 'dispose'
              });
            }
          }]);
        }(EventDispatcher);
        var _inverseMatrix$3 = /*@__PURE__*/new Matrix4();
        var _ray$3 = /*@__PURE__*/new Ray();
        var _sphere$6 = /*@__PURE__*/new Sphere();
        var _sphereHitAt = /*@__PURE__*/new Vector3();
        var _vA$1 = /*@__PURE__*/new Vector3();
        var _vB$1 = /*@__PURE__*/new Vector3();
        var _vC$1 = /*@__PURE__*/new Vector3();
        var _tempA = /*@__PURE__*/new Vector3();
        var _morphA = /*@__PURE__*/new Vector3();
        var _uvA$1 = /*@__PURE__*/new Vector2();
        var _uvB$1 = /*@__PURE__*/new Vector2();
        var _uvC$1 = /*@__PURE__*/new Vector2();
        var _normalA = /*@__PURE__*/new Vector3();
        var _normalB = /*@__PURE__*/new Vector3();
        var _normalC = /*@__PURE__*/new Vector3();
        var _intersectionPoint = /*@__PURE__*/new Vector3();
        var _intersectionPointWorld = /*@__PURE__*/new Vector3();
        var Mesh = /*#__PURE__*/function (_Object3D) {
          function Mesh() {
            var _this27;
            var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();
            var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new MeshBasicMaterial();
            _classCallCheck2(this, Mesh);
            _this27 = _callSuper(this, Mesh);
            _this27.isMesh = true;
            _this27.type = 'Mesh';
            _this27.geometry = geometry;
            _this27.material = material;
            _this27.updateMorphTargets();
            return _this27;
          }
          _inherits(Mesh, _Object3D);
          return _createClass(Mesh, [{
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(Mesh, "copy", this, 3)([source, recursive]);
              if (source.morphTargetInfluences !== undefined) {
                this.morphTargetInfluences = source.morphTargetInfluences.slice();
              }
              if (source.morphTargetDictionary !== undefined) {
                this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
              }
              this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
              this.geometry = source.geometry;
              return this;
            }
          }, {
            key: "updateMorphTargets",
            value: function updateMorphTargets() {
              var geometry = this.geometry;
              var morphAttributes = geometry.morphAttributes;
              var keys = Object.keys(morphAttributes);
              if (keys.length > 0) {
                var morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                  this.morphTargetInfluences = [];
                  this.morphTargetDictionary = {};
                  for (var _m6 = 0, ml = morphAttribute.length; _m6 < ml; _m6++) {
                    var name = morphAttribute[_m6].name || String(_m6);
                    this.morphTargetInfluences.push(0);
                    this.morphTargetDictionary[name] = _m6;
                  }
                }
              }
            }
          }, {
            key: "getVertexPosition",
            value: function getVertexPosition(index, target) {
              var geometry = this.geometry;
              var position = geometry.attributes.position;
              var morphPosition = geometry.morphAttributes.position;
              var morphTargetsRelative = geometry.morphTargetsRelative;
              target.fromBufferAttribute(position, index);
              var morphInfluences = this.morphTargetInfluences;
              if (morphPosition && morphInfluences) {
                _morphA.set(0, 0, 0);
                for (var i = 0, il = morphPosition.length; i < il; i++) {
                  var influence = morphInfluences[i];
                  var morphAttribute = morphPosition[i];
                  if (influence === 0) continue;
                  _tempA.fromBufferAttribute(morphAttribute, index);
                  if (morphTargetsRelative) {
                    _morphA.addScaledVector(_tempA, influence);
                  } else {
                    _morphA.addScaledVector(_tempA.sub(target), influence);
                  }
                }
                target.add(_morphA);
              }
              return target;
            }
          }, {
            key: "raycast",
            value: function raycast(raycaster, intersects) {
              var geometry = this.geometry;
              var material = this.material;
              var matrixWorld = this.matrixWorld;
              if (material === undefined) return;

              // test with bounding sphere in world space

              if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
              _sphere$6.copy(geometry.boundingSphere);
              _sphere$6.applyMatrix4(matrixWorld);

              // check distance from ray origin to bounding sphere

              _ray$3.copy(raycaster.ray).recast(raycaster.near);
              if (_sphere$6.containsPoint(_ray$3.origin) === false) {
                if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
                if (_ray$3.origin.distanceToSquared(_sphereHitAt) > Math.pow(raycaster.far - raycaster.near, 2)) return;
              }

              // convert ray to local space of mesh

              _inverseMatrix$3.copy(matrixWorld).invert();
              _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);

              // test with bounding box in local space

              if (geometry.boundingBox !== null) {
                if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
              }

              // test for intersections with geometry

              this._computeIntersections(raycaster, intersects, _ray$3);
            }
          }, {
            key: "_computeIntersections",
            value: function _computeIntersections(raycaster, intersects, rayLocalSpace) {
              var intersection;
              var geometry = this.geometry;
              var material = this.material;
              var index = geometry.index;
              var position = geometry.attributes.position;
              var uv = geometry.attributes.uv;
              var uv1 = geometry.attributes.uv1;
              var normal = geometry.attributes.normal;
              var groups = geometry.groups;
              var drawRange = geometry.drawRange;
              if (index !== null) {
                // indexed buffer geometry

                if (Array.isArray(material)) {
                  for (var i = 0, il = groups.length; i < il; i++) {
                    var group = groups[i];
                    var groupMaterial = material[group.materialIndex];
                    var start = Math.max(group.start, drawRange.start);
                    var end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                    for (var j = start, jl = end; j < jl; j += 3) {
                      var a = index.getX(j);
                      var b = index.getX(j + 1);
                      var _c3 = index.getX(j + 2);
                      intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, _c3);
                      if (intersection) {
                        intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                        intersection.face.materialIndex = group.materialIndex;
                        intersects.push(intersection);
                      }
                    }
                  }
                } else {
                  var _start3 = Math.max(0, drawRange.start);
                  var _end2 = Math.min(index.count, drawRange.start + drawRange.count);
                  for (var _i29 = _start3, _il6 = _end2; _i29 < _il6; _i29 += 3) {
                    var _a3 = index.getX(_i29);
                    var _b3 = index.getX(_i29 + 1);
                    var _c4 = index.getX(_i29 + 2);
                    intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, _a3, _b3, _c4);
                    if (intersection) {
                      intersection.faceIndex = Math.floor(_i29 / 3); // triangle number in indexed buffer semantics
                      intersects.push(intersection);
                    }
                  }
                }
              } else if (position !== undefined) {
                // non-indexed buffer geometry

                if (Array.isArray(material)) {
                  for (var _i30 = 0, _il7 = groups.length; _i30 < _il7; _i30++) {
                    var _group3 = groups[_i30];
                    var _groupMaterial = material[_group3.materialIndex];
                    var _start4 = Math.max(_group3.start, drawRange.start);
                    var _end3 = Math.min(position.count, Math.min(_group3.start + _group3.count, drawRange.start + drawRange.count));
                    for (var _j2 = _start4, _jl2 = _end3; _j2 < _jl2; _j2 += 3) {
                      var _a4 = _j2;
                      var _b4 = _j2 + 1;
                      var _c5 = _j2 + 2;
                      intersection = checkGeometryIntersection(this, _groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, _a4, _b4, _c5);
                      if (intersection) {
                        intersection.faceIndex = Math.floor(_j2 / 3); // triangle number in non-indexed buffer semantics
                        intersection.face.materialIndex = _group3.materialIndex;
                        intersects.push(intersection);
                      }
                    }
                  }
                } else {
                  var _start5 = Math.max(0, drawRange.start);
                  var _end4 = Math.min(position.count, drawRange.start + drawRange.count);
                  for (var _i31 = _start5, _il8 = _end4; _i31 < _il8; _i31 += 3) {
                    var _a5 = _i31;
                    var _b5 = _i31 + 1;
                    var _c6 = _i31 + 2;
                    intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, _a5, _b5, _c6);
                    if (intersection) {
                      intersection.faceIndex = Math.floor(_i31 / 3); // triangle number in non-indexed buffer semantics
                      intersects.push(intersection);
                    }
                  }
                }
              }
            }
          }]);
        }(Object3D);
        function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
          var intersect;
          if (material.side === BackSide) {
            intersect = ray.intersectTriangle(pC, pB, pA, true, point);
          } else {
            intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
          }
          if (intersect === null) return null;
          _intersectionPointWorld.copy(point);
          _intersectionPointWorld.applyMatrix4(object.matrixWorld);
          var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
          if (distance < raycaster.near || distance > raycaster.far) return null;
          return {
            distance: distance,
            point: _intersectionPointWorld.clone(),
            object: object
          };
        }
        function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
          object.getVertexPosition(a, _vA$1);
          object.getVertexPosition(b, _vB$1);
          object.getVertexPosition(c, _vC$1);
          var intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
          if (intersection) {
            if (uv) {
              _uvA$1.fromBufferAttribute(uv, a);
              _uvB$1.fromBufferAttribute(uv, b);
              _uvC$1.fromBufferAttribute(uv, c);
              intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
            }
            if (uv1) {
              _uvA$1.fromBufferAttribute(uv1, a);
              _uvB$1.fromBufferAttribute(uv1, b);
              _uvC$1.fromBufferAttribute(uv1, c);
              intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
            }
            if (normal) {
              _normalA.fromBufferAttribute(normal, a);
              _normalB.fromBufferAttribute(normal, b);
              _normalC.fromBufferAttribute(normal, c);
              intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3());
              if (intersection.normal.dot(ray.direction) > 0) {
                intersection.normal.multiplyScalar(-1);
              }
            }
            var face = {
              a: a,
              b: b,
              c: c,
              normal: new Vector3(),
              materialIndex: 0
            };
            Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
            intersection.face = face;
          }
          return intersection;
        }
        var BoxGeometry = /*#__PURE__*/function (_BufferGeometry) {
          function BoxGeometry() {
            var _this28;
            var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var widthSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            var heightSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
            var depthSegments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
            _classCallCheck2(this, BoxGeometry);
            _this28 = _callSuper(this, BoxGeometry);
            _this28.type = 'BoxGeometry';
            _this28.parameters = {
              width: width,
              height: height,
              depth: depth,
              widthSegments: widthSegments,
              heightSegments: heightSegments,
              depthSegments: depthSegments
            };
            var scope = _this28;

            // segments

            widthSegments = Math.floor(widthSegments);
            heightSegments = Math.floor(heightSegments);
            depthSegments = Math.floor(depthSegments);

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // helper variables

            var numberOfVertices = 0;
            var groupStart = 0;

            // build each side of the box geometry

            buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
            buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
            buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
            buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
            buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
            buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz

            // build geometry

            _this28.setIndex(indices);
            _this28.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this28.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this28.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
              var segmentWidth = width / gridX;
              var segmentHeight = height / gridY;
              var widthHalf = width / 2;
              var heightHalf = height / 2;
              var depthHalf = depth / 2;
              var gridX1 = gridX + 1;
              var gridY1 = gridY + 1;
              var vertexCounter = 0;
              var groupCount = 0;
              var vector = new Vector3();

              // generate vertices, normals and uvs

              for (var iy = 0; iy < gridY1; iy++) {
                var y = iy * segmentHeight - heightHalf;
                for (var ix = 0; ix < gridX1; ix++) {
                  var x = ix * segmentWidth - widthHalf;

                  // set values to correct vector component

                  vector[u] = x * udir;
                  vector[v] = y * vdir;
                  vector[w] = depthHalf;

                  // now apply vector to vertex buffer

                  vertices.push(vector.x, vector.y, vector.z);

                  // set values to correct vector component

                  vector[u] = 0;
                  vector[v] = 0;
                  vector[w] = depth > 0 ? 1 : -1;

                  // now apply vector to normal buffer

                  normals.push(vector.x, vector.y, vector.z);

                  // uvs

                  uvs.push(ix / gridX);
                  uvs.push(1 - iy / gridY);

                  // counters

                  vertexCounter += 1;
                }
              }

              // indices

              // 1. you need three indices to draw a single face
              // 2. a single segment consists of two faces
              // 3. so we need to generate six (2*3) indices per segment

              for (var _iy = 0; _iy < gridY; _iy++) {
                for (var _ix = 0; _ix < gridX; _ix++) {
                  var a = numberOfVertices + _ix + gridX1 * _iy;
                  var b = numberOfVertices + _ix + gridX1 * (_iy + 1);
                  var _c7 = numberOfVertices + (_ix + 1) + gridX1 * (_iy + 1);
                  var d = numberOfVertices + (_ix + 1) + gridX1 * _iy;

                  // faces

                  indices.push(a, b, d);
                  indices.push(b, _c7, d);

                  // increase counter

                  groupCount += 6;
                }
              }

              // add a group to the geometry. this will ensure multi material support

              scope.addGroup(groupStart, groupCount, materialIndex);

              // calculate new start value for groups

              groupStart += groupCount;

              // update total number of vertices

              numberOfVertices += vertexCounter;
            }
            return _this28;
          }
          _inherits(BoxGeometry, _BufferGeometry);
          return _createClass(BoxGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(BoxGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
            }
          }]);
        }(BufferGeometry);
        /**
         * Uniform Utilities
         */
        function cloneUniforms(src) {
          var dst = {};
          for (var u in src) {
            dst[u] = {};
            for (var _p3 in src[u]) {
              var property = src[u][_p3];
              if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
                if (property.isRenderTargetTexture) {
                  console.warn('UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().');
                  dst[u][_p3] = null;
                } else {
                  dst[u][_p3] = property.clone();
                }
              } else if (Array.isArray(property)) {
                dst[u][_p3] = property.slice();
              } else {
                dst[u][_p3] = property;
              }
            }
          }
          return dst;
        }
        function mergeUniforms(uniforms) {
          var merged = {};
          for (var u = 0; u < uniforms.length; u++) {
            var _tmp2 = cloneUniforms(uniforms[u]);
            for (var _p4 in _tmp2) {
              merged[_p4] = _tmp2[_p4];
            }
          }
          return merged;
        }
        function cloneUniformsGroups(src) {
          var dst = [];
          for (var u = 0; u < src.length; u++) {
            dst.push(src[u].clone());
          }
          return dst;
        }
        function getUnlitUniformColorSpace(renderer) {
          var currentRenderTarget = renderer.getRenderTarget();
          if (currentRenderTarget === null) {
            // https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
            return renderer.outputColorSpace;
          }

          // https://github.com/mrdoob/three.js/issues/27868
          if (currentRenderTarget.isXRRenderTarget === true) {
            return currentRenderTarget.texture.colorSpace;
          }
          return ColorManagement.workingColorSpace;
        }

        // Legacy

        var UniformsUtils = {
          clone: cloneUniforms,
          merge: mergeUniforms
        };
        var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
        var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
        var ShaderMaterial = /*#__PURE__*/function (_Material2) {
          function ShaderMaterial(parameters) {
            var _this29;
            _classCallCheck2(this, ShaderMaterial);
            _this29 = _callSuper(this, ShaderMaterial);
            _this29.isShaderMaterial = true;
            _this29.type = 'ShaderMaterial';
            _this29.defines = {};
            _this29.uniforms = {};
            _this29.uniformsGroups = [];
            _this29.vertexShader = default_vertex;
            _this29.fragmentShader = default_fragment;
            _this29.linewidth = 1;
            _this29.wireframe = false;
            _this29.wireframeLinewidth = 1;
            _this29.fog = false; // set to use scene fog
            _this29.lights = false; // set to use scene lights
            _this29.clipping = false; // set to use user-defined clipping planes

            _this29.forceSinglePass = true;
            _this29.extensions = {
              clipCullDistance: false,
              // set to use vertex shader clipping
              multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
            };

            // When rendered geometry doesn't include these attributes but the material does,
            // use these default values in WebGL. This avoids errors when buffer data is missing.
            _this29.defaultAttributeValues = {
              'color': [1, 1, 1],
              'uv': [0, 0],
              'uv1': [0, 0]
            };
            _this29.index0AttributeName = undefined;
            _this29.uniformsNeedUpdate = false;
            _this29.glslVersion = null;
            if (parameters !== undefined) {
              _this29.setValues(parameters);
            }
            return _this29;
          }
          _inherits(ShaderMaterial, _Material2);
          return _createClass(ShaderMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(ShaderMaterial, "copy", this, 3)([source]);
              this.fragmentShader = source.fragmentShader;
              this.vertexShader = source.vertexShader;
              this.uniforms = cloneUniforms(source.uniforms);
              this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
              this.defines = Object.assign({}, source.defines);
              this.wireframe = source.wireframe;
              this.wireframeLinewidth = source.wireframeLinewidth;
              this.fog = source.fog;
              this.lights = source.lights;
              this.clipping = source.clipping;
              this.extensions = Object.assign({}, source.extensions);
              this.glslVersion = source.glslVersion;
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON(meta) {
              var data = _superPropGet(ShaderMaterial, "toJSON", this, 3)([meta]);
              data.glslVersion = this.glslVersion;
              data.uniforms = {};
              for (var name in this.uniforms) {
                var uniform = this.uniforms[name];
                var value = uniform.value;
                if (value && value.isTexture) {
                  data.uniforms[name] = {
                    type: 't',
                    value: value.toJSON(meta).uuid
                  };
                } else if (value && value.isColor) {
                  data.uniforms[name] = {
                    type: 'c',
                    value: value.getHex()
                  };
                } else if (value && value.isVector2) {
                  data.uniforms[name] = {
                    type: 'v2',
                    value: value.toArray()
                  };
                } else if (value && value.isVector3) {
                  data.uniforms[name] = {
                    type: 'v3',
                    value: value.toArray()
                  };
                } else if (value && value.isVector4) {
                  data.uniforms[name] = {
                    type: 'v4',
                    value: value.toArray()
                  };
                } else if (value && value.isMatrix3) {
                  data.uniforms[name] = {
                    type: 'm3',
                    value: value.toArray()
                  };
                } else if (value && value.isMatrix4) {
                  data.uniforms[name] = {
                    type: 'm4',
                    value: value.toArray()
                  };
                } else {
                  data.uniforms[name] = {
                    value: value
                  };

                  // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
                }
              }
              if (Object.keys(this.defines).length > 0) data.defines = this.defines;
              data.vertexShader = this.vertexShader;
              data.fragmentShader = this.fragmentShader;
              data.lights = this.lights;
              data.clipping = this.clipping;
              var extensions = {};
              for (var key in this.extensions) {
                if (this.extensions[key] === true) extensions[key] = true;
              }
              if (Object.keys(extensions).length > 0) data.extensions = extensions;
              return data;
            }
          }]);
        }(Material);
        var Camera = /*#__PURE__*/function (_Object3D2) {
          function Camera() {
            var _this30;
            _classCallCheck2(this, Camera);
            _this30 = _callSuper(this, Camera);
            _this30.isCamera = true;
            _this30.type = 'Camera';
            _this30.matrixWorldInverse = new Matrix4();
            _this30.projectionMatrix = new Matrix4();
            _this30.projectionMatrixInverse = new Matrix4();
            _this30.coordinateSystem = WebGLCoordinateSystem;
            return _this30;
          }
          _inherits(Camera, _Object3D2);
          return _createClass(Camera, [{
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(Camera, "copy", this, 3)([source, recursive]);
              this.matrixWorldInverse.copy(source.matrixWorldInverse);
              this.projectionMatrix.copy(source.projectionMatrix);
              this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
              this.coordinateSystem = source.coordinateSystem;
              return this;
            }
          }, {
            key: "getWorldDirection",
            value: function getWorldDirection(target) {
              return _superPropGet(Camera, "getWorldDirection", this, 3)([target]).negate();
            }
          }, {
            key: "updateMatrixWorld",
            value: function updateMatrixWorld(force) {
              _superPropGet(Camera, "updateMatrixWorld", this, 3)([force]);
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
            }
          }, {
            key: "updateWorldMatrix",
            value: function updateWorldMatrix(updateParents, updateChildren) {
              _superPropGet(Camera, "updateWorldMatrix", this, 3)([updateParents, updateChildren]);
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }]);
        }(Object3D);
        var _v3$1 = /*@__PURE__*/new Vector3();
        var _minTarget = /*@__PURE__*/new Vector2();
        var _maxTarget = /*@__PURE__*/new Vector2();
        var PerspectiveCamera = /*#__PURE__*/function (_Camera) {
          function PerspectiveCamera() {
            var _this31;
            var fov = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
            var aspect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
            var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2000;
            _classCallCheck2(this, PerspectiveCamera);
            _this31 = _callSuper(this, PerspectiveCamera);
            _this31.isPerspectiveCamera = true;
            _this31.type = 'PerspectiveCamera';
            _this31.fov = fov;
            _this31.zoom = 1;
            _this31.near = near;
            _this31.far = far;
            _this31.focus = 10;
            _this31.aspect = aspect;
            _this31.view = null;
            _this31.filmGauge = 35; // width of the film (default in millimeters)
            _this31.filmOffset = 0; // horizontal film offset (same unit as gauge)

            _this31.updateProjectionMatrix();
            return _this31;
          }
          _inherits(PerspectiveCamera, _Camera);
          return _createClass(PerspectiveCamera, [{
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(PerspectiveCamera, "copy", this, 3)([source, recursive]);
              this.fov = source.fov;
              this.zoom = source.zoom;
              this.near = source.near;
              this.far = source.far;
              this.focus = source.focus;
              this.aspect = source.aspect;
              this.view = source.view === null ? null : Object.assign({}, source.view);
              this.filmGauge = source.filmGauge;
              this.filmOffset = source.filmOffset;
              return this;
            }

            /**
             * Sets the FOV by focal length in respect to the current .filmGauge.
             *
             * The default film gauge is 35, so that the focal length can be specified for
             * a 35mm (full frame) camera.
             *
             * Values for focal length and film gauge must have the same unit.
             */
          }, {
            key: "setFocalLength",
            value: function setFocalLength(focalLength) {
              /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
              var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
              this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
              this.updateProjectionMatrix();
            }

            /**
             * Calculates the focal length from the current .fov and .filmGauge.
             */
          }, {
            key: "getFocalLength",
            value: function getFocalLength() {
              var vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
              return 0.5 * this.getFilmHeight() / vExtentSlope;
            }
          }, {
            key: "getEffectiveFOV",
            value: function getEffectiveFOV() {
              return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
            }
          }, {
            key: "getFilmWidth",
            value: function getFilmWidth() {
              // film not completely covered in portrait format (aspect < 1)
              return this.filmGauge * Math.min(this.aspect, 1);
            }
          }, {
            key: "getFilmHeight",
            value: function getFilmHeight() {
              // film not completely covered in landscape format (aspect > 1)
              return this.filmGauge / Math.max(this.aspect, 1);
            }

            /**
             * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
             * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
             */
          }, {
            key: "getViewBounds",
            value: function getViewBounds(distance, minTarget, maxTarget) {
              _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
              minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
              _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
              maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
            }

            /**
             * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
             * Copies the result into the target Vector2, where x is width and y is height.
             */
          }, {
            key: "getViewSize",
            value: function getViewSize(distance, target) {
              this.getViewBounds(distance, _minTarget, _maxTarget);
              return target.subVectors(_maxTarget, _minTarget);
            }

            /**
             * Sets an offset in a larger frustum. This is useful for multi-window or
             * multi-monitor/multi-machine setups.
             *
             * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
             * the monitors are in grid like this
             *
             *   +---+---+---+
             *   | A | B | C |
             *   +---+---+---+
             *   | D | E | F |
             *   +---+---+---+
             *
             * then for each monitor you would call it like this
             *
             *   const w = 1920;
             *   const h = 1080;
             *   const fullWidth = w * 3;
             *   const fullHeight = h * 2;
             *
             *   --A--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
             *   --B--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
             *   --C--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
             *   --D--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
             *   --E--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
             *   --F--
             *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
             *
             *   Note there is no reason monitors have to be the same size or in a grid.
             */
          }, {
            key: "setViewOffset",
            value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
              this.aspect = fullWidth / fullHeight;
              if (this.view === null) {
                this.view = {
                  enabled: true,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1
                };
              }
              this.view.enabled = true;
              this.view.fullWidth = fullWidth;
              this.view.fullHeight = fullHeight;
              this.view.offsetX = x;
              this.view.offsetY = y;
              this.view.width = width;
              this.view.height = height;
              this.updateProjectionMatrix();
            }
          }, {
            key: "clearViewOffset",
            value: function clearViewOffset() {
              if (this.view !== null) {
                this.view.enabled = false;
              }
              this.updateProjectionMatrix();
            }
          }, {
            key: "updateProjectionMatrix",
            value: function updateProjectionMatrix() {
              var near = this.near;
              var top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
              var height = 2 * top;
              var width = this.aspect * height;
              var left = -0.5 * width;
              var view = this.view;
              if (this.view !== null && this.view.enabled) {
                var fullWidth = view.fullWidth,
                  fullHeight = view.fullHeight;
                left += view.offsetX * width / fullWidth;
                top -= view.offsetY * height / fullHeight;
                width *= view.width / fullWidth;
                height *= view.height / fullHeight;
              }
              var skew = this.filmOffset;
              if (skew !== 0) left += near * skew / this.getFilmWidth();
              this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
            }
          }, {
            key: "toJSON",
            value: function toJSON(meta) {
              var data = _superPropGet(PerspectiveCamera, "toJSON", this, 3)([meta]);
              data.object.fov = this.fov;
              data.object.zoom = this.zoom;
              data.object.near = this.near;
              data.object.far = this.far;
              data.object.focus = this.focus;
              data.object.aspect = this.aspect;
              if (this.view !== null) data.object.view = Object.assign({}, this.view);
              data.object.filmGauge = this.filmGauge;
              data.object.filmOffset = this.filmOffset;
              return data;
            }
          }]);
        }(Camera);
        var fov = -90; // negative fov is not an error
        var aspect = 1;
        var CubeCamera = /*#__PURE__*/function (_Object3D3) {
          function CubeCamera(near, far, renderTarget) {
            var _this32;
            _classCallCheck2(this, CubeCamera);
            _this32 = _callSuper(this, CubeCamera);
            _this32.type = 'CubeCamera';
            _this32.renderTarget = renderTarget;
            _this32.coordinateSystem = null;
            _this32.activeMipmapLevel = 0;
            var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
            cameraPX.layers = _this32.layers;
            _this32.add(cameraPX);
            var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
            cameraNX.layers = _this32.layers;
            _this32.add(cameraNX);
            var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
            cameraPY.layers = _this32.layers;
            _this32.add(cameraPY);
            var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
            cameraNY.layers = _this32.layers;
            _this32.add(cameraNY);
            var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
            cameraPZ.layers = _this32.layers;
            _this32.add(cameraPZ);
            var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
            cameraNZ.layers = _this32.layers;
            _this32.add(cameraNZ);
            return _this32;
          }
          _inherits(CubeCamera, _Object3D3);
          return _createClass(CubeCamera, [{
            key: "updateCoordinateSystem",
            value: function updateCoordinateSystem() {
              var coordinateSystem = this.coordinateSystem;
              var cameras = this.children.concat();
              var _cameras = _slicedToArray(cameras, 6),
                cameraPX = _cameras[0],
                cameraNX = _cameras[1],
                cameraPY = _cameras[2],
                cameraNY = _cameras[3],
                cameraPZ = _cameras[4],
                cameraNZ = _cameras[5];
              var _iterator20 = _createForOfIteratorHelper(cameras),
                _step20;
              try {
                for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
                  var camera = _step20.value;
                  this.remove(camera);
                }
              } catch (err) {
                _iterator20.e(err);
              } finally {
                _iterator20.f();
              }
              if (coordinateSystem === WebGLCoordinateSystem) {
                cameraPX.up.set(0, 1, 0);
                cameraPX.lookAt(1, 0, 0);
                cameraNX.up.set(0, 1, 0);
                cameraNX.lookAt(-1, 0, 0);
                cameraPY.up.set(0, 0, -1);
                cameraPY.lookAt(0, 1, 0);
                cameraNY.up.set(0, 0, 1);
                cameraNY.lookAt(0, -1, 0);
                cameraPZ.up.set(0, 1, 0);
                cameraPZ.lookAt(0, 0, 1);
                cameraNZ.up.set(0, 1, 0);
                cameraNZ.lookAt(0, 0, -1);
              } else if (coordinateSystem === WebGPUCoordinateSystem) {
                cameraPX.up.set(0, -1, 0);
                cameraPX.lookAt(-1, 0, 0);
                cameraNX.up.set(0, -1, 0);
                cameraNX.lookAt(1, 0, 0);
                cameraPY.up.set(0, 0, 1);
                cameraPY.lookAt(0, 1, 0);
                cameraNY.up.set(0, 0, -1);
                cameraNY.lookAt(0, -1, 0);
                cameraPZ.up.set(0, -1, 0);
                cameraPZ.lookAt(0, 0, 1);
                cameraNZ.up.set(0, -1, 0);
                cameraNZ.lookAt(0, 0, -1);
              } else {
                throw new Error('THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem);
              }
              var _iterator21 = _createForOfIteratorHelper(cameras),
                _step21;
              try {
                for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
                  var _camera2 = _step21.value;
                  this.add(_camera2);
                  _camera2.updateMatrixWorld();
                }
              } catch (err) {
                _iterator21.e(err);
              } finally {
                _iterator21.f();
              }
            }
          }, {
            key: "update",
            value: function update(renderer, scene) {
              if (this.parent === null) this.updateMatrixWorld();
              var renderTarget = this.renderTarget,
                activeMipmapLevel = this.activeMipmapLevel;
              if (this.coordinateSystem !== renderer.coordinateSystem) {
                this.coordinateSystem = renderer.coordinateSystem;
                this.updateCoordinateSystem();
              }
              var _this$children = _slicedToArray(this.children, 6),
                cameraPX = _this$children[0],
                cameraNX = _this$children[1],
                cameraPY = _this$children[2],
                cameraNY = _this$children[3],
                cameraPZ = _this$children[4],
                cameraNZ = _this$children[5];
              var currentRenderTarget = renderer.getRenderTarget();
              var currentActiveCubeFace = renderer.getActiveCubeFace();
              var currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
              var currentXrEnabled = renderer.xr.enabled;
              renderer.xr.enabled = false;
              var generateMipmaps = renderTarget.texture.generateMipmaps;
              renderTarget.texture.generateMipmaps = false;
              renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
              renderer.render(scene, cameraPX);
              renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
              renderer.render(scene, cameraNX);
              renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
              renderer.render(scene, cameraPY);
              renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
              renderer.render(scene, cameraNY);
              renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
              renderer.render(scene, cameraPZ);

              // mipmaps are generated during the last call of render()
              // at this point, all sides of the cube render target are defined

              renderTarget.texture.generateMipmaps = generateMipmaps;
              renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
              renderer.render(scene, cameraNZ);
              renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
              renderer.xr.enabled = currentXrEnabled;
              renderTarget.texture.needsPMREMUpdate = true;
            }
          }]);
        }(Object3D);
        var CubeTexture = /*#__PURE__*/function (_Texture3) {
          function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
            var _this33;
            _classCallCheck2(this, CubeTexture);
            images = images !== undefined ? images : [];
            mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
            _this33 = _callSuper(this, CubeTexture, [images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace]);
            _this33.isCubeTexture = true;
            _this33.flipY = false;
            return _this33;
          }
          _inherits(CubeTexture, _Texture3);
          return _createClass(CubeTexture, [{
            key: "images",
            get: function get() {
              return this.image;
            },
            set: function set(value) {
              this.image = value;
            }
          }]);
        }(Texture);
        var WebGLCubeRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget3) {
          function WebGLCubeRenderTarget() {
            var _this34;
            var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck2(this, WebGLCubeRenderTarget);
            _this34 = _callSuper(this, WebGLCubeRenderTarget, [size, size, options]);
            _this34.isWebGLCubeRenderTarget = true;
            var image = {
              width: size,
              height: size,
              depth: 1
            };
            var images = [image, image, image, image, image, image];
            _this34.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);

            // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
            // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
            // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

            // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
            // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
            // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

            _this34.texture.isRenderTargetTexture = true;
            _this34.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
            _this34.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
            return _this34;
          }
          _inherits(WebGLCubeRenderTarget, _WebGLRenderTarget3);
          return _createClass(WebGLCubeRenderTarget, [{
            key: "fromEquirectangularTexture",
            value: function fromEquirectangularTexture(renderer, texture) {
              this.texture.type = texture.type;
              this.texture.colorSpace = texture.colorSpace;
              this.texture.generateMipmaps = texture.generateMipmaps;
              this.texture.minFilter = texture.minFilter;
              this.texture.magFilter = texture.magFilter;
              var shader = {
                uniforms: {
                  tEquirect: {
                    value: null
                  }
                },
                vertexShader: /* glsl */"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                fragmentShader: /* glsl */"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
              };
              var geometry = new BoxGeometry(5, 5, 5);
              var material = new ShaderMaterial({
                name: 'CubemapFromEquirect',
                uniforms: cloneUniforms(shader.uniforms),
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader,
                side: BackSide,
                blending: NoBlending
              });
              material.uniforms.tEquirect.value = texture;
              var mesh = new Mesh(geometry, material);
              var currentMinFilter = texture.minFilter;

              // Avoid blurred poles
              if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
              var camera = new CubeCamera(1, 10, this);
              camera.update(renderer, mesh);
              texture.minFilter = currentMinFilter;
              mesh.geometry.dispose();
              mesh.material.dispose();
              return this;
            }
          }, {
            key: "clear",
            value: function clear(renderer, color, depth, stencil) {
              var currentRenderTarget = renderer.getRenderTarget();
              for (var i = 0; i < 6; i++) {
                renderer.setRenderTarget(this, i);
                renderer.clear(color, depth, stencil);
              }
              renderer.setRenderTarget(currentRenderTarget);
            }
          }]);
        }(WebGLRenderTarget);
        var _vector1 = /*@__PURE__*/new Vector3();
        var _vector2 = /*@__PURE__*/new Vector3();
        var _normalMatrix = /*@__PURE__*/new Matrix3();
        var Plane = /*#__PURE__*/function () {
          function Plane() {
            var normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(1, 0, 0);
            var constant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            _classCallCheck2(this, Plane);
            this.isPlane = true;

            // normal is assumed to be normalized

            this.normal = normal;
            this.constant = constant;
          }
          return _createClass(Plane, [{
            key: "set",
            value: function set(normal, constant) {
              this.normal.copy(normal);
              this.constant = constant;
              return this;
            }
          }, {
            key: "setComponents",
            value: function setComponents(x, y, z, w) {
              this.normal.set(x, y, z);
              this.constant = w;
              return this;
            }
          }, {
            key: "setFromNormalAndCoplanarPoint",
            value: function setFromNormalAndCoplanarPoint(normal, point) {
              this.normal.copy(normal);
              this.constant = -point.dot(this.normal);
              return this;
            }
          }, {
            key: "setFromCoplanarPoints",
            value: function setFromCoplanarPoints(a, b, c) {
              var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();

              // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

              this.setFromNormalAndCoplanarPoint(normal, a);
              return this;
            }
          }, {
            key: "copy",
            value: function copy(plane) {
              this.normal.copy(plane.normal);
              this.constant = plane.constant;
              return this;
            }
          }, {
            key: "normalize",
            value: function normalize() {
              // Note: will lead to a divide by zero if the plane is invalid.

              var inverseNormalLength = 1.0 / this.normal.length();
              this.normal.multiplyScalar(inverseNormalLength);
              this.constant *= inverseNormalLength;
              return this;
            }
          }, {
            key: "negate",
            value: function negate() {
              this.constant *= -1;
              this.normal.negate();
              return this;
            }
          }, {
            key: "distanceToPoint",
            value: function distanceToPoint(point) {
              return this.normal.dot(point) + this.constant;
            }
          }, {
            key: "distanceToSphere",
            value: function distanceToSphere(sphere) {
              return this.distanceToPoint(sphere.center) - sphere.radius;
            }
          }, {
            key: "projectPoint",
            value: function projectPoint(point, target) {
              return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
            }
          }, {
            key: "intersectLine",
            value: function intersectLine(line, target) {
              var direction = line.delta(_vector1);
              var denominator = this.normal.dot(direction);
              if (denominator === 0) {
                // line is coplanar, return origin
                if (this.distanceToPoint(line.start) === 0) {
                  return target.copy(line.start);
                }

                // Unsure if this is the correct method to handle this case.
                return null;
              }
              var t = -(line.start.dot(this.normal) + this.constant) / denominator;
              if (t < 0 || t > 1) {
                return null;
              }
              return target.copy(line.start).addScaledVector(direction, t);
            }
          }, {
            key: "intersectsLine",
            value: function intersectsLine(line) {
              // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

              var startSign = this.distanceToPoint(line.start);
              var endSign = this.distanceToPoint(line.end);
              return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
            }
          }, {
            key: "intersectsBox",
            value: function intersectsBox(box) {
              return box.intersectsPlane(this);
            }
          }, {
            key: "intersectsSphere",
            value: function intersectsSphere(sphere) {
              return sphere.intersectsPlane(this);
            }
          }, {
            key: "coplanarPoint",
            value: function coplanarPoint(target) {
              return target.copy(this.normal).multiplyScalar(-this.constant);
            }
          }, {
            key: "applyMatrix4",
            value: function applyMatrix4(matrix, optionalNormalMatrix) {
              var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
              var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
              var normal = this.normal.applyMatrix3(normalMatrix).normalize();
              this.constant = -referencePoint.dot(normal);
              return this;
            }
          }, {
            key: "translate",
            value: function translate(offset) {
              this.constant -= offset.dot(this.normal);
              return this;
            }
          }, {
            key: "equals",
            value: function equals(plane) {
              return plane.normal.equals(this.normal) && plane.constant === this.constant;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }]);
        }();
        var _sphere$5 = /*@__PURE__*/new Sphere();
        var _vector$7 = /*@__PURE__*/new Vector3();
        var Frustum = /*#__PURE__*/function () {
          function Frustum() {
            var p0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Plane();
            var p1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Plane();
            var p2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Plane();
            var p3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Plane();
            var p4 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Plane();
            var p5 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Plane();
            _classCallCheck2(this, Frustum);
            this.planes = [p0, p1, p2, p3, p4, p5];
          }
          return _createClass(Frustum, [{
            key: "set",
            value: function set(p0, p1, p2, p3, p4, p5) {
              var planes = this.planes;
              planes[0].copy(p0);
              planes[1].copy(p1);
              planes[2].copy(p2);
              planes[3].copy(p3);
              planes[4].copy(p4);
              planes[5].copy(p5);
              return this;
            }
          }, {
            key: "copy",
            value: function copy(frustum) {
              var planes = this.planes;
              for (var i = 0; i < 6; i++) {
                planes[i].copy(frustum.planes[i]);
              }
              return this;
            }
          }, {
            key: "setFromProjectionMatrix",
            value: function setFromProjectionMatrix(m) {
              var coordinateSystem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WebGLCoordinateSystem;
              var planes = this.planes;
              var me = m.elements;
              var me0 = me[0],
                me1 = me[1],
                me2 = me[2],
                me3 = me[3];
              var me4 = me[4],
                me5 = me[5],
                me6 = me[6],
                me7 = me[7];
              var me8 = me[8],
                me9 = me[9],
                me10 = me[10],
                me11 = me[11];
              var me12 = me[12],
                me13 = me[13],
                me14 = me[14],
                me15 = me[15];
              planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
              planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
              planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
              planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
              planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
              if (coordinateSystem === WebGLCoordinateSystem) {
                planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
              } else if (coordinateSystem === WebGPUCoordinateSystem) {
                planes[5].setComponents(me2, me6, me10, me14).normalize();
              } else {
                throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem);
              }
              return this;
            }
          }, {
            key: "intersectsObject",
            value: function intersectsObject(object) {
              if (object.boundingSphere !== undefined) {
                if (object.boundingSphere === null) object.computeBoundingSphere();
                _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
              } else {
                var geometry = object.geometry;
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
              }
              return this.intersectsSphere(_sphere$5);
            }
          }, {
            key: "intersectsSprite",
            value: function intersectsSprite(sprite) {
              _sphere$5.center.set(0, 0, 0);
              _sphere$5.radius = 0.7071067811865476;
              _sphere$5.applyMatrix4(sprite.matrixWorld);
              return this.intersectsSphere(_sphere$5);
            }
          }, {
            key: "intersectsSphere",
            value: function intersectsSphere(sphere) {
              var planes = this.planes;
              var center = sphere.center;
              var negRadius = -sphere.radius;
              for (var i = 0; i < 6; i++) {
                var distance = planes[i].distanceToPoint(center);
                if (distance < negRadius) {
                  return false;
                }
              }
              return true;
            }
          }, {
            key: "intersectsBox",
            value: function intersectsBox(box) {
              var planes = this.planes;
              for (var i = 0; i < 6; i++) {
                var plane = planes[i];

                // corner at max distance

                _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                if (plane.distanceToPoint(_vector$7) < 0) {
                  return false;
                }
              }
              return true;
            }
          }, {
            key: "containsPoint",
            value: function containsPoint(point) {
              var planes = this.planes;
              for (var i = 0; i < 6; i++) {
                if (planes[i].distanceToPoint(point) < 0) {
                  return false;
                }
              }
              return true;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }]);
        }();
        function WebGLAnimation() {
          var context = null;
          var isAnimating = false;
          var animationLoop = null;
          var requestId = null;
          function onAnimationFrame(time, frame) {
            animationLoop(time, frame);
            requestId = context.requestAnimationFrame(onAnimationFrame);
          }
          return {
            start: function start() {
              if (isAnimating === true) return;
              if (animationLoop === null) return;
              requestId = context.requestAnimationFrame(onAnimationFrame);
              isAnimating = true;
            },
            stop: function stop() {
              context.cancelAnimationFrame(requestId);
              isAnimating = false;
            },
            setAnimationLoop: function setAnimationLoop(callback) {
              animationLoop = callback;
            },
            setContext: function setContext(value) {
              context = value;
            }
          };
        }
        function WebGLAttributes(gl) {
          var buffers = new WeakMap();
          function createBuffer(attribute, bufferType) {
            var array = attribute.array;
            var usage = attribute.usage;
            var size = array.byteLength;
            var buffer = gl.createBuffer();
            gl.bindBuffer(bufferType, buffer);
            gl.bufferData(bufferType, array, usage);
            attribute.onUploadCallback();
            var type;
            if (array instanceof Float32Array) {
              type = gl.FLOAT;
            } else if (array instanceof Uint16Array) {
              if (attribute.isFloat16BufferAttribute) {
                type = gl.HALF_FLOAT;
              } else {
                type = gl.UNSIGNED_SHORT;
              }
            } else if (array instanceof Int16Array) {
              type = gl.SHORT;
            } else if (array instanceof Uint32Array) {
              type = gl.UNSIGNED_INT;
            } else if (array instanceof Int32Array) {
              type = gl.INT;
            } else if (array instanceof Int8Array) {
              type = gl.BYTE;
            } else if (array instanceof Uint8Array) {
              type = gl.UNSIGNED_BYTE;
            } else if (array instanceof Uint8ClampedArray) {
              type = gl.UNSIGNED_BYTE;
            } else {
              throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + array);
            }
            return {
              buffer: buffer,
              type: type,
              bytesPerElement: array.BYTES_PER_ELEMENT,
              version: attribute.version,
              size: size
            };
          }
          function updateBuffer(buffer, attribute, bufferType) {
            var array = attribute.array;
            var updateRange = attribute._updateRange; // @deprecated, r159
            var updateRanges = attribute.updateRanges;
            gl.bindBuffer(bufferType, buffer);
            if (updateRange.count === -1 && updateRanges.length === 0) {
              // Not using update ranges
              gl.bufferSubData(bufferType, 0, array);
            }
            if (updateRanges.length !== 0) {
              for (var i = 0, l = updateRanges.length; i < l; i++) {
                var range = updateRanges[i];
                gl.bufferSubData(bufferType, range.start * array.BYTES_PER_ELEMENT, array, range.start, range.count);
              }
              attribute.clearUpdateRanges();
            }

            // @deprecated, r159
            if (updateRange.count !== -1) {
              gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
              updateRange.count = -1; // reset range
            }
            attribute.onUploadCallback();
          }

          //

          function get(attribute) {
            if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
            return buffers.get(attribute);
          }
          function remove(attribute) {
            if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
            var data = buffers.get(attribute);
            if (data) {
              gl.deleteBuffer(data.buffer);
              buffers.delete(attribute);
            }
          }
          function update(attribute, bufferType) {
            if (attribute.isGLBufferAttribute) {
              var cached = buffers.get(attribute);
              if (!cached || cached.version < attribute.version) {
                buffers.set(attribute, {
                  buffer: attribute.buffer,
                  type: attribute.type,
                  bytesPerElement: attribute.elementSize,
                  version: attribute.version
                });
              }
              return;
            }
            if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
            var data = buffers.get(attribute);
            if (data === undefined) {
              buffers.set(attribute, createBuffer(attribute, bufferType));
            } else if (data.version < attribute.version) {
              if (data.size !== attribute.array.byteLength) {
                throw new Error('THREE.WebGLAttributes: The size of the buffer attribute\'s array buffer does not match the original size. Resizing buffer attributes is not supported.');
              }
              updateBuffer(data.buffer, attribute, bufferType);
              data.version = attribute.version;
            }
          }
          return {
            get: get,
            remove: remove,
            update: update
          };
        }
        var PlaneGeometry = /*#__PURE__*/function (_BufferGeometry2) {
          function PlaneGeometry() {
            var _this35;
            var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var widthSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            _classCallCheck2(this, PlaneGeometry);
            _this35 = _callSuper(this, PlaneGeometry);
            _this35.type = 'PlaneGeometry';
            _this35.parameters = {
              width: width,
              height: height,
              widthSegments: widthSegments,
              heightSegments: heightSegments
            };
            var width_half = width / 2;
            var height_half = height / 2;
            var gridX = Math.floor(widthSegments);
            var gridY = Math.floor(heightSegments);
            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;
            var segment_width = width / gridX;
            var segment_height = height / gridY;

            //

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            for (var iy = 0; iy < gridY1; iy++) {
              var y = iy * segment_height - height_half;
              for (var ix = 0; ix < gridX1; ix++) {
                var x = ix * segment_width - width_half;
                vertices.push(x, -y, 0);
                normals.push(0, 0, 1);
                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
              }
            }
            for (var _iy2 = 0; _iy2 < gridY; _iy2++) {
              for (var _ix2 = 0; _ix2 < gridX; _ix2++) {
                var a = _ix2 + gridX1 * _iy2;
                var b = _ix2 + gridX1 * (_iy2 + 1);
                var _c8 = _ix2 + 1 + gridX1 * (_iy2 + 1);
                var d = _ix2 + 1 + gridX1 * _iy2;
                indices.push(a, b, d);
                indices.push(b, _c8, d);
              }
            }
            _this35.setIndex(indices);
            _this35.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this35.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this35.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            return _this35;
          }
          _inherits(PlaneGeometry, _BufferGeometry2);
          return _createClass(PlaneGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(PlaneGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
            }
          }]);
        }(BufferGeometry);
        var alphahash_fragment = "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
        var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif";
        var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
        var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
        var alphatest_fragment = "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif";
        var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";
        var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";
        var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
        var batching_pars_vertex = "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif";
        var batching_vertex = "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";
        var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif";
        var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
        var bsdfs = "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated";
        var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";
        var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
        var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif";
        var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
        var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
        var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
        var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";
        var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";
        var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif";
        var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif";
        var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
        var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
        var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
        var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
        var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
        var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
        var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
        var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
        var colorspace_pars_fragment = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}";
        var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
        var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
        var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
        var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
        var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
        var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";
        var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";
        var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
        var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
        var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";
        var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
        var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
        var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";
        var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";
        var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif";
        var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
        var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";
        var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
        var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";
        var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";
        var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
        var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
        var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";
        var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
        var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
        var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
        var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
        var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";
        var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";
        var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
        var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
        var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
        var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
        var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
        var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif";
        var morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";
        var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";
        var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif";
        var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";
        var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
        var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
        var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
        var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
        var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";
        var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif";
        var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
        var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
        var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif";
        var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";
        var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
        var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}";
        var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
        var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
        var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
        var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
        var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
        var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
        var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif";
        var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
        var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";
        var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
        var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
        var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif";
        var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
        var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
        var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
        var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
        var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
        var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
        var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
        var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif";
        var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";
        var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";
        var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
        var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
        var vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
        var fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
        var vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
        var fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
        var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
        var fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
        var vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
        var fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
        var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
        var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
        var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
        var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
        var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
        var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
        var vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
        var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
        var vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
        var fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
        var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
        var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
        var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
        var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";
        var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
        var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
        var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";
        var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
        var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
        var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
        var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
        var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
        var vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
        var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";
        var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
        var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";
        var ShaderChunk = {
          alphahash_fragment: alphahash_fragment,
          alphahash_pars_fragment: alphahash_pars_fragment,
          alphamap_fragment: alphamap_fragment,
          alphamap_pars_fragment: alphamap_pars_fragment,
          alphatest_fragment: alphatest_fragment,
          alphatest_pars_fragment: alphatest_pars_fragment,
          aomap_fragment: aomap_fragment,
          aomap_pars_fragment: aomap_pars_fragment,
          batching_pars_vertex: batching_pars_vertex,
          batching_vertex: batching_vertex,
          begin_vertex: begin_vertex,
          beginnormal_vertex: beginnormal_vertex,
          bsdfs: bsdfs,
          iridescence_fragment: iridescence_fragment,
          bumpmap_pars_fragment: bumpmap_pars_fragment,
          clipping_planes_fragment: clipping_planes_fragment,
          clipping_planes_pars_fragment: clipping_planes_pars_fragment,
          clipping_planes_pars_vertex: clipping_planes_pars_vertex,
          clipping_planes_vertex: clipping_planes_vertex,
          color_fragment: color_fragment,
          color_pars_fragment: color_pars_fragment,
          color_pars_vertex: color_pars_vertex,
          color_vertex: color_vertex,
          common: common,
          cube_uv_reflection_fragment: cube_uv_reflection_fragment,
          defaultnormal_vertex: defaultnormal_vertex,
          displacementmap_pars_vertex: displacementmap_pars_vertex,
          displacementmap_vertex: displacementmap_vertex,
          emissivemap_fragment: emissivemap_fragment,
          emissivemap_pars_fragment: emissivemap_pars_fragment,
          colorspace_fragment: colorspace_fragment,
          colorspace_pars_fragment: colorspace_pars_fragment,
          envmap_fragment: envmap_fragment,
          envmap_common_pars_fragment: envmap_common_pars_fragment,
          envmap_pars_fragment: envmap_pars_fragment,
          envmap_pars_vertex: envmap_pars_vertex,
          envmap_physical_pars_fragment: envmap_physical_pars_fragment,
          envmap_vertex: envmap_vertex,
          fog_vertex: fog_vertex,
          fog_pars_vertex: fog_pars_vertex,
          fog_fragment: fog_fragment,
          fog_pars_fragment: fog_pars_fragment,
          gradientmap_pars_fragment: gradientmap_pars_fragment,
          lightmap_pars_fragment: lightmap_pars_fragment,
          lights_lambert_fragment: lights_lambert_fragment,
          lights_lambert_pars_fragment: lights_lambert_pars_fragment,
          lights_pars_begin: lights_pars_begin,
          lights_toon_fragment: lights_toon_fragment,
          lights_toon_pars_fragment: lights_toon_pars_fragment,
          lights_phong_fragment: lights_phong_fragment,
          lights_phong_pars_fragment: lights_phong_pars_fragment,
          lights_physical_fragment: lights_physical_fragment,
          lights_physical_pars_fragment: lights_physical_pars_fragment,
          lights_fragment_begin: lights_fragment_begin,
          lights_fragment_maps: lights_fragment_maps,
          lights_fragment_end: lights_fragment_end,
          logdepthbuf_fragment: logdepthbuf_fragment,
          logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
          logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
          logdepthbuf_vertex: logdepthbuf_vertex,
          map_fragment: map_fragment,
          map_pars_fragment: map_pars_fragment,
          map_particle_fragment: map_particle_fragment,
          map_particle_pars_fragment: map_particle_pars_fragment,
          metalnessmap_fragment: metalnessmap_fragment,
          metalnessmap_pars_fragment: metalnessmap_pars_fragment,
          morphinstance_vertex: morphinstance_vertex,
          morphcolor_vertex: morphcolor_vertex,
          morphnormal_vertex: morphnormal_vertex,
          morphtarget_pars_vertex: morphtarget_pars_vertex,
          morphtarget_vertex: morphtarget_vertex,
          normal_fragment_begin: normal_fragment_begin,
          normal_fragment_maps: normal_fragment_maps,
          normal_pars_fragment: normal_pars_fragment,
          normal_pars_vertex: normal_pars_vertex,
          normal_vertex: normal_vertex,
          normalmap_pars_fragment: normalmap_pars_fragment,
          clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
          clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
          clearcoat_pars_fragment: clearcoat_pars_fragment,
          iridescence_pars_fragment: iridescence_pars_fragment,
          opaque_fragment: opaque_fragment,
          packing: packing,
          premultiplied_alpha_fragment: premultiplied_alpha_fragment,
          project_vertex: project_vertex,
          dithering_fragment: dithering_fragment,
          dithering_pars_fragment: dithering_pars_fragment,
          roughnessmap_fragment: roughnessmap_fragment,
          roughnessmap_pars_fragment: roughnessmap_pars_fragment,
          shadowmap_pars_fragment: shadowmap_pars_fragment,
          shadowmap_pars_vertex: shadowmap_pars_vertex,
          shadowmap_vertex: shadowmap_vertex,
          shadowmask_pars_fragment: shadowmask_pars_fragment,
          skinbase_vertex: skinbase_vertex,
          skinning_pars_vertex: skinning_pars_vertex,
          skinning_vertex: skinning_vertex,
          skinnormal_vertex: skinnormal_vertex,
          specularmap_fragment: specularmap_fragment,
          specularmap_pars_fragment: specularmap_pars_fragment,
          tonemapping_fragment: tonemapping_fragment,
          tonemapping_pars_fragment: tonemapping_pars_fragment,
          transmission_fragment: transmission_fragment,
          transmission_pars_fragment: transmission_pars_fragment,
          uv_pars_fragment: uv_pars_fragment,
          uv_pars_vertex: uv_pars_vertex,
          uv_vertex: uv_vertex,
          worldpos_vertex: worldpos_vertex,
          background_vert: vertex$h,
          background_frag: fragment$h,
          backgroundCube_vert: vertex$g,
          backgroundCube_frag: fragment$g,
          cube_vert: vertex$f,
          cube_frag: fragment$f,
          depth_vert: vertex$e,
          depth_frag: fragment$e,
          distanceRGBA_vert: vertex$d,
          distanceRGBA_frag: fragment$d,
          equirect_vert: vertex$c,
          equirect_frag: fragment$c,
          linedashed_vert: vertex$b,
          linedashed_frag: fragment$b,
          meshbasic_vert: vertex$a,
          meshbasic_frag: fragment$a,
          meshlambert_vert: vertex$9,
          meshlambert_frag: fragment$9,
          meshmatcap_vert: vertex$8,
          meshmatcap_frag: fragment$8,
          meshnormal_vert: vertex$7,
          meshnormal_frag: fragment$7,
          meshphong_vert: vertex$6,
          meshphong_frag: fragment$6,
          meshphysical_vert: vertex$5,
          meshphysical_frag: fragment$5,
          meshtoon_vert: vertex$4,
          meshtoon_frag: fragment$4,
          points_vert: vertex$3,
          points_frag: fragment$3,
          shadow_vert: vertex$2,
          shadow_frag: fragment$2,
          sprite_vert: vertex$1,
          sprite_frag: fragment$1
        };

        /**
         * Uniforms library for shared webgl shaders
         */

        var UniformsLib = {
          common: {
            diffuse: {
              value: /*@__PURE__*/new Color(0xffffff)
            },
            opacity: {
              value: 1.0
            },
            map: {
              value: null
            },
            mapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            alphaMap: {
              value: null
            },
            alphaMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            alphaTest: {
              value: 0
            }
          },
          specularmap: {
            specularMap: {
              value: null
            },
            specularMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            }
          },
          envmap: {
            envMap: {
              value: null
            },
            envMapRotation: {
              value: /*@__PURE__*/new Matrix3()
            },
            flipEnvMap: {
              value: -1
            },
            reflectivity: {
              value: 1.0
            },
            // basic, lambert, phong
            ior: {
              value: 1.5
            },
            // physical
            refractionRatio: {
              value: 0.98
            } // basic, lambert, phong
          },
          aomap: {
            aoMap: {
              value: null
            },
            aoMapIntensity: {
              value: 1
            },
            aoMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            }
          },
          lightmap: {
            lightMap: {
              value: null
            },
            lightMapIntensity: {
              value: 1
            },
            lightMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            }
          },
          bumpmap: {
            bumpMap: {
              value: null
            },
            bumpMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            bumpScale: {
              value: 1
            }
          },
          normalmap: {
            normalMap: {
              value: null
            },
            normalMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            normalScale: {
              value: /*@__PURE__*/new Vector2(1, 1)
            }
          },
          displacementmap: {
            displacementMap: {
              value: null
            },
            displacementMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            displacementScale: {
              value: 1
            },
            displacementBias: {
              value: 0
            }
          },
          emissivemap: {
            emissiveMap: {
              value: null
            },
            emissiveMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            }
          },
          metalnessmap: {
            metalnessMap: {
              value: null
            },
            metalnessMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            }
          },
          roughnessmap: {
            roughnessMap: {
              value: null
            },
            roughnessMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            }
          },
          gradientmap: {
            gradientMap: {
              value: null
            }
          },
          fog: {
            fogDensity: {
              value: 0.00025
            },
            fogNear: {
              value: 1
            },
            fogFar: {
              value: 2000
            },
            fogColor: {
              value: /*@__PURE__*/new Color(0xffffff)
            }
          },
          lights: {
            ambientLightColor: {
              value: []
            },
            lightProbe: {
              value: []
            },
            directionalLights: {
              value: [],
              properties: {
                direction: {},
                color: {}
              }
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
              }
            },
            directionalShadowMap: {
              value: []
            },
            directionalShadowMatrix: {
              value: []
            },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
              }
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
              }
            },
            spotLightMap: {
              value: []
            },
            spotShadowMap: {
              value: []
            },
            spotLightMatrix: {
              value: []
            },
            pointLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
              }
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
              }
            },
            pointShadowMap: {
              value: []
            },
            pointShadowMatrix: {
              value: []
            },
            hemisphereLights: {
              value: [],
              properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
              }
            },
            // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
            rectAreaLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                width: {},
                height: {}
              }
            },
            ltc_1: {
              value: null
            },
            ltc_2: {
              value: null
            }
          },
          points: {
            diffuse: {
              value: /*@__PURE__*/new Color(0xffffff)
            },
            opacity: {
              value: 1.0
            },
            size: {
              value: 1.0
            },
            scale: {
              value: 1.0
            },
            map: {
              value: null
            },
            alphaMap: {
              value: null
            },
            alphaMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            alphaTest: {
              value: 0
            },
            uvTransform: {
              value: /*@__PURE__*/new Matrix3()
            }
          },
          sprite: {
            diffuse: {
              value: /*@__PURE__*/new Color(0xffffff)
            },
            opacity: {
              value: 1.0
            },
            center: {
              value: /*@__PURE__*/new Vector2(0.5, 0.5)
            },
            rotation: {
              value: 0.0
            },
            map: {
              value: null
            },
            mapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            alphaMap: {
              value: null
            },
            alphaMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            alphaTest: {
              value: 0
            }
          }
        };
        var ShaderLib = {
          basic: {
            uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
            vertexShader: ShaderChunk.meshbasic_vert,
            fragmentShader: ShaderChunk.meshbasic_frag
          },
          lambert: {
            uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
              emissive: {
                value: /*@__PURE__*/new Color(0x000000)
              }
            }]),
            vertexShader: ShaderChunk.meshlambert_vert,
            fragmentShader: ShaderChunk.meshlambert_frag
          },
          phong: {
            uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
              emissive: {
                value: /*@__PURE__*/new Color(0x000000)
              },
              specular: {
                value: /*@__PURE__*/new Color(0x111111)
              },
              shininess: {
                value: 30
              }
            }]),
            vertexShader: ShaderChunk.meshphong_vert,
            fragmentShader: ShaderChunk.meshphong_frag
          },
          standard: {
            uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
              emissive: {
                value: /*@__PURE__*/new Color(0x000000)
              },
              roughness: {
                value: 1.0
              },
              metalness: {
                value: 0.0
              },
              envMapIntensity: {
                value: 1
              }
            }]),
            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag
          },
          toon: {
            uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
              emissive: {
                value: /*@__PURE__*/new Color(0x000000)
              }
            }]),
            vertexShader: ShaderChunk.meshtoon_vert,
            fragmentShader: ShaderChunk.meshtoon_frag
          },
          matcap: {
            uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
              matcap: {
                value: null
              }
            }]),
            vertexShader: ShaderChunk.meshmatcap_vert,
            fragmentShader: ShaderChunk.meshmatcap_frag
          },
          points: {
            uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.points, UniformsLib.fog]),
            vertexShader: ShaderChunk.points_vert,
            fragmentShader: ShaderChunk.points_frag
          },
          dashed: {
            uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.fog, {
              scale: {
                value: 1
              },
              dashSize: {
                value: 1
              },
              totalSize: {
                value: 2
              }
            }]),
            vertexShader: ShaderChunk.linedashed_vert,
            fragmentShader: ShaderChunk.linedashed_frag
          },
          depth: {
            uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
            vertexShader: ShaderChunk.depth_vert,
            fragmentShader: ShaderChunk.depth_frag
          },
          normal: {
            uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
              opacity: {
                value: 1.0
              }
            }]),
            vertexShader: ShaderChunk.meshnormal_vert,
            fragmentShader: ShaderChunk.meshnormal_frag
          },
          sprite: {
            uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
            vertexShader: ShaderChunk.sprite_vert,
            fragmentShader: ShaderChunk.sprite_frag
          },
          background: {
            uniforms: {
              uvTransform: {
                value: /*@__PURE__*/new Matrix3()
              },
              t2D: {
                value: null
              },
              backgroundIntensity: {
                value: 1
              }
            },
            vertexShader: ShaderChunk.background_vert,
            fragmentShader: ShaderChunk.background_frag
          },
          backgroundCube: {
            uniforms: {
              envMap: {
                value: null
              },
              flipEnvMap: {
                value: -1
              },
              backgroundBlurriness: {
                value: 0
              },
              backgroundIntensity: {
                value: 1
              },
              backgroundRotation: {
                value: /*@__PURE__*/new Matrix3()
              }
            },
            vertexShader: ShaderChunk.backgroundCube_vert,
            fragmentShader: ShaderChunk.backgroundCube_frag
          },
          cube: {
            uniforms: {
              tCube: {
                value: null
              },
              tFlip: {
                value: -1
              },
              opacity: {
                value: 1.0
              }
            },
            vertexShader: ShaderChunk.cube_vert,
            fragmentShader: ShaderChunk.cube_frag
          },
          equirect: {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: ShaderChunk.equirect_vert,
            fragmentShader: ShaderChunk.equirect_frag
          },
          distanceRGBA: {
            uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
              referencePosition: {
                value: /*@__PURE__*/new Vector3()
              },
              nearDistance: {
                value: 1
              },
              farDistance: {
                value: 1000
              }
            }]),
            vertexShader: ShaderChunk.distanceRGBA_vert,
            fragmentShader: ShaderChunk.distanceRGBA_frag
          },
          shadow: {
            uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
              color: {
                value: /*@__PURE__*/new Color(0x00000)
              },
              opacity: {
                value: 1.0
              }
            }]),
            vertexShader: ShaderChunk.shadow_vert,
            fragmentShader: ShaderChunk.shadow_frag
          }
        };
        ShaderLib.physical = {
          uniforms: /*@__PURE__*/mergeUniforms([ShaderLib.standard.uniforms, {
            clearcoat: {
              value: 0
            },
            clearcoatMap: {
              value: null
            },
            clearcoatMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            clearcoatNormalMap: {
              value: null
            },
            clearcoatNormalMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            clearcoatNormalScale: {
              value: /*@__PURE__*/new Vector2(1, 1)
            },
            clearcoatRoughness: {
              value: 0
            },
            clearcoatRoughnessMap: {
              value: null
            },
            clearcoatRoughnessMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            dispersion: {
              value: 0
            },
            iridescence: {
              value: 0
            },
            iridescenceMap: {
              value: null
            },
            iridescenceMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            iridescenceIOR: {
              value: 1.3
            },
            iridescenceThicknessMinimum: {
              value: 100
            },
            iridescenceThicknessMaximum: {
              value: 400
            },
            iridescenceThicknessMap: {
              value: null
            },
            iridescenceThicknessMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            sheen: {
              value: 0
            },
            sheenColor: {
              value: /*@__PURE__*/new Color(0x000000)
            },
            sheenColorMap: {
              value: null
            },
            sheenColorMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            sheenRoughness: {
              value: 1
            },
            sheenRoughnessMap: {
              value: null
            },
            sheenRoughnessMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            transmission: {
              value: 0
            },
            transmissionMap: {
              value: null
            },
            transmissionMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            transmissionSamplerSize: {
              value: /*@__PURE__*/new Vector2()
            },
            transmissionSamplerMap: {
              value: null
            },
            thickness: {
              value: 0
            },
            thicknessMap: {
              value: null
            },
            thicknessMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            attenuationDistance: {
              value: 0
            },
            attenuationColor: {
              value: /*@__PURE__*/new Color(0x000000)
            },
            specularColor: {
              value: /*@__PURE__*/new Color(1, 1, 1)
            },
            specularColorMap: {
              value: null
            },
            specularColorMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            specularIntensity: {
              value: 1
            },
            specularIntensityMap: {
              value: null
            },
            specularIntensityMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            },
            anisotropyVector: {
              value: /*@__PURE__*/new Vector2()
            },
            anisotropyMap: {
              value: null
            },
            anisotropyMapTransform: {
              value: /*@__PURE__*/new Matrix3()
            }
          }]),
          vertexShader: ShaderChunk.meshphysical_vert,
          fragmentShader: ShaderChunk.meshphysical_frag
        };
        var _rgb = {
          r: 0,
          b: 0,
          g: 0
        };
        var _e1$1 = /*@__PURE__*/new Euler();
        var _m1$1 = /*@__PURE__*/new Matrix4();
        function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
          var clearColor = new Color(0x000000);
          var clearAlpha = alpha === true ? 0 : 1;
          var planeMesh;
          var boxMesh;
          var currentBackground = null;
          var currentBackgroundVersion = 0;
          var currentTonemapping = null;
          function getBackground(scene) {
            var background = scene.isScene === true ? scene.background : null;
            if (background && background.isTexture) {
              var usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
              background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
            }
            return background;
          }
          function render(scene) {
            var forceClear = false;
            var background = getBackground(scene);
            if (background === null) {
              setClear(clearColor, clearAlpha);
            } else if (background && background.isColor) {
              setClear(background, 1);
              forceClear = true;
            }
            var environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
            if (environmentBlendMode === 'additive') {
              state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
            } else if (environmentBlendMode === 'alpha-blend') {
              state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
            }
            if (renderer.autoClear || forceClear) {
              // buffers might not be writable which is required to ensure a correct clear

              state.buffers.depth.setTest(true);
              state.buffers.depth.setMask(true);
              state.buffers.color.setMask(true);
              renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
            }
          }
          function addToRenderList(renderList, scene) {
            var background = getBackground(scene);
            if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
              if (boxMesh === undefined) {
                boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
                  name: 'BackgroundCubeMaterial',
                  uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
                  vertexShader: ShaderLib.backgroundCube.vertexShader,
                  fragmentShader: ShaderLib.backgroundCube.fragmentShader,
                  side: BackSide,
                  depthTest: false,
                  depthWrite: false,
                  fog: false
                }));
                boxMesh.geometry.deleteAttribute('normal');
                boxMesh.geometry.deleteAttribute('uv');
                boxMesh.onBeforeRender = function (renderer, scene, camera) {
                  this.matrixWorld.copyPosition(camera.matrixWorld);
                };

                // add "envMap" material property so the renderer can evaluate it like for built-in materials
                Object.defineProperty(boxMesh.material, 'envMap', {
                  get: function get() {
                    return this.uniforms.envMap.value;
                  }
                });
                objects.update(boxMesh);
              }
              _e1$1.copy(scene.backgroundRotation);

              // accommodate left-handed frame
              _e1$1.x *= -1;
              _e1$1.y *= -1;
              _e1$1.z *= -1;
              if (background.isCubeTexture && background.isRenderTargetTexture === false) {
                // environment maps which are not cube render targets or PMREMs follow a different convention
                _e1$1.y *= -1;
                _e1$1.z *= -1;
              }
              boxMesh.material.uniforms.envMap.value = background;
              boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
              boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
              boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
              boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1));
              boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
              if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                boxMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
              }
              boxMesh.layers.enableAll();

              // push to the pre-sorted opaque render list
              renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
            } else if (background && background.isTexture) {
              if (planeMesh === undefined) {
                planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
                  name: 'BackgroundMaterial',
                  uniforms: cloneUniforms(ShaderLib.background.uniforms),
                  vertexShader: ShaderLib.background.vertexShader,
                  fragmentShader: ShaderLib.background.fragmentShader,
                  side: FrontSide,
                  depthTest: false,
                  depthWrite: false,
                  fog: false
                }));
                planeMesh.geometry.deleteAttribute('normal');

                // add "map" material property so the renderer can evaluate it like for built-in materials
                Object.defineProperty(planeMesh.material, 'map', {
                  get: function get() {
                    return this.uniforms.t2D.value;
                  }
                });
                objects.update(planeMesh);
              }
              planeMesh.material.uniforms.t2D.value = background;
              planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
              planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
              if (background.matrixAutoUpdate === true) {
                background.updateMatrix();
              }
              planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
              if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                planeMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
              }
              planeMesh.layers.enableAll();

              // push to the pre-sorted opaque render list
              renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
            }
          }
          function setClear(color, alpha) {
            color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
            state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha);
          }
          return {
            getClearColor: function getClearColor() {
              return clearColor;
            },
            setClearColor: function setClearColor(color) {
              var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
              clearColor.set(color);
              clearAlpha = alpha;
              setClear(clearColor, clearAlpha);
            },
            getClearAlpha: function getClearAlpha() {
              return clearAlpha;
            },
            setClearAlpha: function setClearAlpha(alpha) {
              clearAlpha = alpha;
              setClear(clearColor, clearAlpha);
            },
            render: render,
            addToRenderList: addToRenderList
          };
        }
        function WebGLBindingStates(gl, attributes) {
          var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
          var bindingStates = {};
          var defaultState = createBindingState(null);
          var currentState = defaultState;
          var forceUpdate = false;
          function setup(object, material, program, geometry, index) {
            var updateBuffers = false;
            var state = getBindingState(geometry, program, material);
            if (currentState !== state) {
              currentState = state;
              bindVertexArrayObject(currentState.object);
            }
            updateBuffers = needsUpdate(object, geometry, program, index);
            if (updateBuffers) saveCache(object, geometry, program, index);
            if (index !== null) {
              attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
            }
            if (updateBuffers || forceUpdate) {
              forceUpdate = false;
              setupVertexAttributes(object, material, program, geometry);
              if (index !== null) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
              }
            }
          }
          function createVertexArrayObject() {
            return gl.createVertexArray();
          }
          function bindVertexArrayObject(vao) {
            return gl.bindVertexArray(vao);
          }
          function deleteVertexArrayObject(vao) {
            return gl.deleteVertexArray(vao);
          }
          function getBindingState(geometry, program, material) {
            var wireframe = material.wireframe === true;
            var programMap = bindingStates[geometry.id];
            if (programMap === undefined) {
              programMap = {};
              bindingStates[geometry.id] = programMap;
            }
            var stateMap = programMap[program.id];
            if (stateMap === undefined) {
              stateMap = {};
              programMap[program.id] = stateMap;
            }
            var state = stateMap[wireframe];
            if (state === undefined) {
              state = createBindingState(createVertexArrayObject());
              stateMap[wireframe] = state;
            }
            return state;
          }
          function createBindingState(vao) {
            var newAttributes = [];
            var enabledAttributes = [];
            var attributeDivisors = [];
            for (var i = 0; i < maxVertexAttributes; i++) {
              newAttributes[i] = 0;
              enabledAttributes[i] = 0;
              attributeDivisors[i] = 0;
            }
            return {
              // for backward compatibility on non-VAO support browser
              geometry: null,
              program: null,
              wireframe: false,
              newAttributes: newAttributes,
              enabledAttributes: enabledAttributes,
              attributeDivisors: attributeDivisors,
              object: vao,
              attributes: {},
              index: null
            };
          }
          function needsUpdate(object, geometry, program, index) {
            var cachedAttributes = currentState.attributes;
            var geometryAttributes = geometry.attributes;
            var attributesNum = 0;
            var programAttributes = program.getAttributes();
            for (var name in programAttributes) {
              var programAttribute = programAttributes[name];
              if (programAttribute.location >= 0) {
                var cachedAttribute = cachedAttributes[name];
                var geometryAttribute = geometryAttributes[name];
                if (geometryAttribute === undefined) {
                  if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
                  if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
                }
                if (cachedAttribute === undefined) return true;
                if (cachedAttribute.attribute !== geometryAttribute) return true;
                if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
                attributesNum++;
              }
            }
            if (currentState.attributesNum !== attributesNum) return true;
            if (currentState.index !== index) return true;
            return false;
          }
          function saveCache(object, geometry, program, index) {
            var cache = {};
            var attributes = geometry.attributes;
            var attributesNum = 0;
            var programAttributes = program.getAttributes();
            for (var name in programAttributes) {
              var programAttribute = programAttributes[name];
              if (programAttribute.location >= 0) {
                var attribute = attributes[name];
                if (attribute === undefined) {
                  if (name === 'instanceMatrix' && object.instanceMatrix) attribute = object.instanceMatrix;
                  if (name === 'instanceColor' && object.instanceColor) attribute = object.instanceColor;
                }
                var data = {};
                data.attribute = attribute;
                if (attribute && attribute.data) {
                  data.data = attribute.data;
                }
                cache[name] = data;
                attributesNum++;
              }
            }
            currentState.attributes = cache;
            currentState.attributesNum = attributesNum;
            currentState.index = index;
          }
          function initAttributes() {
            var newAttributes = currentState.newAttributes;
            for (var i = 0, il = newAttributes.length; i < il; i++) {
              newAttributes[i] = 0;
            }
          }
          function enableAttribute(attribute) {
            enableAttributeAndDivisor(attribute, 0);
          }
          function enableAttributeAndDivisor(attribute, meshPerAttribute) {
            var newAttributes = currentState.newAttributes;
            var enabledAttributes = currentState.enabledAttributes;
            var attributeDivisors = currentState.attributeDivisors;
            newAttributes[attribute] = 1;
            if (enabledAttributes[attribute] === 0) {
              gl.enableVertexAttribArray(attribute);
              enabledAttributes[attribute] = 1;
            }
            if (attributeDivisors[attribute] !== meshPerAttribute) {
              gl.vertexAttribDivisor(attribute, meshPerAttribute);
              attributeDivisors[attribute] = meshPerAttribute;
            }
          }
          function disableUnusedAttributes() {
            var newAttributes = currentState.newAttributes;
            var enabledAttributes = currentState.enabledAttributes;
            for (var i = 0, il = enabledAttributes.length; i < il; i++) {
              if (enabledAttributes[i] !== newAttributes[i]) {
                gl.disableVertexAttribArray(i);
                enabledAttributes[i] = 0;
              }
            }
          }
          function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
            if (integer === true) {
              gl.vertexAttribIPointer(index, size, type, stride, offset);
            } else {
              gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
            }
          }
          function setupVertexAttributes(object, material, program, geometry) {
            initAttributes();
            var geometryAttributes = geometry.attributes;
            var programAttributes = program.getAttributes();
            var materialDefaultAttributeValues = material.defaultAttributeValues;
            for (var name in programAttributes) {
              var programAttribute = programAttributes[name];
              if (programAttribute.location >= 0) {
                var geometryAttribute = geometryAttributes[name];
                if (geometryAttribute === undefined) {
                  if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
                  if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
                }
                if (geometryAttribute !== undefined) {
                  var normalized = geometryAttribute.normalized;
                  var size = geometryAttribute.itemSize;
                  var attribute = attributes.get(geometryAttribute);

                  // TODO Attribute may not be available on context restore

                  if (attribute === undefined) continue;
                  var _buffer = attribute.buffer;
                  var type = attribute.type;
                  var bytesPerElement = attribute.bytesPerElement;

                  // check for integer attributes

                  var integer = type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType;
                  if (geometryAttribute.isInterleavedBufferAttribute) {
                    var data = geometryAttribute.data;
                    var stride = data.stride;
                    var offset = geometryAttribute.offset;
                    if (data.isInstancedInterleavedBuffer) {
                      for (var i = 0; i < programAttribute.locationSize; i++) {
                        enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
                      }
                      if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
                        geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                      }
                    } else {
                      for (var _i32 = 0; _i32 < programAttribute.locationSize; _i32++) {
                        enableAttribute(programAttribute.location + _i32);
                      }
                    }
                    gl.bindBuffer(gl.ARRAY_BUFFER, _buffer);
                    for (var _i33 = 0; _i33 < programAttribute.locationSize; _i33++) {
                      vertexAttribPointer(programAttribute.location + _i33, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * _i33) * bytesPerElement, integer);
                    }
                  } else {
                    if (geometryAttribute.isInstancedBufferAttribute) {
                      for (var _i34 = 0; _i34 < programAttribute.locationSize; _i34++) {
                        enableAttributeAndDivisor(programAttribute.location + _i34, geometryAttribute.meshPerAttribute);
                      }
                      if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
                        geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                      }
                    } else {
                      for (var _i35 = 0; _i35 < programAttribute.locationSize; _i35++) {
                        enableAttribute(programAttribute.location + _i35);
                      }
                    }
                    gl.bindBuffer(gl.ARRAY_BUFFER, _buffer);
                    for (var _i36 = 0; _i36 < programAttribute.locationSize; _i36++) {
                      vertexAttribPointer(programAttribute.location + _i36, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * _i36 * bytesPerElement, integer);
                    }
                  }
                } else if (materialDefaultAttributeValues !== undefined) {
                  var value = materialDefaultAttributeValues[name];
                  if (value !== undefined) {
                    switch (value.length) {
                      case 2:
                        gl.vertexAttrib2fv(programAttribute.location, value);
                        break;
                      case 3:
                        gl.vertexAttrib3fv(programAttribute.location, value);
                        break;
                      case 4:
                        gl.vertexAttrib4fv(programAttribute.location, value);
                        break;
                      default:
                        gl.vertexAttrib1fv(programAttribute.location, value);
                    }
                  }
                }
              }
            }
            disableUnusedAttributes();
          }
          function dispose() {
            reset();
            for (var geometryId in bindingStates) {
              var programMap = bindingStates[geometryId];
              for (var programId in programMap) {
                var stateMap = programMap[programId];
                for (var wireframe in stateMap) {
                  deleteVertexArrayObject(stateMap[wireframe].object);
                  delete stateMap[wireframe];
                }
                delete programMap[programId];
              }
              delete bindingStates[geometryId];
            }
          }
          function releaseStatesOfGeometry(geometry) {
            if (bindingStates[geometry.id] === undefined) return;
            var programMap = bindingStates[geometry.id];
            for (var programId in programMap) {
              var stateMap = programMap[programId];
              for (var wireframe in stateMap) {
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
              }
              delete programMap[programId];
            }
            delete bindingStates[geometry.id];
          }
          function releaseStatesOfProgram(program) {
            for (var geometryId in bindingStates) {
              var programMap = bindingStates[geometryId];
              if (programMap[program.id] === undefined) continue;
              var stateMap = programMap[program.id];
              for (var wireframe in stateMap) {
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
              }
              delete programMap[program.id];
            }
          }
          function reset() {
            resetDefaultState();
            forceUpdate = true;
            if (currentState === defaultState) return;
            currentState = defaultState;
            bindVertexArrayObject(currentState.object);
          }

          // for backward-compatibility

          function resetDefaultState() {
            defaultState.geometry = null;
            defaultState.program = null;
            defaultState.wireframe = false;
          }
          return {
            setup: setup,
            reset: reset,
            resetDefaultState: resetDefaultState,
            dispose: dispose,
            releaseStatesOfGeometry: releaseStatesOfGeometry,
            releaseStatesOfProgram: releaseStatesOfProgram,
            initAttributes: initAttributes,
            enableAttribute: enableAttribute,
            disableUnusedAttributes: disableUnusedAttributes
          };
        }
        function WebGLBufferRenderer(gl, extensions, info) {
          var mode;
          function setMode(value) {
            mode = value;
          }
          function render(start, count) {
            gl.drawArrays(mode, start, count);
            info.update(count, mode, 1);
          }
          function renderInstances(start, count, primcount) {
            if (primcount === 0) return;
            gl.drawArraysInstanced(mode, start, count, primcount);
            info.update(count, mode, primcount);
          }
          function renderMultiDraw(starts, counts, drawCount) {
            if (drawCount === 0) return;
            var extension = extensions.get('WEBGL_multi_draw');
            extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
            var elementCount = 0;
            for (var i = 0; i < drawCount; i++) {
              elementCount += counts[i];
            }
            info.update(elementCount, mode, 1);
          }
          function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
            if (drawCount === 0) return;
            var extension = extensions.get('WEBGL_multi_draw');
            if (extension === null) {
              for (var i = 0; i < starts.length; i++) {
                renderInstances(starts[i], counts[i], primcount[i]);
              }
            } else {
              extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
              var elementCount = 0;
              for (var _i37 = 0; _i37 < drawCount; _i37++) {
                elementCount += counts[_i37];
              }
              for (var _i38 = 0; _i38 < primcount.length; _i38++) {
                info.update(elementCount, mode, primcount[_i38]);
              }
            }
          }

          //

          this.setMode = setMode;
          this.render = render;
          this.renderInstances = renderInstances;
          this.renderMultiDraw = renderMultiDraw;
          this.renderMultiDrawInstances = renderMultiDrawInstances;
        }
        function WebGLCapabilities(gl, extensions, parameters, utils) {
          var maxAnisotropy;
          function getMaxAnisotropy() {
            if (maxAnisotropy !== undefined) return maxAnisotropy;
            if (extensions.has('EXT_texture_filter_anisotropic') === true) {
              var extension = extensions.get('EXT_texture_filter_anisotropic');
              maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else {
              maxAnisotropy = 0;
            }
            return maxAnisotropy;
          }
          function textureFormatReadable(textureFormat) {
            if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
              return false;
            }
            return true;
          }
          function textureTypeReadable(textureType) {
            var halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || extensions.has('EXT_color_buffer_float'));
            if (textureType !== UnsignedByteType && utils.convert(textureType) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE) &&
            // Edge and Chrome Mac < 52 (#9513)
            textureType !== FloatType && !halfFloatSupportedByExt) {
              return false;
            }
            return true;
          }
          function getMaxPrecision(precision) {
            if (precision === 'highp') {
              if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                return 'highp';
              }
              precision = 'mediump';
            }
            if (precision === 'mediump') {
              if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                return 'mediump';
              }
            }
            return 'lowp';
          }
          var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
          var maxPrecision = getMaxPrecision(precision);
          if (maxPrecision !== precision) {
            console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
            precision = maxPrecision;
          }
          var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
          var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
          var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
          var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
          var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
          var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
          var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
          var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
          var vertexTextures = maxVertexTextures > 0;
          var maxSamples = gl.getParameter(gl.MAX_SAMPLES);
          return {
            isWebGL2: true,
            // keeping this for backwards compatibility

            getMaxAnisotropy: getMaxAnisotropy,
            getMaxPrecision: getMaxPrecision,
            textureFormatReadable: textureFormatReadable,
            textureTypeReadable: textureTypeReadable,
            precision: precision,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            maxTextures: maxTextures,
            maxVertexTextures: maxVertexTextures,
            maxTextureSize: maxTextureSize,
            maxCubemapSize: maxCubemapSize,
            maxAttributes: maxAttributes,
            maxVertexUniforms: maxVertexUniforms,
            maxVaryings: maxVaryings,
            maxFragmentUniforms: maxFragmentUniforms,
            vertexTextures: vertexTextures,
            maxSamples: maxSamples
          };
        }
        function WebGLClipping(properties) {
          var scope = this;
          var globalState = null,
            numGlobalPlanes = 0,
            localClippingEnabled = false,
            renderingShadows = false;
          var plane = new Plane(),
            viewNormalMatrix = new Matrix3(),
            uniform = {
              value: null,
              needsUpdate: false
            };
          this.uniform = uniform;
          this.numPlanes = 0;
          this.numIntersection = 0;
          this.init = function (planes, enableLocalClipping) {
            var enabled = planes.length !== 0 || enableLocalClipping ||
            // enable state of previous frame - the clipping code has to
            // run another frame in order to reset the state:
            numGlobalPlanes !== 0 || localClippingEnabled;
            localClippingEnabled = enableLocalClipping;
            numGlobalPlanes = planes.length;
            return enabled;
          };
          this.beginShadows = function () {
            renderingShadows = true;
            projectPlanes(null);
          };
          this.endShadows = function () {
            renderingShadows = false;
          };
          this.setGlobalState = function (planes, camera) {
            globalState = projectPlanes(planes, camera, 0);
          };
          this.setState = function (material, camera, useCache) {
            var planes = material.clippingPlanes,
              clipIntersection = material.clipIntersection,
              clipShadows = material.clipShadows;
            var materialProperties = properties.get(material);
            if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
              // there's no local clipping

              if (renderingShadows) {
                // there's no global clipping

                projectPlanes(null);
              } else {
                resetGlobalState();
              }
            } else {
              var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
                lGlobal = nGlobal * 4;
              var dstArray = materialProperties.clippingState || null;
              uniform.value = dstArray; // ensure unique state

              dstArray = projectPlanes(planes, camera, lGlobal, useCache);
              for (var i = 0; i !== lGlobal; ++i) {
                dstArray[i] = globalState[i];
              }
              materialProperties.clippingState = dstArray;
              this.numIntersection = clipIntersection ? this.numPlanes : 0;
              this.numPlanes += nGlobal;
            }
          };
          function resetGlobalState() {
            if (uniform.value !== globalState) {
              uniform.value = globalState;
              uniform.needsUpdate = numGlobalPlanes > 0;
            }
            scope.numPlanes = numGlobalPlanes;
            scope.numIntersection = 0;
          }
          function projectPlanes(planes, camera, dstOffset, skipTransform) {
            var nPlanes = planes !== null ? planes.length : 0;
            var dstArray = null;
            if (nPlanes !== 0) {
              dstArray = uniform.value;
              if (skipTransform !== true || dstArray === null) {
                var flatSize = dstOffset + nPlanes * 4,
                  viewMatrix = camera.matrixWorldInverse;
                viewNormalMatrix.getNormalMatrix(viewMatrix);
                if (dstArray === null || dstArray.length < flatSize) {
                  dstArray = new Float32Array(flatSize);
                }
                for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                  plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                  plane.normal.toArray(dstArray, i4);
                  dstArray[i4 + 3] = plane.constant;
                }
              }
              uniform.value = dstArray;
              uniform.needsUpdate = true;
            }
            scope.numPlanes = nPlanes;
            scope.numIntersection = 0;
            return dstArray;
          }
        }
        function WebGLCubeMaps(renderer) {
          var cubemaps = new WeakMap();
          function mapTextureMapping(texture, mapping) {
            if (mapping === EquirectangularReflectionMapping) {
              texture.mapping = CubeReflectionMapping;
            } else if (mapping === EquirectangularRefractionMapping) {
              texture.mapping = CubeRefractionMapping;
            }
            return texture;
          }
          function get(texture) {
            if (texture && texture.isTexture) {
              var mapping = texture.mapping;
              if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
                if (cubemaps.has(texture)) {
                  var cubemap = cubemaps.get(texture).texture;
                  return mapTextureMapping(cubemap, texture.mapping);
                } else {
                  var image = texture.image;
                  if (image && image.height > 0) {
                    var renderTarget = new WebGLCubeRenderTarget(image.height);
                    renderTarget.fromEquirectangularTexture(renderer, texture);
                    cubemaps.set(texture, renderTarget);
                    texture.addEventListener('dispose', onTextureDispose);
                    return mapTextureMapping(renderTarget.texture, texture.mapping);
                  } else {
                    // image not yet ready. try the conversion next frame

                    return null;
                  }
                }
              }
            }
            return texture;
          }
          function onTextureDispose(event) {
            var texture = event.target;
            texture.removeEventListener('dispose', onTextureDispose);
            var cubemap = cubemaps.get(texture);
            if (cubemap !== undefined) {
              cubemaps.delete(texture);
              cubemap.dispose();
            }
          }
          function dispose() {
            cubemaps = new WeakMap();
          }
          return {
            get: get,
            dispose: dispose
          };
        }
        var OrthographicCamera = /*#__PURE__*/function (_Camera2) {
          function OrthographicCamera() {
            var _this36;
            var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
            var right = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var top = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var bottom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
            var near = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;
            var far = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2000;
            _classCallCheck2(this, OrthographicCamera);
            _this36 = _callSuper(this, OrthographicCamera);
            _this36.isOrthographicCamera = true;
            _this36.type = 'OrthographicCamera';
            _this36.zoom = 1;
            _this36.view = null;
            _this36.left = left;
            _this36.right = right;
            _this36.top = top;
            _this36.bottom = bottom;
            _this36.near = near;
            _this36.far = far;
            _this36.updateProjectionMatrix();
            return _this36;
          }
          _inherits(OrthographicCamera, _Camera2);
          return _createClass(OrthographicCamera, [{
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(OrthographicCamera, "copy", this, 3)([source, recursive]);
              this.left = source.left;
              this.right = source.right;
              this.top = source.top;
              this.bottom = source.bottom;
              this.near = source.near;
              this.far = source.far;
              this.zoom = source.zoom;
              this.view = source.view === null ? null : Object.assign({}, source.view);
              return this;
            }
          }, {
            key: "setViewOffset",
            value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
              if (this.view === null) {
                this.view = {
                  enabled: true,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1
                };
              }
              this.view.enabled = true;
              this.view.fullWidth = fullWidth;
              this.view.fullHeight = fullHeight;
              this.view.offsetX = x;
              this.view.offsetY = y;
              this.view.width = width;
              this.view.height = height;
              this.updateProjectionMatrix();
            }
          }, {
            key: "clearViewOffset",
            value: function clearViewOffset() {
              if (this.view !== null) {
                this.view.enabled = false;
              }
              this.updateProjectionMatrix();
            }
          }, {
            key: "updateProjectionMatrix",
            value: function updateProjectionMatrix() {
              var dx = (this.right - this.left) / (2 * this.zoom);
              var dy = (this.top - this.bottom) / (2 * this.zoom);
              var cx = (this.right + this.left) / 2;
              var cy = (this.top + this.bottom) / 2;
              var left = cx - dx;
              var right = cx + dx;
              var top = cy + dy;
              var bottom = cy - dy;
              if (this.view !== null && this.view.enabled) {
                var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
                var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                left += scaleW * this.view.offsetX;
                right = left + scaleW * this.view.width;
                top -= scaleH * this.view.offsetY;
                bottom = top - scaleH * this.view.height;
              }
              this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
            }
          }, {
            key: "toJSON",
            value: function toJSON(meta) {
              var data = _superPropGet(OrthographicCamera, "toJSON", this, 3)([meta]);
              data.object.zoom = this.zoom;
              data.object.left = this.left;
              data.object.right = this.right;
              data.object.top = this.top;
              data.object.bottom = this.bottom;
              data.object.near = this.near;
              data.object.far = this.far;
              if (this.view !== null) data.object.view = Object.assign({}, this.view);
              return data;
            }
          }]);
        }(Camera);
        var LOD_MIN = 4;

        // The standard deviations (radians) associated with the extra mips. These are
        // chosen to approximate a Trowbridge-Reitz distribution function times the
        // geometric shadowing function. These sigma values squared must match the
        // variance #defines in cube_uv_reflection_fragment.glsl.js.
        var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];

        // The maximum length of the blur for loop. Smaller sigmas will use fewer
        // samples and exit early, but not recompile the shader.
        var MAX_SAMPLES = 20;
        var _flatCamera = /*@__PURE__*/new OrthographicCamera();
        var _clearColor = /*@__PURE__*/new Color();
        var _oldTarget = null;
        var _oldActiveCubeFace = 0;
        var _oldActiveMipmapLevel = 0;
        var _oldXrEnabled = false;

        // Golden Ratio
        var PHI = (1 + Math.sqrt(5)) / 2;
        var INV_PHI = 1 / PHI;

        // Vertices of a dodecahedron (except the opposites, which represent the
        // same axis), used as axis directions evenly spread on a sphere.
        var _axisDirections = [/*@__PURE__*/new Vector3(-PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, 1)];

        /**
         * This class generates a Prefiltered, Mipmapped Radiance Environment Map
         * (PMREM) from a cubeMap environment texture. This allows different levels of
         * blur to be quickly accessed based on material roughness. It is packed into a
         * special CubeUV format that allows us to perform custom interpolation so that
         * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
         * chain, it only goes down to the LOD_MIN level (above), and then creates extra
         * even more filtered 'mips' at the same LOD_MIN resolution, associated with
         * higher roughness levels. In this way we maintain resolution to smoothly
         * interpolate diffuse lighting while limiting sampling computation.
         *
         * Paper: Fast, Accurate Image-Based Lighting
         * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
        */
        var PMREMGenerator = /*#__PURE__*/function () {
          function PMREMGenerator(renderer) {
            _classCallCheck2(this, PMREMGenerator);
            this._renderer = renderer;
            this._pingPongRenderTarget = null;
            this._lodMax = 0;
            this._cubeSize = 0;
            this._lodPlanes = [];
            this._sizeLods = [];
            this._sigmas = [];
            this._blurMaterial = null;
            this._cubemapMaterial = null;
            this._equirectMaterial = null;
            this._compileMaterial(this._blurMaterial);
          }

          /**
           * Generates a PMREM from a supplied Scene, which can be faster than using an
           * image if networking bandwidth is low. Optional sigma specifies a blur radius
           * in radians to be applied to the scene before PMREM generation. Optional near
           * and far planes ensure the scene is rendered in its entirety (the cubeCamera
           * is placed at the origin).
           */
          return _createClass(PMREMGenerator, [{
            key: "fromScene",
            value: function fromScene(scene) {
              var sigma = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
              var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;
              _oldTarget = this._renderer.getRenderTarget();
              _oldActiveCubeFace = this._renderer.getActiveCubeFace();
              _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
              _oldXrEnabled = this._renderer.xr.enabled;
              this._renderer.xr.enabled = false;
              this._setSize(256);
              var cubeUVRenderTarget = this._allocateTargets();
              cubeUVRenderTarget.depthBuffer = true;
              this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
              if (sigma > 0) {
                this._blur(cubeUVRenderTarget, 0, 0, sigma);
              }
              this._applyPMREM(cubeUVRenderTarget);
              this._cleanup(cubeUVRenderTarget);
              return cubeUVRenderTarget;
            }

            /**
             * Generates a PMREM from an equirectangular texture, which can be either LDR
             * or HDR. The ideal input image size is 1k (1024 x 512),
             * as this matches best with the 256 x 256 cubemap output.
             * The smallest supported equirectangular image size is 64 x 32.
             */
          }, {
            key: "fromEquirectangular",
            value: function fromEquirectangular(equirectangular) {
              var renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
              return this._fromTexture(equirectangular, renderTarget);
            }

            /**
             * Generates a PMREM from an cubemap texture, which can be either LDR
             * or HDR. The ideal input cube size is 256 x 256,
             * as this matches best with the 256 x 256 cubemap output.
             * The smallest supported cube size is 16 x 16.
             */
          }, {
            key: "fromCubemap",
            value: function fromCubemap(cubemap) {
              var renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
              return this._fromTexture(cubemap, renderTarget);
            }

            /**
             * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
             * your texture's network fetch for increased concurrency.
             */
          }, {
            key: "compileCubemapShader",
            value: function compileCubemapShader() {
              if (this._cubemapMaterial === null) {
                this._cubemapMaterial = _getCubemapMaterial();
                this._compileMaterial(this._cubemapMaterial);
              }
            }

            /**
             * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
             * your texture's network fetch for increased concurrency.
             */
          }, {
            key: "compileEquirectangularShader",
            value: function compileEquirectangularShader() {
              if (this._equirectMaterial === null) {
                this._equirectMaterial = _getEquirectMaterial();
                this._compileMaterial(this._equirectMaterial);
              }
            }

            /**
             * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
             * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
             * one of them will cause any others to also become unusable.
             */
          }, {
            key: "dispose",
            value: function dispose() {
              this._dispose();
              if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
              if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
            }

            // private interface
          }, {
            key: "_setSize",
            value: function _setSize(cubeSize) {
              this._lodMax = Math.floor(Math.log2(cubeSize));
              this._cubeSize = Math.pow(2, this._lodMax);
            }
          }, {
            key: "_dispose",
            value: function _dispose() {
              if (this._blurMaterial !== null) this._blurMaterial.dispose();
              if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
              for (var i = 0; i < this._lodPlanes.length; i++) {
                this._lodPlanes[i].dispose();
              }
            }
          }, {
            key: "_cleanup",
            value: function _cleanup(outputTarget) {
              this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
              this._renderer.xr.enabled = _oldXrEnabled;
              outputTarget.scissorTest = false;
              _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
            }
          }, {
            key: "_fromTexture",
            value: function _fromTexture(texture, renderTarget) {
              if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
                this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
              } else {
                // Equirectangular

                this._setSize(texture.image.width / 4);
              }
              _oldTarget = this._renderer.getRenderTarget();
              _oldActiveCubeFace = this._renderer.getActiveCubeFace();
              _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
              _oldXrEnabled = this._renderer.xr.enabled;
              this._renderer.xr.enabled = false;
              var cubeUVRenderTarget = renderTarget || this._allocateTargets();
              this._textureToCubeUV(texture, cubeUVRenderTarget);
              this._applyPMREM(cubeUVRenderTarget);
              this._cleanup(cubeUVRenderTarget);
              return cubeUVRenderTarget;
            }
          }, {
            key: "_allocateTargets",
            value: function _allocateTargets() {
              var width = 3 * Math.max(this._cubeSize, 16 * 7);
              var height = 4 * this._cubeSize;
              var params = {
                magFilter: LinearFilter,
                minFilter: LinearFilter,
                generateMipmaps: false,
                type: HalfFloatType,
                format: RGBAFormat,
                colorSpace: LinearSRGBColorSpace,
                depthBuffer: false
              };
              var cubeUVRenderTarget = _createRenderTarget(width, height, params);
              if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
                if (this._pingPongRenderTarget !== null) {
                  this._dispose();
                }
                this._pingPongRenderTarget = _createRenderTarget(width, height, params);
                var _lodMax = this._lodMax;
                var _createPlanes2 = _createPlanes(_lodMax);
                this._sizeLods = _createPlanes2.sizeLods;
                this._lodPlanes = _createPlanes2.lodPlanes;
                this._sigmas = _createPlanes2.sigmas;
                this._blurMaterial = _getBlurShader(_lodMax, width, height);
              }
              return cubeUVRenderTarget;
            }
          }, {
            key: "_compileMaterial",
            value: function _compileMaterial(material) {
              var tmpMesh = new Mesh(this._lodPlanes[0], material);
              this._renderer.compile(tmpMesh, _flatCamera);
            }
          }, {
            key: "_sceneToCubeUV",
            value: function _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
              var fov = 90;
              var aspect = 1;
              var cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
              var upSign = [1, -1, 1, 1, 1, 1];
              var forwardSign = [1, 1, 1, -1, -1, -1];
              var renderer = this._renderer;
              var originalAutoClear = renderer.autoClear;
              var toneMapping = renderer.toneMapping;
              renderer.getClearColor(_clearColor);
              renderer.toneMapping = NoToneMapping;
              renderer.autoClear = false;
              var backgroundMaterial = new MeshBasicMaterial({
                name: 'PMREM.Background',
                side: BackSide,
                depthWrite: false,
                depthTest: false
              });
              var backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
              var useSolidColor = false;
              var background = scene.background;
              if (background) {
                if (background.isColor) {
                  backgroundMaterial.color.copy(background);
                  scene.background = null;
                  useSolidColor = true;
                }
              } else {
                backgroundMaterial.color.copy(_clearColor);
                useSolidColor = true;
              }
              for (var i = 0; i < 6; i++) {
                var col = i % 3;
                if (col === 0) {
                  cubeCamera.up.set(0, upSign[i], 0);
                  cubeCamera.lookAt(forwardSign[i], 0, 0);
                } else if (col === 1) {
                  cubeCamera.up.set(0, 0, upSign[i]);
                  cubeCamera.lookAt(0, forwardSign[i], 0);
                } else {
                  cubeCamera.up.set(0, upSign[i], 0);
                  cubeCamera.lookAt(0, 0, forwardSign[i]);
                }
                var size = this._cubeSize;
                _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
                renderer.setRenderTarget(cubeUVRenderTarget);
                if (useSolidColor) {
                  renderer.render(backgroundBox, cubeCamera);
                }
                renderer.render(scene, cubeCamera);
              }
              backgroundBox.geometry.dispose();
              backgroundBox.material.dispose();
              renderer.toneMapping = toneMapping;
              renderer.autoClear = originalAutoClear;
              scene.background = background;
            }
          }, {
            key: "_textureToCubeUV",
            value: function _textureToCubeUV(texture, cubeUVRenderTarget) {
              var renderer = this._renderer;
              var isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
              if (isCubeTexture) {
                if (this._cubemapMaterial === null) {
                  this._cubemapMaterial = _getCubemapMaterial();
                }
                this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
              } else {
                if (this._equirectMaterial === null) {
                  this._equirectMaterial = _getEquirectMaterial();
                }
              }
              var material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
              var mesh = new Mesh(this._lodPlanes[0], material);
              var uniforms = material.uniforms;
              uniforms['envMap'].value = texture;
              var size = this._cubeSize;
              _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
              renderer.setRenderTarget(cubeUVRenderTarget);
              renderer.render(mesh, _flatCamera);
            }
          }, {
            key: "_applyPMREM",
            value: function _applyPMREM(cubeUVRenderTarget) {
              var renderer = this._renderer;
              var autoClear = renderer.autoClear;
              renderer.autoClear = false;
              var n = this._lodPlanes.length;
              for (var i = 1; i < n; i++) {
                var sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
                var poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];
                this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
              }
              renderer.autoClear = autoClear;
            }

            /**
             * This is a two-pass Gaussian blur for a cubemap. Normally this is done
             * vertically and horizontally, but this breaks down on a cube. Here we apply
             * the blur latitudinally (around the poles), and then longitudinally (towards
             * the poles) to approximate the orthogonally-separable blur. It is least
             * accurate at the poles, but still does a decent job.
             */
          }, {
            key: "_blur",
            value: function _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
              var pingPongRenderTarget = this._pingPongRenderTarget;
              this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
              this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
            }
          }, {
            key: "_halfBlur",
            value: function _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
              var renderer = this._renderer;
              var blurMaterial = this._blurMaterial;
              if (direction !== 'latitudinal' && direction !== 'longitudinal') {
                console.error('blur direction must be either latitudinal or longitudinal!');
              }

              // Number of standard deviations at which to cut off the discrete approximation.
              var STANDARD_DEVIATIONS = 3;
              var blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
              var blurUniforms = blurMaterial.uniforms;
              var pixels = this._sizeLods[lodIn] - 1;
              var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
              var sigmaPixels = sigmaRadians / radiansPerPixel;
              var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
              if (samples > MAX_SAMPLES) {
                console.warn("sigmaRadians, ".concat(sigmaRadians, ", is too large and will clip, as it requested ").concat(samples, " samples when the maximum is set to ").concat(MAX_SAMPLES));
              }
              var weights = [];
              var sum = 0;
              for (var i = 0; i < MAX_SAMPLES; ++i) {
                var _x3 = i / sigmaPixels;
                var weight = Math.exp(-_x3 * _x3 / 2);
                weights.push(weight);
                if (i === 0) {
                  sum += weight;
                } else if (i < samples) {
                  sum += 2 * weight;
                }
              }
              for (var _i39 = 0; _i39 < weights.length; _i39++) {
                weights[_i39] = weights[_i39] / sum;
              }
              blurUniforms['envMap'].value = targetIn.texture;
              blurUniforms['samples'].value = samples;
              blurUniforms['weights'].value = weights;
              blurUniforms['latitudinal'].value = direction === 'latitudinal';
              if (poleAxis) {
                blurUniforms['poleAxis'].value = poleAxis;
              }
              var _lodMax = this._lodMax;
              blurUniforms['dTheta'].value = radiansPerPixel;
              blurUniforms['mipInt'].value = _lodMax - lodIn;
              var outputSize = this._sizeLods[lodOut];
              var x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
              var y = 4 * (this._cubeSize - outputSize);
              _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
              renderer.setRenderTarget(targetOut);
              renderer.render(blurMesh, _flatCamera);
            }
          }]);
        }();
        function _createPlanes(lodMax) {
          var lodPlanes = [];
          var sizeLods = [];
          var sigmas = [];
          var lod = lodMax;
          var totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
          for (var i = 0; i < totalLods; i++) {
            var sizeLod = Math.pow(2, lod);
            sizeLods.push(sizeLod);
            var sigma = 1.0 / sizeLod;
            if (i > lodMax - LOD_MIN) {
              sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
            } else if (i === 0) {
              sigma = 0;
            }
            sigmas.push(sigma);
            var texelSize = 1.0 / (sizeLod - 2);
            var min = -texelSize;
            var max = 1 + texelSize;
            var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
            var cubeFaces = 6;
            var vertices = 6;
            var positionSize = 3;
            var uvSize = 2;
            var faceIndexSize = 1;
            var position = new Float32Array(positionSize * vertices * cubeFaces);
            var uv = new Float32Array(uvSize * vertices * cubeFaces);
            var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
            for (var face = 0; face < cubeFaces; face++) {
              var x = face % 3 * 2 / 3 - 1;
              var y = face > 2 ? 0 : -1;
              var coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
              position.set(coordinates, positionSize * vertices * face);
              uv.set(uv1, uvSize * vertices * face);
              var _fill = [face, face, face, face, face, face];
              faceIndex.set(_fill, faceIndexSize * vertices * face);
            }
            var planes = new BufferGeometry();
            planes.setAttribute('position', new BufferAttribute(position, positionSize));
            planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
            planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
            lodPlanes.push(planes);
            if (lod > LOD_MIN) {
              lod--;
            }
          }
          return {
            lodPlanes: lodPlanes,
            sizeLods: sizeLods,
            sigmas: sigmas
          };
        }
        function _createRenderTarget(width, height, params) {
          var cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
          cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
          cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
          cubeUVRenderTarget.scissorTest = true;
          return cubeUVRenderTarget;
        }
        function _setViewport(target, x, y, width, height) {
          target.viewport.set(x, y, width, height);
          target.scissor.set(x, y, width, height);
        }
        function _getBlurShader(lodMax, width, height) {
          var weights = new Float32Array(MAX_SAMPLES);
          var poleAxis = new Vector3(0, 1, 0);
          var shaderMaterial = new ShaderMaterial({
            name: 'SphericalGaussianBlur',
            defines: {
              'n': MAX_SAMPLES,
              'CUBEUV_TEXEL_WIDTH': 1.0 / width,
              'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
              'CUBEUV_MAX_MIP': "".concat(lodMax, ".0")
            },
            uniforms: {
              'envMap': {
                value: null
              },
              'samples': {
                value: 1
              },
              'weights': {
                value: weights
              },
              'latitudinal': {
                value: false
              },
              'dTheta': {
                value: 0
              },
              'mipInt': {
                value: 0
              },
              'poleAxis': {
                value: poleAxis
              }
            },
            vertexShader: _getCommonVertexShader(),
            fragmentShader: /* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
          });
          return shaderMaterial;
        }
        function _getEquirectMaterial() {
          return new ShaderMaterial({
            name: 'EquirectangularToCubeUV',
            uniforms: {
              'envMap': {
                value: null
              }
            },
            vertexShader: _getCommonVertexShader(),
            fragmentShader: /* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
          });
        }
        function _getCubemapMaterial() {
          return new ShaderMaterial({
            name: 'CubemapToCubeUV',
            uniforms: {
              'envMap': {
                value: null
              },
              'flipEnvMap': {
                value: -1
              }
            },
            vertexShader: _getCommonVertexShader(),
            fragmentShader: /* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
          });
        }
        function _getCommonVertexShader() {
          return /* glsl */"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
        }
        function WebGLCubeUVMaps(renderer) {
          var cubeUVmaps = new WeakMap();
          var pmremGenerator = null;
          function get(texture) {
            if (texture && texture.isTexture) {
              var mapping = texture.mapping;
              var isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
              var isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;

              // equirect/cube map to cubeUV conversion

              if (isEquirectMap || isCubeMap) {
                var renderTarget = cubeUVmaps.get(texture);
                var currentPMREMVersion = renderTarget !== undefined ? renderTarget.texture.pmremVersion : 0;
                if (texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion) {
                  if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
                  renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
                  renderTarget.texture.pmremVersion = texture.pmremVersion;
                  cubeUVmaps.set(texture, renderTarget);
                  return renderTarget.texture;
                } else {
                  if (renderTarget !== undefined) {
                    return renderTarget.texture;
                  } else {
                    var image = texture.image;
                    if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
                      if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
                      renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                      renderTarget.texture.pmremVersion = texture.pmremVersion;
                      cubeUVmaps.set(texture, renderTarget);
                      texture.addEventListener('dispose', onTextureDispose);
                      return renderTarget.texture;
                    } else {
                      // image not yet ready. try the conversion next frame

                      return null;
                    }
                  }
                }
              }
            }
            return texture;
          }
          function isCubeTextureComplete(image) {
            var count = 0;
            var length = 6;
            for (var i = 0; i < length; i++) {
              if (image[i] !== undefined) count++;
            }
            return count === length;
          }
          function onTextureDispose(event) {
            var texture = event.target;
            texture.removeEventListener('dispose', onTextureDispose);
            var cubemapUV = cubeUVmaps.get(texture);
            if (cubemapUV !== undefined) {
              cubeUVmaps.delete(texture);
              cubemapUV.dispose();
            }
          }
          function dispose() {
            cubeUVmaps = new WeakMap();
            if (pmremGenerator !== null) {
              pmremGenerator.dispose();
              pmremGenerator = null;
            }
          }
          return {
            get: get,
            dispose: dispose
          };
        }
        function WebGLExtensions(gl) {
          var extensions = {};
          function getExtension(name) {
            if (extensions[name] !== undefined) {
              return extensions[name];
            }
            var extension;
            switch (name) {
              case 'WEBGL_depth_texture':
                extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                break;
              case 'EXT_texture_filter_anisotropic':
                extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                break;
              case 'WEBGL_compressed_texture_s3tc':
                extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                break;
              case 'WEBGL_compressed_texture_pvrtc':
                extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                break;
              default:
                extension = gl.getExtension(name);
            }
            extensions[name] = extension;
            return extension;
          }
          return {
            has: function has(name) {
              return getExtension(name) !== null;
            },
            init: function init() {
              getExtension('EXT_color_buffer_float');
              getExtension('WEBGL_clip_cull_distance');
              getExtension('OES_texture_float_linear');
              getExtension('EXT_color_buffer_half_float');
              getExtension('WEBGL_multisampled_render_to_texture');
              getExtension('WEBGL_render_shared_exponent');
            },
            get: function get(name) {
              var extension = getExtension(name);
              if (extension === null) {
                warnOnce('THREE.WebGLRenderer: ' + name + ' extension not supported.');
              }
              return extension;
            }
          };
        }
        function WebGLGeometries(gl, attributes, info, bindingStates) {
          var geometries = {};
          var wireframeAttributes = new WeakMap();
          function onGeometryDispose(event) {
            var geometry = event.target;
            if (geometry.index !== null) {
              attributes.remove(geometry.index);
            }
            for (var name in geometry.attributes) {
              attributes.remove(geometry.attributes[name]);
            }
            for (var _name4 in geometry.morphAttributes) {
              var array = geometry.morphAttributes[_name4];
              for (var i = 0, l = array.length; i < l; i++) {
                attributes.remove(array[i]);
              }
            }
            geometry.removeEventListener('dispose', onGeometryDispose);
            delete geometries[geometry.id];
            var attribute = wireframeAttributes.get(geometry);
            if (attribute) {
              attributes.remove(attribute);
              wireframeAttributes.delete(geometry);
            }
            bindingStates.releaseStatesOfGeometry(geometry);
            if (geometry.isInstancedBufferGeometry === true) {
              delete geometry._maxInstanceCount;
            }

            //

            info.memory.geometries--;
          }
          function get(object, geometry) {
            if (geometries[geometry.id] === true) return geometry;
            geometry.addEventListener('dispose', onGeometryDispose);
            geometries[geometry.id] = true;
            info.memory.geometries++;
            return geometry;
          }
          function update(geometry) {
            var geometryAttributes = geometry.attributes;

            // Updating index buffer in VAO now. See WebGLBindingStates.

            for (var name in geometryAttributes) {
              attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
            }

            // morph targets

            var morphAttributes = geometry.morphAttributes;
            for (var _name5 in morphAttributes) {
              var array = morphAttributes[_name5];
              for (var i = 0, l = array.length; i < l; i++) {
                attributes.update(array[i], gl.ARRAY_BUFFER);
              }
            }
          }
          function updateWireframeAttribute(geometry) {
            var indices = [];
            var geometryIndex = geometry.index;
            var geometryPosition = geometry.attributes.position;
            var version = 0;
            if (geometryIndex !== null) {
              var array = geometryIndex.array;
              version = geometryIndex.version;
              for (var i = 0, l = array.length; i < l; i += 3) {
                var a = array[i + 0];
                var b = array[i + 1];
                var _c9 = array[i + 2];
                indices.push(a, b, b, _c9, _c9, a);
              }
            } else if (geometryPosition !== undefined) {
              var _array = geometryPosition.array;
              version = geometryPosition.version;
              for (var _i40 = 0, _l6 = _array.length / 3 - 1; _i40 < _l6; _i40 += 3) {
                var _a6 = _i40 + 0;
                var _b6 = _i40 + 1;
                var _c10 = _i40 + 2;
                indices.push(_a6, _b6, _b6, _c10, _c10, _a6);
              }
            } else {
              return;
            }
            var attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
            attribute.version = version;

            // Updating index buffer in VAO now. See WebGLBindingStates

            //

            var previousAttribute = wireframeAttributes.get(geometry);
            if (previousAttribute) attributes.remove(previousAttribute);

            //

            wireframeAttributes.set(geometry, attribute);
          }
          function getWireframeAttribute(geometry) {
            var currentAttribute = wireframeAttributes.get(geometry);
            if (currentAttribute) {
              var geometryIndex = geometry.index;
              if (geometryIndex !== null) {
                // if the attribute is obsolete, create a new one

                if (currentAttribute.version < geometryIndex.version) {
                  updateWireframeAttribute(geometry);
                }
              }
            } else {
              updateWireframeAttribute(geometry);
            }
            return wireframeAttributes.get(geometry);
          }
          return {
            get: get,
            update: update,
            getWireframeAttribute: getWireframeAttribute
          };
        }
        function WebGLIndexedBufferRenderer(gl, extensions, info) {
          var mode;
          function setMode(value) {
            mode = value;
          }
          var type, bytesPerElement;
          function setIndex(value) {
            type = value.type;
            bytesPerElement = value.bytesPerElement;
          }
          function render(start, count) {
            gl.drawElements(mode, count, type, start * bytesPerElement);
            info.update(count, mode, 1);
          }
          function renderInstances(start, count, primcount) {
            if (primcount === 0) return;
            gl.drawElementsInstanced(mode, count, type, start * bytesPerElement, primcount);
            info.update(count, mode, primcount);
          }
          function renderMultiDraw(starts, counts, drawCount) {
            if (drawCount === 0) return;
            var extension = extensions.get('WEBGL_multi_draw');
            extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);
            var elementCount = 0;
            for (var i = 0; i < drawCount; i++) {
              elementCount += counts[i];
            }
            info.update(elementCount, mode, 1);
          }
          function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
            if (drawCount === 0) return;
            var extension = extensions.get('WEBGL_multi_draw');
            if (extension === null) {
              for (var i = 0; i < starts.length; i++) {
                renderInstances(starts[i] / bytesPerElement, counts[i], primcount[i]);
              }
            } else {
              extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, primcount, 0, drawCount);
              var elementCount = 0;
              for (var _i41 = 0; _i41 < drawCount; _i41++) {
                elementCount += counts[_i41];
              }
              for (var _i42 = 0; _i42 < primcount.length; _i42++) {
                info.update(elementCount, mode, primcount[_i42]);
              }
            }
          }

          //

          this.setMode = setMode;
          this.setIndex = setIndex;
          this.render = render;
          this.renderInstances = renderInstances;
          this.renderMultiDraw = renderMultiDraw;
          this.renderMultiDrawInstances = renderMultiDrawInstances;
        }
        function WebGLInfo(gl) {
          var memory = {
            geometries: 0,
            textures: 0
          };
          var render = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
          };
          function update(count, mode, instanceCount) {
            render.calls++;
            switch (mode) {
              case gl.TRIANGLES:
                render.triangles += instanceCount * (count / 3);
                break;
              case gl.LINES:
                render.lines += instanceCount * (count / 2);
                break;
              case gl.LINE_STRIP:
                render.lines += instanceCount * (count - 1);
                break;
              case gl.LINE_LOOP:
                render.lines += instanceCount * count;
                break;
              case gl.POINTS:
                render.points += instanceCount * count;
                break;
              default:
                console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                break;
            }
          }
          function reset() {
            render.calls = 0;
            render.triangles = 0;
            render.points = 0;
            render.lines = 0;
          }
          return {
            memory: memory,
            render: render,
            programs: null,
            autoReset: true,
            reset: reset,
            update: update
          };
        }
        function WebGLMorphtargets(gl, capabilities, textures) {
          var morphTextures = new WeakMap();
          var morph = new Vector4();
          function update(object, geometry, program) {
            var objectInfluences = object.morphTargetInfluences;

            // the following encodes morph targets into an array of data textures. Each layer represents a single morph target.

            var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
            var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
            var entry = morphTextures.get(geometry);
            if (entry === undefined || entry.count !== morphTargetsCount) {
              if (entry !== undefined) entry.texture.dispose();
              var hasMorphPosition = geometry.morphAttributes.position !== undefined;
              var hasMorphNormals = geometry.morphAttributes.normal !== undefined;
              var hasMorphColors = geometry.morphAttributes.color !== undefined;
              var morphTargets = geometry.morphAttributes.position || [];
              var morphNormals = geometry.morphAttributes.normal || [];
              var morphColors = geometry.morphAttributes.color || [];
              var vertexDataCount = 0;
              if (hasMorphPosition === true) vertexDataCount = 1;
              if (hasMorphNormals === true) vertexDataCount = 2;
              if (hasMorphColors === true) vertexDataCount = 3;
              var width = geometry.attributes.position.count * vertexDataCount;
              var height = 1;
              if (width > capabilities.maxTextureSize) {
                height = Math.ceil(width / capabilities.maxTextureSize);
                width = capabilities.maxTextureSize;
              }
              var _buffer2 = new Float32Array(width * height * 4 * morphTargetsCount);
              var texture = new DataArrayTexture(_buffer2, width, height, morphTargetsCount);
              texture.type = FloatType;
              texture.needsUpdate = true;

              // fill buffer

              var vertexDataStride = vertexDataCount * 4;
              for (var i = 0; i < morphTargetsCount; i++) {
                var morphTarget = morphTargets[i];
                var morphNormal = morphNormals[i];
                var morphColor = morphColors[i];
                var offset = width * height * 4 * i;
                for (var j = 0; j < morphTarget.count; j++) {
                  var stride = j * vertexDataStride;
                  if (hasMorphPosition === true) {
                    morph.fromBufferAttribute(morphTarget, j);
                    _buffer2[offset + stride + 0] = morph.x;
                    _buffer2[offset + stride + 1] = morph.y;
                    _buffer2[offset + stride + 2] = morph.z;
                    _buffer2[offset + stride + 3] = 0;
                  }
                  if (hasMorphNormals === true) {
                    morph.fromBufferAttribute(morphNormal, j);
                    _buffer2[offset + stride + 4] = morph.x;
                    _buffer2[offset + stride + 5] = morph.y;
                    _buffer2[offset + stride + 6] = morph.z;
                    _buffer2[offset + stride + 7] = 0;
                  }
                  if (hasMorphColors === true) {
                    morph.fromBufferAttribute(morphColor, j);
                    _buffer2[offset + stride + 8] = morph.x;
                    _buffer2[offset + stride + 9] = morph.y;
                    _buffer2[offset + stride + 10] = morph.z;
                    _buffer2[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
                  }
                }
              }
              entry = {
                count: morphTargetsCount,
                texture: texture,
                size: new Vector2(width, height)
              };
              morphTextures.set(geometry, entry);
              function disposeTexture() {
                texture.dispose();
                morphTextures.delete(geometry);
                geometry.removeEventListener('dispose', disposeTexture);
              }
              geometry.addEventListener('dispose', disposeTexture);
            }

            //
            if (object.isInstancedMesh === true && object.morphTexture !== null) {
              program.getUniforms().setValue(gl, 'morphTexture', object.morphTexture, textures);
            } else {
              var morphInfluencesSum = 0;
              for (var _i43 = 0; _i43 < objectInfluences.length; _i43++) {
                morphInfluencesSum += objectInfluences[_i43];
              }
              var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
              program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
              program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);
            }
            program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);
            program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);
          }
          return {
            update: update
          };
        }
        function WebGLObjects(gl, geometries, attributes, info) {
          var updateMap = new WeakMap();
          function update(object) {
            var frame = info.render.frame;
            var geometry = object.geometry;
            var buffergeometry = geometries.get(object, geometry);

            // Update once per frame

            if (updateMap.get(buffergeometry) !== frame) {
              geometries.update(buffergeometry);
              updateMap.set(buffergeometry, frame);
            }
            if (object.isInstancedMesh) {
              if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
                object.addEventListener('dispose', onInstancedMeshDispose);
              }
              if (updateMap.get(object) !== frame) {
                attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
                if (object.instanceColor !== null) {
                  attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
                }
                updateMap.set(object, frame);
              }
            }
            if (object.isSkinnedMesh) {
              var skeleton = object.skeleton;
              if (updateMap.get(skeleton) !== frame) {
                skeleton.update();
                updateMap.set(skeleton, frame);
              }
            }
            return buffergeometry;
          }
          function dispose() {
            updateMap = new WeakMap();
          }
          function onInstancedMeshDispose(event) {
            var instancedMesh = event.target;
            instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
            attributes.remove(instancedMesh.instanceMatrix);
            if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
          }
          return {
            update: update,
            dispose: dispose
          };
        }
        var DepthTexture = /*#__PURE__*/function (_Texture4) {
          function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
            var _this37;
            var format = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : DepthFormat;
            _classCallCheck2(this, DepthTexture);
            if (format !== DepthFormat && format !== DepthStencilFormat) {
              throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
            }
            if (type === undefined && format === DepthFormat) type = UnsignedIntType;
            if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
            _this37 = _callSuper(this, DepthTexture, [null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy]);
            _this37.isDepthTexture = true;
            _this37.image = {
              width: width,
              height: height
            };
            _this37.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
            _this37.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
            _this37.flipY = false;
            _this37.generateMipmaps = false;
            _this37.compareFunction = null;
            return _this37;
          }
          _inherits(DepthTexture, _Texture4);
          return _createClass(DepthTexture, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(DepthTexture, "copy", this, 3)([source]);
              this.compareFunction = source.compareFunction;
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON(meta) {
              var data = _superPropGet(DepthTexture, "toJSON", this, 3)([meta]);
              if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
              return data;
            }
          }]);
        }(Texture);
        /**
         * Uniforms of a program.
         * Those form a tree structure with a special top-level container for the root,
         * which you get by calling 'new WebGLUniforms( gl, program )'.
         *
         *
         * Properties of inner nodes including the top-level container:
         *
         * .seq - array of nested uniforms
         * .map - nested uniforms by name
         *
         *
         * Methods of all nodes except the top-level container:
         *
         * .setValue( gl, value, [textures] )
         *
         * 		uploads a uniform value(s)
         *  	the 'textures' parameter is needed for sampler uniforms
         *
         *
         * Static methods of the top-level container (textures factorizations):
         *
         * .upload( gl, seq, values, textures )
         *
         * 		sets uniforms in 'seq' to 'values[id].value'
         *
         * .seqWithValue( seq, values ) : filteredSeq
         *
         * 		filters 'seq' entries with corresponding entry in values
         *
         *
         * Methods of the top-level container (textures factorizations):
         *
         * .setValue( gl, name, value, textures )
         *
         * 		sets uniform with  name 'name' to 'value'
         *
         * .setOptional( gl, obj, prop )
         *
         * 		like .set for an optional property of the object
         *
         */
        var emptyTexture = /*@__PURE__*/new Texture();
        var emptyShadowTexture = /*@__PURE__*/new DepthTexture(1, 1);
        var emptyArrayTexture = /*@__PURE__*/new DataArrayTexture();
        var empty3dTexture = /*@__PURE__*/new Data3DTexture();
        var emptyCubeTexture = /*@__PURE__*/new CubeTexture();

        // --- Utilities ---

        // Array Caches (provide typed arrays for temporary by size)

        var arrayCacheF32 = [];
        var arrayCacheI32 = [];

        // Float32Array caches used for uploading Matrix uniforms

        var mat4array = new Float32Array(16);
        var mat3array = new Float32Array(9);
        var mat2array = new Float32Array(4);

        // Flattening for arrays of vectors and matrices

        function flatten(array, nBlocks, blockSize) {
          var firstElem = array[0];
          if (firstElem <= 0 || firstElem > 0) return array;
          // unoptimized: ! isNaN( firstElem )
          // see http://jacksondunstan.com/articles/983

          var n = nBlocks * blockSize;
          var r = arrayCacheF32[n];
          if (r === undefined) {
            r = new Float32Array(n);
            arrayCacheF32[n] = r;
          }
          if (nBlocks !== 0) {
            firstElem.toArray(r, 0);
            for (var i = 1, offset = 0; i !== nBlocks; ++i) {
              offset += blockSize;
              array[i].toArray(r, offset);
            }
          }
          return r;
        }
        function arraysEqual(a, b) {
          if (a.length !== b.length) return false;
          for (var i = 0, l = a.length; i < l; i++) {
            if (a[i] !== b[i]) return false;
          }
          return true;
        }
        function copyArray(a, b) {
          for (var i = 0, l = b.length; i < l; i++) {
            a[i] = b[i];
          }
        }

        // Texture unit allocation

        function allocTexUnits(textures, n) {
          var r = arrayCacheI32[n];
          if (r === undefined) {
            r = new Int32Array(n);
            arrayCacheI32[n] = r;
          }
          for (var i = 0; i !== n; ++i) {
            r[i] = textures.allocateTextureUnit();
          }
          return r;
        }

        // --- Setters ---

        // Note: Defining these methods externally, because they come in a bunch
        // and this way their names minify.

        // Single scalar

        function setValueV1f(gl, v) {
          var cache = this.cache;
          if (cache[0] === v) return;
          gl.uniform1f(this.addr, v);
          cache[0] = v;
        }

        // Single float vector (from flat array or THREE.VectorN)

        function setValueV2f(gl, v) {
          var cache = this.cache;
          if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y) {
              gl.uniform2f(this.addr, v.x, v.y);
              cache[0] = v.x;
              cache[1] = v.y;
            }
          } else {
            if (arraysEqual(cache, v)) return;
            gl.uniform2fv(this.addr, v);
            copyArray(cache, v);
          }
        }
        function setValueV3f(gl, v) {
          var cache = this.cache;
          if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
              gl.uniform3f(this.addr, v.x, v.y, v.z);
              cache[0] = v.x;
              cache[1] = v.y;
              cache[2] = v.z;
            }
          } else if (v.r !== undefined) {
            if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
              gl.uniform3f(this.addr, v.r, v.g, v.b);
              cache[0] = v.r;
              cache[1] = v.g;
              cache[2] = v.b;
            }
          } else {
            if (arraysEqual(cache, v)) return;
            gl.uniform3fv(this.addr, v);
            copyArray(cache, v);
          }
        }
        function setValueV4f(gl, v) {
          var cache = this.cache;
          if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
              gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
              cache[0] = v.x;
              cache[1] = v.y;
              cache[2] = v.z;
              cache[3] = v.w;
            }
          } else {
            if (arraysEqual(cache, v)) return;
            gl.uniform4fv(this.addr, v);
            copyArray(cache, v);
          }
        }

        // Single matrix (from flat array or THREE.MatrixN)

        function setValueM2(gl, v) {
          var cache = this.cache;
          var elements = v.elements;
          if (elements === undefined) {
            if (arraysEqual(cache, v)) return;
            gl.uniformMatrix2fv(this.addr, false, v);
            copyArray(cache, v);
          } else {
            if (arraysEqual(cache, elements)) return;
            mat2array.set(elements);
            gl.uniformMatrix2fv(this.addr, false, mat2array);
            copyArray(cache, elements);
          }
        }
        function setValueM3(gl, v) {
          var cache = this.cache;
          var elements = v.elements;
          if (elements === undefined) {
            if (arraysEqual(cache, v)) return;
            gl.uniformMatrix3fv(this.addr, false, v);
            copyArray(cache, v);
          } else {
            if (arraysEqual(cache, elements)) return;
            mat3array.set(elements);
            gl.uniformMatrix3fv(this.addr, false, mat3array);
            copyArray(cache, elements);
          }
        }
        function setValueM4(gl, v) {
          var cache = this.cache;
          var elements = v.elements;
          if (elements === undefined) {
            if (arraysEqual(cache, v)) return;
            gl.uniformMatrix4fv(this.addr, false, v);
            copyArray(cache, v);
          } else {
            if (arraysEqual(cache, elements)) return;
            mat4array.set(elements);
            gl.uniformMatrix4fv(this.addr, false, mat4array);
            copyArray(cache, elements);
          }
        }

        // Single integer / boolean

        function setValueV1i(gl, v) {
          var cache = this.cache;
          if (cache[0] === v) return;
          gl.uniform1i(this.addr, v);
          cache[0] = v;
        }

        // Single integer / boolean vector (from flat array or THREE.VectorN)

        function setValueV2i(gl, v) {
          var cache = this.cache;
          if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y) {
              gl.uniform2i(this.addr, v.x, v.y);
              cache[0] = v.x;
              cache[1] = v.y;
            }
          } else {
            if (arraysEqual(cache, v)) return;
            gl.uniform2iv(this.addr, v);
            copyArray(cache, v);
          }
        }
        function setValueV3i(gl, v) {
          var cache = this.cache;
          if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
              gl.uniform3i(this.addr, v.x, v.y, v.z);
              cache[0] = v.x;
              cache[1] = v.y;
              cache[2] = v.z;
            }
          } else {
            if (arraysEqual(cache, v)) return;
            gl.uniform3iv(this.addr, v);
            copyArray(cache, v);
          }
        }
        function setValueV4i(gl, v) {
          var cache = this.cache;
          if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
              gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
              cache[0] = v.x;
              cache[1] = v.y;
              cache[2] = v.z;
              cache[3] = v.w;
            }
          } else {
            if (arraysEqual(cache, v)) return;
            gl.uniform4iv(this.addr, v);
            copyArray(cache, v);
          }
        }

        // Single unsigned integer

        function setValueV1ui(gl, v) {
          var cache = this.cache;
          if (cache[0] === v) return;
          gl.uniform1ui(this.addr, v);
          cache[0] = v;
        }

        // Single unsigned integer vector (from flat array or THREE.VectorN)

        function setValueV2ui(gl, v) {
          var cache = this.cache;
          if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y) {
              gl.uniform2ui(this.addr, v.x, v.y);
              cache[0] = v.x;
              cache[1] = v.y;
            }
          } else {
            if (arraysEqual(cache, v)) return;
            gl.uniform2uiv(this.addr, v);
            copyArray(cache, v);
          }
        }
        function setValueV3ui(gl, v) {
          var cache = this.cache;
          if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
              gl.uniform3ui(this.addr, v.x, v.y, v.z);
              cache[0] = v.x;
              cache[1] = v.y;
              cache[2] = v.z;
            }
          } else {
            if (arraysEqual(cache, v)) return;
            gl.uniform3uiv(this.addr, v);
            copyArray(cache, v);
          }
        }
        function setValueV4ui(gl, v) {
          var cache = this.cache;
          if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
              gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
              cache[0] = v.x;
              cache[1] = v.y;
              cache[2] = v.z;
              cache[3] = v.w;
            }
          } else {
            if (arraysEqual(cache, v)) return;
            gl.uniform4uiv(this.addr, v);
            copyArray(cache, v);
          }
        }

        // Single texture (2D / Cube)

        function setValueT1(gl, v, textures) {
          var cache = this.cache;
          var unit = textures.allocateTextureUnit();
          if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
          }
          var emptyTexture2D;
          if (this.type === gl.SAMPLER_2D_SHADOW) {
            emptyShadowTexture.compareFunction = LessEqualCompare; // #28670
            emptyTexture2D = emptyShadowTexture;
          } else {
            emptyTexture2D = emptyTexture;
          }
          textures.setTexture2D(v || emptyTexture2D, unit);
        }
        function setValueT3D1(gl, v, textures) {
          var cache = this.cache;
          var unit = textures.allocateTextureUnit();
          if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
          }
          textures.setTexture3D(v || empty3dTexture, unit);
        }
        function setValueT6(gl, v, textures) {
          var cache = this.cache;
          var unit = textures.allocateTextureUnit();
          if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
          }
          textures.setTextureCube(v || emptyCubeTexture, unit);
        }
        function setValueT2DArray1(gl, v, textures) {
          var cache = this.cache;
          var unit = textures.allocateTextureUnit();
          if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
          }
          textures.setTexture2DArray(v || emptyArrayTexture, unit);
        }

        // Helper to pick the right setter for the singular case

        function getSingularSetter(type) {
          switch (type) {
            case 0x1406:
              return setValueV1f;
            // FLOAT
            case 0x8b50:
              return setValueV2f;
            // _VEC2
            case 0x8b51:
              return setValueV3f;
            // _VEC3
            case 0x8b52:
              return setValueV4f;
            // _VEC4

            case 0x8b5a:
              return setValueM2;
            // _MAT2
            case 0x8b5b:
              return setValueM3;
            // _MAT3
            case 0x8b5c:
              return setValueM4;
            // _MAT4

            case 0x1404:
            case 0x8b56:
              return setValueV1i;
            // INT, BOOL
            case 0x8b53:
            case 0x8b57:
              return setValueV2i;
            // _VEC2
            case 0x8b54:
            case 0x8b58:
              return setValueV3i;
            // _VEC3
            case 0x8b55:
            case 0x8b59:
              return setValueV4i;
            // _VEC4

            case 0x1405:
              return setValueV1ui;
            // UINT
            case 0x8dc6:
              return setValueV2ui;
            // _VEC2
            case 0x8dc7:
              return setValueV3ui;
            // _VEC3
            case 0x8dc8:
              return setValueV4ui;
            // _VEC4

            case 0x8b5e: // SAMPLER_2D
            case 0x8d66: // SAMPLER_EXTERNAL_OES
            case 0x8dca: // INT_SAMPLER_2D
            case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
            case 0x8b62:
              // SAMPLER_2D_SHADOW
              return setValueT1;
            case 0x8b5f: // SAMPLER_3D
            case 0x8dcb: // INT_SAMPLER_3D
            case 0x8dd3:
              // UNSIGNED_INT_SAMPLER_3D
              return setValueT3D1;
            case 0x8b60: // SAMPLER_CUBE
            case 0x8dcc: // INT_SAMPLER_CUBE
            case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
            case 0x8dc5:
              // SAMPLER_CUBE_SHADOW
              return setValueT6;
            case 0x8dc1: // SAMPLER_2D_ARRAY
            case 0x8dcf: // INT_SAMPLER_2D_ARRAY
            case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
            case 0x8dc4:
              // SAMPLER_2D_ARRAY_SHADOW
              return setValueT2DArray1;
          }
        }

        // Array of scalars

        function setValueV1fArray(gl, v) {
          gl.uniform1fv(this.addr, v);
        }

        // Array of vectors (from flat array or array of THREE.VectorN)

        function setValueV2fArray(gl, v) {
          var data = flatten(v, this.size, 2);
          gl.uniform2fv(this.addr, data);
        }
        function setValueV3fArray(gl, v) {
          var data = flatten(v, this.size, 3);
          gl.uniform3fv(this.addr, data);
        }
        function setValueV4fArray(gl, v) {
          var data = flatten(v, this.size, 4);
          gl.uniform4fv(this.addr, data);
        }

        // Array of matrices (from flat array or array of THREE.MatrixN)

        function setValueM2Array(gl, v) {
          var data = flatten(v, this.size, 4);
          gl.uniformMatrix2fv(this.addr, false, data);
        }
        function setValueM3Array(gl, v) {
          var data = flatten(v, this.size, 9);
          gl.uniformMatrix3fv(this.addr, false, data);
        }
        function setValueM4Array(gl, v) {
          var data = flatten(v, this.size, 16);
          gl.uniformMatrix4fv(this.addr, false, data);
        }

        // Array of integer / boolean

        function setValueV1iArray(gl, v) {
          gl.uniform1iv(this.addr, v);
        }

        // Array of integer / boolean vectors (from flat array)

        function setValueV2iArray(gl, v) {
          gl.uniform2iv(this.addr, v);
        }
        function setValueV3iArray(gl, v) {
          gl.uniform3iv(this.addr, v);
        }
        function setValueV4iArray(gl, v) {
          gl.uniform4iv(this.addr, v);
        }

        // Array of unsigned integer

        function setValueV1uiArray(gl, v) {
          gl.uniform1uiv(this.addr, v);
        }

        // Array of unsigned integer vectors (from flat array)

        function setValueV2uiArray(gl, v) {
          gl.uniform2uiv(this.addr, v);
        }
        function setValueV3uiArray(gl, v) {
          gl.uniform3uiv(this.addr, v);
        }
        function setValueV4uiArray(gl, v) {
          gl.uniform4uiv(this.addr, v);
        }

        // Array of textures (2D / 3D / Cube / 2DArray)

        function setValueT1Array(gl, v, textures) {
          var cache = this.cache;
          var n = v.length;
          var units = allocTexUnits(textures, n);
          if (!arraysEqual(cache, units)) {
            gl.uniform1iv(this.addr, units);
            copyArray(cache, units);
          }
          for (var i = 0; i !== n; ++i) {
            textures.setTexture2D(v[i] || emptyTexture, units[i]);
          }
        }
        function setValueT3DArray(gl, v, textures) {
          var cache = this.cache;
          var n = v.length;
          var units = allocTexUnits(textures, n);
          if (!arraysEqual(cache, units)) {
            gl.uniform1iv(this.addr, units);
            copyArray(cache, units);
          }
          for (var i = 0; i !== n; ++i) {
            textures.setTexture3D(v[i] || empty3dTexture, units[i]);
          }
        }
        function setValueT6Array(gl, v, textures) {
          var cache = this.cache;
          var n = v.length;
          var units = allocTexUnits(textures, n);
          if (!arraysEqual(cache, units)) {
            gl.uniform1iv(this.addr, units);
            copyArray(cache, units);
          }
          for (var i = 0; i !== n; ++i) {
            textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
          }
        }
        function setValueT2DArrayArray(gl, v, textures) {
          var cache = this.cache;
          var n = v.length;
          var units = allocTexUnits(textures, n);
          if (!arraysEqual(cache, units)) {
            gl.uniform1iv(this.addr, units);
            copyArray(cache, units);
          }
          for (var i = 0; i !== n; ++i) {
            textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
          }
        }

        // Helper to pick the right setter for a pure (bottom-level) array

        function getPureArraySetter(type) {
          switch (type) {
            case 0x1406:
              return setValueV1fArray;
            // FLOAT
            case 0x8b50:
              return setValueV2fArray;
            // _VEC2
            case 0x8b51:
              return setValueV3fArray;
            // _VEC3
            case 0x8b52:
              return setValueV4fArray;
            // _VEC4

            case 0x8b5a:
              return setValueM2Array;
            // _MAT2
            case 0x8b5b:
              return setValueM3Array;
            // _MAT3
            case 0x8b5c:
              return setValueM4Array;
            // _MAT4

            case 0x1404:
            case 0x8b56:
              return setValueV1iArray;
            // INT, BOOL
            case 0x8b53:
            case 0x8b57:
              return setValueV2iArray;
            // _VEC2
            case 0x8b54:
            case 0x8b58:
              return setValueV3iArray;
            // _VEC3
            case 0x8b55:
            case 0x8b59:
              return setValueV4iArray;
            // _VEC4

            case 0x1405:
              return setValueV1uiArray;
            // UINT
            case 0x8dc6:
              return setValueV2uiArray;
            // _VEC2
            case 0x8dc7:
              return setValueV3uiArray;
            // _VEC3
            case 0x8dc8:
              return setValueV4uiArray;
            // _VEC4

            case 0x8b5e: // SAMPLER_2D
            case 0x8d66: // SAMPLER_EXTERNAL_OES
            case 0x8dca: // INT_SAMPLER_2D
            case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
            case 0x8b62:
              // SAMPLER_2D_SHADOW
              return setValueT1Array;
            case 0x8b5f: // SAMPLER_3D
            case 0x8dcb: // INT_SAMPLER_3D
            case 0x8dd3:
              // UNSIGNED_INT_SAMPLER_3D
              return setValueT3DArray;
            case 0x8b60: // SAMPLER_CUBE
            case 0x8dcc: // INT_SAMPLER_CUBE
            case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
            case 0x8dc5:
              // SAMPLER_CUBE_SHADOW
              return setValueT6Array;
            case 0x8dc1: // SAMPLER_2D_ARRAY
            case 0x8dcf: // INT_SAMPLER_2D_ARRAY
            case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
            case 0x8dc4:
              // SAMPLER_2D_ARRAY_SHADOW
              return setValueT2DArrayArray;
          }
        }

        // --- Uniform Classes ---
        var SingleUniform = /*#__PURE__*/_createClass(function SingleUniform(id, activeInfo, addr) {
          _classCallCheck2(this, SingleUniform);
          this.id = id;
          this.addr = addr;
          this.cache = [];
          this.type = activeInfo.type;
          this.setValue = getSingularSetter(activeInfo.type);

          // this.path = activeInfo.name; // DEBUG
        });
        var PureArrayUniform = /*#__PURE__*/_createClass(function PureArrayUniform(id, activeInfo, addr) {
          _classCallCheck2(this, PureArrayUniform);
          this.id = id;
          this.addr = addr;
          this.cache = [];
          this.type = activeInfo.type;
          this.size = activeInfo.size;
          this.setValue = getPureArraySetter(activeInfo.type);

          // this.path = activeInfo.name; // DEBUG
        });
        var StructuredUniform = /*#__PURE__*/function () {
          function StructuredUniform(id) {
            _classCallCheck2(this, StructuredUniform);
            this.id = id;
            this.seq = [];
            this.map = {};
          }
          return _createClass(StructuredUniform, [{
            key: "setValue",
            value: function setValue(gl, value, textures) {
              var seq = this.seq;
              for (var i = 0, n = seq.length; i !== n; ++i) {
                var u = seq[i];
                u.setValue(gl, value[u.id], textures);
              }
            }
          }]);
        }(); // --- Top-level ---
        // Parser - builds up the property tree from the path strings
        var RePathPart = /(\w+)(\])?(\[|\.)?/g;

        // extracts
        // 	- the identifier (member name or array index)
        //  - followed by an optional right bracket (found when array index)
        //  - followed by an optional left bracket or dot (type of subscript)
        //
        // Note: These portions can be read in a non-overlapping fashion and
        // allow straightforward parsing of the hierarchy that WebGL encodes
        // in the uniform names.

        function addUniform(container, uniformObject) {
          container.seq.push(uniformObject);
          container.map[uniformObject.id] = uniformObject;
        }
        function parseUniform(activeInfo, addr, container) {
          var path = activeInfo.name,
            pathLength = path.length;

          // reset RegExp object, because of the early exit of a previous run
          RePathPart.lastIndex = 0;
          while (true) {
            var match = RePathPart.exec(path),
              matchEnd = RePathPart.lastIndex;
            var id = match[1];
            var idIsIndex = match[2] === ']',
              subscript = match[3];
            if (idIsIndex) id = id | 0; // convert to integer

            if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
              // bare name or "pure" bottom-level array "[0]" suffix

              addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
              break;
            } else {
              // step into inner node / create it in case it doesn't exist

              var map = container.map;
              var next = map[id];
              if (next === undefined) {
                next = new StructuredUniform(id);
                addUniform(container, next);
              }
              container = next;
            }
          }
        }

        // Root Container
        var WebGLUniforms = /*#__PURE__*/function () {
          function WebGLUniforms(gl, program) {
            _classCallCheck2(this, WebGLUniforms);
            this.seq = [];
            this.map = {};
            var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
            for (var i = 0; i < n; ++i) {
              var info = gl.getActiveUniform(program, i),
                addr = gl.getUniformLocation(program, info.name);
              parseUniform(info, addr, this);
            }
          }
          return _createClass(WebGLUniforms, [{
            key: "setValue",
            value: function setValue(gl, name, value, textures) {
              var u = this.map[name];
              if (u !== undefined) u.setValue(gl, value, textures);
            }
          }, {
            key: "setOptional",
            value: function setOptional(gl, object, name) {
              var v = object[name];
              if (v !== undefined) this.setValue(gl, name, v);
            }
          }], [{
            key: "upload",
            value: function upload(gl, seq, values, textures) {
              for (var i = 0, n = seq.length; i !== n; ++i) {
                var u = seq[i],
                  v = values[u.id];
                if (v.needsUpdate !== false) {
                  // note: always updating when .needsUpdate is undefined
                  u.setValue(gl, v.value, textures);
                }
              }
            }
          }, {
            key: "seqWithValue",
            value: function seqWithValue(seq, values) {
              var r = [];
              for (var i = 0, n = seq.length; i !== n; ++i) {
                var u = seq[i];
                if (u.id in values) r.push(u);
              }
              return r;
            }
          }]);
        }();
        function WebGLShader(gl, type, string) {
          var shader = gl.createShader(type);
          gl.shaderSource(shader, string);
          gl.compileShader(shader);
          return shader;
        }

        // From https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/
        var COMPLETION_STATUS_KHR = 0x91B1;
        var programIdCount = 0;
        function handleSource(string, errorLine) {
          var lines = string.split('\n');
          var lines2 = [];
          var from = Math.max(errorLine - 6, 0);
          var to = Math.min(errorLine + 6, lines.length);
          for (var i = from; i < to; i++) {
            var line = i + 1;
            lines2.push("".concat(line === errorLine ? '>' : ' ', " ").concat(line, ": ").concat(lines[i]));
          }
          return lines2.join('\n');
        }
        function getEncodingComponents(colorSpace) {
          var workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
          var encodingPrimaries = ColorManagement.getPrimaries(colorSpace);
          var gamutMapping;
          if (workingPrimaries === encodingPrimaries) {
            gamutMapping = '';
          } else if (workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries) {
            gamutMapping = 'LinearDisplayP3ToLinearSRGB';
          } else if (workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries) {
            gamutMapping = 'LinearSRGBToLinearDisplayP3';
          }
          switch (colorSpace) {
            case LinearSRGBColorSpace:
            case LinearDisplayP3ColorSpace:
              return [gamutMapping, 'LinearTransferOETF'];
            case SRGBColorSpace:
            case DisplayP3ColorSpace:
              return [gamutMapping, 'sRGBTransferOETF'];
            default:
              console.warn('THREE.WebGLProgram: Unsupported color space:', colorSpace);
              return [gamutMapping, 'LinearTransferOETF'];
          }
        }
        function getShaderErrors(gl, shader, type) {
          var status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
          var errors = gl.getShaderInfoLog(shader).trim();
          if (status && errors === '') return '';
          var errorMatches = /ERROR: 0:(\d+)/.exec(errors);
          if (errorMatches) {
            // --enable-privileged-webgl-extension
            // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

            var errorLine = parseInt(errorMatches[1]);
            return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource(gl.getShaderSource(shader), errorLine);
          } else {
            return errors;
          }
        }
        function getTexelEncodingFunction(functionName, colorSpace) {
          var components = getEncodingComponents(colorSpace);
          return "vec4 ".concat(functionName, "( vec4 value ) { return ").concat(components[0], "( ").concat(components[1], "( value ) ); }");
        }
        function getToneMappingFunction(functionName, toneMapping) {
          var toneMappingName;
          switch (toneMapping) {
            case LinearToneMapping:
              toneMappingName = 'Linear';
              break;
            case ReinhardToneMapping:
              toneMappingName = 'Reinhard';
              break;
            case CineonToneMapping:
              toneMappingName = 'OptimizedCineon';
              break;
            case ACESFilmicToneMapping:
              toneMappingName = 'ACESFilmic';
              break;
            case AgXToneMapping:
              toneMappingName = 'AgX';
              break;
            case NeutralToneMapping:
              toneMappingName = 'Neutral';
              break;
            case CustomToneMapping:
              toneMappingName = 'Custom';
              break;
            default:
              console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
              toneMappingName = 'Linear';
          }
          return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
        }
        function generateVertexExtensions(parameters) {
          var chunks = [parameters.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '', parameters.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : ''];
          return chunks.filter(filterEmptyLine).join('\n');
        }
        function generateDefines(defines) {
          var chunks = [];
          for (var name in defines) {
            var value = defines[name];
            if (value === false) continue;
            chunks.push('#define ' + name + ' ' + value);
          }
          return chunks.join('\n');
        }
        function fetchAttributeLocations(gl, program) {
          var attributes = {};
          var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
          for (var i = 0; i < n; i++) {
            var info = gl.getActiveAttrib(program, i);
            var name = info.name;
            var locationSize = 1;
            if (info.type === gl.FLOAT_MAT2) locationSize = 2;
            if (info.type === gl.FLOAT_MAT3) locationSize = 3;
            if (info.type === gl.FLOAT_MAT4) locationSize = 4;

            // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

            attributes[name] = {
              type: info.type,
              location: gl.getAttribLocation(program, name),
              locationSize: locationSize
            };
          }
          return attributes;
        }
        function filterEmptyLine(string) {
          return string !== '';
        }
        function replaceLightNums(string, parameters) {
          var numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
          return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
        }
        function replaceClippingPlaneNums(string, parameters) {
          return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
        }

        // Resolve Includes

        var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function resolveIncludes(string) {
          return string.replace(includePattern, includeReplacer);
        }
        var shaderChunkMap = new Map();
        function includeReplacer(match, include) {
          var string = ShaderChunk[include];
          if (string === undefined) {
            var newInclude = shaderChunkMap.get(include);
            if (newInclude !== undefined) {
              string = ShaderChunk[newInclude];
              console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
            } else {
              throw new Error('Can not resolve #include <' + include + '>');
            }
          }
          return resolveIncludes(string);
        }

        // Unroll Loops

        var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function unrollLoops(string) {
          return string.replace(unrollLoopPattern, loopReplacer);
        }
        function loopReplacer(match, start, end, snippet) {
          var string = '';
          for (var i = parseInt(start); i < parseInt(end); i++) {
            string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
          }
          return string;
        }

        //

        function generatePrecision(parameters) {
          var precisionstring = "precision ".concat(parameters.precision, " float;\n\tprecision ").concat(parameters.precision, " int;\n\tprecision ").concat(parameters.precision, " sampler2D;\n\tprecision ").concat(parameters.precision, " samplerCube;\n\tprecision ").concat(parameters.precision, " sampler3D;\n\tprecision ").concat(parameters.precision, " sampler2DArray;\n\tprecision ").concat(parameters.precision, " sampler2DShadow;\n\tprecision ").concat(parameters.precision, " samplerCubeShadow;\n\tprecision ").concat(parameters.precision, " sampler2DArrayShadow;\n\tprecision ").concat(parameters.precision, " isampler2D;\n\tprecision ").concat(parameters.precision, " isampler3D;\n\tprecision ").concat(parameters.precision, " isamplerCube;\n\tprecision ").concat(parameters.precision, " isampler2DArray;\n\tprecision ").concat(parameters.precision, " usampler2D;\n\tprecision ").concat(parameters.precision, " usampler3D;\n\tprecision ").concat(parameters.precision, " usamplerCube;\n\tprecision ").concat(parameters.precision, " usampler2DArray;\n\t");
          if (parameters.precision === 'highp') {
            precisionstring += '\n#define HIGH_PRECISION';
          } else if (parameters.precision === 'mediump') {
            precisionstring += '\n#define MEDIUM_PRECISION';
          } else if (parameters.precision === 'lowp') {
            precisionstring += '\n#define LOW_PRECISION';
          }
          return precisionstring;
        }
        function generateShadowMapTypeDefine(parameters) {
          var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
          if (parameters.shadowMapType === PCFShadowMap) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
          } else if (parameters.shadowMapType === PCFSoftShadowMap) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
          } else if (parameters.shadowMapType === VSMShadowMap) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
          }
          return shadowMapTypeDefine;
        }
        function generateEnvMapTypeDefine(parameters) {
          var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
          if (parameters.envMap) {
            switch (parameters.envMapMode) {
              case CubeReflectionMapping:
              case CubeRefractionMapping:
                envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                break;
              case CubeUVReflectionMapping:
                envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                break;
            }
          }
          return envMapTypeDefine;
        }
        function generateEnvMapModeDefine(parameters) {
          var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
          if (parameters.envMap) {
            switch (parameters.envMapMode) {
              case CubeRefractionMapping:
                envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                break;
            }
          }
          return envMapModeDefine;
        }
        function generateEnvMapBlendingDefine(parameters) {
          var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
          if (parameters.envMap) {
            switch (parameters.combine) {
              case MultiplyOperation:
                envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                break;
              case MixOperation:
                envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                break;
              case AddOperation:
                envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                break;
            }
          }
          return envMapBlendingDefine;
        }
        function generateCubeUVSize(parameters) {
          var imageHeight = parameters.envMapCubeUVHeight;
          if (imageHeight === null) return null;
          var maxMip = Math.log2(imageHeight) - 2;
          var texelHeight = 1.0 / imageHeight;
          var texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
          return {
            texelWidth: texelWidth,
            texelHeight: texelHeight,
            maxMip: maxMip
          };
        }
        function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
          // TODO Send this event to Three.js DevTools
          // console.log( 'WebGLProgram', cacheKey );

          var gl = renderer.getContext();
          var defines = parameters.defines;
          var vertexShader = parameters.vertexShader;
          var fragmentShader = parameters.fragmentShader;
          var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
          var envMapTypeDefine = generateEnvMapTypeDefine(parameters);
          var envMapModeDefine = generateEnvMapModeDefine(parameters);
          var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
          var envMapCubeUVSize = generateCubeUVSize(parameters);
          var customVertexExtensions = generateVertexExtensions(parameters);
          var customDefines = generateDefines(defines);
          var program = gl.createProgram();
          var prefixVertex, prefixFragment;
          var versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';
          if (parameters.isRawShaderMaterial) {
            prefixVertex = ['#define SHADER_TYPE ' + parameters.shaderType, '#define SHADER_NAME ' + parameters.shaderName, customDefines].filter(filterEmptyLine).join('\n');
            if (prefixVertex.length > 0) {
              prefixVertex += '\n';
            }
            prefixFragment = ['#define SHADER_TYPE ' + parameters.shaderType, '#define SHADER_NAME ' + parameters.shaderName, customDefines].filter(filterEmptyLine).join('\n');
            if (prefixFragment.length > 0) {
              prefixFragment += '\n';
            }
          } else {
            prefixVertex = [generatePrecision(parameters), '#define SHADER_TYPE ' + parameters.shaderType, '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '', parameters.batching ? '#define USE_BATCHING' : '', parameters.batchingColor ? '#define USE_BATCHING_COLOR' : '', parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.instancingMorph ? '#define USE_INSTANCING_MORPH' : '', parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '', parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '', parameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.anisotropy ? '#define USE_ANISOTROPY' : '', parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '', parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.alphaHash ? '#define USE_ALPHAHASH' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
            //

            parameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '', parameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '', parameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '', parameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '', parameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '', parameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '', parameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '', parameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '', parameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '', parameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '', parameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '', parameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '', parameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '', parameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '', parameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '', parameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '', parameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '', parameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '', parameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '', parameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '', parameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '', parameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '', parameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',
            //

            parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUv1s ? '#define USE_UV1' : '', parameters.vertexUv2s ? '#define USE_UV2' : '', parameters.vertexUv3s ? '#define USE_UV3' : '', parameters.pointsUvs ? '#define USE_POINTS_UV' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.morphColors ? '#define USE_MORPHCOLORS' : '', parameters.morphTargetsCount > 0 ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '', parameters.morphTargetsCount > 0 ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', '#ifdef USE_INSTANCING_MORPH', '	uniform sampler2D morphTexture;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_UV1', '	attribute vec2 uv1;', '#endif', '#ifdef USE_UV2', '	attribute vec2 uv2;', '#endif', '#ifdef USE_UV3', '	attribute vec2 uv3;', '#endif', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '	attribute vec4 color;', '#elif defined( USE_COLOR )', '	attribute vec3 color;', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
            prefixFragment = [generatePrecision(parameters), '#define SHADER_TYPE ' + parameters.shaderType, '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '', envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '', parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.anisotropy ? '#define USE_ANISOTROPY' : '', parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '', parameters.clearcoat ? '#define USE_CLEARCOAT' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.dispersion ? '#define USE_DISPERSION' : '', parameters.iridescence ? '#define USE_IRIDESCENCE' : '', parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '', parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.alphaTest ? '#define USE_ALPHATEST' : '', parameters.alphaHash ? '#define USE_ALPHAHASH' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUv1s ? '#define USE_UV1' : '', parameters.vertexUv2s ? '#define USE_UV2' : '', parameters.vertexUv3s ? '#define USE_UV3' : '', parameters.pointsUvs ? '#define USE_POINTS_UV' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '', parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '',
            // this code is required here because it is used by the toneMapping() function defined below
            parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.opaque ? '#define OPAQUE' : '', ShaderChunk['colorspace_pars_fragment'],
            // this code is required here because it is used by the various encoding/decoding function defined below
            getTexelEncodingFunction('linearToOutputTexel', parameters.outputColorSpace), parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
          }
          vertexShader = resolveIncludes(vertexShader);
          vertexShader = replaceLightNums(vertexShader, parameters);
          vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
          fragmentShader = resolveIncludes(fragmentShader);
          fragmentShader = replaceLightNums(fragmentShader, parameters);
          fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
          vertexShader = unrollLoops(vertexShader);
          fragmentShader = unrollLoops(fragmentShader);
          if (parameters.isRawShaderMaterial !== true) {
            // GLSL 3.0 conversion for built-in materials and ShaderMaterial

            versionString = '#version 300 es\n';
            prefixVertex = [customVertexExtensions, '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
            prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
          }
          var vertexGlsl = versionString + prefixVertex + vertexShader;
          var fragmentGlsl = versionString + prefixFragment + fragmentShader;

          // console.log( '*VERTEX*', vertexGlsl );
          // console.log( '*FRAGMENT*', fragmentGlsl );

          var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
          var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
          gl.attachShader(program, glVertexShader);
          gl.attachShader(program, glFragmentShader);

          // Force a particular attribute to index 0.

          if (parameters.index0AttributeName !== undefined) {
            gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
          } else if (parameters.morphTargets === true) {
            // programs with morphTargets displace position out of attribute 0
            gl.bindAttribLocation(program, 0, 'position');
          }
          gl.linkProgram(program);
          function onFirstUse(self) {
            // check for link errors
            if (renderer.debug.checkShaderErrors) {
              var programLog = gl.getProgramInfoLog(program).trim();
              var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
              var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
              var runnable = true;
              var haveDiagnostics = true;
              if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
                runnable = false;
                if (typeof renderer.debug.onShaderError === 'function') {
                  renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
                } else {
                  // default error reporting

                  var vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
                  var fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
                  console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + '\n\n' + 'Material Name: ' + self.name + '\n' + 'Material Type: ' + self.type + '\n\n' + 'Program Info Log: ' + programLog + '\n' + vertexErrors + '\n' + fragmentErrors);
                }
              } else if (programLog !== '') {
                console.warn('THREE.WebGLProgram: Program Info Log:', programLog);
              } else if (vertexLog === '' || fragmentLog === '') {
                haveDiagnostics = false;
              }
              if (haveDiagnostics) {
                self.diagnostics = {
                  runnable: runnable,
                  programLog: programLog,
                  vertexShader: {
                    log: vertexLog,
                    prefix: prefixVertex
                  },
                  fragmentShader: {
                    log: fragmentLog,
                    prefix: prefixFragment
                  }
                };
              }
            }

            // Clean up

            // Crashes in iOS9 and iOS10. #18402
            // gl.detachShader( program, glVertexShader );
            // gl.detachShader( program, glFragmentShader );

            gl.deleteShader(glVertexShader);
            gl.deleteShader(glFragmentShader);
            cachedUniforms = new WebGLUniforms(gl, program);
            cachedAttributes = fetchAttributeLocations(gl, program);
          }

          // set up caching for uniform locations

          var cachedUniforms;
          this.getUniforms = function () {
            if (cachedUniforms === undefined) {
              // Populates cachedUniforms and cachedAttributes
              onFirstUse(this);
            }
            return cachedUniforms;
          };

          // set up caching for attribute locations

          var cachedAttributes;
          this.getAttributes = function () {
            if (cachedAttributes === undefined) {
              // Populates cachedAttributes and cachedUniforms
              onFirstUse(this);
            }
            return cachedAttributes;
          };

          // indicate when the program is ready to be used. if the KHR_parallel_shader_compile extension isn't supported,
          // flag the program as ready immediately. It may cause a stall when it's first used.

          var programReady = parameters.rendererExtensionParallelShaderCompile === false;
          this.isReady = function () {
            if (programReady === false) {
              programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR);
            }
            return programReady;
          };

          // free resource

          this.destroy = function () {
            bindingStates.releaseStatesOfProgram(this);
            gl.deleteProgram(program);
            this.program = undefined;
          };

          //

          this.type = parameters.shaderType;
          this.name = parameters.shaderName;
          this.id = programIdCount++;
          this.cacheKey = cacheKey;
          this.usedTimes = 1;
          this.program = program;
          this.vertexShader = glVertexShader;
          this.fragmentShader = glFragmentShader;
          return this;
        }
        var _id$1 = 0;
        var WebGLShaderCache = /*#__PURE__*/function () {
          function WebGLShaderCache() {
            _classCallCheck2(this, WebGLShaderCache);
            this.shaderCache = new Map();
            this.materialCache = new Map();
          }
          return _createClass(WebGLShaderCache, [{
            key: "update",
            value: function update(material) {
              var vertexShader = material.vertexShader;
              var fragmentShader = material.fragmentShader;
              var vertexShaderStage = this._getShaderStage(vertexShader);
              var fragmentShaderStage = this._getShaderStage(fragmentShader);
              var materialShaders = this._getShaderCacheForMaterial(material);
              if (materialShaders.has(vertexShaderStage) === false) {
                materialShaders.add(vertexShaderStage);
                vertexShaderStage.usedTimes++;
              }
              if (materialShaders.has(fragmentShaderStage) === false) {
                materialShaders.add(fragmentShaderStage);
                fragmentShaderStage.usedTimes++;
              }
              return this;
            }
          }, {
            key: "remove",
            value: function remove(material) {
              var materialShaders = this.materialCache.get(material);
              var _iterator22 = _createForOfIteratorHelper(materialShaders),
                _step22;
              try {
                for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
                  var shaderStage = _step22.value;
                  shaderStage.usedTimes--;
                  if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
                }
              } catch (err) {
                _iterator22.e(err);
              } finally {
                _iterator22.f();
              }
              this.materialCache.delete(material);
              return this;
            }
          }, {
            key: "getVertexShaderID",
            value: function getVertexShaderID(material) {
              return this._getShaderStage(material.vertexShader).id;
            }
          }, {
            key: "getFragmentShaderID",
            value: function getFragmentShaderID(material) {
              return this._getShaderStage(material.fragmentShader).id;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.shaderCache.clear();
              this.materialCache.clear();
            }
          }, {
            key: "_getShaderCacheForMaterial",
            value: function _getShaderCacheForMaterial(material) {
              var cache = this.materialCache;
              var set = cache.get(material);
              if (set === undefined) {
                set = new Set();
                cache.set(material, set);
              }
              return set;
            }
          }, {
            key: "_getShaderStage",
            value: function _getShaderStage(code) {
              var cache = this.shaderCache;
              var stage = cache.get(code);
              if (stage === undefined) {
                stage = new WebGLShaderStage(code);
                cache.set(code, stage);
              }
              return stage;
            }
          }]);
        }();
        var WebGLShaderStage = /*#__PURE__*/_createClass(function WebGLShaderStage(code) {
          _classCallCheck2(this, WebGLShaderStage);
          this.id = _id$1++;
          this.code = code;
          this.usedTimes = 0;
        });
        function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
          var _programLayers = new Layers();
          var _customShaders = new WebGLShaderCache();
          var _activeChannels = new Set();
          var programs = [];
          var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
          var SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
          var precision = capabilities.precision;
          var shaderIDs = {
            MeshDepthMaterial: 'depth',
            MeshDistanceMaterial: 'distanceRGBA',
            MeshNormalMaterial: 'normal',
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshToonMaterial: 'toon',
            MeshStandardMaterial: 'physical',
            MeshPhysicalMaterial: 'physical',
            MeshMatcapMaterial: 'matcap',
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points',
            ShadowMaterial: 'shadow',
            SpriteMaterial: 'sprite'
          };
          function getChannel(value) {
            _activeChannels.add(value);
            if (value === 0) return 'uv';
            return "uv".concat(value);
          }
          function getParameters(material, lights, shadows, scene, object) {
            var fog = scene.fog;
            var geometry = object.geometry;
            var environment = material.isMeshStandardMaterial ? scene.environment : null;
            var envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
            var envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
            var shaderID = shaderIDs[material.type];

            // heuristics to create shader parameters according to lights in the scene
            // (not to blow over maxLights budget)

            if (material.precision !== null) {
              precision = capabilities.getMaxPrecision(material.precision);
              if (precision !== material.precision) {
                console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
              }
            }

            //

            var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
            var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
            var morphTextureStride = 0;
            if (geometry.morphAttributes.position !== undefined) morphTextureStride = 1;
            if (geometry.morphAttributes.normal !== undefined) morphTextureStride = 2;
            if (geometry.morphAttributes.color !== undefined) morphTextureStride = 3;

            //

            var vertexShader, fragmentShader;
            var customVertexShaderID, customFragmentShaderID;
            if (shaderID) {
              var shader = ShaderLib[shaderID];
              vertexShader = shader.vertexShader;
              fragmentShader = shader.fragmentShader;
            } else {
              vertexShader = material.vertexShader;
              fragmentShader = material.fragmentShader;
              _customShaders.update(material);
              customVertexShaderID = _customShaders.getVertexShaderID(material);
              customFragmentShaderID = _customShaders.getFragmentShaderID(material);
            }
            var currentRenderTarget = renderer.getRenderTarget();
            var IS_INSTANCEDMESH = object.isInstancedMesh === true;
            var IS_BATCHEDMESH = object.isBatchedMesh === true;
            var HAS_MAP = !!material.map;
            var HAS_MATCAP = !!material.matcap;
            var HAS_ENVMAP = !!envMap;
            var HAS_AOMAP = !!material.aoMap;
            var HAS_LIGHTMAP = !!material.lightMap;
            var HAS_BUMPMAP = !!material.bumpMap;
            var HAS_NORMALMAP = !!material.normalMap;
            var HAS_DISPLACEMENTMAP = !!material.displacementMap;
            var HAS_EMISSIVEMAP = !!material.emissiveMap;
            var HAS_METALNESSMAP = !!material.metalnessMap;
            var HAS_ROUGHNESSMAP = !!material.roughnessMap;
            var HAS_ANISOTROPY = material.anisotropy > 0;
            var HAS_CLEARCOAT = material.clearcoat > 0;
            var HAS_DISPERSION = material.dispersion > 0;
            var HAS_IRIDESCENCE = material.iridescence > 0;
            var HAS_SHEEN = material.sheen > 0;
            var HAS_TRANSMISSION = material.transmission > 0;
            var HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
            var HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
            var HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
            var HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
            var HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
            var HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
            var HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
            var HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
            var HAS_SPECULARMAP = !!material.specularMap;
            var HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
            var HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
            var HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
            var HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
            var HAS_GRADIENTMAP = !!material.gradientMap;
            var HAS_ALPHAMAP = !!material.alphaMap;
            var HAS_ALPHATEST = material.alphaTest > 0;
            var HAS_ALPHAHASH = !!material.alphaHash;
            var HAS_EXTENSIONS = !!material.extensions;
            var toneMapping = NoToneMapping;
            if (material.toneMapped) {
              if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
                toneMapping = renderer.toneMapping;
              }
            }
            var parameters = {
              shaderID: shaderID,
              shaderType: material.type,
              shaderName: material.name,
              vertexShader: vertexShader,
              fragmentShader: fragmentShader,
              defines: material.defines,
              customVertexShaderID: customVertexShaderID,
              customFragmentShaderID: customFragmentShaderID,
              isRawShaderMaterial: material.isRawShaderMaterial === true,
              glslVersion: material.glslVersion,
              precision: precision,
              batching: IS_BATCHEDMESH,
              batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
              instancing: IS_INSTANCEDMESH,
              instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
              instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
              supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
              outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
              alphaToCoverage: !!material.alphaToCoverage,
              map: HAS_MAP,
              matcap: HAS_MATCAP,
              envMap: HAS_ENVMAP,
              envMapMode: HAS_ENVMAP && envMap.mapping,
              envMapCubeUVHeight: envMapCubeUVHeight,
              aoMap: HAS_AOMAP,
              lightMap: HAS_LIGHTMAP,
              bumpMap: HAS_BUMPMAP,
              normalMap: HAS_NORMALMAP,
              displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
              emissiveMap: HAS_EMISSIVEMAP,
              normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
              normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
              metalnessMap: HAS_METALNESSMAP,
              roughnessMap: HAS_ROUGHNESSMAP,
              anisotropy: HAS_ANISOTROPY,
              anisotropyMap: HAS_ANISOTROPYMAP,
              clearcoat: HAS_CLEARCOAT,
              clearcoatMap: HAS_CLEARCOATMAP,
              clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
              clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
              dispersion: HAS_DISPERSION,
              iridescence: HAS_IRIDESCENCE,
              iridescenceMap: HAS_IRIDESCENCEMAP,
              iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
              sheen: HAS_SHEEN,
              sheenColorMap: HAS_SHEEN_COLORMAP,
              sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
              specularMap: HAS_SPECULARMAP,
              specularColorMap: HAS_SPECULAR_COLORMAP,
              specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
              transmission: HAS_TRANSMISSION,
              transmissionMap: HAS_TRANSMISSIONMAP,
              thicknessMap: HAS_THICKNESSMAP,
              gradientMap: HAS_GRADIENTMAP,
              opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,
              alphaMap: HAS_ALPHAMAP,
              alphaTest: HAS_ALPHATEST,
              alphaHash: HAS_ALPHAHASH,
              combine: material.combine,
              //

              mapUv: HAS_MAP && getChannel(material.map.channel),
              aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
              lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
              bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
              normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
              displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
              emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
              metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
              roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
              anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
              clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
              clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
              clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
              iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
              iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
              sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
              sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
              specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
              specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
              specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
              transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
              thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
              alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
              //

              vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
              vertexColors: material.vertexColors,
              vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
              pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
              fog: !!fog,
              useFog: material.fog === true,
              fogExp2: !!fog && fog.isFogExp2,
              flatShading: material.flatShading === true,
              sizeAttenuation: material.sizeAttenuation === true,
              logarithmicDepthBuffer: logarithmicDepthBuffer,
              skinning: object.isSkinnedMesh === true,
              morphTargets: geometry.morphAttributes.position !== undefined,
              morphNormals: geometry.morphAttributes.normal !== undefined,
              morphColors: geometry.morphAttributes.color !== undefined,
              morphTargetsCount: morphTargetsCount,
              morphTextureStride: morphTextureStride,
              numDirLights: lights.directional.length,
              numPointLights: lights.point.length,
              numSpotLights: lights.spot.length,
              numSpotLightMaps: lights.spotLightMap.length,
              numRectAreaLights: lights.rectArea.length,
              numHemiLights: lights.hemi.length,
              numDirLightShadows: lights.directionalShadowMap.length,
              numPointLightShadows: lights.pointShadowMap.length,
              numSpotLightShadows: lights.spotShadowMap.length,
              numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
              numLightProbes: lights.numLightProbes,
              numClippingPlanes: clipping.numPlanes,
              numClipIntersection: clipping.numIntersection,
              dithering: material.dithering,
              shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
              shadowMapType: renderer.shadowMap.type,
              toneMapping: toneMapping,
              decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
              premultipliedAlpha: material.premultipliedAlpha,
              doubleSided: material.side === DoubleSide,
              flipSided: material.side === BackSide,
              useDepthPacking: material.depthPacking >= 0,
              depthPacking: material.depthPacking || 0,
              index0AttributeName: material.index0AttributeName,
              extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has('WEBGL_clip_cull_distance'),
              extensionMultiDraw: (HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH) && extensions.has('WEBGL_multi_draw'),
              rendererExtensionParallelShaderCompile: extensions.has('KHR_parallel_shader_compile'),
              customProgramCacheKey: material.customProgramCacheKey()
            };

            // the usage of getChannel() determines the active texture channels for this shader

            parameters.vertexUv1s = _activeChannels.has(1);
            parameters.vertexUv2s = _activeChannels.has(2);
            parameters.vertexUv3s = _activeChannels.has(3);
            _activeChannels.clear();
            return parameters;
          }
          function getProgramCacheKey(parameters) {
            var array = [];
            if (parameters.shaderID) {
              array.push(parameters.shaderID);
            } else {
              array.push(parameters.customVertexShaderID);
              array.push(parameters.customFragmentShaderID);
            }
            if (parameters.defines !== undefined) {
              for (var name in parameters.defines) {
                array.push(name);
                array.push(parameters.defines[name]);
              }
            }
            if (parameters.isRawShaderMaterial === false) {
              getProgramCacheKeyParameters(array, parameters);
              getProgramCacheKeyBooleans(array, parameters);
              array.push(renderer.outputColorSpace);
            }
            array.push(parameters.customProgramCacheKey);
            return array.join();
          }
          function getProgramCacheKeyParameters(array, parameters) {
            array.push(parameters.precision);
            array.push(parameters.outputColorSpace);
            array.push(parameters.envMapMode);
            array.push(parameters.envMapCubeUVHeight);
            array.push(parameters.mapUv);
            array.push(parameters.alphaMapUv);
            array.push(parameters.lightMapUv);
            array.push(parameters.aoMapUv);
            array.push(parameters.bumpMapUv);
            array.push(parameters.normalMapUv);
            array.push(parameters.displacementMapUv);
            array.push(parameters.emissiveMapUv);
            array.push(parameters.metalnessMapUv);
            array.push(parameters.roughnessMapUv);
            array.push(parameters.anisotropyMapUv);
            array.push(parameters.clearcoatMapUv);
            array.push(parameters.clearcoatNormalMapUv);
            array.push(parameters.clearcoatRoughnessMapUv);
            array.push(parameters.iridescenceMapUv);
            array.push(parameters.iridescenceThicknessMapUv);
            array.push(parameters.sheenColorMapUv);
            array.push(parameters.sheenRoughnessMapUv);
            array.push(parameters.specularMapUv);
            array.push(parameters.specularColorMapUv);
            array.push(parameters.specularIntensityMapUv);
            array.push(parameters.transmissionMapUv);
            array.push(parameters.thicknessMapUv);
            array.push(parameters.combine);
            array.push(parameters.fogExp2);
            array.push(parameters.sizeAttenuation);
            array.push(parameters.morphTargetsCount);
            array.push(parameters.morphAttributeCount);
            array.push(parameters.numDirLights);
            array.push(parameters.numPointLights);
            array.push(parameters.numSpotLights);
            array.push(parameters.numSpotLightMaps);
            array.push(parameters.numHemiLights);
            array.push(parameters.numRectAreaLights);
            array.push(parameters.numDirLightShadows);
            array.push(parameters.numPointLightShadows);
            array.push(parameters.numSpotLightShadows);
            array.push(parameters.numSpotLightShadowsWithMaps);
            array.push(parameters.numLightProbes);
            array.push(parameters.shadowMapType);
            array.push(parameters.toneMapping);
            array.push(parameters.numClippingPlanes);
            array.push(parameters.numClipIntersection);
            array.push(parameters.depthPacking);
          }
          function getProgramCacheKeyBooleans(array, parameters) {
            _programLayers.disableAll();
            if (parameters.supportsVertexTextures) _programLayers.enable(0);
            if (parameters.instancing) _programLayers.enable(1);
            if (parameters.instancingColor) _programLayers.enable(2);
            if (parameters.instancingMorph) _programLayers.enable(3);
            if (parameters.matcap) _programLayers.enable(4);
            if (parameters.envMap) _programLayers.enable(5);
            if (parameters.normalMapObjectSpace) _programLayers.enable(6);
            if (parameters.normalMapTangentSpace) _programLayers.enable(7);
            if (parameters.clearcoat) _programLayers.enable(8);
            if (parameters.iridescence) _programLayers.enable(9);
            if (parameters.alphaTest) _programLayers.enable(10);
            if (parameters.vertexColors) _programLayers.enable(11);
            if (parameters.vertexAlphas) _programLayers.enable(12);
            if (parameters.vertexUv1s) _programLayers.enable(13);
            if (parameters.vertexUv2s) _programLayers.enable(14);
            if (parameters.vertexUv3s) _programLayers.enable(15);
            if (parameters.vertexTangents) _programLayers.enable(16);
            if (parameters.anisotropy) _programLayers.enable(17);
            if (parameters.alphaHash) _programLayers.enable(18);
            if (parameters.batching) _programLayers.enable(19);
            if (parameters.dispersion) _programLayers.enable(20);
            if (parameters.batchingColor) _programLayers.enable(21);
            array.push(_programLayers.mask);
            _programLayers.disableAll();
            if (parameters.fog) _programLayers.enable(0);
            if (parameters.useFog) _programLayers.enable(1);
            if (parameters.flatShading) _programLayers.enable(2);
            if (parameters.logarithmicDepthBuffer) _programLayers.enable(3);
            if (parameters.skinning) _programLayers.enable(4);
            if (parameters.morphTargets) _programLayers.enable(5);
            if (parameters.morphNormals) _programLayers.enable(6);
            if (parameters.morphColors) _programLayers.enable(7);
            if (parameters.premultipliedAlpha) _programLayers.enable(8);
            if (parameters.shadowMapEnabled) _programLayers.enable(9);
            if (parameters.doubleSided) _programLayers.enable(10);
            if (parameters.flipSided) _programLayers.enable(11);
            if (parameters.useDepthPacking) _programLayers.enable(12);
            if (parameters.dithering) _programLayers.enable(13);
            if (parameters.transmission) _programLayers.enable(14);
            if (parameters.sheen) _programLayers.enable(15);
            if (parameters.opaque) _programLayers.enable(16);
            if (parameters.pointsUvs) _programLayers.enable(17);
            if (parameters.decodeVideoTexture) _programLayers.enable(18);
            if (parameters.alphaToCoverage) _programLayers.enable(19);
            array.push(_programLayers.mask);
          }
          function getUniforms(material) {
            var shaderID = shaderIDs[material.type];
            var uniforms;
            if (shaderID) {
              var shader = ShaderLib[shaderID];
              uniforms = UniformsUtils.clone(shader.uniforms);
            } else {
              uniforms = material.uniforms;
            }
            return uniforms;
          }
          function acquireProgram(parameters, cacheKey) {
            var program;

            // Check if code has been already compiled
            for (var _p5 = 0, pl = programs.length; _p5 < pl; _p5++) {
              var preexistingProgram = programs[_p5];
              if (preexistingProgram.cacheKey === cacheKey) {
                program = preexistingProgram;
                ++program.usedTimes;
                break;
              }
            }
            if (program === undefined) {
              program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
              programs.push(program);
            }
            return program;
          }
          function releaseProgram(program) {
            if (--program.usedTimes === 0) {
              // Remove from unordered set
              var i = programs.indexOf(program);
              programs[i] = programs[programs.length - 1];
              programs.pop();

              // Free WebGL resources
              program.destroy();
            }
          }
          function releaseShaderCache(material) {
            _customShaders.remove(material);
          }
          function dispose() {
            _customShaders.dispose();
          }
          return {
            getParameters: getParameters,
            getProgramCacheKey: getProgramCacheKey,
            getUniforms: getUniforms,
            acquireProgram: acquireProgram,
            releaseProgram: releaseProgram,
            releaseShaderCache: releaseShaderCache,
            // Exposed for resource monitoring & error feedback via renderer.info:
            programs: programs,
            dispose: dispose
          };
        }
        function WebGLProperties() {
          var properties = new WeakMap();
          function get(object) {
            var map = properties.get(object);
            if (map === undefined) {
              map = {};
              properties.set(object, map);
            }
            return map;
          }
          function remove(object) {
            properties.delete(object);
          }
          function update(object, key, value) {
            properties.get(object)[key] = value;
          }
          function dispose() {
            properties = new WeakMap();
          }
          return {
            get: get,
            remove: remove,
            update: update,
            dispose: dispose
          };
        }
        function painterSortStable(a, b) {
          if (a.groupOrder !== b.groupOrder) {
            return a.groupOrder - b.groupOrder;
          } else if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
          } else if (a.material.id !== b.material.id) {
            return a.material.id - b.material.id;
          } else if (a.z !== b.z) {
            return a.z - b.z;
          } else {
            return a.id - b.id;
          }
        }
        function reversePainterSortStable(a, b) {
          if (a.groupOrder !== b.groupOrder) {
            return a.groupOrder - b.groupOrder;
          } else if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
          } else if (a.z !== b.z) {
            return b.z - a.z;
          } else {
            return a.id - b.id;
          }
        }
        function WebGLRenderList() {
          var renderItems = [];
          var renderItemsIndex = 0;
          var opaque = [];
          var transmissive = [];
          var transparent = [];
          function init() {
            renderItemsIndex = 0;
            opaque.length = 0;
            transmissive.length = 0;
            transparent.length = 0;
          }
          function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
            var renderItem = renderItems[renderItemsIndex];
            if (renderItem === undefined) {
              renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                groupOrder: groupOrder,
                renderOrder: object.renderOrder,
                z: z,
                group: group
              };
              renderItems[renderItemsIndex] = renderItem;
            } else {
              renderItem.id = object.id;
              renderItem.object = object;
              renderItem.geometry = geometry;
              renderItem.material = material;
              renderItem.groupOrder = groupOrder;
              renderItem.renderOrder = object.renderOrder;
              renderItem.z = z;
              renderItem.group = group;
            }
            renderItemsIndex++;
            return renderItem;
          }
          function push(object, geometry, material, groupOrder, z, group) {
            var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
            if (material.transmission > 0.0) {
              transmissive.push(renderItem);
            } else if (material.transparent === true) {
              transparent.push(renderItem);
            } else {
              opaque.push(renderItem);
            }
          }
          function unshift(object, geometry, material, groupOrder, z, group) {
            var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
            if (material.transmission > 0.0) {
              transmissive.unshift(renderItem);
            } else if (material.transparent === true) {
              transparent.unshift(renderItem);
            } else {
              opaque.unshift(renderItem);
            }
          }
          function sort(customOpaqueSort, customTransparentSort) {
            if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
            if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
            if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
          }
          function finish() {
            // Clear references from inactive renderItems in the list

            for (var i = renderItemsIndex, il = renderItems.length; i < il; i++) {
              var renderItem = renderItems[i];
              if (renderItem.id === null) break;
              renderItem.id = null;
              renderItem.object = null;
              renderItem.geometry = null;
              renderItem.material = null;
              renderItem.group = null;
            }
          }
          return {
            opaque: opaque,
            transmissive: transmissive,
            transparent: transparent,
            init: init,
            push: push,
            unshift: unshift,
            finish: finish,
            sort: sort
          };
        }
        function WebGLRenderLists() {
          var lists = new WeakMap();
          function get(scene, renderCallDepth) {
            var listArray = lists.get(scene);
            var list;
            if (listArray === undefined) {
              list = new WebGLRenderList();
              lists.set(scene, [list]);
            } else {
              if (renderCallDepth >= listArray.length) {
                list = new WebGLRenderList();
                listArray.push(list);
              } else {
                list = listArray[renderCallDepth];
              }
            }
            return list;
          }
          function dispose() {
            lists = new WeakMap();
          }
          return {
            get: get,
            dispose: dispose
          };
        }
        function UniformsCache() {
          var lights = {};
          return {
            get: function get(light) {
              if (lights[light.id] !== undefined) {
                return lights[light.id];
              }
              var uniforms;
              switch (light.type) {
                case 'DirectionalLight':
                  uniforms = {
                    direction: new Vector3(),
                    color: new Color()
                  };
                  break;
                case 'SpotLight':
                  uniforms = {
                    position: new Vector3(),
                    direction: new Vector3(),
                    color: new Color(),
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                  };
                  break;
                case 'PointLight':
                  uniforms = {
                    position: new Vector3(),
                    color: new Color(),
                    distance: 0,
                    decay: 0
                  };
                  break;
                case 'HemisphereLight':
                  uniforms = {
                    direction: new Vector3(),
                    skyColor: new Color(),
                    groundColor: new Color()
                  };
                  break;
                case 'RectAreaLight':
                  uniforms = {
                    color: new Color(),
                    position: new Vector3(),
                    halfWidth: new Vector3(),
                    halfHeight: new Vector3()
                  };
                  break;
              }
              lights[light.id] = uniforms;
              return uniforms;
            }
          };
        }
        function ShadowUniformsCache() {
          var lights = {};
          return {
            get: function get(light) {
              if (lights[light.id] !== undefined) {
                return lights[light.id];
              }
              var uniforms;
              switch (light.type) {
                case 'DirectionalLight':
                  uniforms = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2()
                  };
                  break;
                case 'SpotLight':
                  uniforms = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2()
                  };
                  break;
                case 'PointLight':
                  uniforms = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2(),
                    shadowCameraNear: 1,
                    shadowCameraFar: 1000
                  };
                  break;

                // TODO (abelnation): set RectAreaLight shadow uniforms
              }
              lights[light.id] = uniforms;
              return uniforms;
            }
          };
        }
        var nextVersion = 0;
        function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
          return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
        }
        function WebGLLights(extensions) {
          var cache = new UniformsCache();
          var shadowCache = ShadowUniformsCache();
          var state = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
              numSpotMaps: -1,
              numLightProbes: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0
          };
          for (var i = 0; i < 9; i++) state.probe.push(new Vector3());
          var vector3 = new Vector3();
          var matrix4 = new Matrix4();
          var matrix42 = new Matrix4();
          function setup(lights) {
            var r = 0,
              g = 0,
              b = 0;
            for (var _i44 = 0; _i44 < 9; _i44++) state.probe[_i44].set(0, 0, 0);
            var directionalLength = 0;
            var pointLength = 0;
            var spotLength = 0;
            var rectAreaLength = 0;
            var hemiLength = 0;
            var numDirectionalShadows = 0;
            var numPointShadows = 0;
            var numSpotShadows = 0;
            var numSpotMaps = 0;
            var numSpotShadowsWithMaps = 0;
            var numLightProbes = 0;

            // ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
            lights.sort(shadowCastingAndTexturingLightsFirst);
            for (var _i45 = 0, l = lights.length; _i45 < l; _i45++) {
              var light = lights[_i45];
              var color = light.color;
              var intensity = light.intensity;
              var distance = light.distance;
              var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
              if (light.isAmbientLight) {
                r += color.r * intensity;
                g += color.g * intensity;
                b += color.b * intensity;
              } else if (light.isLightProbe) {
                for (var j = 0; j < 9; j++) {
                  state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
                }
                numLightProbes++;
              } else if (light.isDirectionalLight) {
                var uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                if (light.castShadow) {
                  var shadow = light.shadow;
                  var shadowUniforms = shadowCache.get(light);
                  shadowUniforms.shadowIntensity = shadow.intensity;
                  shadowUniforms.shadowBias = shadow.bias;
                  shadowUniforms.shadowNormalBias = shadow.normalBias;
                  shadowUniforms.shadowRadius = shadow.radius;
                  shadowUniforms.shadowMapSize = shadow.mapSize;
                  state.directionalShadow[directionalLength] = shadowUniforms;
                  state.directionalShadowMap[directionalLength] = shadowMap;
                  state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                  numDirectionalShadows++;
                }
                state.directional[directionalLength] = uniforms;
                directionalLength++;
              } else if (light.isSpotLight) {
                var _uniforms = cache.get(light);
                _uniforms.position.setFromMatrixPosition(light.matrixWorld);
                _uniforms.color.copy(color).multiplyScalar(intensity);
                _uniforms.distance = distance;
                _uniforms.coneCos = Math.cos(light.angle);
                _uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                _uniforms.decay = light.decay;
                state.spot[spotLength] = _uniforms;
                var _shadow = light.shadow;
                if (light.map) {
                  state.spotLightMap[numSpotMaps] = light.map;
                  numSpotMaps++;

                  // make sure the lightMatrix is up to date
                  // TODO : do it if required only
                  _shadow.updateMatrices(light);
                  if (light.castShadow) numSpotShadowsWithMaps++;
                }
                state.spotLightMatrix[spotLength] = _shadow.matrix;
                if (light.castShadow) {
                  var _shadowUniforms = shadowCache.get(light);
                  _shadowUniforms.shadowIntensity = _shadow.intensity;
                  _shadowUniforms.shadowBias = _shadow.bias;
                  _shadowUniforms.shadowNormalBias = _shadow.normalBias;
                  _shadowUniforms.shadowRadius = _shadow.radius;
                  _shadowUniforms.shadowMapSize = _shadow.mapSize;
                  state.spotShadow[spotLength] = _shadowUniforms;
                  state.spotShadowMap[spotLength] = shadowMap;
                  numSpotShadows++;
                }
                spotLength++;
              } else if (light.isRectAreaLight) {
                var _uniforms2 = cache.get(light);
                _uniforms2.color.copy(color).multiplyScalar(intensity);
                _uniforms2.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                _uniforms2.halfHeight.set(0.0, light.height * 0.5, 0.0);
                state.rectArea[rectAreaLength] = _uniforms2;
                rectAreaLength++;
              } else if (light.isPointLight) {
                var _uniforms3 = cache.get(light);
                _uniforms3.color.copy(light.color).multiplyScalar(light.intensity);
                _uniforms3.distance = light.distance;
                _uniforms3.decay = light.decay;
                if (light.castShadow) {
                  var _shadow2 = light.shadow;
                  var _shadowUniforms2 = shadowCache.get(light);
                  _shadowUniforms2.shadowIntensity = _shadow2.intensity;
                  _shadowUniforms2.shadowBias = _shadow2.bias;
                  _shadowUniforms2.shadowNormalBias = _shadow2.normalBias;
                  _shadowUniforms2.shadowRadius = _shadow2.radius;
                  _shadowUniforms2.shadowMapSize = _shadow2.mapSize;
                  _shadowUniforms2.shadowCameraNear = _shadow2.camera.near;
                  _shadowUniforms2.shadowCameraFar = _shadow2.camera.far;
                  state.pointShadow[pointLength] = _shadowUniforms2;
                  state.pointShadowMap[pointLength] = shadowMap;
                  state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                  numPointShadows++;
                }
                state.point[pointLength] = _uniforms3;
                pointLength++;
              } else if (light.isHemisphereLight) {
                var _uniforms4 = cache.get(light);
                _uniforms4.skyColor.copy(light.color).multiplyScalar(intensity);
                _uniforms4.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                state.hemi[hemiLength] = _uniforms4;
                hemiLength++;
              }
            }
            if (rectAreaLength > 0) {
              if (extensions.has('OES_texture_float_linear') === true) {
                state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
              } else {
                state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
                state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
              }
            }
            state.ambient[0] = r;
            state.ambient[1] = g;
            state.ambient[2] = b;
            var hash = state.hash;
            if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {
              state.directional.length = directionalLength;
              state.spot.length = spotLength;
              state.rectArea.length = rectAreaLength;
              state.point.length = pointLength;
              state.hemi.length = hemiLength;
              state.directionalShadow.length = numDirectionalShadows;
              state.directionalShadowMap.length = numDirectionalShadows;
              state.pointShadow.length = numPointShadows;
              state.pointShadowMap.length = numPointShadows;
              state.spotShadow.length = numSpotShadows;
              state.spotShadowMap.length = numSpotShadows;
              state.directionalShadowMatrix.length = numDirectionalShadows;
              state.pointShadowMatrix.length = numPointShadows;
              state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
              state.spotLightMap.length = numSpotMaps;
              state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
              state.numLightProbes = numLightProbes;
              hash.directionalLength = directionalLength;
              hash.pointLength = pointLength;
              hash.spotLength = spotLength;
              hash.rectAreaLength = rectAreaLength;
              hash.hemiLength = hemiLength;
              hash.numDirectionalShadows = numDirectionalShadows;
              hash.numPointShadows = numPointShadows;
              hash.numSpotShadows = numSpotShadows;
              hash.numSpotMaps = numSpotMaps;
              hash.numLightProbes = numLightProbes;
              state.version = nextVersion++;
            }
          }
          function setupView(lights, camera) {
            var directionalLength = 0;
            var pointLength = 0;
            var spotLength = 0;
            var rectAreaLength = 0;
            var hemiLength = 0;
            var viewMatrix = camera.matrixWorldInverse;
            for (var _i46 = 0, l = lights.length; _i46 < l; _i46++) {
              var light = lights[_i46];
              if (light.isDirectionalLight) {
                var uniforms = state.directional[directionalLength];
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                directionalLength++;
              } else if (light.isSpotLight) {
                var _uniforms5 = state.spot[spotLength];
                _uniforms5.position.setFromMatrixPosition(light.matrixWorld);
                _uniforms5.position.applyMatrix4(viewMatrix);
                _uniforms5.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                _uniforms5.direction.sub(vector3);
                _uniforms5.direction.transformDirection(viewMatrix);
                spotLength++;
              } else if (light.isRectAreaLight) {
                var _uniforms6 = state.rectArea[rectAreaLength];
                _uniforms6.position.setFromMatrixPosition(light.matrixWorld);
                _uniforms6.position.applyMatrix4(viewMatrix);

                // extract local rotation of light to derive width/height half vectors
                matrix42.identity();
                matrix4.copy(light.matrixWorld);
                matrix4.premultiply(viewMatrix);
                matrix42.extractRotation(matrix4);
                _uniforms6.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                _uniforms6.halfHeight.set(0.0, light.height * 0.5, 0.0);
                _uniforms6.halfWidth.applyMatrix4(matrix42);
                _uniforms6.halfHeight.applyMatrix4(matrix42);
                rectAreaLength++;
              } else if (light.isPointLight) {
                var _uniforms7 = state.point[pointLength];
                _uniforms7.position.setFromMatrixPosition(light.matrixWorld);
                _uniforms7.position.applyMatrix4(viewMatrix);
                pointLength++;
              } else if (light.isHemisphereLight) {
                var _uniforms8 = state.hemi[hemiLength];
                _uniforms8.direction.setFromMatrixPosition(light.matrixWorld);
                _uniforms8.direction.transformDirection(viewMatrix);
                hemiLength++;
              }
            }
          }
          return {
            setup: setup,
            setupView: setupView,
            state: state
          };
        }
        function WebGLRenderState(extensions) {
          var lights = new WebGLLights(extensions);
          var lightsArray = [];
          var shadowsArray = [];
          function init(camera) {
            state.camera = camera;
            lightsArray.length = 0;
            shadowsArray.length = 0;
          }
          function pushLight(light) {
            lightsArray.push(light);
          }
          function pushShadow(shadowLight) {
            shadowsArray.push(shadowLight);
          }
          function setupLights() {
            lights.setup(lightsArray);
          }
          function setupLightsView(camera) {
            lights.setupView(lightsArray, camera);
          }
          var state = {
            lightsArray: lightsArray,
            shadowsArray: shadowsArray,
            camera: null,
            lights: lights,
            transmissionRenderTarget: {}
          };
          return {
            init: init,
            state: state,
            setupLights: setupLights,
            setupLightsView: setupLightsView,
            pushLight: pushLight,
            pushShadow: pushShadow
          };
        }
        function WebGLRenderStates(extensions) {
          var renderStates = new WeakMap();
          function get(scene) {
            var renderCallDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var renderStateArray = renderStates.get(scene);
            var renderState;
            if (renderStateArray === undefined) {
              renderState = new WebGLRenderState(extensions);
              renderStates.set(scene, [renderState]);
            } else {
              if (renderCallDepth >= renderStateArray.length) {
                renderState = new WebGLRenderState(extensions);
                renderStateArray.push(renderState);
              } else {
                renderState = renderStateArray[renderCallDepth];
              }
            }
            return renderState;
          }
          function dispose() {
            renderStates = new WeakMap();
          }
          return {
            get: get,
            dispose: dispose
          };
        }
        var MeshDepthMaterial = /*#__PURE__*/function (_Material3) {
          function MeshDepthMaterial(parameters) {
            var _this38;
            _classCallCheck2(this, MeshDepthMaterial);
            _this38 = _callSuper(this, MeshDepthMaterial);
            _this38.isMeshDepthMaterial = true;
            _this38.type = 'MeshDepthMaterial';
            _this38.depthPacking = BasicDepthPacking;
            _this38.map = null;
            _this38.alphaMap = null;
            _this38.displacementMap = null;
            _this38.displacementScale = 1;
            _this38.displacementBias = 0;
            _this38.wireframe = false;
            _this38.wireframeLinewidth = 1;
            _this38.setValues(parameters);
            return _this38;
          }
          _inherits(MeshDepthMaterial, _Material3);
          return _createClass(MeshDepthMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(MeshDepthMaterial, "copy", this, 3)([source]);
              this.depthPacking = source.depthPacking;
              this.map = source.map;
              this.alphaMap = source.alphaMap;
              this.displacementMap = source.displacementMap;
              this.displacementScale = source.displacementScale;
              this.displacementBias = source.displacementBias;
              this.wireframe = source.wireframe;
              this.wireframeLinewidth = source.wireframeLinewidth;
              return this;
            }
          }]);
        }(Material);
        var MeshDistanceMaterial = /*#__PURE__*/function (_Material4) {
          function MeshDistanceMaterial(parameters) {
            var _this39;
            _classCallCheck2(this, MeshDistanceMaterial);
            _this39 = _callSuper(this, MeshDistanceMaterial);
            _this39.isMeshDistanceMaterial = true;
            _this39.type = 'MeshDistanceMaterial';
            _this39.map = null;
            _this39.alphaMap = null;
            _this39.displacementMap = null;
            _this39.displacementScale = 1;
            _this39.displacementBias = 0;
            _this39.setValues(parameters);
            return _this39;
          }
          _inherits(MeshDistanceMaterial, _Material4);
          return _createClass(MeshDistanceMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(MeshDistanceMaterial, "copy", this, 3)([source]);
              this.map = source.map;
              this.alphaMap = source.alphaMap;
              this.displacementMap = source.displacementMap;
              this.displacementScale = source.displacementScale;
              this.displacementBias = source.displacementBias;
              return this;
            }
          }]);
        }(Material);
        var vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
        var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
        function WebGLShadowMap(renderer, objects, capabilities) {
          var _frustum = new Frustum();
          var _shadowMapSize = new Vector2(),
            _viewportSize = new Vector2(),
            _viewport = new Vector4(),
            _depthMaterial = new MeshDepthMaterial({
              depthPacking: RGBADepthPacking
            }),
            _distanceMaterial = new MeshDistanceMaterial(),
            _materialCache = {},
            _maxTextureSize = capabilities.maxTextureSize;
          var shadowSide = _defineProperty2(_defineProperty2(_defineProperty2({}, FrontSide, BackSide), BackSide, FrontSide), DoubleSide, DoubleSide);
          var shadowMaterialVertical = new ShaderMaterial({
            defines: {
              VSM_SAMPLES: 8
            },
            uniforms: {
              shadow_pass: {
                value: null
              },
              resolution: {
                value: new Vector2()
              },
              radius: {
                value: 4.0
              }
            },
            vertexShader: vertex,
            fragmentShader: fragment
          });
          var shadowMaterialHorizontal = shadowMaterialVertical.clone();
          shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
          var fullScreenTri = new BufferGeometry();
          fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
          var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
          var scope = this;
          this.enabled = false;
          this.autoUpdate = true;
          this.needsUpdate = false;
          this.type = PCFShadowMap;
          var _previousType = this.type;
          this.render = function (lights, scene, camera) {
            if (scope.enabled === false) return;
            if (scope.autoUpdate === false && scope.needsUpdate === false) return;
            if (lights.length === 0) return;
            var currentRenderTarget = renderer.getRenderTarget();
            var activeCubeFace = renderer.getActiveCubeFace();
            var activeMipmapLevel = renderer.getActiveMipmapLevel();
            var _state = renderer.state;

            // Set GL state for depth map.
            _state.setBlending(NoBlending);
            _state.buffers.color.setClear(1, 1, 1, 1);
            _state.buffers.depth.setTest(true);
            _state.setScissorTest(false);

            // check for shadow map type changes

            var toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
            var fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;

            // render depth map

            for (var i = 0, il = lights.length; i < il; i++) {
              var light = lights[i];
              var shadow = light.shadow;
              if (shadow === undefined) {
                console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                continue;
              }
              if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
              _shadowMapSize.copy(shadow.mapSize);
              var shadowFrameExtents = shadow.getFrameExtents();
              _shadowMapSize.multiply(shadowFrameExtents);
              _viewportSize.copy(shadow.mapSize);
              if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
                if (_shadowMapSize.x > _maxTextureSize) {
                  _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
                  _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                  shadow.mapSize.x = _viewportSize.x;
                }
                if (_shadowMapSize.y > _maxTextureSize) {
                  _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
                  _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                  shadow.mapSize.y = _viewportSize.y;
                }
              }
              if (shadow.map === null || toVSM === true || fromVSM === true) {
                var pars = this.type !== VSMShadowMap ? {
                  minFilter: NearestFilter,
                  magFilter: NearestFilter
                } : {};
                if (shadow.map !== null) {
                  shadow.map.dispose();
                }
                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + '.shadowMap';
                shadow.camera.updateProjectionMatrix();
              }
              renderer.setRenderTarget(shadow.map);
              renderer.clear();
              var viewportCount = shadow.getViewportCount();
              for (var vp = 0; vp < viewportCount; vp++) {
                var viewport = shadow.getViewport(vp);
                _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
                _state.viewport(_viewport);
                shadow.updateMatrices(light, vp);
                _frustum = shadow.getFrustum();
                renderObject(scene, camera, shadow.camera, light, this.type);
              }

              // do blur pass for VSM

              if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
                VSMPass(shadow, camera);
              }
              shadow.needsUpdate = false;
            }
            _previousType = this.type;
            scope.needsUpdate = false;
            renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
          };
          function VSMPass(shadow, camera) {
            var geometry = objects.update(fullScreenMesh);
            if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
              shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
              shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
              shadowMaterialVertical.needsUpdate = true;
              shadowMaterialHorizontal.needsUpdate = true;
            }
            if (shadow.mapPass === null) {
              shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
            }

            // vertical pass

            shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
            shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
            shadowMaterialVertical.uniforms.radius.value = shadow.radius;
            renderer.setRenderTarget(shadow.mapPass);
            renderer.clear();
            renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);

            // horizontal pass

            shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
            shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
            shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
            renderer.setRenderTarget(shadow.map);
            renderer.clear();
            renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
          }
          function getDepthMaterial(object, material, light, type) {
            var result = null;
            var customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
            if (customMaterial !== undefined) {
              result = customMaterial;
            } else {
              result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
              if (renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
                // in this case we need a unique material instance reflecting the
                // appropriate state

                var keyA = result.uuid,
                  keyB = material.uuid;
                var materialsForVariant = _materialCache[keyA];
                if (materialsForVariant === undefined) {
                  materialsForVariant = {};
                  _materialCache[keyA] = materialsForVariant;
                }
                var cachedMaterial = materialsForVariant[keyB];
                if (cachedMaterial === undefined) {
                  cachedMaterial = result.clone();
                  materialsForVariant[keyB] = cachedMaterial;
                  material.addEventListener('dispose', onMaterialDispose);
                }
                result = cachedMaterial;
              }
            }
            result.visible = material.visible;
            result.wireframe = material.wireframe;
            if (type === VSMShadowMap) {
              result.side = material.shadowSide !== null ? material.shadowSide : material.side;
            } else {
              result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
            }
            result.alphaMap = material.alphaMap;
            result.alphaTest = material.alphaTest;
            result.map = material.map;
            result.clipShadows = material.clipShadows;
            result.clippingPlanes = material.clippingPlanes;
            result.clipIntersection = material.clipIntersection;
            result.displacementMap = material.displacementMap;
            result.displacementScale = material.displacementScale;
            result.displacementBias = material.displacementBias;
            result.wireframeLinewidth = material.wireframeLinewidth;
            result.linewidth = material.linewidth;
            if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
              var materialProperties = renderer.properties.get(result);
              materialProperties.light = light;
            }
            return result;
          }
          function renderObject(object, camera, shadowCamera, light, type) {
            if (object.visible === false) return;
            var visible = object.layers.test(camera.layers);
            if (visible && (object.isMesh || object.isLine || object.isPoints)) {
              if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                var geometry = objects.update(object);
                var material = object.material;
                if (Array.isArray(material)) {
                  var groups = geometry.groups;
                  for (var _k = 0, kl = groups.length; _k < kl; _k++) {
                    var group = groups[_k];
                    var groupMaterial = material[group.materialIndex];
                    if (groupMaterial && groupMaterial.visible) {
                      var depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
                      object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
                      renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                      object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
                    }
                  }
                } else if (material.visible) {
                  var _depthMaterial2 = getDepthMaterial(object, material, light, type);
                  object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, _depthMaterial2, null);
                  renderer.renderBufferDirect(shadowCamera, null, geometry, _depthMaterial2, object, null);
                  object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, _depthMaterial2, null);
                }
              }
            }
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
              renderObject(children[i], camera, shadowCamera, light, type);
            }
          }
          function onMaterialDispose(event) {
            var material = event.target;
            material.removeEventListener('dispose', onMaterialDispose);

            // make sure to remove the unique distance/depth materials used for shadow map rendering

            for (var id in _materialCache) {
              var _cache2 = _materialCache[id];
              var uuid = event.target.uuid;
              if (uuid in _cache2) {
                var shadowMaterial = _cache2[uuid];
                shadowMaterial.dispose();
                delete _cache2[uuid];
              }
            }
          }
        }
        function WebGLState(gl) {
          var _factorToGL;
          function ColorBuffer() {
            var locked = false;
            var color = new Vector4();
            var currentColorMask = null;
            var currentColorClear = new Vector4(0, 0, 0, 0);
            return {
              setMask: function setMask(colorMask) {
                if (currentColorMask !== colorMask && !locked) {
                  gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                  currentColorMask = colorMask;
                }
              },
              setLocked: function setLocked(lock) {
                locked = lock;
              },
              setClear: function setClear(r, g, b, a, premultipliedAlpha) {
                if (premultipliedAlpha === true) {
                  r *= a;
                  g *= a;
                  b *= a;
                }
                color.set(r, g, b, a);
                if (currentColorClear.equals(color) === false) {
                  gl.clearColor(r, g, b, a);
                  currentColorClear.copy(color);
                }
              },
              reset: function reset() {
                locked = false;
                currentColorMask = null;
                currentColorClear.set(-1, 0, 0, 0); // set to invalid state
              }
            };
          }
          function DepthBuffer() {
            var locked = false;
            var currentDepthMask = null;
            var currentDepthFunc = null;
            var currentDepthClear = null;
            return {
              setTest: function setTest(depthTest) {
                if (depthTest) {
                  enable(gl.DEPTH_TEST);
                } else {
                  disable(gl.DEPTH_TEST);
                }
              },
              setMask: function setMask(depthMask) {
                if (currentDepthMask !== depthMask && !locked) {
                  gl.depthMask(depthMask);
                  currentDepthMask = depthMask;
                }
              },
              setFunc: function setFunc(depthFunc) {
                if (currentDepthFunc !== depthFunc) {
                  switch (depthFunc) {
                    case NeverDepth:
                      gl.depthFunc(gl.NEVER);
                      break;
                    case AlwaysDepth:
                      gl.depthFunc(gl.ALWAYS);
                      break;
                    case LessDepth:
                      gl.depthFunc(gl.LESS);
                      break;
                    case LessEqualDepth:
                      gl.depthFunc(gl.LEQUAL);
                      break;
                    case EqualDepth:
                      gl.depthFunc(gl.EQUAL);
                      break;
                    case GreaterEqualDepth:
                      gl.depthFunc(gl.GEQUAL);
                      break;
                    case GreaterDepth:
                      gl.depthFunc(gl.GREATER);
                      break;
                    case NotEqualDepth:
                      gl.depthFunc(gl.NOTEQUAL);
                      break;
                    default:
                      gl.depthFunc(gl.LEQUAL);
                  }
                  currentDepthFunc = depthFunc;
                }
              },
              setLocked: function setLocked(lock) {
                locked = lock;
              },
              setClear: function setClear(depth) {
                if (currentDepthClear !== depth) {
                  gl.clearDepth(depth);
                  currentDepthClear = depth;
                }
              },
              reset: function reset() {
                locked = false;
                currentDepthMask = null;
                currentDepthFunc = null;
                currentDepthClear = null;
              }
            };
          }
          function StencilBuffer() {
            var locked = false;
            var currentStencilMask = null;
            var currentStencilFunc = null;
            var currentStencilRef = null;
            var currentStencilFuncMask = null;
            var currentStencilFail = null;
            var currentStencilZFail = null;
            var currentStencilZPass = null;
            var currentStencilClear = null;
            return {
              setTest: function setTest(stencilTest) {
                if (!locked) {
                  if (stencilTest) {
                    enable(gl.STENCIL_TEST);
                  } else {
                    disable(gl.STENCIL_TEST);
                  }
                }
              },
              setMask: function setMask(stencilMask) {
                if (currentStencilMask !== stencilMask && !locked) {
                  gl.stencilMask(stencilMask);
                  currentStencilMask = stencilMask;
                }
              },
              setFunc: function setFunc(stencilFunc, stencilRef, stencilMask) {
                if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                  gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                  currentStencilFunc = stencilFunc;
                  currentStencilRef = stencilRef;
                  currentStencilFuncMask = stencilMask;
                }
              },
              setOp: function setOp(stencilFail, stencilZFail, stencilZPass) {
                if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                  gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                  currentStencilFail = stencilFail;
                  currentStencilZFail = stencilZFail;
                  currentStencilZPass = stencilZPass;
                }
              },
              setLocked: function setLocked(lock) {
                locked = lock;
              },
              setClear: function setClear(stencil) {
                if (currentStencilClear !== stencil) {
                  gl.clearStencil(stencil);
                  currentStencilClear = stencil;
                }
              },
              reset: function reset() {
                locked = false;
                currentStencilMask = null;
                currentStencilFunc = null;
                currentStencilRef = null;
                currentStencilFuncMask = null;
                currentStencilFail = null;
                currentStencilZFail = null;
                currentStencilZPass = null;
                currentStencilClear = null;
              }
            };
          }

          //

          var colorBuffer = new ColorBuffer();
          var depthBuffer = new DepthBuffer();
          var stencilBuffer = new StencilBuffer();
          var uboBindings = new WeakMap();
          var uboProgramMap = new WeakMap();
          var enabledCapabilities = {};
          var currentBoundFramebuffers = {};
          var currentDrawbuffers = new WeakMap();
          var defaultDrawbuffers = [];
          var currentProgram = null;
          var currentBlendingEnabled = false;
          var currentBlending = null;
          var currentBlendEquation = null;
          var currentBlendSrc = null;
          var currentBlendDst = null;
          var currentBlendEquationAlpha = null;
          var currentBlendSrcAlpha = null;
          var currentBlendDstAlpha = null;
          var currentBlendColor = new Color(0, 0, 0);
          var currentBlendAlpha = 0;
          var currentPremultipledAlpha = false;
          var currentFlipSided = null;
          var currentCullFace = null;
          var currentLineWidth = null;
          var currentPolygonOffsetFactor = null;
          var currentPolygonOffsetUnits = null;
          var maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
          var lineWidthAvailable = false;
          var version = 0;
          var glVersion = gl.getParameter(gl.VERSION);
          if (glVersion.indexOf('WebGL') !== -1) {
            version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
            lineWidthAvailable = version >= 1.0;
          } else if (glVersion.indexOf('OpenGL ES') !== -1) {
            version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
            lineWidthAvailable = version >= 2.0;
          }
          var currentTextureSlot = null;
          var currentBoundTextures = {};
          var scissorParam = gl.getParameter(gl.SCISSOR_BOX);
          var viewportParam = gl.getParameter(gl.VIEWPORT);
          var currentScissor = new Vector4().fromArray(scissorParam);
          var currentViewport = new Vector4().fromArray(viewportParam);
          function createTexture(type, target, count, dimensions) {
            var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
            var texture = gl.createTexture();
            gl.bindTexture(type, texture);
            gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            for (var i = 0; i < count; i++) {
              if (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY) {
                gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
              } else {
                gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
              }
            }
            return texture;
          }
          var emptyTextures = {};
          emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
          emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
          emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);
          emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);

          // init

          colorBuffer.setClear(0, 0, 0, 1);
          depthBuffer.setClear(1);
          stencilBuffer.setClear(0);
          enable(gl.DEPTH_TEST);
          depthBuffer.setFunc(LessEqualDepth);
          setFlipSided(false);
          setCullFace(CullFaceBack);
          enable(gl.CULL_FACE);
          setBlending(NoBlending);

          //

          function enable(id) {
            if (enabledCapabilities[id] !== true) {
              gl.enable(id);
              enabledCapabilities[id] = true;
            }
          }
          function disable(id) {
            if (enabledCapabilities[id] !== false) {
              gl.disable(id);
              enabledCapabilities[id] = false;
            }
          }
          function bindFramebuffer(target, framebuffer) {
            if (currentBoundFramebuffers[target] !== framebuffer) {
              gl.bindFramebuffer(target, framebuffer);
              currentBoundFramebuffers[target] = framebuffer;

              // gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

              if (target === gl.DRAW_FRAMEBUFFER) {
                currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
              }
              if (target === gl.FRAMEBUFFER) {
                currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
              }
              return true;
            }
            return false;
          }
          function drawBuffers(renderTarget, framebuffer) {
            var drawBuffers = defaultDrawbuffers;
            var needsUpdate = false;
            if (renderTarget) {
              drawBuffers = currentDrawbuffers.get(framebuffer);
              if (drawBuffers === undefined) {
                drawBuffers = [];
                currentDrawbuffers.set(framebuffer, drawBuffers);
              }
              var textures = renderTarget.textures;
              if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
                for (var i = 0, il = textures.length; i < il; i++) {
                  drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;
                }
                drawBuffers.length = textures.length;
                needsUpdate = true;
              }
            } else {
              if (drawBuffers[0] !== gl.BACK) {
                drawBuffers[0] = gl.BACK;
                needsUpdate = true;
              }
            }
            if (needsUpdate) {
              gl.drawBuffers(drawBuffers);
            }
          }
          function useProgram(program) {
            if (currentProgram !== program) {
              gl.useProgram(program);
              currentProgram = program;
              return true;
            }
            return false;
          }
          var equationToGL = _defineProperty2(_defineProperty2(_defineProperty2({}, AddEquation, gl.FUNC_ADD), SubtractEquation, gl.FUNC_SUBTRACT), ReverseSubtractEquation, gl.FUNC_REVERSE_SUBTRACT);
          equationToGL[MinEquation] = gl.MIN;
          equationToGL[MaxEquation] = gl.MAX;
          var factorToGL = (_factorToGL = {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_factorToGL, ZeroFactor, gl.ZERO), OneFactor, gl.ONE), SrcColorFactor, gl.SRC_COLOR), SrcAlphaFactor, gl.SRC_ALPHA), SrcAlphaSaturateFactor, gl.SRC_ALPHA_SATURATE), DstColorFactor, gl.DST_COLOR), DstAlphaFactor, gl.DST_ALPHA), OneMinusSrcColorFactor, gl.ONE_MINUS_SRC_COLOR), OneMinusSrcAlphaFactor, gl.ONE_MINUS_SRC_ALPHA), OneMinusDstColorFactor, gl.ONE_MINUS_DST_COLOR), _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_factorToGL, OneMinusDstAlphaFactor, gl.ONE_MINUS_DST_ALPHA), ConstantColorFactor, gl.CONSTANT_COLOR), OneMinusConstantColorFactor, gl.ONE_MINUS_CONSTANT_COLOR), ConstantAlphaFactor, gl.CONSTANT_ALPHA), OneMinusConstantAlphaFactor, gl.ONE_MINUS_CONSTANT_ALPHA));
          function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
            if (blending === NoBlending) {
              if (currentBlendingEnabled === true) {
                disable(gl.BLEND);
                currentBlendingEnabled = false;
              }
              return;
            }
            if (currentBlendingEnabled === false) {
              enable(gl.BLEND);
              currentBlendingEnabled = true;
            }
            if (blending !== CustomBlending) {
              if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                  gl.blendEquation(gl.FUNC_ADD);
                  currentBlendEquation = AddEquation;
                  currentBlendEquationAlpha = AddEquation;
                }
                if (premultipliedAlpha) {
                  switch (blending) {
                    case NormalBlending:
                      gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                      break;
                    case AdditiveBlending:
                      gl.blendFunc(gl.ONE, gl.ONE);
                      break;
                    case SubtractiveBlending:
                      gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
                      break;
                    case MultiplyBlending:
                      gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                      break;
                    default:
                      console.error('THREE.WebGLState: Invalid blending: ', blending);
                      break;
                  }
                } else {
                  switch (blending) {
                    case NormalBlending:
                      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                      break;
                    case AdditiveBlending:
                      gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                      break;
                    case SubtractiveBlending:
                      gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
                      break;
                    case MultiplyBlending:
                      gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                      break;
                    default:
                      console.error('THREE.WebGLState: Invalid blending: ', blending);
                      break;
                  }
                }
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
                currentBlendColor.set(0, 0, 0);
                currentBlendAlpha = 0;
                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;
              }
              return;
            }

            // custom blending

            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;
            if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
              gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
              currentBlendEquation = blendEquation;
              currentBlendEquationAlpha = blendEquationAlpha;
            }
            if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
              gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
              currentBlendSrc = blendSrc;
              currentBlendDst = blendDst;
              currentBlendSrcAlpha = blendSrcAlpha;
              currentBlendDstAlpha = blendDstAlpha;
            }
            if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
              gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
              currentBlendColor.copy(blendColor);
              currentBlendAlpha = blendAlpha;
            }
            currentBlending = blending;
            currentPremultipledAlpha = false;
          }
          function setMaterial(material, frontFaceCW) {
            material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
            var flipSided = material.side === BackSide;
            if (frontFaceCW) flipSided = !flipSided;
            setFlipSided(flipSided);
            material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
            depthBuffer.setFunc(material.depthFunc);
            depthBuffer.setTest(material.depthTest);
            depthBuffer.setMask(material.depthWrite);
            colorBuffer.setMask(material.colorWrite);
            var stencilWrite = material.stencilWrite;
            stencilBuffer.setTest(stencilWrite);
            if (stencilWrite) {
              stencilBuffer.setMask(material.stencilWriteMask);
              stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
              stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
            }
            setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
            material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
          }

          //

          function setFlipSided(flipSided) {
            if (currentFlipSided !== flipSided) {
              if (flipSided) {
                gl.frontFace(gl.CW);
              } else {
                gl.frontFace(gl.CCW);
              }
              currentFlipSided = flipSided;
            }
          }
          function setCullFace(cullFace) {
            if (cullFace !== CullFaceNone) {
              enable(gl.CULL_FACE);
              if (cullFace !== currentCullFace) {
                if (cullFace === CullFaceBack) {
                  gl.cullFace(gl.BACK);
                } else if (cullFace === CullFaceFront) {
                  gl.cullFace(gl.FRONT);
                } else {
                  gl.cullFace(gl.FRONT_AND_BACK);
                }
              }
            } else {
              disable(gl.CULL_FACE);
            }
            currentCullFace = cullFace;
          }
          function setLineWidth(width) {
            if (width !== currentLineWidth) {
              if (lineWidthAvailable) gl.lineWidth(width);
              currentLineWidth = width;
            }
          }
          function setPolygonOffset(polygonOffset, factor, units) {
            if (polygonOffset) {
              enable(gl.POLYGON_OFFSET_FILL);
              if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                gl.polygonOffset(factor, units);
                currentPolygonOffsetFactor = factor;
                currentPolygonOffsetUnits = units;
              }
            } else {
              disable(gl.POLYGON_OFFSET_FILL);
            }
          }
          function setScissorTest(scissorTest) {
            if (scissorTest) {
              enable(gl.SCISSOR_TEST);
            } else {
              disable(gl.SCISSOR_TEST);
            }
          }

          // texture

          function activeTexture(webglSlot) {
            if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
            if (currentTextureSlot !== webglSlot) {
              gl.activeTexture(webglSlot);
              currentTextureSlot = webglSlot;
            }
          }
          function bindTexture(webglType, webglTexture, webglSlot) {
            if (webglSlot === undefined) {
              if (currentTextureSlot === null) {
                webglSlot = gl.TEXTURE0 + maxTextures - 1;
              } else {
                webglSlot = currentTextureSlot;
              }
            }
            var boundTexture = currentBoundTextures[webglSlot];
            if (boundTexture === undefined) {
              boundTexture = {
                type: undefined,
                texture: undefined
              };
              currentBoundTextures[webglSlot] = boundTexture;
            }
            if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
              if (currentTextureSlot !== webglSlot) {
                gl.activeTexture(webglSlot);
                currentTextureSlot = webglSlot;
              }
              gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
              boundTexture.type = webglType;
              boundTexture.texture = webglTexture;
            }
          }
          function unbindTexture() {
            var boundTexture = currentBoundTextures[currentTextureSlot];
            if (boundTexture !== undefined && boundTexture.type !== undefined) {
              gl.bindTexture(boundTexture.type, null);
              boundTexture.type = undefined;
              boundTexture.texture = undefined;
            }
          }
          function compressedTexImage2D() {
            try {
              gl.compressedTexImage2D.apply(gl, arguments);
            } catch (error) {
              console.error('THREE.WebGLState:', error);
            }
          }
          function compressedTexImage3D() {
            try {
              gl.compressedTexImage3D.apply(gl, arguments);
            } catch (error) {
              console.error('THREE.WebGLState:', error);
            }
          }
          function texSubImage2D() {
            try {
              gl.texSubImage2D.apply(gl, arguments);
            } catch (error) {
              console.error('THREE.WebGLState:', error);
            }
          }
          function texSubImage3D() {
            try {
              gl.texSubImage3D.apply(gl, arguments);
            } catch (error) {
              console.error('THREE.WebGLState:', error);
            }
          }
          function compressedTexSubImage2D() {
            try {
              gl.compressedTexSubImage2D.apply(gl, arguments);
            } catch (error) {
              console.error('THREE.WebGLState:', error);
            }
          }
          function compressedTexSubImage3D() {
            try {
              gl.compressedTexSubImage3D.apply(gl, arguments);
            } catch (error) {
              console.error('THREE.WebGLState:', error);
            }
          }
          function texStorage2D() {
            try {
              gl.texStorage2D.apply(gl, arguments);
            } catch (error) {
              console.error('THREE.WebGLState:', error);
            }
          }
          function texStorage3D() {
            try {
              gl.texStorage3D.apply(gl, arguments);
            } catch (error) {
              console.error('THREE.WebGLState:', error);
            }
          }
          function texImage2D() {
            try {
              gl.texImage2D.apply(gl, arguments);
            } catch (error) {
              console.error('THREE.WebGLState:', error);
            }
          }
          function texImage3D() {
            try {
              gl.texImage3D.apply(gl, arguments);
            } catch (error) {
              console.error('THREE.WebGLState:', error);
            }
          }

          //

          function scissor(scissor) {
            if (currentScissor.equals(scissor) === false) {
              gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
              currentScissor.copy(scissor);
            }
          }
          function viewport(viewport) {
            if (currentViewport.equals(viewport) === false) {
              gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
              currentViewport.copy(viewport);
            }
          }
          function updateUBOMapping(uniformsGroup, program) {
            var mapping = uboProgramMap.get(program);
            if (mapping === undefined) {
              mapping = new WeakMap();
              uboProgramMap.set(program, mapping);
            }
            var blockIndex = mapping.get(uniformsGroup);
            if (blockIndex === undefined) {
              blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
              mapping.set(uniformsGroup, blockIndex);
            }
          }
          function uniformBlockBinding(uniformsGroup, program) {
            var mapping = uboProgramMap.get(program);
            var blockIndex = mapping.get(uniformsGroup);
            if (uboBindings.get(program) !== blockIndex) {
              // bind shader specific block index to global block point
              gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
              uboBindings.set(program, blockIndex);
            }
          }

          //

          function reset() {
            // reset state

            gl.disable(gl.BLEND);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.POLYGON_OFFSET_FILL);
            gl.disable(gl.SCISSOR_TEST);
            gl.disable(gl.STENCIL_TEST);
            gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ONE, gl.ZERO);
            gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
            gl.blendColor(0, 0, 0, 0);
            gl.colorMask(true, true, true, true);
            gl.clearColor(0, 0, 0, 0);
            gl.depthMask(true);
            gl.depthFunc(gl.LESS);
            gl.clearDepth(1);
            gl.stencilMask(0xffffffff);
            gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
            gl.clearStencil(0);
            gl.cullFace(gl.BACK);
            gl.frontFace(gl.CCW);
            gl.polygonOffset(0, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
            gl.useProgram(null);
            gl.lineWidth(1);
            gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            // reset internals

            enabledCapabilities = {};
            currentTextureSlot = null;
            currentBoundTextures = {};
            currentBoundFramebuffers = {};
            currentDrawbuffers = new WeakMap();
            defaultDrawbuffers = [];
            currentProgram = null;
            currentBlendingEnabled = false;
            currentBlending = null;
            currentBlendEquation = null;
            currentBlendSrc = null;
            currentBlendDst = null;
            currentBlendEquationAlpha = null;
            currentBlendSrcAlpha = null;
            currentBlendDstAlpha = null;
            currentBlendColor = new Color(0, 0, 0);
            currentBlendAlpha = 0;
            currentPremultipledAlpha = false;
            currentFlipSided = null;
            currentCullFace = null;
            currentLineWidth = null;
            currentPolygonOffsetFactor = null;
            currentPolygonOffsetUnits = null;
            currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
            currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
            colorBuffer.reset();
            depthBuffer.reset();
            stencilBuffer.reset();
          }
          return {
            buffers: {
              color: colorBuffer,
              depth: depthBuffer,
              stencil: stencilBuffer
            },
            enable: enable,
            disable: disable,
            bindFramebuffer: bindFramebuffer,
            drawBuffers: drawBuffers,
            useProgram: useProgram,
            setBlending: setBlending,
            setMaterial: setMaterial,
            setFlipSided: setFlipSided,
            setCullFace: setCullFace,
            setLineWidth: setLineWidth,
            setPolygonOffset: setPolygonOffset,
            setScissorTest: setScissorTest,
            activeTexture: activeTexture,
            bindTexture: bindTexture,
            unbindTexture: unbindTexture,
            compressedTexImage2D: compressedTexImage2D,
            compressedTexImage3D: compressedTexImage3D,
            texImage2D: texImage2D,
            texImage3D: texImage3D,
            updateUBOMapping: updateUBOMapping,
            uniformBlockBinding: uniformBlockBinding,
            texStorage2D: texStorage2D,
            texStorage3D: texStorage3D,
            texSubImage2D: texSubImage2D,
            texSubImage3D: texSubImage3D,
            compressedTexSubImage2D: compressedTexSubImage2D,
            compressedTexSubImage3D: compressedTexSubImage3D,
            scissor: scissor,
            viewport: viewport,
            reset: reset
          };
        }
        function contain(texture, aspect) {
          var imageAspect = texture.image && texture.image.width ? texture.image.width / texture.image.height : 1;
          if (imageAspect > aspect) {
            texture.repeat.x = 1;
            texture.repeat.y = imageAspect / aspect;
            texture.offset.x = 0;
            texture.offset.y = (1 - texture.repeat.y) / 2;
          } else {
            texture.repeat.x = aspect / imageAspect;
            texture.repeat.y = 1;
            texture.offset.x = (1 - texture.repeat.x) / 2;
            texture.offset.y = 0;
          }
          return texture;
        }
        function cover(texture, aspect) {
          var imageAspect = texture.image && texture.image.width ? texture.image.width / texture.image.height : 1;
          if (imageAspect > aspect) {
            texture.repeat.x = aspect / imageAspect;
            texture.repeat.y = 1;
            texture.offset.x = (1 - texture.repeat.x) / 2;
            texture.offset.y = 0;
          } else {
            texture.repeat.x = 1;
            texture.repeat.y = imageAspect / aspect;
            texture.offset.x = 0;
            texture.offset.y = (1 - texture.repeat.y) / 2;
          }
          return texture;
        }
        function fill(texture) {
          texture.repeat.x = 1;
          texture.repeat.y = 1;
          texture.offset.x = 0;
          texture.offset.y = 0;
          return texture;
        }

        /**
         * Given the width, height, format, and type of a texture. Determines how many
         * bytes must be used to represent the texture.
         */
        function getByteLength(width, height, format, type) {
          var typeByteLength = getTextureTypeByteLength(type);
          switch (format) {
            // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
            case AlphaFormat:
              return width * height;
            case LuminanceFormat:
              return width * height;
            case LuminanceAlphaFormat:
              return width * height * 2;
            case RedFormat:
              return width * height / typeByteLength.components * typeByteLength.byteLength;
            case RedIntegerFormat:
              return width * height / typeByteLength.components * typeByteLength.byteLength;
            case RGFormat:
              return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
            case RGIntegerFormat:
              return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
            case RGBFormat:
              return width * height * 3 / typeByteLength.components * typeByteLength.byteLength;
            case RGBAFormat:
              return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
            case RGBAIntegerFormat:
              return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;

            // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
            case RGB_S3TC_DXT1_Format:
            case RGBA_S3TC_DXT1_Format:
              return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
            case RGBA_S3TC_DXT3_Format:
            case RGBA_S3TC_DXT5_Format:
              return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;

            // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
            case RGB_PVRTC_2BPPV1_Format:
            case RGBA_PVRTC_2BPPV1_Format:
              return Math.max(width, 16) * Math.max(height, 8) / 4;
            case RGB_PVRTC_4BPPV1_Format:
            case RGBA_PVRTC_4BPPV1_Format:
              return Math.max(width, 8) * Math.max(height, 8) / 2;

            // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
            case RGB_ETC1_Format:
            case RGB_ETC2_Format:
              return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
            case RGBA_ETC2_EAC_Format:
              return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;

            // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
            case RGBA_ASTC_4x4_Format:
              return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
            case RGBA_ASTC_5x4_Format:
              return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
            case RGBA_ASTC_5x5_Format:
              return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
            case RGBA_ASTC_6x5_Format:
              return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
            case RGBA_ASTC_6x6_Format:
              return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
            case RGBA_ASTC_8x5_Format:
              return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
            case RGBA_ASTC_8x6_Format:
              return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
            case RGBA_ASTC_8x8_Format:
              return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
            case RGBA_ASTC_10x5_Format:
              return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
            case RGBA_ASTC_10x6_Format:
              return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
            case RGBA_ASTC_10x8_Format:
              return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
            case RGBA_ASTC_10x10_Format:
              return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
            case RGBA_ASTC_12x10_Format:
              return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
            case RGBA_ASTC_12x12_Format:
              return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;

            // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
            case RGBA_BPTC_Format:
            case RGB_BPTC_SIGNED_Format:
            case RGB_BPTC_UNSIGNED_Format:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;

            // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
            case RED_RGTC1_Format:
            case SIGNED_RED_RGTC1_Format:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;
            case RED_GREEN_RGTC2_Format:
            case SIGNED_RED_GREEN_RGTC2_Format:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
          }
          throw new Error("Unable to determine texture byte length for ".concat(format, " format."));
        }
        function getTextureTypeByteLength(type) {
          switch (type) {
            case UnsignedByteType:
            case ByteType:
              return {
                byteLength: 1,
                components: 1
              };
            case UnsignedShortType:
            case ShortType:
            case HalfFloatType:
              return {
                byteLength: 2,
                components: 1
              };
            case UnsignedShort4444Type:
            case UnsignedShort5551Type:
              return {
                byteLength: 2,
                components: 4
              };
            case UnsignedIntType:
            case IntType:
            case FloatType:
              return {
                byteLength: 4,
                components: 1
              };
            case UnsignedInt5999Type:
              return {
                byteLength: 4,
                components: 3
              };
          }
          throw new Error("Unknown texture type ".concat(type, "."));
        }
        var TextureUtils = {
          contain: contain,
          cover: cover,
          fill: fill,
          getByteLength: getByteLength
        };
        function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
          var multisampledRTTExt = extensions.has('WEBGL_multisampled_render_to_texture') ? extensions.get('WEBGL_multisampled_render_to_texture') : null;
          var supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test(navigator.userAgent);
          var _imageDimensions = new Vector2();
          var _videoTextures = new WeakMap();
          var _canvas;
          var _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

          // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
          // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
          // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

          var useOffscreenCanvas = false;
          try {
            useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
            // eslint-disable-next-line compat/compat
            && new OffscreenCanvas(1, 1).getContext('2d') !== null;
          } catch (err) {

            // Ignore any errors
          }
          function createCanvas(width, height) {
            // Use OffscreenCanvas when available. Specially needed in web workers

            return useOffscreenCanvas ?
            // eslint-disable-next-line compat/compat
            new OffscreenCanvas(width, height) : createElementNS('canvas');
          }
          function resizeImage(image, needsNewCanvas, maxSize) {
            var scale = 1;
            var dimensions = getDimensions(image);

            // handle case if texture exceeds max size

            if (dimensions.width > maxSize || dimensions.height > maxSize) {
              scale = maxSize / Math.max(dimensions.width, dimensions.height);
            }

            // only perform resize if necessary

            if (scale < 1) {
              // only perform resize for certain image types

              if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap || typeof VideoFrame !== 'undefined' && image instanceof VideoFrame) {
                var width = Math.floor(scale * dimensions.width);
                var height = Math.floor(scale * dimensions.height);
                if (_canvas === undefined) _canvas = createCanvas(width, height);

                // cube textures can't reuse the same canvas

                var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
                canvas.width = width;
                canvas.height = height;
                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, width, height);
                console.warn('THREE.WebGLRenderer: Texture has been resized from (' + dimensions.width + 'x' + dimensions.height + ') to (' + width + 'x' + height + ').');
                return canvas;
              } else {
                if ('data' in image) {
                  console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + dimensions.width + 'x' + dimensions.height + ').');
                }
                return image;
              }
            }
            return image;
          }
          function textureNeedsGenerateMipmaps(texture) {
            return texture.generateMipmaps && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
          }
          function generateMipmap(target) {
            _gl.generateMipmap(target);
          }
          function getInternalFormat(internalFormatName, glFormat, glType, colorSpace) {
            var forceLinearTransfer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
            if (internalFormatName !== null) {
              if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
              console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
            }
            var internalFormat = glFormat;
            if (glFormat === _gl.RED) {
              if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
              if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
              if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
            }
            if (glFormat === _gl.RED_INTEGER) {
              if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8UI;
              if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.R16UI;
              if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.R32UI;
              if (glType === _gl.BYTE) internalFormat = _gl.R8I;
              if (glType === _gl.SHORT) internalFormat = _gl.R16I;
              if (glType === _gl.INT) internalFormat = _gl.R32I;
            }
            if (glFormat === _gl.RG) {
              if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
              if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
              if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
            }
            if (glFormat === _gl.RG_INTEGER) {
              if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8UI;
              if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RG16UI;
              if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RG32UI;
              if (glType === _gl.BYTE) internalFormat = _gl.RG8I;
              if (glType === _gl.SHORT) internalFormat = _gl.RG16I;
              if (glType === _gl.INT) internalFormat = _gl.RG32I;
            }
            if (glFormat === _gl.RGB) {
              if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = _gl.RGB9_E5;
            }
            if (glFormat === _gl.RGBA) {
              var transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
              if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
              if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
              if (glType === _gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
              if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
              if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
            }
            if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
              extensions.get('EXT_color_buffer_float');
            }
            return internalFormat;
          }
          function getInternalDepthFormat(useStencil, depthType) {
            var glInternalFormat;
            if (useStencil) {
              if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
                glInternalFormat = _gl.DEPTH24_STENCIL8;
              } else if (depthType === FloatType) {
                glInternalFormat = _gl.DEPTH32F_STENCIL8;
              } else if (depthType === UnsignedShortType) {
                glInternalFormat = _gl.DEPTH24_STENCIL8;
                console.warn('DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.');
              }
            } else {
              if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
                glInternalFormat = _gl.DEPTH_COMPONENT24;
              } else if (depthType === FloatType) {
                glInternalFormat = _gl.DEPTH_COMPONENT32F;
              } else if (depthType === UnsignedShortType) {
                glInternalFormat = _gl.DEPTH_COMPONENT16;
              }
            }
            return glInternalFormat;
          }
          function getMipLevels(texture, image) {
            if (textureNeedsGenerateMipmaps(texture) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
              return Math.log2(Math.max(image.width, image.height)) + 1;
            } else if (texture.mipmaps !== undefined && texture.mipmaps.length > 0) {
              // user-defined mipmaps

              return texture.mipmaps.length;
            } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
              return image.mipmaps.length;
            } else {
              // texture without mipmaps (only base level)

              return 1;
            }
          }

          //

          function onTextureDispose(event) {
            var texture = event.target;
            texture.removeEventListener('dispose', onTextureDispose);
            deallocateTexture(texture);
            if (texture.isVideoTexture) {
              _videoTextures.delete(texture);
            }
          }
          function onRenderTargetDispose(event) {
            var renderTarget = event.target;
            renderTarget.removeEventListener('dispose', onRenderTargetDispose);
            deallocateRenderTarget(renderTarget);
          }

          //

          function deallocateTexture(texture) {
            var textureProperties = properties.get(texture);
            if (textureProperties.__webglInit === undefined) return;

            // check if it's necessary to remove the WebGLTexture object

            var source = texture.source;
            var webglTextures = _sources.get(source);
            if (webglTextures) {
              var webglTexture = webglTextures[textureProperties.__cacheKey];
              webglTexture.usedTimes--;

              // the WebGLTexture object is not used anymore, remove it

              if (webglTexture.usedTimes === 0) {
                deleteTexture(texture);
              }

              // remove the weak map entry if no WebGLTexture uses the source anymore

              if (Object.keys(webglTextures).length === 0) {
                _sources.delete(source);
              }
            }
            properties.remove(texture);
          }
          function deleteTexture(texture) {
            var textureProperties = properties.get(texture);
            _gl.deleteTexture(textureProperties.__webglTexture);
            var source = texture.source;
            var webglTextures = _sources.get(source);
            delete webglTextures[textureProperties.__cacheKey];
            info.memory.textures--;
          }
          function deallocateRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            if (renderTarget.depthTexture) {
              renderTarget.depthTexture.dispose();
            }
            if (renderTarget.isWebGLCubeRenderTarget) {
              for (var i = 0; i < 6; i++) {
                if (Array.isArray(renderTargetProperties.__webglFramebuffer[i])) {
                  for (var level = 0; level < renderTargetProperties.__webglFramebuffer[i].length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);
                } else {
                  _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                }
                if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
              }
            } else {
              if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
                for (var _level = 0; _level < renderTargetProperties.__webglFramebuffer.length; _level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[_level]);
              } else {
                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
              }
              if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
              if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
              if (renderTargetProperties.__webglColorRenderbuffer) {
                for (var _i47 = 0; _i47 < renderTargetProperties.__webglColorRenderbuffer.length; _i47++) {
                  if (renderTargetProperties.__webglColorRenderbuffer[_i47]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[_i47]);
                }
              }
              if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
            }
            var textures = renderTarget.textures;
            for (var _i48 = 0, il = textures.length; _i48 < il; _i48++) {
              var attachmentProperties = properties.get(textures[_i48]);
              if (attachmentProperties.__webglTexture) {
                _gl.deleteTexture(attachmentProperties.__webglTexture);
                info.memory.textures--;
              }
              properties.remove(textures[_i48]);
            }
            properties.remove(renderTarget);
          }

          //

          var textureUnits = 0;
          function resetTextureUnits() {
            textureUnits = 0;
          }
          function allocateTextureUnit() {
            var textureUnit = textureUnits;
            if (textureUnit >= capabilities.maxTextures) {
              console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
            }
            textureUnits += 1;
            return textureUnit;
          }
          function getTextureCacheKey(texture) {
            var array = [];
            array.push(texture.wrapS);
            array.push(texture.wrapT);
            array.push(texture.wrapR || 0);
            array.push(texture.magFilter);
            array.push(texture.minFilter);
            array.push(texture.anisotropy);
            array.push(texture.internalFormat);
            array.push(texture.format);
            array.push(texture.type);
            array.push(texture.generateMipmaps);
            array.push(texture.premultiplyAlpha);
            array.push(texture.flipY);
            array.push(texture.unpackAlignment);
            array.push(texture.colorSpace);
            return array.join();
          }

          //

          function setTexture2D(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.isVideoTexture) updateVideoTexture(texture);
            if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
              var image = texture.image;
              if (image === null) {
                console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.');
              } else if (image.complete === false) {
                console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
              } else {
                uploadTexture(textureProperties, texture, slot);
                return;
              }
            }
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
          }
          function setTexture2DArray(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
              uploadTexture(textureProperties, texture, slot);
              return;
            }
            state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
          }
          function setTexture3D(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
              uploadTexture(textureProperties, texture, slot);
              return;
            }
            state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
          }
          function setTextureCube(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
              uploadCubeTexture(textureProperties, texture, slot);
              return;
            }
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
          }
          var wrappingToGL = _defineProperty2(_defineProperty2(_defineProperty2({}, RepeatWrapping, _gl.REPEAT), ClampToEdgeWrapping, _gl.CLAMP_TO_EDGE), MirroredRepeatWrapping, _gl.MIRRORED_REPEAT);
          var filterToGL = _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, NearestFilter, _gl.NEAREST), NearestMipmapNearestFilter, _gl.NEAREST_MIPMAP_NEAREST), NearestMipmapLinearFilter, _gl.NEAREST_MIPMAP_LINEAR), LinearFilter, _gl.LINEAR), LinearMipmapNearestFilter, _gl.LINEAR_MIPMAP_NEAREST), LinearMipmapLinearFilter, _gl.LINEAR_MIPMAP_LINEAR);
          var compareToGL = _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2({}, NeverCompare, _gl.NEVER), AlwaysCompare, _gl.ALWAYS), LessCompare, _gl.LESS), LessEqualCompare, _gl.LEQUAL), EqualCompare, _gl.EQUAL), GreaterEqualCompare, _gl.GEQUAL), GreaterCompare, _gl.GREATER), NotEqualCompare, _gl.NOTEQUAL);
          function setTextureParameters(textureType, texture) {
            if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false && (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter)) {
              console.warn('THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.');
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
              _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
            if (texture.compareFunction) {
              _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
              _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
            }
            if (extensions.has('EXT_texture_filter_anisotropic') === true) {
              if (texture.magFilter === NearestFilter) return;
              if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;
              if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension

              if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                var extension = extensions.get('EXT_texture_filter_anisotropic');
                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                properties.get(texture).__currentAnisotropy = texture.anisotropy;
              }
            }
          }
          function initTexture(textureProperties, texture) {
            var forceUpload = false;
            if (textureProperties.__webglInit === undefined) {
              textureProperties.__webglInit = true;
              texture.addEventListener('dispose', onTextureDispose);
            }

            // create Source <-> WebGLTextures mapping if necessary

            var source = texture.source;
            var webglTextures = _sources.get(source);
            if (webglTextures === undefined) {
              webglTextures = {};
              _sources.set(source, webglTextures);
            }

            // check if there is already a WebGLTexture object for the given texture parameters

            var textureCacheKey = getTextureCacheKey(texture);
            if (textureCacheKey !== textureProperties.__cacheKey) {
              // if not, create a new instance of WebGLTexture

              if (webglTextures[textureCacheKey] === undefined) {
                // create new entry

                webglTextures[textureCacheKey] = {
                  texture: _gl.createTexture(),
                  usedTimes: 0
                };
                info.memory.textures++;

                // when a new instance of WebGLTexture was created, a texture upload is required
                // even if the image contents are identical

                forceUpload = true;
              }
              webglTextures[textureCacheKey].usedTimes++;

              // every time the texture cache key changes, it's necessary to check if an instance of
              // WebGLTexture can be deleted in order to avoid a memory leak.

              var webglTexture = webglTextures[textureProperties.__cacheKey];
              if (webglTexture !== undefined) {
                webglTextures[textureProperties.__cacheKey].usedTimes--;
                if (webglTexture.usedTimes === 0) {
                  deleteTexture(texture);
                }
              }

              // store references to cache key and WebGLTexture object

              textureProperties.__cacheKey = textureCacheKey;
              textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
            }
            return forceUpload;
          }
          function uploadTexture(textureProperties, texture, slot) {
            var textureType = _gl.TEXTURE_2D;
            if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
            if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
            var forceUpload = initTexture(textureProperties, texture);
            var source = texture.source;
            state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
            var sourceProperties = properties.get(source);
            if (source.version !== sourceProperties.__version || forceUpload === true) {
              state.activeTexture(_gl.TEXTURE0 + slot);
              var workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
              var texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
              var unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
              _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
              _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
              _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
              _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
              var image = resizeImage(texture.image, false, capabilities.maxTextureSize);
              image = verifyColorSpace(texture, image);
              var glFormat = utils.convert(texture.format, texture.colorSpace);
              var glType = utils.convert(texture.type);
              var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
              setTextureParameters(textureType, texture);
              var mipmap;
              var mipmaps = texture.mipmaps;
              var useTexStorage = texture.isVideoTexture !== true;
              var allocateMemory = sourceProperties.__version === undefined || forceUpload === true;
              var dataReady = source.dataReady;
              var levels = getMipLevels(texture, image);
              if (texture.isDepthTexture) {
                glInternalFormat = getInternalDepthFormat(texture.format === DepthStencilFormat, texture.type);

                //

                if (allocateMemory) {
                  if (useTexStorage) {
                    state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
                  } else {
                    state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
                  }
                }
              } else if (texture.isDataTexture) {
                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels

                if (mipmaps.length > 0) {
                  if (useTexStorage && allocateMemory) {
                    state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
                  }
                  for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    if (useTexStorage) {
                      if (dataReady) {
                        state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                      }
                    } else {
                      state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                  }
                  texture.generateMipmaps = false;
                } else {
                  if (useTexStorage) {
                    if (allocateMemory) {
                      state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
                    }
                    if (dataReady) {
                      state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
                    }
                  } else {
                    state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                  }
                }
              } else if (texture.isCompressedTexture) {
                if (texture.isCompressedArrayTexture) {
                  if (useTexStorage && allocateMemory) {
                    state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
                  }
                  for (var _i49 = 0, _il9 = mipmaps.length; _i49 < _il9; _i49++) {
                    mipmap = mipmaps[_i49];
                    if (texture.format !== RGBAFormat) {
                      if (glFormat !== null) {
                        if (useTexStorage) {
                          if (dataReady) {
                            if (texture.layerUpdates.size > 0) {
                              var layerByteLength = getByteLength(mipmap.width, mipmap.height, texture.format, texture.type);
                              var _iterator23 = _createForOfIteratorHelper(texture.layerUpdates),
                                _step23;
                              try {
                                for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                                  var layerIndex = _step23.value;
                                  var layerData = mipmap.data.subarray(layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT, (layerIndex + 1) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT);
                                  state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, _i49, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData, 0, 0);
                                }
                              } catch (err) {
                                _iterator23.e(err);
                              } finally {
                                _iterator23.f();
                              }
                              texture.clearLayerUpdates();
                            } else {
                              state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, _i49, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0);
                            }
                          }
                        } else {
                          state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, _i49, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                        }
                      } else {
                        console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                      }
                    } else {
                      if (useTexStorage) {
                        if (dataReady) {
                          state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, _i49, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
                        }
                      } else {
                        state.texImage3D(_gl.TEXTURE_2D_ARRAY, _i49, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
                      }
                    }
                  }
                } else {
                  if (useTexStorage && allocateMemory) {
                    state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
                  }
                  for (var _i50 = 0, _il10 = mipmaps.length; _i50 < _il10; _i50++) {
                    mipmap = mipmaps[_i50];
                    if (texture.format !== RGBAFormat) {
                      if (glFormat !== null) {
                        if (useTexStorage) {
                          if (dataReady) {
                            state.compressedTexSubImage2D(_gl.TEXTURE_2D, _i50, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                          }
                        } else {
                          state.compressedTexImage2D(_gl.TEXTURE_2D, _i50, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        }
                      } else {
                        console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                      }
                    } else {
                      if (useTexStorage) {
                        if (dataReady) {
                          state.texSubImage2D(_gl.TEXTURE_2D, _i50, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                        }
                      } else {
                        state.texImage2D(_gl.TEXTURE_2D, _i50, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                      }
                    }
                  }
                }
              } else if (texture.isDataArrayTexture) {
                if (useTexStorage) {
                  if (allocateMemory) {
                    state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
                  }
                  if (dataReady) {
                    if (texture.layerUpdates.size > 0) {
                      var _layerByteLength = getByteLength(image.width, image.height, texture.format, texture.type);
                      var _iterator24 = _createForOfIteratorHelper(texture.layerUpdates),
                        _step24;
                      try {
                        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
                          var _layerIndex = _step24.value;
                          var _layerData = image.data.subarray(_layerIndex * _layerByteLength / image.data.BYTES_PER_ELEMENT, (_layerIndex + 1) * _layerByteLength / image.data.BYTES_PER_ELEMENT);
                          state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, _layerIndex, image.width, image.height, 1, glFormat, glType, _layerData);
                        }
                      } catch (err) {
                        _iterator24.e(err);
                      } finally {
                        _iterator24.f();
                      }
                      texture.clearLayerUpdates();
                    } else {
                      state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
                    }
                  }
                } else {
                  state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
                }
              } else if (texture.isData3DTexture) {
                if (useTexStorage) {
                  if (allocateMemory) {
                    state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
                  }
                  if (dataReady) {
                    state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
                  }
                } else {
                  state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
                }
              } else if (texture.isFramebufferTexture) {
                if (allocateMemory) {
                  if (useTexStorage) {
                    state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
                  } else {
                    var width = image.width,
                      height = image.height;
                    for (var _i51 = 0; _i51 < levels; _i51++) {
                      state.texImage2D(_gl.TEXTURE_2D, _i51, glInternalFormat, width, height, 0, glFormat, glType, null);
                      width >>= 1;
                      height >>= 1;
                    }
                  }
                }
              } else {
                // regular Texture (image, video, canvas)

                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels

                if (mipmaps.length > 0) {
                  if (useTexStorage && allocateMemory) {
                    var dimensions = getDimensions(mipmaps[0]);
                    state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
                  }
                  for (var _i52 = 0, _il11 = mipmaps.length; _i52 < _il11; _i52++) {
                    mipmap = mipmaps[_i52];
                    if (useTexStorage) {
                      if (dataReady) {
                        state.texSubImage2D(_gl.TEXTURE_2D, _i52, 0, 0, glFormat, glType, mipmap);
                      }
                    } else {
                      state.texImage2D(_gl.TEXTURE_2D, _i52, glInternalFormat, glFormat, glType, mipmap);
                    }
                  }
                  texture.generateMipmaps = false;
                } else {
                  if (useTexStorage) {
                    if (allocateMemory) {
                      var _dimensions = getDimensions(image);
                      state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, _dimensions.width, _dimensions.height);
                    }
                    if (dataReady) {
                      state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
                    }
                  } else {
                    state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
                  }
                }
              }
              if (textureNeedsGenerateMipmaps(texture)) {
                generateMipmap(textureType);
              }
              sourceProperties.__version = source.version;
              if (texture.onUpdate) texture.onUpdate(texture);
            }
            textureProperties.__version = texture.version;
          }
          function uploadCubeTexture(textureProperties, texture, slot) {
            if (texture.image.length !== 6) return;
            var forceUpload = initTexture(textureProperties, texture);
            var source = texture.source;
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
            var sourceProperties = properties.get(source);
            if (source.version !== sourceProperties.__version || forceUpload === true) {
              state.activeTexture(_gl.TEXTURE0 + slot);
              var workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
              var texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
              var unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
              _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
              _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
              _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
              _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
              var isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
              var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
              var cubeImage = [];
              for (var i = 0; i < 6; i++) {
                if (!isCompressed && !isDataTexture) {
                  cubeImage[i] = resizeImage(texture.image[i], true, capabilities.maxCubemapSize);
                } else {
                  cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                }
                cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
              }
              var image = cubeImage[0],
                glFormat = utils.convert(texture.format, texture.colorSpace),
                glType = utils.convert(texture.type),
                glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
              var useTexStorage = texture.isVideoTexture !== true;
              var allocateMemory = sourceProperties.__version === undefined || forceUpload === true;
              var dataReady = source.dataReady;
              var levels = getMipLevels(texture, image);
              setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
              var mipmaps;
              if (isCompressed) {
                if (useTexStorage && allocateMemory) {
                  state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
                }
                for (var _i53 = 0; _i53 < 6; _i53++) {
                  mipmaps = cubeImage[_i53].mipmaps;
                  for (var j = 0; j < mipmaps.length; j++) {
                    var mipmap = mipmaps[j];
                    if (texture.format !== RGBAFormat) {
                      if (glFormat !== null) {
                        if (useTexStorage) {
                          if (dataReady) {
                            state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i53, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                          }
                        } else {
                          state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i53, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        }
                      } else {
                        console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                      }
                    } else {
                      if (useTexStorage) {
                        if (dataReady) {
                          state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i53, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                        }
                      } else {
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i53, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                      }
                    }
                  }
                }
              } else {
                mipmaps = texture.mipmaps;
                if (useTexStorage && allocateMemory) {
                  // TODO: Uniformly handle mipmap definitions
                  // Normal textures and compressed cube textures define base level + mips with their mipmap array
                  // Uncompressed cube textures use their mipmap array only for mips (no base level)

                  if (mipmaps.length > 0) levels++;
                  var dimensions = getDimensions(cubeImage[0]);
                  state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height);
                }
                for (var _i54 = 0; _i54 < 6; _i54++) {
                  if (isDataTexture) {
                    if (useTexStorage) {
                      if (dataReady) {
                        state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i54, 0, 0, 0, cubeImage[_i54].width, cubeImage[_i54].height, glFormat, glType, cubeImage[_i54].data);
                      }
                    } else {
                      state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i54, 0, glInternalFormat, cubeImage[_i54].width, cubeImage[_i54].height, 0, glFormat, glType, cubeImage[_i54].data);
                    }
                    for (var _j3 = 0; _j3 < mipmaps.length; _j3++) {
                      var _mipmap = mipmaps[_j3];
                      var mipmapImage = _mipmap.image[_i54].image;
                      if (useTexStorage) {
                        if (dataReady) {
                          state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i54, _j3 + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                        }
                      } else {
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i54, _j3 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                      }
                    }
                  } else {
                    if (useTexStorage) {
                      if (dataReady) {
                        state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i54, 0, 0, 0, glFormat, glType, cubeImage[_i54]);
                      }
                    } else {
                      state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i54, 0, glInternalFormat, glFormat, glType, cubeImage[_i54]);
                    }
                    for (var _j4 = 0; _j4 < mipmaps.length; _j4++) {
                      var _mipmap2 = mipmaps[_j4];
                      if (useTexStorage) {
                        if (dataReady) {
                          state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i54, _j4 + 1, 0, 0, glFormat, glType, _mipmap2.image[_i54]);
                        }
                      } else {
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i54, _j4 + 1, glInternalFormat, glFormat, glType, _mipmap2.image[_i54]);
                      }
                    }
                  }
                }
              }
              if (textureNeedsGenerateMipmaps(texture)) {
                // We assume images for cube map have the same size.
                generateMipmap(_gl.TEXTURE_CUBE_MAP);
              }
              sourceProperties.__version = source.version;
              if (texture.onUpdate) texture.onUpdate(texture);
            }
            textureProperties.__version = texture.version;
          }

          // Render targets

          // Setup storage for target texture and bind it to correct framebuffer
          function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
            var glFormat = utils.convert(texture.format, texture.colorSpace);
            var glType = utils.convert(texture.type);
            var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
            var renderTargetProperties = properties.get(renderTarget);
            if (!renderTargetProperties.__hasExternalTextures) {
              var width = Math.max(1, renderTarget.width >> level);
              var height = Math.max(1, renderTarget.height >> level);
              if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
                state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
              } else {
                state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
              }
            }
            state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            if (useMultisampledRTT(renderTarget)) {
              multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
            } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
              // see #24753

              _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, level);
            }
            state.bindFramebuffer(_gl.FRAMEBUFFER, null);
          }

          // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
          function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
            if (renderTarget.depthBuffer) {
              // retrieve the depth attachment types
              var depthTexture = renderTarget.depthTexture;
              var depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
              var glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, depthType);
              var glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;

              // set up the attachment
              var samples = getRenderTargetSamples(renderTarget);
              var isUseMultisampledRTT = useMultisampledRTT(renderTarget);
              if (isUseMultisampledRTT) {
                multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
              } else if (isMultisample) {
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
              } else {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
              }
              _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
            } else {
              var textures = renderTarget.textures;
              for (var i = 0; i < textures.length; i++) {
                var texture = textures[i];
                var glFormat = utils.convert(texture.format, texture.colorSpace);
                var glType = utils.convert(texture.type);
                var _glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
                var _samples = getRenderTargetSamples(renderTarget);
                if (isMultisample && useMultisampledRTT(renderTarget) === false) {
                  _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, _samples, _glInternalFormat, renderTarget.width, renderTarget.height);
                } else if (useMultisampledRTT(renderTarget)) {
                  multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, _samples, _glInternalFormat, renderTarget.width, renderTarget.height);
                } else {
                  _gl.renderbufferStorage(_gl.RENDERBUFFER, _glInternalFormat, renderTarget.width, renderTarget.height);
                }
              }
            }
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
          }

          // Setup resources for a Depth Texture for a FBO (needs an extension)
          function setupDepthTexture(framebuffer, renderTarget) {
            var isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
            if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
            state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
              throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
            }

            // upload an empty depth texture with framebuffer size
            if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
              renderTarget.depthTexture.image.width = renderTarget.width;
              renderTarget.depthTexture.image.height = renderTarget.height;
              renderTarget.depthTexture.needsUpdate = true;
            }
            setTexture2D(renderTarget.depthTexture, 0);
            var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
            var samples = getRenderTargetSamples(renderTarget);
            if (renderTarget.depthTexture.format === DepthFormat) {
              if (useMultisampledRTT(renderTarget)) {
                multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
              } else {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
              }
            } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
              if (useMultisampledRTT(renderTarget)) {
                multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
              } else {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
              }
            } else {
              throw new Error('Unknown depthTexture format');
            }
          }

          // Setup GL resources for a non-texture depth buffer
          function setupDepthRenderbuffer(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var isCube = renderTarget.isWebGLCubeRenderTarget === true;
            if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
              if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
              setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
            } else {
              if (isCube) {
                renderTargetProperties.__webglDepthbuffer = [];
                for (var i = 0; i < 6; i++) {
                  state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                  renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                  setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
                }
              } else {
                state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
              }
            }
            state.bindFramebuffer(_gl.FRAMEBUFFER, null);
          }

          // rebind framebuffer with external textures
          function rebindTextures(renderTarget, colorTexture, depthTexture) {
            var renderTargetProperties = properties.get(renderTarget);
            if (colorTexture !== undefined) {
              setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
            }
            if (depthTexture !== undefined) {
              setupDepthRenderbuffer(renderTarget);
            }
          }

          // Set up GL resources for the render target
          function setupRenderTarget(renderTarget) {
            var texture = renderTarget.texture;
            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(texture);
            renderTarget.addEventListener('dispose', onRenderTargetDispose);
            var textures = renderTarget.textures;
            var isCube = renderTarget.isWebGLCubeRenderTarget === true;
            var isMultipleRenderTargets = textures.length > 1;
            if (!isMultipleRenderTargets) {
              if (textureProperties.__webglTexture === undefined) {
                textureProperties.__webglTexture = _gl.createTexture();
              }
              textureProperties.__version = texture.version;
              info.memory.textures++;
            }

            // Setup framebuffer

            if (isCube) {
              renderTargetProperties.__webglFramebuffer = [];
              for (var i = 0; i < 6; i++) {
                if (texture.mipmaps && texture.mipmaps.length > 0) {
                  renderTargetProperties.__webglFramebuffer[i] = [];
                  for (var level = 0; level < texture.mipmaps.length; level++) {
                    renderTargetProperties.__webglFramebuffer[i][level] = _gl.createFramebuffer();
                  }
                } else {
                  renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
                }
              }
            } else {
              if (texture.mipmaps && texture.mipmaps.length > 0) {
                renderTargetProperties.__webglFramebuffer = [];
                for (var _level2 = 0; _level2 < texture.mipmaps.length; _level2++) {
                  renderTargetProperties.__webglFramebuffer[_level2] = _gl.createFramebuffer();
                }
              } else {
                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
              }
              if (isMultipleRenderTargets) {
                for (var _i55 = 0, il = textures.length; _i55 < il; _i55++) {
                  var attachmentProperties = properties.get(textures[_i55]);
                  if (attachmentProperties.__webglTexture === undefined) {
                    attachmentProperties.__webglTexture = _gl.createTexture();
                    info.memory.textures++;
                  }
                }
              }
              if (renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
                renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                renderTargetProperties.__webglColorRenderbuffer = [];
                state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                for (var _i56 = 0; _i56 < textures.length; _i56++) {
                  var _texture = textures[_i56];
                  renderTargetProperties.__webglColorRenderbuffer[_i56] = _gl.createRenderbuffer();
                  _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[_i56]);
                  var glFormat = utils.convert(_texture.format, _texture.colorSpace);
                  var glType = utils.convert(_texture.type);
                  var glInternalFormat = getInternalFormat(_texture.internalFormat, glFormat, glType, _texture.colorSpace, renderTarget.isXRRenderTarget === true);
                  var samples = getRenderTargetSamples(renderTarget);
                  _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                  _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + _i56, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[_i56]);
                }
                _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
                if (renderTarget.depthBuffer) {
                  renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                  setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                }
                state.bindFramebuffer(_gl.FRAMEBUFFER, null);
              }
            }

            // Setup color buffer

            if (isCube) {
              state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
              setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
              for (var _i57 = 0; _i57 < 6; _i57++) {
                if (texture.mipmaps && texture.mipmaps.length > 0) {
                  for (var _level3 = 0; _level3 < texture.mipmaps.length; _level3++) {
                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_i57][_level3], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i57, _level3);
                  }
                } else {
                  setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_i57], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i57, 0);
                }
              }
              if (textureNeedsGenerateMipmaps(texture)) {
                generateMipmap(_gl.TEXTURE_CUBE_MAP);
              }
              state.unbindTexture();
            } else if (isMultipleRenderTargets) {
              for (var _i58 = 0, _il12 = textures.length; _i58 < _il12; _i58++) {
                var attachment = textures[_i58];
                var _attachmentProperties = properties.get(attachment);
                state.bindTexture(_gl.TEXTURE_2D, _attachmentProperties.__webglTexture);
                setTextureParameters(_gl.TEXTURE_2D, attachment);
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + _i58, _gl.TEXTURE_2D, 0);
                if (textureNeedsGenerateMipmaps(attachment)) {
                  generateMipmap(_gl.TEXTURE_2D);
                }
              }
              state.unbindTexture();
            } else {
              var glTextureType = _gl.TEXTURE_2D;
              if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
                glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
              }
              state.bindTexture(glTextureType, textureProperties.__webglTexture);
              setTextureParameters(glTextureType, texture);
              if (texture.mipmaps && texture.mipmaps.length > 0) {
                for (var _level4 = 0; _level4 < texture.mipmaps.length; _level4++) {
                  setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_level4], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, _level4);
                }
              } else {
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
              }
              if (textureNeedsGenerateMipmaps(texture)) {
                generateMipmap(glTextureType);
              }
              state.unbindTexture();
            }

            // Setup depth and stencil buffers

            if (renderTarget.depthBuffer) {
              setupDepthRenderbuffer(renderTarget);
            }
          }
          function updateRenderTargetMipmap(renderTarget) {
            var textures = renderTarget.textures;
            for (var i = 0, il = textures.length; i < il; i++) {
              var texture = textures[i];
              if (textureNeedsGenerateMipmaps(texture)) {
                var _target2 = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
                var webglTexture = properties.get(texture).__webglTexture;
                state.bindTexture(_target2, webglTexture);
                generateMipmap(_target2);
                state.unbindTexture();
              }
            }
          }
          var invalidationArrayRead = [];
          var invalidationArrayDraw = [];
          function updateMultisampleRenderTarget(renderTarget) {
            if (renderTarget.samples > 0) {
              if (useMultisampledRTT(renderTarget) === false) {
                var textures = renderTarget.textures;
                var width = renderTarget.width;
                var height = renderTarget.height;
                var mask = _gl.COLOR_BUFFER_BIT;
                var depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
                var renderTargetProperties = properties.get(renderTarget);
                var isMultipleRenderTargets = textures.length > 1;

                // If MRT we need to remove FBO attachments
                if (isMultipleRenderTargets) {
                  for (var i = 0; i < textures.length; i++) {
                    state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);
                    state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                    _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
                  }
                }
                state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                for (var _i59 = 0; _i59 < textures.length; _i59++) {
                  if (renderTarget.resolveDepthBuffer) {
                    if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;

                    // resolving stencil is slow with a D3D backend. disable it for all transmission render targets (see #27799)

                    if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
                  }
                  if (isMultipleRenderTargets) {
                    _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[_i59]);
                    var webglTexture = properties.get(textures[_i59]).__webglTexture;
                    _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
                  }
                  _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
                  if (supportsInvalidateFramebuffer === true) {
                    invalidationArrayRead.length = 0;
                    invalidationArrayDraw.length = 0;
                    invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + _i59);
                    if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false) {
                      invalidationArrayRead.push(depthStyle);
                      invalidationArrayDraw.push(depthStyle);
                      _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw);
                    }
                    _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead);
                  }
                }
                state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
                state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);

                // If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
                if (isMultipleRenderTargets) {
                  for (var _i60 = 0; _i60 < textures.length; _i60++) {
                    state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + _i60, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[_i60]);
                    var _webglTexture = properties.get(textures[_i60]).__webglTexture;
                    state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                    _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + _i60, _gl.TEXTURE_2D, _webglTexture, 0);
                  }
                }
                state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
              } else {
                if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer) {
                  var _depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
                  _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [_depthStyle]);
                }
              }
            }
          }
          function getRenderTargetSamples(renderTarget) {
            return Math.min(capabilities.maxSamples, renderTarget.samples);
          }
          function useMultisampledRTT(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            return renderTarget.samples > 0 && extensions.has('WEBGL_multisampled_render_to_texture') === true && renderTargetProperties.__useRenderToTexture !== false;
          }
          function updateVideoTexture(texture) {
            var frame = info.render.frame;

            // Check the last frame we updated the VideoTexture

            if (_videoTextures.get(texture) !== frame) {
              _videoTextures.set(texture, frame);
              texture.update();
            }
          }
          function verifyColorSpace(texture, image) {
            var colorSpace = texture.colorSpace;
            var format = texture.format;
            var type = texture.type;
            if (texture.isCompressedTexture === true || texture.isVideoTexture === true) return image;
            if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
              // sRGB

              if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
                // in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

                if (format !== RGBAFormat || type !== UnsignedByteType) {
                  console.warn('THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.');
                }
              } else {
                console.error('THREE.WebGLTextures: Unsupported texture color space:', colorSpace);
              }
            }
            return image;
          }
          function getDimensions(image) {
            if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) {
              // if intrinsic data are not available, fallback to width/height

              _imageDimensions.width = image.naturalWidth || image.width;
              _imageDimensions.height = image.naturalHeight || image.height;
            } else if (typeof VideoFrame !== 'undefined' && image instanceof VideoFrame) {
              _imageDimensions.width = image.displayWidth;
              _imageDimensions.height = image.displayHeight;
            } else {
              _imageDimensions.width = image.width;
              _imageDimensions.height = image.height;
            }
            return _imageDimensions;
          }

          //

          this.allocateTextureUnit = allocateTextureUnit;
          this.resetTextureUnits = resetTextureUnits;
          this.setTexture2D = setTexture2D;
          this.setTexture2DArray = setTexture2DArray;
          this.setTexture3D = setTexture3D;
          this.setTextureCube = setTextureCube;
          this.rebindTextures = rebindTextures;
          this.setupRenderTarget = setupRenderTarget;
          this.updateRenderTargetMipmap = updateRenderTargetMipmap;
          this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
          this.setupDepthRenderbuffer = setupDepthRenderbuffer;
          this.setupFrameBufferTexture = setupFrameBufferTexture;
          this.useMultisampledRTT = useMultisampledRTT;
        }
        function WebGLUtils(gl, extensions) {
          function convert(p) {
            var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NoColorSpace;
            var extension;
            var transfer = ColorManagement.getTransfer(colorSpace);
            if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
            if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
            if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
            if (p === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
            if (p === ByteType) return gl.BYTE;
            if (p === ShortType) return gl.SHORT;
            if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
            if (p === IntType) return gl.INT;
            if (p === UnsignedIntType) return gl.UNSIGNED_INT;
            if (p === FloatType) return gl.FLOAT;
            if (p === HalfFloatType) return gl.HALF_FLOAT;
            if (p === AlphaFormat) return gl.ALPHA;
            if (p === RGBFormat) return gl.RGB;
            if (p === RGBAFormat) return gl.RGBA;
            if (p === LuminanceFormat) return gl.LUMINANCE;
            if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
            if (p === DepthFormat) return gl.DEPTH_COMPONENT;
            if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;

            // WebGL2 formats.

            if (p === RedFormat) return gl.RED;
            if (p === RedIntegerFormat) return gl.RED_INTEGER;
            if (p === RGFormat) return gl.RG;
            if (p === RGIntegerFormat) return gl.RG_INTEGER;
            if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;

            // S3TC

            if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
              if (transfer === SRGBTransfer) {
                extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb');
                if (extension !== null) {
                  if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                  if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                  if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                  if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                } else {
                  return null;
                }
              } else {
                extension = extensions.get('WEBGL_compressed_texture_s3tc');
                if (extension !== null) {
                  if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                  if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                  if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                  if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                } else {
                  return null;
                }
              }
            }

            // PVRTC

            if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
              extension = extensions.get('WEBGL_compressed_texture_pvrtc');
              if (extension !== null) {
                if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
              } else {
                return null;
              }
            }

            // ETC

            if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
              extension = extensions.get('WEBGL_compressed_texture_etc');
              if (extension !== null) {
                if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
                if (p === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
              } else {
                return null;
              }
            }

            // ASTC

            if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
              extension = extensions.get('WEBGL_compressed_texture_astc');
              if (extension !== null) {
                if (p === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (p === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (p === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (p === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (p === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (p === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (p === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (p === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (p === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (p === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (p === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (p === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (p === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (p === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
              } else {
                return null;
              }
            }

            // BPTC

            if (p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format) {
              extension = extensions.get('EXT_texture_compression_bptc');
              if (extension !== null) {
                if (p === RGBA_BPTC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (p === RGB_BPTC_SIGNED_Format) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (p === RGB_BPTC_UNSIGNED_Format) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
              } else {
                return null;
              }
            }

            // RGTC

            if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
              extension = extensions.get('EXT_texture_compression_rgtc');
              if (extension !== null) {
                if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
                if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
              } else {
                return null;
              }
            }

            //

            if (p === UnsignedInt248Type) return gl.UNSIGNED_INT_24_8;

            // if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

            return gl[p] !== undefined ? gl[p] : null;
          }
          return {
            convert: convert
          };
        }
        var ArrayCamera = /*#__PURE__*/function (_PerspectiveCamera) {
          function ArrayCamera() {
            var _this40;
            var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            _classCallCheck2(this, ArrayCamera);
            _this40 = _callSuper(this, ArrayCamera);
            _this40.isArrayCamera = true;
            _this40.cameras = array;
            return _this40;
          }
          _inherits(ArrayCamera, _PerspectiveCamera);
          return _createClass(ArrayCamera);
        }(PerspectiveCamera);
        var Group = /*#__PURE__*/function (_Object3D4) {
          function Group() {
            var _this41;
            _classCallCheck2(this, Group);
            _this41 = _callSuper(this, Group);
            _this41.isGroup = true;
            _this41.type = 'Group';
            return _this41;
          }
          _inherits(Group, _Object3D4);
          return _createClass(Group);
        }(Object3D);
        var _moveEvent = {
          type: 'move'
        };
        var WebXRController = /*#__PURE__*/function () {
          function WebXRController() {
            _classCallCheck2(this, WebXRController);
            this._targetRay = null;
            this._grip = null;
            this._hand = null;
          }
          return _createClass(WebXRController, [{
            key: "getHandSpace",
            value: function getHandSpace() {
              if (this._hand === null) {
                this._hand = new Group();
                this._hand.matrixAutoUpdate = false;
                this._hand.visible = false;
                this._hand.joints = {};
                this._hand.inputState = {
                  pinching: false
                };
              }
              return this._hand;
            }
          }, {
            key: "getTargetRaySpace",
            value: function getTargetRaySpace() {
              if (this._targetRay === null) {
                this._targetRay = new Group();
                this._targetRay.matrixAutoUpdate = false;
                this._targetRay.visible = false;
                this._targetRay.hasLinearVelocity = false;
                this._targetRay.linearVelocity = new Vector3();
                this._targetRay.hasAngularVelocity = false;
                this._targetRay.angularVelocity = new Vector3();
              }
              return this._targetRay;
            }
          }, {
            key: "getGripSpace",
            value: function getGripSpace() {
              if (this._grip === null) {
                this._grip = new Group();
                this._grip.matrixAutoUpdate = false;
                this._grip.visible = false;
                this._grip.hasLinearVelocity = false;
                this._grip.linearVelocity = new Vector3();
                this._grip.hasAngularVelocity = false;
                this._grip.angularVelocity = new Vector3();
              }
              return this._grip;
            }
          }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {
              if (this._targetRay !== null) {
                this._targetRay.dispatchEvent(event);
              }
              if (this._grip !== null) {
                this._grip.dispatchEvent(event);
              }
              if (this._hand !== null) {
                this._hand.dispatchEvent(event);
              }
              return this;
            }
          }, {
            key: "connect",
            value: function connect(inputSource) {
              if (inputSource && inputSource.hand) {
                var hand = this._hand;
                if (hand) {
                  var _iterator25 = _createForOfIteratorHelper(inputSource.hand.values()),
                    _step25;
                  try {
                    for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
                      var inputjoint = _step25.value;
                      // Initialize hand with joints when connected
                      this._getHandJoint(hand, inputjoint);
                    }
                  } catch (err) {
                    _iterator25.e(err);
                  } finally {
                    _iterator25.f();
                  }
                }
              }
              this.dispatchEvent({
                type: 'connected',
                data: inputSource
              });
              return this;
            }
          }, {
            key: "disconnect",
            value: function disconnect(inputSource) {
              this.dispatchEvent({
                type: 'disconnected',
                data: inputSource
              });
              if (this._targetRay !== null) {
                this._targetRay.visible = false;
              }
              if (this._grip !== null) {
                this._grip.visible = false;
              }
              if (this._hand !== null) {
                this._hand.visible = false;
              }
              return this;
            }
          }, {
            key: "update",
            value: function update(inputSource, frame, referenceSpace) {
              var inputPose = null;
              var gripPose = null;
              var handPose = null;
              var targetRay = this._targetRay;
              var grip = this._grip;
              var hand = this._hand;
              if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
                if (hand && inputSource.hand) {
                  handPose = true;
                  var _iterator26 = _createForOfIteratorHelper(inputSource.hand.values()),
                    _step26;
                  try {
                    for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
                      var inputjoint = _step26.value;
                      // Update the joints groups with the XRJoint poses
                      var jointPose = frame.getJointPose(inputjoint, referenceSpace);

                      // The transform of this joint will be updated with the joint pose on each frame
                      var joint = this._getHandJoint(hand, inputjoint);
                      if (jointPose !== null) {
                        joint.matrix.fromArray(jointPose.transform.matrix);
                        joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                        joint.matrixWorldNeedsUpdate = true;
                        joint.jointRadius = jointPose.radius;
                      }
                      joint.visible = jointPose !== null;
                    }

                    // Custom events

                    // Check pinchz
                  } catch (err) {
                    _iterator26.e(err);
                  } finally {
                    _iterator26.f();
                  }
                  var indexTip = hand.joints['index-finger-tip'];
                  var thumbTip = hand.joints['thumb-tip'];
                  var distance = indexTip.position.distanceTo(thumbTip.position);
                  var distanceToPinch = 0.02;
                  var threshold = 0.005;
                  if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                    hand.inputState.pinching = false;
                    this.dispatchEvent({
                      type: 'pinchend',
                      handedness: inputSource.handedness,
                      target: this
                    });
                  } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                    hand.inputState.pinching = true;
                    this.dispatchEvent({
                      type: 'pinchstart',
                      handedness: inputSource.handedness,
                      target: this
                    });
                  }
                } else {
                  if (grip !== null && inputSource.gripSpace) {
                    gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                    if (gripPose !== null) {
                      grip.matrix.fromArray(gripPose.transform.matrix);
                      grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                      grip.matrixWorldNeedsUpdate = true;
                      if (gripPose.linearVelocity) {
                        grip.hasLinearVelocity = true;
                        grip.linearVelocity.copy(gripPose.linearVelocity);
                      } else {
                        grip.hasLinearVelocity = false;
                      }
                      if (gripPose.angularVelocity) {
                        grip.hasAngularVelocity = true;
                        grip.angularVelocity.copy(gripPose.angularVelocity);
                      } else {
                        grip.hasAngularVelocity = false;
                      }
                    }
                  }
                }
                if (targetRay !== null) {
                  inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

                  // Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
                  if (inputPose === null && gripPose !== null) {
                    inputPose = gripPose;
                  }
                  if (inputPose !== null) {
                    targetRay.matrix.fromArray(inputPose.transform.matrix);
                    targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                    targetRay.matrixWorldNeedsUpdate = true;
                    if (inputPose.linearVelocity) {
                      targetRay.hasLinearVelocity = true;
                      targetRay.linearVelocity.copy(inputPose.linearVelocity);
                    } else {
                      targetRay.hasLinearVelocity = false;
                    }
                    if (inputPose.angularVelocity) {
                      targetRay.hasAngularVelocity = true;
                      targetRay.angularVelocity.copy(inputPose.angularVelocity);
                    } else {
                      targetRay.hasAngularVelocity = false;
                    }
                    this.dispatchEvent(_moveEvent);
                  }
                }
              }
              if (targetRay !== null) {
                targetRay.visible = inputPose !== null;
              }
              if (grip !== null) {
                grip.visible = gripPose !== null;
              }
              if (hand !== null) {
                hand.visible = handPose !== null;
              }
              return this;
            }

            // private method
          }, {
            key: "_getHandJoint",
            value: function _getHandJoint(hand, inputjoint) {
              if (hand.joints[inputjoint.jointName] === undefined) {
                var joint = new Group();
                joint.matrixAutoUpdate = false;
                joint.visible = false;
                hand.joints[inputjoint.jointName] = joint;
                hand.add(joint);
              }
              return hand.joints[inputjoint.jointName];
            }
          }]);
        }();
        var _occlusion_vertex = "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}";
        var _occlusion_fragment = "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}";
        var WebXRDepthSensing = /*#__PURE__*/function () {
          function WebXRDepthSensing() {
            _classCallCheck2(this, WebXRDepthSensing);
            this.texture = null;
            this.mesh = null;
            this.depthNear = 0;
            this.depthFar = 0;
          }
          return _createClass(WebXRDepthSensing, [{
            key: "init",
            value: function init(renderer, depthData, renderState) {
              if (this.texture === null) {
                var texture = new Texture();
                var texProps = renderer.properties.get(texture);
                texProps.__webglTexture = depthData.texture;
                if (depthData.depthNear != renderState.depthNear || depthData.depthFar != renderState.depthFar) {
                  this.depthNear = depthData.depthNear;
                  this.depthFar = depthData.depthFar;
                }
                this.texture = texture;
              }
            }
          }, {
            key: "getMesh",
            value: function getMesh(cameraXR) {
              if (this.texture !== null) {
                if (this.mesh === null) {
                  var viewport = cameraXR.cameras[0].viewport;
                  var material = new ShaderMaterial({
                    vertexShader: _occlusion_vertex,
                    fragmentShader: _occlusion_fragment,
                    uniforms: {
                      depthColor: {
                        value: this.texture
                      },
                      depthWidth: {
                        value: viewport.z
                      },
                      depthHeight: {
                        value: viewport.w
                      }
                    }
                  });
                  this.mesh = new Mesh(new PlaneGeometry(20, 20), material);
                }
              }
              return this.mesh;
            }
          }, {
            key: "reset",
            value: function reset() {
              this.texture = null;
              this.mesh = null;
            }
          }, {
            key: "getDepthTexture",
            value: function getDepthTexture() {
              return this.texture;
            }
          }]);
        }();
        var WebXRManager = /*#__PURE__*/function (_EventDispatcher6) {
          function WebXRManager(renderer, gl) {
            var _this42;
            _classCallCheck2(this, WebXRManager);
            _this42 = _callSuper(this, WebXRManager);
            var scope = _this42;
            var session = null;
            var framebufferScaleFactor = 1.0;
            var referenceSpace = null;
            var referenceSpaceType = 'local-floor';
            // Set default foveation to maximum.
            var foveation = 1.0;
            var customReferenceSpace = null;
            var pose = null;
            var glBinding = null;
            var glProjLayer = null;
            var glBaseLayer = null;
            var xrFrame = null;
            var depthSensing = new WebXRDepthSensing();
            var attributes = gl.getContextAttributes();
            var initialRenderTarget = null;
            var newRenderTarget = null;
            var controllers = [];
            var controllerInputSources = [];
            var currentSize = new Vector2();
            var currentPixelRatio = null;

            //

            var cameraL = new PerspectiveCamera();
            cameraL.layers.enable(1);
            cameraL.viewport = new Vector4();
            var cameraR = new PerspectiveCamera();
            cameraR.layers.enable(2);
            cameraR.viewport = new Vector4();
            var cameras = [cameraL, cameraR];
            var cameraXR = new ArrayCamera();
            cameraXR.layers.enable(1);
            cameraXR.layers.enable(2);
            var _currentDepthNear = null;
            var _currentDepthFar = null;

            //

            _this42.cameraAutoUpdate = true;
            _this42.enabled = false;
            _this42.isPresenting = false;
            _this42.getController = function (index) {
              var controller = controllers[index];
              if (controller === undefined) {
                controller = new WebXRController();
                controllers[index] = controller;
              }
              return controller.getTargetRaySpace();
            };
            _this42.getControllerGrip = function (index) {
              var controller = controllers[index];
              if (controller === undefined) {
                controller = new WebXRController();
                controllers[index] = controller;
              }
              return controller.getGripSpace();
            };
            _this42.getHand = function (index) {
              var controller = controllers[index];
              if (controller === undefined) {
                controller = new WebXRController();
                controllers[index] = controller;
              }
              return controller.getHandSpace();
            };

            //

            function onSessionEvent(event) {
              var controllerIndex = controllerInputSources.indexOf(event.inputSource);
              if (controllerIndex === -1) {
                return;
              }
              var controller = controllers[controllerIndex];
              if (controller !== undefined) {
                controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
                controller.dispatchEvent({
                  type: event.type,
                  data: event.inputSource
                });
              }
            }
            function onSessionEnd() {
              session.removeEventListener('select', onSessionEvent);
              session.removeEventListener('selectstart', onSessionEvent);
              session.removeEventListener('selectend', onSessionEvent);
              session.removeEventListener('squeeze', onSessionEvent);
              session.removeEventListener('squeezestart', onSessionEvent);
              session.removeEventListener('squeezeend', onSessionEvent);
              session.removeEventListener('end', onSessionEnd);
              session.removeEventListener('inputsourceschange', onInputSourcesChange);
              for (var i = 0; i < controllers.length; i++) {
                var inputSource = controllerInputSources[i];
                if (inputSource === null) continue;
                controllerInputSources[i] = null;
                controllers[i].disconnect(inputSource);
              }
              _currentDepthNear = null;
              _currentDepthFar = null;
              depthSensing.reset();

              // restore framebuffer/rendering state

              renderer.setRenderTarget(initialRenderTarget);
              glBaseLayer = null;
              glProjLayer = null;
              glBinding = null;
              session = null;
              newRenderTarget = null;

              //

              animation.stop();
              scope.isPresenting = false;
              renderer.setPixelRatio(currentPixelRatio);
              renderer.setSize(currentSize.width, currentSize.height, false);
              scope.dispatchEvent({
                type: 'sessionend'
              });
            }
            _this42.setFramebufferScaleFactor = function (value) {
              framebufferScaleFactor = value;
              if (scope.isPresenting === true) {
                console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
              }
            };
            _this42.setReferenceSpaceType = function (value) {
              referenceSpaceType = value;
              if (scope.isPresenting === true) {
                console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
              }
            };
            _this42.getReferenceSpace = function () {
              return customReferenceSpace || referenceSpace;
            };
            _this42.setReferenceSpace = function (space) {
              customReferenceSpace = space;
            };
            _this42.getBaseLayer = function () {
              return glProjLayer !== null ? glProjLayer : glBaseLayer;
            };
            _this42.getBinding = function () {
              return glBinding;
            };
            _this42.getFrame = function () {
              return xrFrame;
            };
            _this42.getSession = function () {
              return session;
            };
            _this42.setSession = /*#__PURE__*/function () {
              var _ref68 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(value) {
                var layerInit, depthFormat, depthType, glDepthFormat, projectionlayerInit;
                return _regeneratorRuntime().wrap(function _callee6$(_context14) {
                  while (1) switch (_context14.prev = _context14.next) {
                    case 0:
                      session = value;
                      if (!(session !== null)) {
                        _context14.next = 27;
                        break;
                      }
                      initialRenderTarget = renderer.getRenderTarget();
                      session.addEventListener('select', onSessionEvent);
                      session.addEventListener('selectstart', onSessionEvent);
                      session.addEventListener('selectend', onSessionEvent);
                      session.addEventListener('squeeze', onSessionEvent);
                      session.addEventListener('squeezestart', onSessionEvent);
                      session.addEventListener('squeezeend', onSessionEvent);
                      session.addEventListener('end', onSessionEnd);
                      session.addEventListener('inputsourceschange', onInputSourcesChange);
                      if (!(attributes.xrCompatible !== true)) {
                        _context14.next = 14;
                        break;
                      }
                      _context14.next = 14;
                      return gl.makeXRCompatible();
                    case 14:
                      currentPixelRatio = renderer.getPixelRatio();
                      renderer.getSize(currentSize);
                      if (session.renderState.layers === undefined) {
                        layerInit = {
                          antialias: attributes.antialias,
                          alpha: true,
                          depth: attributes.depth,
                          stencil: attributes.stencil,
                          framebufferScaleFactor: framebufferScaleFactor
                        };
                        glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                        session.updateRenderState({
                          baseLayer: glBaseLayer
                        });
                        renderer.setPixelRatio(1);
                        renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false);
                        newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
                          format: RGBAFormat,
                          type: UnsignedByteType,
                          colorSpace: renderer.outputColorSpace,
                          stencilBuffer: attributes.stencil
                        });
                      } else {
                        depthFormat = null;
                        depthType = null;
                        glDepthFormat = null;
                        if (attributes.depth) {
                          glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
                          depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                          depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
                        }
                        projectionlayerInit = {
                          colorFormat: gl.RGBA8,
                          depthFormat: glDepthFormat,
                          scaleFactor: framebufferScaleFactor
                        };
                        glBinding = new XRWebGLBinding(session, gl);
                        glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                        session.updateRenderState({
                          layers: [glProjLayer]
                        });
                        renderer.setPixelRatio(1);
                        renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, false);
                        newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                          format: RGBAFormat,
                          type: UnsignedByteType,
                          depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),
                          stencilBuffer: attributes.stencil,
                          colorSpace: renderer.outputColorSpace,
                          samples: attributes.antialias ? 4 : 0,
                          resolveDepthBuffer: glProjLayer.ignoreDepthValues === false
                        });
                      }
                      newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

                      this.setFoveation(foveation);
                      customReferenceSpace = null;
                      _context14.next = 22;
                      return session.requestReferenceSpace(referenceSpaceType);
                    case 22:
                      referenceSpace = _context14.sent;
                      animation.setContext(session);
                      animation.start();
                      scope.isPresenting = true;
                      scope.dispatchEvent({
                        type: 'sessionstart'
                      });
                    case 27:
                    case "end":
                      return _context14.stop();
                  }
                }, _callee6, this);
              }));
              return function (_x4) {
                return _ref68.apply(this, arguments);
              };
            }();
            _this42.getEnvironmentBlendMode = function () {
              if (session !== null) {
                return session.environmentBlendMode;
              }
            };
            _this42.getDepthTexture = function () {
              return depthSensing.getDepthTexture();
            };
            function onInputSourcesChange(event) {
              // Notify disconnected

              for (var i = 0; i < event.removed.length; i++) {
                var inputSource = event.removed[i];
                var _index7 = controllerInputSources.indexOf(inputSource);
                if (_index7 >= 0) {
                  controllerInputSources[_index7] = null;
                  controllers[_index7].disconnect(inputSource);
                }
              }

              // Notify connected

              for (var _i61 = 0; _i61 < event.added.length; _i61++) {
                var _inputSource = event.added[_i61];
                var controllerIndex = controllerInputSources.indexOf(_inputSource);
                if (controllerIndex === -1) {
                  // Assign input source a controller that currently has no input source

                  for (var _i62 = 0; _i62 < controllers.length; _i62++) {
                    if (_i62 >= controllerInputSources.length) {
                      controllerInputSources.push(_inputSource);
                      controllerIndex = _i62;
                      break;
                    } else if (controllerInputSources[_i62] === null) {
                      controllerInputSources[_i62] = _inputSource;
                      controllerIndex = _i62;
                      break;
                    }
                  }

                  // If all controllers do currently receive input we ignore new ones

                  if (controllerIndex === -1) break;
                }
                var controller = controllers[controllerIndex];
                if (controller) {
                  controller.connect(_inputSource);
                }
              }
            }

            //

            var cameraLPos = new Vector3();
            var cameraRPos = new Vector3();

            /**
             * Assumes 2 cameras that are parallel and share an X-axis, and that
             * the cameras' projection and world matrices have already been set.
             * And that near and far planes are identical for both cameras.
             * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
             */
            function setProjectionFromUnion(camera, cameraL, cameraR) {
              cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
              cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
              var ipd = cameraLPos.distanceTo(cameraRPos);
              var projL = cameraL.projectionMatrix.elements;
              var projR = cameraR.projectionMatrix.elements;

              // VR systems will have identical far and near planes, and
              // most likely identical top and bottom frustum extents.
              // Use the left camera for these values.
              var near = projL[14] / (projL[10] - 1);
              var far = projL[14] / (projL[10] + 1);
              var topFov = (projL[9] + 1) / projL[5];
              var bottomFov = (projL[9] - 1) / projL[5];
              var leftFov = (projL[8] - 1) / projL[0];
              var rightFov = (projR[8] + 1) / projR[0];
              var left = near * leftFov;
              var right = near * rightFov;

              // Calculate the new camera's position offset from the
              // left camera. xOffset should be roughly half `ipd`.
              var zOffset = ipd / (-leftFov + rightFov);
              var xOffset = zOffset * -leftFov;

              // TODO: Better way to apply this offset?
              cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
              camera.translateX(xOffset);
              camera.translateZ(zOffset);
              camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
              camera.matrixWorldInverse.copy(camera.matrixWorld).invert();

              // Find the union of the frustum values of the cameras and scale
              // the values so that the near plane's position does not change in world space,
              // although must now be relative to the new union camera.
              var near2 = near + zOffset;
              var far2 = far + zOffset;
              var left2 = left - xOffset;
              var right2 = right + (ipd - xOffset);
              var top2 = topFov * far / far2 * near2;
              var bottom2 = bottomFov * far / far2 * near2;
              camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
              camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
            }
            function updateCamera(camera, parent) {
              if (parent === null) {
                camera.matrixWorld.copy(camera.matrix);
              } else {
                camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
              }
              camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            }
            _this42.updateCamera = function (camera) {
              if (session === null) return;
              if (depthSensing.texture !== null) {
                camera.near = depthSensing.depthNear;
                camera.far = depthSensing.depthFar;
              }
              cameraXR.near = cameraR.near = cameraL.near = camera.near;
              cameraXR.far = cameraR.far = cameraL.far = camera.far;
              if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
                // Note that the new renderState won't apply until the next frame. See #18320

                session.updateRenderState({
                  depthNear: cameraXR.near,
                  depthFar: cameraXR.far
                });
                _currentDepthNear = cameraXR.near;
                _currentDepthFar = cameraXR.far;
                cameraL.near = _currentDepthNear;
                cameraL.far = _currentDepthFar;
                cameraR.near = _currentDepthNear;
                cameraR.far = _currentDepthFar;
                cameraL.updateProjectionMatrix();
                cameraR.updateProjectionMatrix();
                camera.updateProjectionMatrix();
              }
              var parent = camera.parent;
              var cameras = cameraXR.cameras;
              updateCamera(cameraXR, parent);
              for (var i = 0; i < cameras.length; i++) {
                updateCamera(cameras[i], parent);
              }

              // update projection matrix for proper view frustum culling

              if (cameras.length === 2) {
                setProjectionFromUnion(cameraXR, cameraL, cameraR);
              } else {
                // assume single camera setup (AR)

                cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
              }

              // update user camera and its children

              updateUserCamera(camera, cameraXR, parent);
            };
            function updateUserCamera(camera, cameraXR, parent) {
              if (parent === null) {
                camera.matrix.copy(cameraXR.matrixWorld);
              } else {
                camera.matrix.copy(parent.matrixWorld);
                camera.matrix.invert();
                camera.matrix.multiply(cameraXR.matrixWorld);
              }
              camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
              camera.updateMatrixWorld(true);
              camera.projectionMatrix.copy(cameraXR.projectionMatrix);
              camera.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse);
              if (camera.isPerspectiveCamera) {
                camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
                camera.zoom = 1;
              }
            }
            _this42.getCamera = function () {
              return cameraXR;
            };
            _this42.getFoveation = function () {
              if (glProjLayer === null && glBaseLayer === null) {
                return undefined;
              }
              return foveation;
            };
            _this42.setFoveation = function (value) {
              // 0 = no foveation = full resolution
              // 1 = maximum foveation = the edges render at lower resolution

              foveation = value;
              if (glProjLayer !== null) {
                glProjLayer.fixedFoveation = value;
              }
              if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
                glBaseLayer.fixedFoveation = value;
              }
            };
            _this42.hasDepthSensing = function () {
              return depthSensing.texture !== null;
            };
            _this42.getDepthSensingMesh = function () {
              return depthSensing.getMesh(cameraXR);
            };

            // Animation Loop

            var onAnimationFrameCallback = null;
            function onAnimationFrame(time, frame) {
              pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
              xrFrame = frame;
              if (pose !== null) {
                var views = pose.views;
                if (glBaseLayer !== null) {
                  renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
                  renderer.setRenderTarget(newRenderTarget);
                }
                var cameraXRNeedsUpdate = false;

                // check if it's necessary to rebuild cameraXR's camera list

                if (views.length !== cameraXR.cameras.length) {
                  cameraXR.cameras.length = 0;
                  cameraXRNeedsUpdate = true;
                }
                for (var i = 0; i < views.length; i++) {
                  var view = views[i];
                  var viewport = null;
                  if (glBaseLayer !== null) {
                    viewport = glBaseLayer.getViewport(view);
                  } else {
                    var glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                    viewport = glSubImage.viewport;

                    // For side-by-side projection, we only produce a single texture for both eyes.
                    if (i === 0) {
                      renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);
                      renderer.setRenderTarget(newRenderTarget);
                    }
                  }
                  var camera = cameras[i];
                  if (camera === undefined) {
                    camera = new PerspectiveCamera();
                    camera.layers.enable(i);
                    camera.viewport = new Vector4();
                    cameras[i] = camera;
                  }
                  camera.matrix.fromArray(view.transform.matrix);
                  camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
                  camera.projectionMatrix.fromArray(view.projectionMatrix);
                  camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
                  camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                  if (i === 0) {
                    cameraXR.matrix.copy(camera.matrix);
                    cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
                  }
                  if (cameraXRNeedsUpdate === true) {
                    cameraXR.cameras.push(camera);
                  }
                }

                //

                var enabledFeatures = session.enabledFeatures;
                if (enabledFeatures && enabledFeatures.includes('depth-sensing')) {
                  var depthData = glBinding.getDepthInformation(views[0]);
                  if (depthData && depthData.isValid && depthData.texture) {
                    depthSensing.init(renderer, depthData, session.renderState);
                  }
                }
              }

              //

              for (var _i63 = 0; _i63 < controllers.length; _i63++) {
                var inputSource = controllerInputSources[_i63];
                var controller = controllers[_i63];
                if (inputSource !== null && controller !== undefined) {
                  controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
                }
              }
              if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
              if (frame.detectedPlanes) {
                scope.dispatchEvent({
                  type: 'planesdetected',
                  data: frame
                });
              }
              xrFrame = null;
            }
            var animation = new WebGLAnimation();
            animation.setAnimationLoop(onAnimationFrame);
            _this42.setAnimationLoop = function (callback) {
              onAnimationFrameCallback = callback;
            };
            _this42.dispose = function () {};
            return _this42;
          }
          _inherits(WebXRManager, _EventDispatcher6);
          return _createClass(WebXRManager);
        }(EventDispatcher);
        var _e1 = /*@__PURE__*/new Euler();
        var _m1 = /*@__PURE__*/new Matrix4();
        function WebGLMaterials(renderer, properties) {
          function refreshTransformUniform(map, uniform) {
            if (map.matrixAutoUpdate === true) {
              map.updateMatrix();
            }
            uniform.value.copy(map.matrix);
          }
          function refreshFogUniforms(uniforms, fog) {
            fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
            if (fog.isFog) {
              uniforms.fogNear.value = fog.near;
              uniforms.fogFar.value = fog.far;
            } else if (fog.isFogExp2) {
              uniforms.fogDensity.value = fog.density;
            }
          }
          function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
            if (material.isMeshBasicMaterial) {
              refreshUniformsCommon(uniforms, material);
            } else if (material.isMeshLambertMaterial) {
              refreshUniformsCommon(uniforms, material);
            } else if (material.isMeshToonMaterial) {
              refreshUniformsCommon(uniforms, material);
              refreshUniformsToon(uniforms, material);
            } else if (material.isMeshPhongMaterial) {
              refreshUniformsCommon(uniforms, material);
              refreshUniformsPhong(uniforms, material);
            } else if (material.isMeshStandardMaterial) {
              refreshUniformsCommon(uniforms, material);
              refreshUniformsStandard(uniforms, material);
              if (material.isMeshPhysicalMaterial) {
                refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
              }
            } else if (material.isMeshMatcapMaterial) {
              refreshUniformsCommon(uniforms, material);
              refreshUniformsMatcap(uniforms, material);
            } else if (material.isMeshDepthMaterial) {
              refreshUniformsCommon(uniforms, material);
            } else if (material.isMeshDistanceMaterial) {
              refreshUniformsCommon(uniforms, material);
              refreshUniformsDistance(uniforms, material);
            } else if (material.isMeshNormalMaterial) {
              refreshUniformsCommon(uniforms, material);
            } else if (material.isLineBasicMaterial) {
              refreshUniformsLine(uniforms, material);
              if (material.isLineDashedMaterial) {
                refreshUniformsDash(uniforms, material);
              }
            } else if (material.isPointsMaterial) {
              refreshUniformsPoints(uniforms, material, pixelRatio, height);
            } else if (material.isSpriteMaterial) {
              refreshUniformsSprites(uniforms, material);
            } else if (material.isShadowMaterial) {
              uniforms.color.value.copy(material.color);
              uniforms.opacity.value = material.opacity;
            } else if (material.isShaderMaterial) {
              material.uniformsNeedUpdate = false; // #15581
            }
          }
          function refreshUniformsCommon(uniforms, material) {
            uniforms.opacity.value = material.opacity;
            if (material.color) {
              uniforms.diffuse.value.copy(material.color);
            }
            if (material.emissive) {
              uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
            }
            if (material.map) {
              uniforms.map.value = material.map;
              refreshTransformUniform(material.map, uniforms.mapTransform);
            }
            if (material.alphaMap) {
              uniforms.alphaMap.value = material.alphaMap;
              refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
            }
            if (material.bumpMap) {
              uniforms.bumpMap.value = material.bumpMap;
              refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
              uniforms.bumpScale.value = material.bumpScale;
              if (material.side === BackSide) {
                uniforms.bumpScale.value *= -1;
              }
            }
            if (material.normalMap) {
              uniforms.normalMap.value = material.normalMap;
              refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
              uniforms.normalScale.value.copy(material.normalScale);
              if (material.side === BackSide) {
                uniforms.normalScale.value.negate();
              }
            }
            if (material.displacementMap) {
              uniforms.displacementMap.value = material.displacementMap;
              refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
              uniforms.displacementScale.value = material.displacementScale;
              uniforms.displacementBias.value = material.displacementBias;
            }
            if (material.emissiveMap) {
              uniforms.emissiveMap.value = material.emissiveMap;
              refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
            }
            if (material.specularMap) {
              uniforms.specularMap.value = material.specularMap;
              refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
            }
            if (material.alphaTest > 0) {
              uniforms.alphaTest.value = material.alphaTest;
            }
            var materialProperties = properties.get(material);
            var envMap = materialProperties.envMap;
            var envMapRotation = materialProperties.envMapRotation;
            if (envMap) {
              uniforms.envMap.value = envMap;
              _e1.copy(envMapRotation);

              // accommodate left-handed frame
              _e1.x *= -1;
              _e1.y *= -1;
              _e1.z *= -1;
              if (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {
                // environment maps which are not cube render targets or PMREMs follow a different convention
                _e1.y *= -1;
                _e1.z *= -1;
              }
              uniforms.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1));
              uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
              uniforms.reflectivity.value = material.reflectivity;
              uniforms.ior.value = material.ior;
              uniforms.refractionRatio.value = material.refractionRatio;
            }
            if (material.lightMap) {
              uniforms.lightMap.value = material.lightMap;
              uniforms.lightMapIntensity.value = material.lightMapIntensity;
              refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
            }
            if (material.aoMap) {
              uniforms.aoMap.value = material.aoMap;
              uniforms.aoMapIntensity.value = material.aoMapIntensity;
              refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
            }
          }
          function refreshUniformsLine(uniforms, material) {
            uniforms.diffuse.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
            if (material.map) {
              uniforms.map.value = material.map;
              refreshTransformUniform(material.map, uniforms.mapTransform);
            }
          }
          function refreshUniformsDash(uniforms, material) {
            uniforms.dashSize.value = material.dashSize;
            uniforms.totalSize.value = material.dashSize + material.gapSize;
            uniforms.scale.value = material.scale;
          }
          function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
            uniforms.diffuse.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
            uniforms.size.value = material.size * pixelRatio;
            uniforms.scale.value = height * 0.5;
            if (material.map) {
              uniforms.map.value = material.map;
              refreshTransformUniform(material.map, uniforms.uvTransform);
            }
            if (material.alphaMap) {
              uniforms.alphaMap.value = material.alphaMap;
              refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
            }
            if (material.alphaTest > 0) {
              uniforms.alphaTest.value = material.alphaTest;
            }
          }
          function refreshUniformsSprites(uniforms, material) {
            uniforms.diffuse.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
            uniforms.rotation.value = material.rotation;
            if (material.map) {
              uniforms.map.value = material.map;
              refreshTransformUniform(material.map, uniforms.mapTransform);
            }
            if (material.alphaMap) {
              uniforms.alphaMap.value = material.alphaMap;
              refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
            }
            if (material.alphaTest > 0) {
              uniforms.alphaTest.value = material.alphaTest;
            }
          }
          function refreshUniformsPhong(uniforms, material) {
            uniforms.specular.value.copy(material.specular);
            uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )
          }
          function refreshUniformsToon(uniforms, material) {
            if (material.gradientMap) {
              uniforms.gradientMap.value = material.gradientMap;
            }
          }
          function refreshUniformsStandard(uniforms, material) {
            uniforms.metalness.value = material.metalness;
            if (material.metalnessMap) {
              uniforms.metalnessMap.value = material.metalnessMap;
              refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
            }
            uniforms.roughness.value = material.roughness;
            if (material.roughnessMap) {
              uniforms.roughnessMap.value = material.roughnessMap;
              refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
            }
            if (material.envMap) {
              //uniforms.envMap.value = material.envMap; // part of uniforms common

              uniforms.envMapIntensity.value = material.envMapIntensity;
            }
          }
          function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
            uniforms.ior.value = material.ior; // also part of uniforms common

            if (material.sheen > 0) {
              uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
              uniforms.sheenRoughness.value = material.sheenRoughness;
              if (material.sheenColorMap) {
                uniforms.sheenColorMap.value = material.sheenColorMap;
                refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
              }
              if (material.sheenRoughnessMap) {
                uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
                refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
              }
            }
            if (material.clearcoat > 0) {
              uniforms.clearcoat.value = material.clearcoat;
              uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
              if (material.clearcoatMap) {
                uniforms.clearcoatMap.value = material.clearcoatMap;
                refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
              }
              if (material.clearcoatRoughnessMap) {
                uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
                refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
              }
              if (material.clearcoatNormalMap) {
                uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
                refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
                uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
                if (material.side === BackSide) {
                  uniforms.clearcoatNormalScale.value.negate();
                }
              }
            }
            if (material.dispersion > 0) {
              uniforms.dispersion.value = material.dispersion;
            }
            if (material.iridescence > 0) {
              uniforms.iridescence.value = material.iridescence;
              uniforms.iridescenceIOR.value = material.iridescenceIOR;
              uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
              uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
              if (material.iridescenceMap) {
                uniforms.iridescenceMap.value = material.iridescenceMap;
                refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
              }
              if (material.iridescenceThicknessMap) {
                uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
                refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
              }
            }
            if (material.transmission > 0) {
              uniforms.transmission.value = material.transmission;
              uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
              uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
              if (material.transmissionMap) {
                uniforms.transmissionMap.value = material.transmissionMap;
                refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
              }
              uniforms.thickness.value = material.thickness;
              if (material.thicknessMap) {
                uniforms.thicknessMap.value = material.thicknessMap;
                refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
              }
              uniforms.attenuationDistance.value = material.attenuationDistance;
              uniforms.attenuationColor.value.copy(material.attenuationColor);
            }
            if (material.anisotropy > 0) {
              uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
              if (material.anisotropyMap) {
                uniforms.anisotropyMap.value = material.anisotropyMap;
                refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
              }
            }
            uniforms.specularIntensity.value = material.specularIntensity;
            uniforms.specularColor.value.copy(material.specularColor);
            if (material.specularColorMap) {
              uniforms.specularColorMap.value = material.specularColorMap;
              refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
            }
            if (material.specularIntensityMap) {
              uniforms.specularIntensityMap.value = material.specularIntensityMap;
              refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
            }
          }
          function refreshUniformsMatcap(uniforms, material) {
            if (material.matcap) {
              uniforms.matcap.value = material.matcap;
            }
          }
          function refreshUniformsDistance(uniforms, material) {
            var light = properties.get(material).light;
            uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
            uniforms.nearDistance.value = light.shadow.camera.near;
            uniforms.farDistance.value = light.shadow.camera.far;
          }
          return {
            refreshFogUniforms: refreshFogUniforms,
            refreshMaterialUniforms: refreshMaterialUniforms
          };
        }
        function WebGLUniformsGroups(gl, info, capabilities, state) {
          var buffers = {};
          var updateList = {};
          var allocatedBindingPoints = [];
          var maxBindingPoints = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS); // binding points are global whereas block indices are per shader program

          function bind(uniformsGroup, program) {
            var webglProgram = program.program;
            state.uniformBlockBinding(uniformsGroup, webglProgram);
          }
          function update(uniformsGroup, program) {
            var buffer = buffers[uniformsGroup.id];
            if (buffer === undefined) {
              prepareUniformsGroup(uniformsGroup);
              buffer = createBuffer(uniformsGroup);
              buffers[uniformsGroup.id] = buffer;
              uniformsGroup.addEventListener('dispose', onUniformsGroupsDispose);
            }

            // ensure to update the binding points/block indices mapping for this program

            var webglProgram = program.program;
            state.updateUBOMapping(uniformsGroup, webglProgram);

            // update UBO once per frame

            var frame = info.render.frame;
            if (updateList[uniformsGroup.id] !== frame) {
              updateBufferData(uniformsGroup);
              updateList[uniformsGroup.id] = frame;
            }
          }
          function createBuffer(uniformsGroup) {
            // the setup of an UBO is independent of a particular shader program but global

            var bindingPointIndex = allocateBindingPointIndex();
            uniformsGroup.__bindingPointIndex = bindingPointIndex;
            var buffer = gl.createBuffer();
            var size = uniformsGroup.__size;
            var usage = uniformsGroup.usage;
            gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
            gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
            gl.bindBuffer(gl.UNIFORM_BUFFER, null);
            gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
            return buffer;
          }
          function allocateBindingPointIndex() {
            for (var i = 0; i < maxBindingPoints; i++) {
              if (allocatedBindingPoints.indexOf(i) === -1) {
                allocatedBindingPoints.push(i);
                return i;
              }
            }
            console.error('THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.');
            return 0;
          }
          function updateBufferData(uniformsGroup) {
            var buffer = buffers[uniformsGroup.id];
            var uniforms = uniformsGroup.uniforms;
            var cache = uniformsGroup.__cache;
            gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
            for (var i = 0, il = uniforms.length; i < il; i++) {
              var uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
              for (var j = 0, jl = uniformArray.length; j < jl; j++) {
                var uniform = uniformArray[j];
                if (hasUniformChanged(uniform, i, j, cache) === true) {
                  var offset = uniform.__offset;
                  var values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
                  var arrayOffset = 0;
                  for (var _k2 = 0; _k2 < values.length; _k2++) {
                    var value = values[_k2];
                    var _info = getUniformSize(value);

                    // TODO add integer and struct support
                    if (typeof value === 'number' || typeof value === 'boolean') {
                      uniform.__data[0] = value;
                      gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
                    } else if (value.isMatrix3) {
                      // manually converting 3x3 to 3x4

                      uniform.__data[0] = value.elements[0];
                      uniform.__data[1] = value.elements[1];
                      uniform.__data[2] = value.elements[2];
                      uniform.__data[3] = 0;
                      uniform.__data[4] = value.elements[3];
                      uniform.__data[5] = value.elements[4];
                      uniform.__data[6] = value.elements[5];
                      uniform.__data[7] = 0;
                      uniform.__data[8] = value.elements[6];
                      uniform.__data[9] = value.elements[7];
                      uniform.__data[10] = value.elements[8];
                      uniform.__data[11] = 0;
                    } else {
                      value.toArray(uniform.__data, arrayOffset);
                      arrayOffset += _info.storage / Float32Array.BYTES_PER_ELEMENT;
                    }
                  }
                  gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
                }
              }
            }
            gl.bindBuffer(gl.UNIFORM_BUFFER, null);
          }
          function hasUniformChanged(uniform, index, indexArray, cache) {
            var value = uniform.value;
            var indexString = index + '_' + indexArray;
            if (cache[indexString] === undefined) {
              // cache entry does not exist so far

              if (typeof value === 'number' || typeof value === 'boolean') {
                cache[indexString] = value;
              } else {
                cache[indexString] = value.clone();
              }
              return true;
            } else {
              var cachedObject = cache[indexString];

              // compare current value with cached entry

              if (typeof value === 'number' || typeof value === 'boolean') {
                if (cachedObject !== value) {
                  cache[indexString] = value;
                  return true;
                }
              } else {
                if (cachedObject.equals(value) === false) {
                  cachedObject.copy(value);
                  return true;
                }
              }
            }
            return false;
          }
          function prepareUniformsGroup(uniformsGroup) {
            // determine total buffer size according to the STD140 layout
            // Hint: STD140 is the only supported layout in WebGL 2

            var uniforms = uniformsGroup.uniforms;
            var offset = 0; // global buffer offset in bytes
            var chunkSize = 16; // size of a chunk in bytes

            for (var i = 0, l = uniforms.length; i < l; i++) {
              var uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
              for (var j = 0, jl = uniformArray.length; j < jl; j++) {
                var uniform = uniformArray[j];
                var values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
                for (var _k3 = 0, kl = values.length; _k3 < kl; _k3++) {
                  var value = values[_k3];
                  var _info2 = getUniformSize(value);

                  // Calculate the chunk offset
                  var chunkOffsetUniform = offset % chunkSize;

                  // Check for chunk overflow
                  if (chunkOffsetUniform !== 0 && chunkSize - chunkOffsetUniform < _info2.boundary) {
                    // Add padding and adjust offset
                    offset += chunkSize - chunkOffsetUniform;
                  }

                  // the following two properties will be used for partial buffer updates

                  uniform.__data = new Float32Array(_info2.storage / Float32Array.BYTES_PER_ELEMENT);
                  uniform.__offset = offset;

                  // Update the global offset
                  offset += _info2.storage;
                }
              }
            }

            // ensure correct final padding

            var chunkOffset = offset % chunkSize;
            if (chunkOffset > 0) offset += chunkSize - chunkOffset;

            //

            uniformsGroup.__size = offset;
            uniformsGroup.__cache = {};
            return this;
          }
          function getUniformSize(value) {
            var info = {
              boundary: 0,
              // bytes
              storage: 0 // bytes
            };

            // determine sizes according to STD140

            if (typeof value === 'number' || typeof value === 'boolean') {
              // float/int/bool

              info.boundary = 4;
              info.storage = 4;
            } else if (value.isVector2) {
              // vec2

              info.boundary = 8;
              info.storage = 8;
            } else if (value.isVector3 || value.isColor) {
              // vec3

              info.boundary = 16;
              info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes
            } else if (value.isVector4) {
              // vec4

              info.boundary = 16;
              info.storage = 16;
            } else if (value.isMatrix3) {
              // mat3 (in STD140 a 3x3 matrix is represented as 3x4)

              info.boundary = 48;
              info.storage = 48;
            } else if (value.isMatrix4) {
              // mat4

              info.boundary = 64;
              info.storage = 64;
            } else if (value.isTexture) {
              console.warn('THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.');
            } else {
              console.warn('THREE.WebGLRenderer: Unsupported uniform value type.', value);
            }
            return info;
          }
          function onUniformsGroupsDispose(event) {
            var uniformsGroup = event.target;
            uniformsGroup.removeEventListener('dispose', onUniformsGroupsDispose);
            var index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
            allocatedBindingPoints.splice(index, 1);
            gl.deleteBuffer(buffers[uniformsGroup.id]);
            delete buffers[uniformsGroup.id];
            delete updateList[uniformsGroup.id];
          }
          function dispose() {
            for (var id in buffers) {
              gl.deleteBuffer(buffers[id]);
            }
            allocatedBindingPoints = [];
            buffers = {};
            updateList = {};
          }
          return {
            bind: bind,
            update: update,
            dispose: dispose
          };
        }
        var WebGLRenderer = /*#__PURE__*/function () {
          function WebGLRenderer() {
            var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            _classCallCheck2(this, WebGLRenderer);
            var _parameters$canvas = parameters.canvas,
              canvas = _parameters$canvas === void 0 ? createCanvasElement() : _parameters$canvas,
              _parameters$context = parameters.context,
              context = _parameters$context === void 0 ? null : _parameters$context,
              _parameters$depth = parameters.depth,
              depth = _parameters$depth === void 0 ? true : _parameters$depth,
              _parameters$stencil = parameters.stencil,
              stencil = _parameters$stencil === void 0 ? false : _parameters$stencil,
              _parameters$alpha = parameters.alpha,
              alpha = _parameters$alpha === void 0 ? false : _parameters$alpha,
              _parameters$antialias = parameters.antialias,
              antialias = _parameters$antialias === void 0 ? false : _parameters$antialias,
              _parameters$premultip = parameters.premultipliedAlpha,
              premultipliedAlpha = _parameters$premultip === void 0 ? true : _parameters$premultip,
              _parameters$preserveD = parameters.preserveDrawingBuffer,
              preserveDrawingBuffer = _parameters$preserveD === void 0 ? false : _parameters$preserveD,
              _parameters$powerPref = parameters.powerPreference,
              powerPreference = _parameters$powerPref === void 0 ? 'default' : _parameters$powerPref,
              _parameters$failIfMaj = parameters.failIfMajorPerformanceCaveat,
              failIfMajorPerformanceCaveat = _parameters$failIfMaj === void 0 ? false : _parameters$failIfMaj;
            this.isWebGLRenderer = true;
            var _alpha;
            if (context !== null) {
              if (typeof WebGLRenderingContext !== 'undefined' && context instanceof WebGLRenderingContext) {
                throw new Error('THREE.WebGLRenderer: WebGL 1 is not supported since r163.');
              }
              _alpha = context.getContextAttributes().alpha;
            } else {
              _alpha = alpha;
            }
            var uintClearColor = new Uint32Array(4);
            var intClearColor = new Int32Array(4);
            var currentRenderList = null;
            var currentRenderState = null;

            // render() can be called from within a callback triggered by another render.
            // We track this so that the nested render call gets its list and state isolated from the parent render call.

            var renderListStack = [];
            var renderStateStack = [];

            // public properties

            this.domElement = canvas;

            // Debug configuration container
            this.debug = {
              /**
               * Enables error checking and reporting when shader programs are being compiled
               * @type {boolean}
               */
              checkShaderErrors: true,
              /**
               * Callback for custom error reporting.
               * @type {?Function}
               */
              onShaderError: null
            };

            // clearing

            this.autoClear = true;
            this.autoClearColor = true;
            this.autoClearDepth = true;
            this.autoClearStencil = true;

            // scene graph

            this.sortObjects = true;

            // user-defined clipping

            this.clippingPlanes = [];
            this.localClippingEnabled = false;

            // physically based shading

            this._outputColorSpace = SRGBColorSpace;

            // tone mapping

            this.toneMapping = NoToneMapping;
            this.toneMappingExposure = 1.0;

            // internal properties

            var _this = this;
            var _isContextLost = false;

            // internal state cache

            var _currentActiveCubeFace = 0;
            var _currentActiveMipmapLevel = 0;
            var _currentRenderTarget = null;
            var _currentMaterialId = -1;
            var _currentCamera = null;
            var _currentViewport = new Vector4();
            var _currentScissor = new Vector4();
            var _currentScissorTest = null;
            var _currentClearColor = new Color(0x000000);
            var _currentClearAlpha = 0;

            //

            var _width = canvas.width;
            var _height = canvas.height;
            var _pixelRatio = 1;
            var _opaqueSort = null;
            var _transparentSort = null;
            var _viewport = new Vector4(0, 0, _width, _height);
            var _scissor = new Vector4(0, 0, _width, _height);
            var _scissorTest = false;

            // frustum

            var _frustum = new Frustum();

            // clipping

            var _clippingEnabled = false;
            var _localClippingEnabled = false;

            // camera matrices cache

            var _projScreenMatrix = new Matrix4();
            var _vector3 = new Vector3();
            var _vector4 = new Vector4();
            var _emptyScene = {
              background: null,
              fog: null,
              environment: null,
              overrideMaterial: null,
              isScene: true
            };
            var _renderBackground = false;
            function getTargetPixelRatio() {
              return _currentRenderTarget === null ? _pixelRatio : 1;
            }

            // initialize

            var _gl = context;
            function getContext(contextName, contextAttributes) {
              return canvas.getContext(contextName, contextAttributes);
            }
            try {
              var contextAttributes = {
                alpha: true,
                depth: depth,
                stencil: stencil,
                antialias: antialias,
                premultipliedAlpha: premultipliedAlpha,
                preserveDrawingBuffer: preserveDrawingBuffer,
                powerPreference: powerPreference,
                failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat
              };

              // OffscreenCanvas does not have setAttribute, see #22811
              if ('setAttribute' in canvas) canvas.setAttribute('data-engine', "three.js r".concat(REVISION));

              // event listeners must be registered before WebGL context is created, see #12753
              canvas.addEventListener('webglcontextlost', onContextLost, false);
              canvas.addEventListener('webglcontextrestored', onContextRestore, false);
              canvas.addEventListener('webglcontextcreationerror', onContextCreationError, false);
              if (_gl === null) {
                var contextName = 'webgl2';
                _gl = getContext(contextName, contextAttributes);
                if (_gl === null) {
                  if (getContext(contextName)) {
                    throw new Error('Error creating WebGL context with your selected attributes.');
                  } else {
                    throw new Error('Error creating WebGL context.');
                  }
                }
              }
            } catch (error) {
              console.error('THREE.WebGLRenderer: ' + error.message);
              throw error;
            }
            var extensions, capabilities, state, info;
            var properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
            var programCache, materials, renderLists, renderStates, clipping, shadowMap;
            var background, morphtargets, bufferRenderer, indexedBufferRenderer;
            var utils, bindingStates, uniformsGroups;
            function initGLContext() {
              extensions = new WebGLExtensions(_gl);
              extensions.init();
              utils = new WebGLUtils(_gl, extensions);
              capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils);
              state = new WebGLState(_gl);
              info = new WebGLInfo(_gl);
              properties = new WebGLProperties();
              textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
              cubemaps = new WebGLCubeMaps(_this);
              cubeuvmaps = new WebGLCubeUVMaps(_this);
              attributes = new WebGLAttributes(_gl);
              bindingStates = new WebGLBindingStates(_gl, attributes);
              geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
              objects = new WebGLObjects(_gl, geometries, attributes, info);
              morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
              clipping = new WebGLClipping(properties);
              programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
              materials = new WebGLMaterials(_this, properties);
              renderLists = new WebGLRenderLists();
              renderStates = new WebGLRenderStates(extensions);
              background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
              shadowMap = new WebGLShadowMap(_this, objects, capabilities);
              uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
              bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
              indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
              info.programs = programCache.programs;
              _this.capabilities = capabilities;
              _this.extensions = extensions;
              _this.properties = properties;
              _this.renderLists = renderLists;
              _this.shadowMap = shadowMap;
              _this.state = state;
              _this.info = info;
            }
            initGLContext();

            // xr

            var xr = new WebXRManager(_this, _gl);
            this.xr = xr;

            // API

            this.getContext = function () {
              return _gl;
            };
            this.getContextAttributes = function () {
              return _gl.getContextAttributes();
            };
            this.forceContextLoss = function () {
              var extension = extensions.get('WEBGL_lose_context');
              if (extension) extension.loseContext();
            };
            this.forceContextRestore = function () {
              var extension = extensions.get('WEBGL_lose_context');
              if (extension) extension.restoreContext();
            };
            this.getPixelRatio = function () {
              return _pixelRatio;
            };
            this.setPixelRatio = function (value) {
              if (value === undefined) return;
              _pixelRatio = value;
              this.setSize(_width, _height, false);
            };
            this.getSize = function (target) {
              return target.set(_width, _height);
            };
            this.setSize = function (width, height) {
              var updateStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
              if (xr.isPresenting) {
                console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
                return;
              }
              _width = width;
              _height = height;
              canvas.width = Math.floor(width * _pixelRatio);
              canvas.height = Math.floor(height * _pixelRatio);
              if (updateStyle === true) {
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
              }
              this.setViewport(0, 0, width, height);
            };
            this.getDrawingBufferSize = function (target) {
              return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
            };
            this.setDrawingBufferSize = function (width, height, pixelRatio) {
              _width = width;
              _height = height;
              _pixelRatio = pixelRatio;
              canvas.width = Math.floor(width * pixelRatio);
              canvas.height = Math.floor(height * pixelRatio);
              this.setViewport(0, 0, width, height);
            };
            this.getCurrentViewport = function (target) {
              return target.copy(_currentViewport);
            };
            this.getViewport = function (target) {
              return target.copy(_viewport);
            };
            this.setViewport = function (x, y, width, height) {
              if (x.isVector4) {
                _viewport.set(x.x, x.y, x.z, x.w);
              } else {
                _viewport.set(x, y, width, height);
              }
              state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round());
            };
            this.getScissor = function (target) {
              return target.copy(_scissor);
            };
            this.setScissor = function (x, y, width, height) {
              if (x.isVector4) {
                _scissor.set(x.x, x.y, x.z, x.w);
              } else {
                _scissor.set(x, y, width, height);
              }
              state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());
            };
            this.getScissorTest = function () {
              return _scissorTest;
            };
            this.setScissorTest = function (boolean) {
              state.setScissorTest(_scissorTest = boolean);
            };
            this.setOpaqueSort = function (method) {
              _opaqueSort = method;
            };
            this.setTransparentSort = function (method) {
              _transparentSort = method;
            };

            // Clearing

            this.getClearColor = function (target) {
              return target.copy(background.getClearColor());
            };
            this.setClearColor = function () {
              background.setClearColor.apply(background, arguments);
            };
            this.getClearAlpha = function () {
              return background.getClearAlpha();
            };
            this.setClearAlpha = function () {
              background.setClearAlpha.apply(background, arguments);
            };
            this.clear = function () {
              var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
              var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
              var stencil = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
              var bits = 0;
              if (color) {
                // check if we're trying to clear an integer target
                var isIntegerFormat = false;
                if (_currentRenderTarget !== null) {
                  var targetFormat = _currentRenderTarget.texture.format;
                  isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
                }

                // use the appropriate clear functions to clear the target if it's a signed
                // or unsigned integer target
                if (isIntegerFormat) {
                  var targetType = _currentRenderTarget.texture.type;
                  var isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
                  var clearColor = background.getClearColor();
                  var a = background.getClearAlpha();
                  var r = clearColor.r;
                  var _g3 = clearColor.g;
                  var b = clearColor.b;
                  if (isUnsignedType) {
                    uintClearColor[0] = r;
                    uintClearColor[1] = _g3;
                    uintClearColor[2] = b;
                    uintClearColor[3] = a;
                    _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
                  } else {
                    intClearColor[0] = r;
                    intClearColor[1] = _g3;
                    intClearColor[2] = b;
                    intClearColor[3] = a;
                    _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
                  }
                } else {
                  bits |= _gl.COLOR_BUFFER_BIT;
                }
              }
              if (depth) bits |= _gl.DEPTH_BUFFER_BIT;
              if (stencil) {
                bits |= _gl.STENCIL_BUFFER_BIT;
                this.state.buffers.stencil.setMask(0xffffffff);
              }
              _gl.clear(bits);
            };
            this.clearColor = function () {
              this.clear(true, false, false);
            };
            this.clearDepth = function () {
              this.clear(false, true, false);
            };
            this.clearStencil = function () {
              this.clear(false, false, true);
            };

            //

            this.dispose = function () {
              canvas.removeEventListener('webglcontextlost', onContextLost, false);
              canvas.removeEventListener('webglcontextrestored', onContextRestore, false);
              canvas.removeEventListener('webglcontextcreationerror', onContextCreationError, false);
              renderLists.dispose();
              renderStates.dispose();
              properties.dispose();
              cubemaps.dispose();
              cubeuvmaps.dispose();
              objects.dispose();
              bindingStates.dispose();
              uniformsGroups.dispose();
              programCache.dispose();
              xr.dispose();
              xr.removeEventListener('sessionstart', onXRSessionStart);
              xr.removeEventListener('sessionend', onXRSessionEnd);
              animation.stop();
            };

            // Events

            function onContextLost(event) {
              event.preventDefault();
              console.log('THREE.WebGLRenderer: Context Lost.');
              _isContextLost = true;
            }
            function onContextRestore(/* event */
            ) {
              console.log('THREE.WebGLRenderer: Context Restored.');
              _isContextLost = false;
              var infoAutoReset = info.autoReset;
              var shadowMapEnabled = shadowMap.enabled;
              var shadowMapAutoUpdate = shadowMap.autoUpdate;
              var shadowMapNeedsUpdate = shadowMap.needsUpdate;
              var shadowMapType = shadowMap.type;
              initGLContext();
              info.autoReset = infoAutoReset;
              shadowMap.enabled = shadowMapEnabled;
              shadowMap.autoUpdate = shadowMapAutoUpdate;
              shadowMap.needsUpdate = shadowMapNeedsUpdate;
              shadowMap.type = shadowMapType;
            }
            function onContextCreationError(event) {
              console.error('THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage);
            }
            function onMaterialDispose(event) {
              var material = event.target;
              material.removeEventListener('dispose', onMaterialDispose);
              deallocateMaterial(material);
            }

            // Buffer deallocation

            function deallocateMaterial(material) {
              releaseMaterialProgramReferences(material);
              properties.remove(material);
            }
            function releaseMaterialProgramReferences(material) {
              var programs = properties.get(material).programs;
              if (programs !== undefined) {
                programs.forEach(function (program) {
                  programCache.releaseProgram(program);
                });
                if (material.isShaderMaterial) {
                  programCache.releaseShaderCache(material);
                }
              }
            }

            // Buffer rendering

            this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
              if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

              var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
              var program = setProgram(camera, scene, geometry, material, object);
              state.setMaterial(material, frontFaceCW);

              //

              var index = geometry.index;
              var rangeFactor = 1;
              if (material.wireframe === true) {
                index = geometries.getWireframeAttribute(geometry);
                if (index === undefined) return;
                rangeFactor = 2;
              }

              //

              var drawRange = geometry.drawRange;
              var position = geometry.attributes.position;
              var drawStart = drawRange.start * rangeFactor;
              var drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
              if (group !== null) {
                drawStart = Math.max(drawStart, group.start * rangeFactor);
                drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
              }
              if (index !== null) {
                drawStart = Math.max(drawStart, 0);
                drawEnd = Math.min(drawEnd, index.count);
              } else if (position !== undefined && position !== null) {
                drawStart = Math.max(drawStart, 0);
                drawEnd = Math.min(drawEnd, position.count);
              }
              var drawCount = drawEnd - drawStart;
              if (drawCount < 0 || drawCount === Infinity) return;

              //

              bindingStates.setup(object, material, program, geometry, index);
              var attribute;
              var renderer = bufferRenderer;
              if (index !== null) {
                attribute = attributes.get(index);
                renderer = indexedBufferRenderer;
                renderer.setIndex(attribute);
              }

              //

              if (object.isMesh) {
                if (material.wireframe === true) {
                  state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                  renderer.setMode(_gl.LINES);
                } else {
                  renderer.setMode(_gl.TRIANGLES);
                }
              } else if (object.isLine) {
                var lineWidth = material.linewidth;
                if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

                state.setLineWidth(lineWidth * getTargetPixelRatio());
                if (object.isLineSegments) {
                  renderer.setMode(_gl.LINES);
                } else if (object.isLineLoop) {
                  renderer.setMode(_gl.LINE_LOOP);
                } else {
                  renderer.setMode(_gl.LINE_STRIP);
                }
              } else if (object.isPoints) {
                renderer.setMode(_gl.POINTS);
              } else if (object.isSprite) {
                renderer.setMode(_gl.TRIANGLES);
              }
              if (object.isBatchedMesh) {
                if (object._multiDrawInstances !== null) {
                  renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
                } else {
                  if (!extensions.get('WEBGL_multi_draw')) {
                    var starts = object._multiDrawStarts;
                    var counts = object._multiDrawCounts;
                    var _drawCount = object._multiDrawCount;
                    var bytesPerElement = index ? attributes.get(index).bytesPerElement : 1;
                    var uniforms = properties.get(material).currentProgram.getUniforms();
                    for (var i = 0; i < _drawCount; i++) {
                      uniforms.setValue(_gl, '_gl_DrawID', i);
                      renderer.render(starts[i] / bytesPerElement, counts[i]);
                    }
                  } else {
                    renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
                  }
                }
              } else if (object.isInstancedMesh) {
                renderer.renderInstances(drawStart, drawCount, object.count);
              } else if (geometry.isInstancedBufferGeometry) {
                var maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
                var instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
                renderer.renderInstances(drawStart, drawCount, instanceCount);
              } else {
                renderer.render(drawStart, drawCount);
              }
            };

            // Compile

            function prepareMaterial(material, scene, object) {
              if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
                material.side = BackSide;
                material.needsUpdate = true;
                getProgram(material, scene, object);
                material.side = FrontSide;
                material.needsUpdate = true;
                getProgram(material, scene, object);
                material.side = DoubleSide;
              } else {
                getProgram(material, scene, object);
              }
            }
            this.compile = function (scene, camera) {
              var targetScene = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
              if (targetScene === null) targetScene = scene;
              currentRenderState = renderStates.get(targetScene);
              currentRenderState.init(camera);
              renderStateStack.push(currentRenderState);

              // gather lights from both the target scene and the new object that will be added to the scene.

              targetScene.traverseVisible(function (object) {
                if (object.isLight && object.layers.test(camera.layers)) {
                  currentRenderState.pushLight(object);
                  if (object.castShadow) {
                    currentRenderState.pushShadow(object);
                  }
                }
              });
              if (scene !== targetScene) {
                scene.traverseVisible(function (object) {
                  if (object.isLight && object.layers.test(camera.layers)) {
                    currentRenderState.pushLight(object);
                    if (object.castShadow) {
                      currentRenderState.pushShadow(object);
                    }
                  }
                });
              }
              currentRenderState.setupLights();

              // Only initialize materials in the new scene, not the targetScene.

              var materials = new Set();
              scene.traverse(function (object) {
                var material = object.material;
                if (material) {
                  if (Array.isArray(material)) {
                    for (var i = 0; i < material.length; i++) {
                      var material2 = material[i];
                      prepareMaterial(material2, targetScene, object);
                      materials.add(material2);
                    }
                  } else {
                    prepareMaterial(material, targetScene, object);
                    materials.add(material);
                  }
                }
              });
              renderStateStack.pop();
              currentRenderState = null;
              return materials;
            };

            // compileAsync

            this.compileAsync = function (scene, camera) {
              var targetScene = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
              var materials = this.compile(scene, camera, targetScene);

              // Wait for all the materials in the new object to indicate that they're
              // ready to be used before resolving the promise.

              return new Promise(function (resolve) {
                function checkMaterialsReady() {
                  materials.forEach(function (material) {
                    var materialProperties = properties.get(material);
                    var program = materialProperties.currentProgram;
                    if (program.isReady()) {
                      // remove any programs that report they're ready to use from the list
                      materials.delete(material);
                    }
                  });

                  // once the list of compiling materials is empty, call the callback

                  if (materials.size === 0) {
                    resolve(scene);
                    return;
                  }

                  // if some materials are still not ready, wait a bit and check again

                  setTimeout(checkMaterialsReady, 10);
                }
                if (extensions.get('KHR_parallel_shader_compile') !== null) {
                  // If we can check the compilation status of the materials without
                  // blocking then do so right away.

                  checkMaterialsReady();
                } else {
                  // Otherwise start by waiting a bit to give the materials we just
                  // initialized a chance to finish.

                  setTimeout(checkMaterialsReady, 10);
                }
              });
            };

            // Animation Loop

            var onAnimationFrameCallback = null;
            function onAnimationFrame(time) {
              if (onAnimationFrameCallback) onAnimationFrameCallback(time);
            }
            function onXRSessionStart() {
              animation.stop();
            }
            function onXRSessionEnd() {
              animation.start();
            }
            var animation = new WebGLAnimation();
            animation.setAnimationLoop(onAnimationFrame);
            if (typeof self !== 'undefined') animation.setContext(self);
            this.setAnimationLoop = function (callback) {
              onAnimationFrameCallback = callback;
              xr.setAnimationLoop(callback);
              callback === null ? animation.stop() : animation.start();
            };
            xr.addEventListener('sessionstart', onXRSessionStart);
            xr.addEventListener('sessionend', onXRSessionEnd);

            // Rendering

            this.render = function (scene, camera) {
              if (camera !== undefined && camera.isCamera !== true) {
                console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                return;
              }
              if (_isContextLost === true) return;

              // update scene graph

              if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();

              // update camera matrices and frustum

              if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
              if (xr.enabled === true && xr.isPresenting === true) {
                if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
                camera = xr.getCamera(); // use XR camera for rendering
              }

              //
              if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
              currentRenderState = renderStates.get(scene, renderStateStack.length);
              currentRenderState.init(camera);
              renderStateStack.push(currentRenderState);
              _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
              _frustum.setFromProjectionMatrix(_projScreenMatrix);
              _localClippingEnabled = this.localClippingEnabled;
              _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
              currentRenderList = renderLists.get(scene, renderListStack.length);
              currentRenderList.init();
              renderListStack.push(currentRenderList);
              if (xr.enabled === true && xr.isPresenting === true) {
                var depthSensingMesh = _this.xr.getDepthSensingMesh();
                if (depthSensingMesh !== null) {
                  projectObject(depthSensingMesh, camera, -Infinity, _this.sortObjects);
                }
              }
              projectObject(scene, camera, 0, _this.sortObjects);
              currentRenderList.finish();
              if (_this.sortObjects === true) {
                currentRenderList.sort(_opaqueSort, _transparentSort);
              }
              _renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
              if (_renderBackground) {
                background.addToRenderList(currentRenderList, scene);
              }

              //

              this.info.render.frame++;
              if (_clippingEnabled === true) clipping.beginShadows();
              var shadowsArray = currentRenderState.state.shadowsArray;
              shadowMap.render(shadowsArray, scene, camera);
              if (_clippingEnabled === true) clipping.endShadows();

              //

              if (this.info.autoReset === true) this.info.reset();

              // render scene

              var opaqueObjects = currentRenderList.opaque;
              var transmissiveObjects = currentRenderList.transmissive;
              currentRenderState.setupLights();
              if (camera.isArrayCamera) {
                var cameras = camera.cameras;
                if (transmissiveObjects.length > 0) {
                  for (var i = 0, l = cameras.length; i < l; i++) {
                    var camera2 = cameras[i];
                    renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2);
                  }
                }
                if (_renderBackground) background.render(scene);
                for (var _i64 = 0, _l7 = cameras.length; _i64 < _l7; _i64++) {
                  var _camera3 = cameras[_i64];
                  renderScene(currentRenderList, scene, _camera3, _camera3.viewport);
                }
              } else {
                if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
                if (_renderBackground) background.render(scene);
                renderScene(currentRenderList, scene, camera);
              }

              //

              if (_currentRenderTarget !== null) {
                // resolve multisample renderbuffers to a single-sample texture if necessary

                textures.updateMultisampleRenderTarget(_currentRenderTarget);

                // Generate mipmap if we're using any kind of mipmap filtering

                textures.updateRenderTargetMipmap(_currentRenderTarget);
              }

              //

              if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);

              // _gl.finish();

              bindingStates.resetDefaultState();
              _currentMaterialId = -1;
              _currentCamera = null;
              renderStateStack.pop();
              if (renderStateStack.length > 0) {
                currentRenderState = renderStateStack[renderStateStack.length - 1];
                if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera);
              } else {
                currentRenderState = null;
              }
              renderListStack.pop();
              if (renderListStack.length > 0) {
                currentRenderList = renderListStack[renderListStack.length - 1];
              } else {
                currentRenderList = null;
              }
            };
            function projectObject(object, camera, groupOrder, sortObjects) {
              if (object.visible === false) return;
              var visible = object.layers.test(camera.layers);
              if (visible) {
                if (object.isGroup) {
                  groupOrder = object.renderOrder;
                } else if (object.isLOD) {
                  if (object.autoUpdate === true) object.update(camera);
                } else if (object.isLight) {
                  currentRenderState.pushLight(object);
                  if (object.castShadow) {
                    currentRenderState.pushShadow(object);
                  }
                } else if (object.isSprite) {
                  if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                    if (sortObjects) {
                      _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    }
                    var geometry = objects.update(object);
                    var material = object.material;
                    if (material.visible) {
                      currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
                    }
                  }
                } else if (object.isMesh || object.isLine || object.isPoints) {
                  if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                    var _geometry2 = objects.update(object);
                    var _material = object.material;
                    if (sortObjects) {
                      if (object.boundingSphere !== undefined) {
                        if (object.boundingSphere === null) object.computeBoundingSphere();
                        _vector4.copy(object.boundingSphere.center);
                      } else {
                        if (_geometry2.boundingSphere === null) _geometry2.computeBoundingSphere();
                        _vector4.copy(_geometry2.boundingSphere.center);
                      }
                      _vector4.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    }
                    if (Array.isArray(_material)) {
                      var groups = _geometry2.groups;
                      for (var i = 0, l = groups.length; i < l; i++) {
                        var group = groups[i];
                        var groupMaterial = _material[group.materialIndex];
                        if (groupMaterial && groupMaterial.visible) {
                          currentRenderList.push(object, _geometry2, groupMaterial, groupOrder, _vector4.z, group);
                        }
                      }
                    } else if (_material.visible) {
                      currentRenderList.push(object, _geometry2, _material, groupOrder, _vector4.z, null);
                    }
                  }
                }
              }
              var children = object.children;
              for (var _i65 = 0, _l8 = children.length; _i65 < _l8; _i65++) {
                projectObject(children[_i65], camera, groupOrder, sortObjects);
              }
            }
            function renderScene(currentRenderList, scene, camera, viewport) {
              var opaqueObjects = currentRenderList.opaque;
              var transmissiveObjects = currentRenderList.transmissive;
              var transparentObjects = currentRenderList.transparent;
              currentRenderState.setupLightsView(camera);
              if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
              if (viewport) state.viewport(_currentViewport.copy(viewport));
              if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
              if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
              if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);

              // Ensure depth buffer writing is enabled so it can be cleared on next render

              state.buffers.depth.setTest(true);
              state.buffers.depth.setMask(true);
              state.buffers.color.setMask(true);
              state.setPolygonOffset(false);
            }
            function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
              var overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
              if (overrideMaterial !== null) {
                return;
              }
              if (currentRenderState.state.transmissionRenderTarget[camera.id] === undefined) {
                currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, {
                  generateMipmaps: true,
                  type: extensions.has('EXT_color_buffer_half_float') || extensions.has('EXT_color_buffer_float') ? HalfFloatType : UnsignedByteType,
                  minFilter: LinearMipmapLinearFilter,
                  samples: 4,
                  stencilBuffer: stencil,
                  resolveDepthBuffer: false,
                  resolveStencilBuffer: false,
                  colorSpace: ColorManagement.workingColorSpace
                });

                // debug

                /*
                const geometry = new PlaneGeometry();
                const material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );
                	const mesh = new Mesh( geometry, material );
                scene.add( mesh );
                */
              }
              var transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id];
              var activeViewport = camera.viewport || _currentViewport;
              transmissionRenderTarget.setSize(activeViewport.z, activeViewport.w);

              //

              var currentRenderTarget = _this.getRenderTarget();
              _this.setRenderTarget(transmissionRenderTarget);
              _this.getClearColor(_currentClearColor);
              _currentClearAlpha = _this.getClearAlpha();
              if (_currentClearAlpha < 1) _this.setClearColor(0xffffff, 0.5);
              if (_renderBackground) {
                background.render(scene);
              } else {
                _this.clear();
              }

              // Turn off the features which can affect the frag color for opaque objects pass.
              // Otherwise they are applied twice in opaque objects pass and transmission objects pass.
              var currentToneMapping = _this.toneMapping;
              _this.toneMapping = NoToneMapping;

              // Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).
              // Transmission render pass requires viewport to match the transmissionRenderTarget.
              var currentCameraViewport = camera.viewport;
              if (camera.viewport !== undefined) camera.viewport = undefined;
              currentRenderState.setupLightsView(camera);
              if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
              renderObjects(opaqueObjects, scene, camera);
              textures.updateMultisampleRenderTarget(transmissionRenderTarget);
              textures.updateRenderTargetMipmap(transmissionRenderTarget);
              if (extensions.has('WEBGL_multisampled_render_to_texture') === false) {
                // see #28131

                var renderTargetNeedsUpdate = false;
                for (var i = 0, l = transmissiveObjects.length; i < l; i++) {
                  var renderItem = transmissiveObjects[i];
                  var object = renderItem.object;
                  var geometry = renderItem.geometry;
                  var material = renderItem.material;
                  var group = renderItem.group;
                  if (material.side === DoubleSide && object.layers.test(camera.layers)) {
                    var currentSide = material.side;
                    material.side = BackSide;
                    material.needsUpdate = true;
                    renderObject(object, scene, camera, geometry, material, group);
                    material.side = currentSide;
                    material.needsUpdate = true;
                    renderTargetNeedsUpdate = true;
                  }
                }
                if (renderTargetNeedsUpdate === true) {
                  textures.updateMultisampleRenderTarget(transmissionRenderTarget);
                  textures.updateRenderTargetMipmap(transmissionRenderTarget);
                }
              }
              _this.setRenderTarget(currentRenderTarget);
              _this.setClearColor(_currentClearColor, _currentClearAlpha);
              if (currentCameraViewport !== undefined) camera.viewport = currentCameraViewport;
              _this.toneMapping = currentToneMapping;
            }
            function renderObjects(renderList, scene, camera) {
              var overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
              for (var i = 0, l = renderList.length; i < l; i++) {
                var renderItem = renderList[i];
                var object = renderItem.object;
                var geometry = renderItem.geometry;
                var material = overrideMaterial === null ? renderItem.material : overrideMaterial;
                var group = renderItem.group;
                if (object.layers.test(camera.layers)) {
                  renderObject(object, scene, camera, geometry, material, group);
                }
              }
            }
            function renderObject(object, scene, camera, geometry, material, group) {
              object.onBeforeRender(_this, scene, camera, geometry, material, group);
              object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
              object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
              if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
                material.side = BackSide;
                material.needsUpdate = true;
                _this.renderBufferDirect(camera, scene, geometry, material, object, group);
                material.side = FrontSide;
                material.needsUpdate = true;
                _this.renderBufferDirect(camera, scene, geometry, material, object, group);
                material.side = DoubleSide;
              } else {
                _this.renderBufferDirect(camera, scene, geometry, material, object, group);
              }
              object.onAfterRender(_this, scene, camera, geometry, material, group);
            }
            function getProgram(material, scene, object) {
              if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

              var materialProperties = properties.get(material);
              var lights = currentRenderState.state.lights;
              var shadowsArray = currentRenderState.state.shadowsArray;
              var lightsStateVersion = lights.state.version;
              var parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
              var programCacheKey = programCache.getProgramCacheKey(parameters);
              var programs = materialProperties.programs;

              // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

              materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
              materialProperties.fog = scene.fog;
              materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
              materialProperties.envMapRotation = materialProperties.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
              if (programs === undefined) {
                // new material

                material.addEventListener('dispose', onMaterialDispose);
                programs = new Map();
                materialProperties.programs = programs;
              }
              var program = programs.get(programCacheKey);
              if (program !== undefined) {
                // early out if program and light state is identical

                if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
                  updateCommonMaterialProperties(material, parameters);
                  return program;
                }
              } else {
                parameters.uniforms = programCache.getUniforms(material);
                material.onBeforeCompile(parameters, _this);
                program = programCache.acquireProgram(parameters, programCacheKey);
                programs.set(programCacheKey, program);
                materialProperties.uniforms = parameters.uniforms;
              }
              var uniforms = materialProperties.uniforms;
              if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
                uniforms.clippingPlanes = clipping.uniform;
              }
              updateCommonMaterialProperties(material, parameters);

              // store the light setup it was created for

              materialProperties.needsLights = materialNeedsLights(material);
              materialProperties.lightsStateVersion = lightsStateVersion;
              if (materialProperties.needsLights) {
                // wire up the material to this renderer's lighting state

                uniforms.ambientLightColor.value = lights.state.ambient;
                uniforms.lightProbe.value = lights.state.probe;
                uniforms.directionalLights.value = lights.state.directional;
                uniforms.directionalLightShadows.value = lights.state.directionalShadow;
                uniforms.spotLights.value = lights.state.spot;
                uniforms.spotLightShadows.value = lights.state.spotShadow;
                uniforms.rectAreaLights.value = lights.state.rectArea;
                uniforms.ltc_1.value = lights.state.rectAreaLTC1;
                uniforms.ltc_2.value = lights.state.rectAreaLTC2;
                uniforms.pointLights.value = lights.state.point;
                uniforms.pointLightShadows.value = lights.state.pointShadow;
                uniforms.hemisphereLights.value = lights.state.hemi;
                uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
                uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
                uniforms.spotShadowMap.value = lights.state.spotShadowMap;
                uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
                uniforms.spotLightMap.value = lights.state.spotLightMap;
                uniforms.pointShadowMap.value = lights.state.pointShadowMap;
                uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
                // TODO (abelnation): add area lights shadow info to uniforms
              }
              materialProperties.currentProgram = program;
              materialProperties.uniformsList = null;
              return program;
            }
            function getUniformList(materialProperties) {
              if (materialProperties.uniformsList === null) {
                var progUniforms = materialProperties.currentProgram.getUniforms();
                materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
              }
              return materialProperties.uniformsList;
            }
            function updateCommonMaterialProperties(material, parameters) {
              var materialProperties = properties.get(material);
              materialProperties.outputColorSpace = parameters.outputColorSpace;
              materialProperties.batching = parameters.batching;
              materialProperties.batchingColor = parameters.batchingColor;
              materialProperties.instancing = parameters.instancing;
              materialProperties.instancingColor = parameters.instancingColor;
              materialProperties.instancingMorph = parameters.instancingMorph;
              materialProperties.skinning = parameters.skinning;
              materialProperties.morphTargets = parameters.morphTargets;
              materialProperties.morphNormals = parameters.morphNormals;
              materialProperties.morphColors = parameters.morphColors;
              materialProperties.morphTargetsCount = parameters.morphTargetsCount;
              materialProperties.numClippingPlanes = parameters.numClippingPlanes;
              materialProperties.numIntersection = parameters.numClipIntersection;
              materialProperties.vertexAlphas = parameters.vertexAlphas;
              materialProperties.vertexTangents = parameters.vertexTangents;
              materialProperties.toneMapping = parameters.toneMapping;
            }
            function setProgram(camera, scene, geometry, material, object) {
              if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

              textures.resetTextureUnits();
              var fog = scene.fog;
              var environment = material.isMeshStandardMaterial ? scene.environment : null;
              var colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
              var envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
              var vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
              var vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
              var morphTargets = !!geometry.morphAttributes.position;
              var morphNormals = !!geometry.morphAttributes.normal;
              var morphColors = !!geometry.morphAttributes.color;
              var toneMapping = NoToneMapping;
              if (material.toneMapped) {
                if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
                  toneMapping = _this.toneMapping;
                }
              }
              var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
              var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
              var materialProperties = properties.get(material);
              var lights = currentRenderState.state.lights;
              if (_clippingEnabled === true) {
                if (_localClippingEnabled === true || camera !== _currentCamera) {
                  var useCache = camera === _currentCamera && material.id === _currentMaterialId;

                  // we might want to call this function with some ClippingGroup
                  // object instead of the material, once it becomes feasible
                  // (#8465, #8379)
                  clipping.setState(material, camera, useCache);
                }
              }

              //

              var needsProgramChange = false;
              if (material.version === materialProperties.__version) {
                if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
                  needsProgramChange = true;
                } else if (materialProperties.outputColorSpace !== colorSpace) {
                  needsProgramChange = true;
                } else if (object.isBatchedMesh && materialProperties.batching === false) {
                  needsProgramChange = true;
                } else if (!object.isBatchedMesh && materialProperties.batching === true) {
                  needsProgramChange = true;
                } else if (object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null) {
                  needsProgramChange = true;
                } else if (object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null) {
                  needsProgramChange = true;
                } else if (object.isInstancedMesh && materialProperties.instancing === false) {
                  needsProgramChange = true;
                } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
                  needsProgramChange = true;
                } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
                  needsProgramChange = true;
                } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
                  needsProgramChange = true;
                } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
                  needsProgramChange = true;
                } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
                  needsProgramChange = true;
                } else if (object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null) {
                  needsProgramChange = true;
                } else if (object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null) {
                  needsProgramChange = true;
                } else if (materialProperties.envMap !== envMap) {
                  needsProgramChange = true;
                } else if (material.fog === true && materialProperties.fog !== fog) {
                  needsProgramChange = true;
                } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
                  needsProgramChange = true;
                } else if (materialProperties.vertexAlphas !== vertexAlphas) {
                  needsProgramChange = true;
                } else if (materialProperties.vertexTangents !== vertexTangents) {
                  needsProgramChange = true;
                } else if (materialProperties.morphTargets !== morphTargets) {
                  needsProgramChange = true;
                } else if (materialProperties.morphNormals !== morphNormals) {
                  needsProgramChange = true;
                } else if (materialProperties.morphColors !== morphColors) {
                  needsProgramChange = true;
                } else if (materialProperties.toneMapping !== toneMapping) {
                  needsProgramChange = true;
                } else if (materialProperties.morphTargetsCount !== morphTargetsCount) {
                  needsProgramChange = true;
                }
              } else {
                needsProgramChange = true;
                materialProperties.__version = material.version;
              }

              //

              var program = materialProperties.currentProgram;
              if (needsProgramChange === true) {
                program = getProgram(material, scene, object);
              }
              var refreshProgram = false;
              var refreshMaterial = false;
              var refreshLights = false;
              var p_uniforms = program.getUniforms(),
                m_uniforms = materialProperties.uniforms;
              if (state.useProgram(program.program)) {
                refreshProgram = true;
                refreshMaterial = true;
                refreshLights = true;
              }
              if (material.id !== _currentMaterialId) {
                _currentMaterialId = material.id;
                refreshMaterial = true;
              }
              if (refreshProgram || _currentCamera !== camera) {
                // common camera uniforms

                p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
                p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
                var uCamPos = p_uniforms.map.cameraPosition;
                if (uCamPos !== undefined) {
                  uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                }
                if (capabilities.logarithmicDepthBuffer) {
                  p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
                }

                // consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067

                if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
                  p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
                }
                if (_currentCamera !== camera) {
                  _currentCamera = camera;

                  // lighting uniforms depend on the camera so enforce an update
                  // now, in case this material supports lights - or later, when
                  // the next material that does gets activated:

                  refreshMaterial = true; // set to true on material change
                  refreshLights = true; // remains set until update done
                }
              }

              // skinning and morph target uniforms must be set even if material didn't change
              // auto-setting of texture unit for bone and morph texture must go before other textures
              // otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

              if (object.isSkinnedMesh) {
                p_uniforms.setOptional(_gl, object, 'bindMatrix');
                p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
                var skeleton = object.skeleton;
                if (skeleton) {
                  if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
                  p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
                }
              }
              if (object.isBatchedMesh) {
                p_uniforms.setOptional(_gl, object, 'batchingTexture');
                p_uniforms.setValue(_gl, 'batchingTexture', object._matricesTexture, textures);
                p_uniforms.setOptional(_gl, object, 'batchingIdTexture');
                p_uniforms.setValue(_gl, 'batchingIdTexture', object._indirectTexture, textures);
                p_uniforms.setOptional(_gl, object, 'batchingColorTexture');
                if (object._colorsTexture !== null) {
                  p_uniforms.setValue(_gl, 'batchingColorTexture', object._colorsTexture, textures);
                }
              }
              var morphAttributes = geometry.morphAttributes;
              if (morphAttributes.position !== undefined || morphAttributes.normal !== undefined || morphAttributes.color !== undefined) {
                morphtargets.update(object, geometry, program);
              }
              if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
                materialProperties.receiveShadow = object.receiveShadow;
                p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
              }

              // https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

              if (material.isMeshGouraudMaterial && material.envMap !== null) {
                m_uniforms.envMap.value = envMap;
                m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
              }
              if (material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null) {
                m_uniforms.envMapIntensity.value = scene.environmentIntensity;
              }
              if (refreshMaterial) {
                p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
                if (materialProperties.needsLights) {
                  // the current material requires lighting info

                  // note: all lighting uniforms are always set correctly
                  // they simply reference the renderer's state for their
                  // values
                  //
                  // use the current material's .needsUpdate flags to set
                  // the GL state when required

                  markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
                }

                // refresh uniforms common to several materials

                if (fog && material.fog === true) {
                  materials.refreshFogUniforms(m_uniforms, fog);
                }
                materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]);
                WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
              }
              if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
                WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
                material.uniformsNeedUpdate = false;
              }
              if (material.isSpriteMaterial) {
                p_uniforms.setValue(_gl, 'center', object.center);
              }

              // common matrices

              p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
              p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
              p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);

              // UBOs

              if (material.isShaderMaterial || material.isRawShaderMaterial) {
                var groups = material.uniformsGroups;
                for (var i = 0, l = groups.length; i < l; i++) {
                  var group = groups[i];
                  uniformsGroups.update(group, program);
                  uniformsGroups.bind(group, program);
                }
              }
              return program;
            }

            // If uniforms are marked as clean, they don't need to be loaded to the GPU.

            function markUniformsLightsNeedsUpdate(uniforms, value) {
              uniforms.ambientLightColor.needsUpdate = value;
              uniforms.lightProbe.needsUpdate = value;
              uniforms.directionalLights.needsUpdate = value;
              uniforms.directionalLightShadows.needsUpdate = value;
              uniforms.pointLights.needsUpdate = value;
              uniforms.pointLightShadows.needsUpdate = value;
              uniforms.spotLights.needsUpdate = value;
              uniforms.spotLightShadows.needsUpdate = value;
              uniforms.rectAreaLights.needsUpdate = value;
              uniforms.hemisphereLights.needsUpdate = value;
            }
            function materialNeedsLights(material) {
              return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
            }
            this.getActiveCubeFace = function () {
              return _currentActiveCubeFace;
            };
            this.getActiveMipmapLevel = function () {
              return _currentActiveMipmapLevel;
            };
            this.getRenderTarget = function () {
              return _currentRenderTarget;
            };
            this.setRenderTargetTextures = function (renderTarget, colorTexture, depthTexture) {
              properties.get(renderTarget.texture).__webglTexture = colorTexture;
              properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
              var renderTargetProperties = properties.get(renderTarget);
              renderTargetProperties.__hasExternalTextures = true;
              renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;
              if (!renderTargetProperties.__autoAllocateDepthBuffer) {
                // The multisample_render_to_texture extension doesn't work properly if there
                // are midframe flushes and an external depth buffer. Disable use of the extension.
                if (extensions.has('WEBGL_multisampled_render_to_texture') === true) {
                  console.warn('THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided');
                  renderTargetProperties.__useRenderToTexture = false;
                }
              }
            };
            this.setRenderTargetFramebuffer = function (renderTarget, defaultFramebuffer) {
              var renderTargetProperties = properties.get(renderTarget);
              renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
              renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;
            };
            this.setRenderTarget = function (renderTarget) {
              var activeCubeFace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var activeMipmapLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              _currentRenderTarget = renderTarget;
              _currentActiveCubeFace = activeCubeFace;
              _currentActiveMipmapLevel = activeMipmapLevel;
              var useDefaultFramebuffer = true;
              var framebuffer = null;
              var isCube = false;
              var isRenderTarget3D = false;
              if (renderTarget) {
                var renderTargetProperties = properties.get(renderTarget);
                if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {
                  // We need to make sure to rebind the framebuffer.
                  state.bindFramebuffer(_gl.FRAMEBUFFER, null);
                  useDefaultFramebuffer = false;
                } else if (renderTargetProperties.__webglFramebuffer === undefined) {
                  textures.setupRenderTarget(renderTarget);
                } else if (renderTargetProperties.__hasExternalTextures) {
                  // Color and depth texture must be rebound in order for the swapchain to update.
                  textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
                }
                var texture = renderTarget.texture;
                if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
                  isRenderTarget3D = true;
                }
                var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
                if (renderTarget.isWebGLCubeRenderTarget) {
                  if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
                    framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
                  } else {
                    framebuffer = __webglFramebuffer[activeCubeFace];
                  }
                  isCube = true;
                } else if (renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
                  framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
                } else {
                  if (Array.isArray(__webglFramebuffer)) {
                    framebuffer = __webglFramebuffer[activeMipmapLevel];
                  } else {
                    framebuffer = __webglFramebuffer;
                  }
                }
                _currentViewport.copy(renderTarget.viewport);
                _currentScissor.copy(renderTarget.scissor);
                _currentScissorTest = renderTarget.scissorTest;
              } else {
                _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
                _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
                _currentScissorTest = _scissorTest;
              }
              var framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
              if (framebufferBound && useDefaultFramebuffer) {
                state.drawBuffers(renderTarget, framebuffer);
              }
              state.viewport(_currentViewport);
              state.scissor(_currentScissor);
              state.setScissorTest(_currentScissorTest);
              if (isCube) {
                var textureProperties = properties.get(renderTarget.texture);
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
              } else if (isRenderTarget3D) {
                var _textureProperties = properties.get(renderTarget.texture);
                var layer = activeCubeFace || 0;
                _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
              }
              _currentMaterialId = -1; // reset current material to ensure correct uniform bindings
            };
            this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
              if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
                console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                return;
              }
              var framebuffer = properties.get(renderTarget).__webglFramebuffer;
              if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
                framebuffer = framebuffer[activeCubeFaceIndex];
              }
              if (framebuffer) {
                state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                try {
                  var texture = renderTarget.texture;
                  var textureFormat = texture.format;
                  var textureType = texture.type;
                  if (!capabilities.textureFormatReadable(textureFormat)) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                    return;
                  }
                  if (!capabilities.textureTypeReadable(textureType)) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                    return;
                  }

                  // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

                  if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
                    _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                  }
                } finally {
                  // restore framebuffer of current render target if necessary

                  var _framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
                  state.bindFramebuffer(_gl.FRAMEBUFFER, _framebuffer);
                }
              }
            };
            this.readRenderTargetPixelsAsync = /*#__PURE__*/function () {
              var _ref69 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
                var framebuffer, texture, textureFormat, textureType, glBuffer, sync, _framebuffer2;
                return _regeneratorRuntime().wrap(function _callee7$(_context15) {
                  while (1) switch (_context15.prev = _context15.next) {
                    case 0:
                      if (renderTarget && renderTarget.isWebGLRenderTarget) {
                        _context15.next = 2;
                        break;
                      }
                      throw new Error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                    case 2:
                      framebuffer = properties.get(renderTarget).__webglFramebuffer;
                      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
                        framebuffer = framebuffer[activeCubeFaceIndex];
                      }
                      if (!framebuffer) {
                        _context15.next = 29;
                        break;
                      }
                      state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                      _context15.prev = 6;
                      texture = renderTarget.texture;
                      textureFormat = texture.format;
                      textureType = texture.type;
                      if (capabilities.textureFormatReadable(textureFormat)) {
                        _context15.next = 12;
                        break;
                      }
                      throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.');
                    case 12:
                      if (capabilities.textureTypeReadable(textureType)) {
                        _context15.next = 14;
                        break;
                      }
                      throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.');
                    case 14:
                      if (!(x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height)) {
                        _context15.next = 25;
                        break;
                      }
                      glBuffer = _gl.createBuffer();
                      _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
                      _gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ);
                      _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), 0);
                      _gl.flush();

                      // check if the commands have finished every 8 ms
                      sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
                      _context15.next = 23;
                      return probeAsync(_gl, sync, 4);
                    case 23:
                      try {
                        _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
                        _gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer);
                      } finally {
                        _gl.deleteBuffer(glBuffer);
                        _gl.deleteSync(sync);
                      }
                      return _context15.abrupt("return", buffer);
                    case 25:
                      _context15.prev = 25;
                      // restore framebuffer of current render target if necessary
                      _framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
                      state.bindFramebuffer(_gl.FRAMEBUFFER, _framebuffer2);
                      return _context15.finish(25);
                    case 29:
                    case "end":
                      return _context15.stop();
                  }
                }, _callee7, null, [[6,, 25, 29]]);
              }));
              return function (_x5, _x6, _x7, _x8, _x9, _x10, _x11) {
                return _ref69.apply(this, arguments);
              };
            }();
            this.copyFramebufferToTexture = function (texture) {
              var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
              var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              // support previous signature with position first
              if (texture.isTexture !== true) {
                // @deprecated, r165
                console.warn('WebGLRenderer: copyFramebufferToTexture function signature has changed.');
                position = arguments[0] || null;
                texture = arguments[1];
              }
              var levelScale = Math.pow(2, -level);
              var width = Math.floor(texture.image.width * levelScale);
              var height = Math.floor(texture.image.height * levelScale);
              var x = position !== null ? position.x : 0;
              var y = position !== null ? position.y : 0;
              textures.setTexture2D(texture, 0);
              _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x, y, width, height);
              state.unbindTexture();
            };
            this.copyTextureToTexture = function (srcTexture, dstTexture) {
              var srcRegion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
              var dstPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
              var level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
              // support previous signature with dstPosition first
              if (srcTexture.isTexture !== true) {
                // @deprecated, r165
                console.warn('WebGLRenderer: copyTextureToTexture function signature has changed.');
                dstPosition = arguments[0] || null;
                srcTexture = arguments[1];
                dstTexture = arguments[2];
                level = arguments[3] || 0;
                srcRegion = null;
              }
              var width, height, minX, minY;
              var dstX, dstY;
              if (srcRegion !== null) {
                width = srcRegion.max.x - srcRegion.min.x;
                height = srcRegion.max.y - srcRegion.min.y;
                minX = srcRegion.min.x;
                minY = srcRegion.min.y;
              } else {
                width = srcTexture.image.width;
                height = srcTexture.image.height;
                minX = 0;
                minY = 0;
              }
              if (dstPosition !== null) {
                dstX = dstPosition.x;
                dstY = dstPosition.y;
              } else {
                dstX = 0;
                dstY = 0;
              }
              var glFormat = utils.convert(dstTexture.format);
              var glType = utils.convert(dstTexture.type);
              textures.setTexture2D(dstTexture, 0);

              // As another texture upload may have changed pixelStorei
              // parameters, make sure they are correct for the dstTexture
              _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
              _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
              _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
              var currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
              var currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
              var currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
              var currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
              var currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
              var image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
              _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
              _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
              _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
              _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
              if (srcTexture.isDataTexture) {
                _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data);
              } else {
                if (srcTexture.isCompressedTexture) {
                  _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data);
                } else {
                  _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image);
                }
              }
              _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
              _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
              _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
              _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
              _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);

              // Generate mipmaps only when copying level 0
              if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
              state.unbindTexture();
            };
            this.copyTextureToTexture3D = function (srcTexture, dstTexture) {
              var srcRegion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
              var dstPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
              var level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
              // support previous signature with source box first
              if (srcTexture.isTexture !== true) {
                // @deprecated, r165
                console.warn('WebGLRenderer: copyTextureToTexture3D function signature has changed.');
                srcRegion = arguments[0] || null;
                dstPosition = arguments[1] || null;
                srcTexture = arguments[2];
                dstTexture = arguments[3];
                level = arguments[4] || 0;
              }
              var width, height, depth, minX, minY, minZ;
              var dstX, dstY, dstZ;
              var image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
              if (srcRegion !== null) {
                width = srcRegion.max.x - srcRegion.min.x;
                height = srcRegion.max.y - srcRegion.min.y;
                depth = srcRegion.max.z - srcRegion.min.z;
                minX = srcRegion.min.x;
                minY = srcRegion.min.y;
                minZ = srcRegion.min.z;
              } else {
                width = image.width;
                height = image.height;
                depth = image.depth;
                minX = 0;
                minY = 0;
                minZ = 0;
              }
              if (dstPosition !== null) {
                dstX = dstPosition.x;
                dstY = dstPosition.y;
                dstZ = dstPosition.z;
              } else {
                dstX = 0;
                dstY = 0;
                dstZ = 0;
              }
              var glFormat = utils.convert(dstTexture.format);
              var glType = utils.convert(dstTexture.type);
              var glTarget;
              if (dstTexture.isData3DTexture) {
                textures.setTexture3D(dstTexture, 0);
                glTarget = _gl.TEXTURE_3D;
              } else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {
                textures.setTexture2DArray(dstTexture, 0);
                glTarget = _gl.TEXTURE_2D_ARRAY;
              } else {
                console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
                return;
              }
              _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
              _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
              _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
              var currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
              var currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
              var currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
              var currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
              var currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
              _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
              _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
              _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
              _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
              _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);
              if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
                _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image.data);
              } else {
                if (dstTexture.isCompressedArrayTexture) {
                  _gl.compressedTexSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, image.data);
                } else {
                  _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image);
                }
              }
              _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
              _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
              _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
              _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
              _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);

              // Generate mipmaps only when copying level 0
              if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
              state.unbindTexture();
            };
            this.initRenderTarget = function (target) {
              if (properties.get(target).__webglFramebuffer === undefined) {
                textures.setupRenderTarget(target);
              }
            };
            this.initTexture = function (texture) {
              if (texture.isCubeTexture) {
                textures.setTextureCube(texture, 0);
              } else if (texture.isData3DTexture) {
                textures.setTexture3D(texture, 0);
              } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
                textures.setTexture2DArray(texture, 0);
              } else {
                textures.setTexture2D(texture, 0);
              }
              state.unbindTexture();
            };
            this.resetState = function () {
              _currentActiveCubeFace = 0;
              _currentActiveMipmapLevel = 0;
              _currentRenderTarget = null;
              state.reset();
              bindingStates.reset();
            };
            if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
              __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
                detail: this
              }));
            }
          }
          return _createClass(WebGLRenderer, [{
            key: "coordinateSystem",
            get: function get() {
              return WebGLCoordinateSystem;
            }
          }, {
            key: "outputColorSpace",
            get: function get() {
              return this._outputColorSpace;
            },
            set: function set(colorSpace) {
              this._outputColorSpace = colorSpace;
              var gl = this.getContext();
              gl.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? 'display-p3' : 'srgb';
              gl.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? 'display-p3' : 'srgb';
            }
          }]);
        }();
        var FogExp2 = /*#__PURE__*/function () {
          function FogExp2(color) {
            var density = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00025;
            _classCallCheck2(this, FogExp2);
            this.isFogExp2 = true;
            this.name = '';
            this.color = new Color(color);
            this.density = density;
          }
          return _createClass(FogExp2, [{
            key: "clone",
            value: function clone() {
              return new FogExp2(this.color, this.density);
            }
          }, {
            key: "toJSON",
            value: function toJSON(/* meta */
            ) {
              return {
                type: 'FogExp2',
                name: this.name,
                color: this.color.getHex(),
                density: this.density
              };
            }
          }]);
        }();
        var Fog = /*#__PURE__*/function () {
          function Fog(color) {
            var near = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var far = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
            _classCallCheck2(this, Fog);
            this.isFog = true;
            this.name = '';
            this.color = new Color(color);
            this.near = near;
            this.far = far;
          }
          return _createClass(Fog, [{
            key: "clone",
            value: function clone() {
              return new Fog(this.color, this.near, this.far);
            }
          }, {
            key: "toJSON",
            value: function toJSON(/* meta */
            ) {
              return {
                type: 'Fog',
                name: this.name,
                color: this.color.getHex(),
                near: this.near,
                far: this.far
              };
            }
          }]);
        }();
        var Scene = /*#__PURE__*/function (_Object3D5) {
          function Scene() {
            var _this43;
            _classCallCheck2(this, Scene);
            _this43 = _callSuper(this, Scene);
            _this43.isScene = true;
            _this43.type = 'Scene';
            _this43.background = null;
            _this43.environment = null;
            _this43.fog = null;
            _this43.backgroundBlurriness = 0;
            _this43.backgroundIntensity = 1;
            _this43.backgroundRotation = new Euler();
            _this43.environmentIntensity = 1;
            _this43.environmentRotation = new Euler();
            _this43.overrideMaterial = null;
            if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
              __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
                detail: _this43
              }));
            }
            return _this43;
          }
          _inherits(Scene, _Object3D5);
          return _createClass(Scene, [{
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(Scene, "copy", this, 3)([source, recursive]);
              if (source.background !== null) this.background = source.background.clone();
              if (source.environment !== null) this.environment = source.environment.clone();
              if (source.fog !== null) this.fog = source.fog.clone();
              this.backgroundBlurriness = source.backgroundBlurriness;
              this.backgroundIntensity = source.backgroundIntensity;
              this.backgroundRotation.copy(source.backgroundRotation);
              this.environmentIntensity = source.environmentIntensity;
              this.environmentRotation.copy(source.environmentRotation);
              if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
              this.matrixAutoUpdate = source.matrixAutoUpdate;
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON(meta) {
              var data = _superPropGet(Scene, "toJSON", this, 3)([meta]);
              if (this.fog !== null) data.object.fog = this.fog.toJSON();
              if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
              if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
              data.object.backgroundRotation = this.backgroundRotation.toArray();
              if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
              data.object.environmentRotation = this.environmentRotation.toArray();
              return data;
            }
          }]);
        }(Object3D);
        var InterleavedBuffer = /*#__PURE__*/function () {
          function InterleavedBuffer(array, stride) {
            _classCallCheck2(this, InterleavedBuffer);
            this.isInterleavedBuffer = true;
            this.array = array;
            this.stride = stride;
            this.count = array !== undefined ? array.length / stride : 0;
            this.usage = StaticDrawUsage;
            this._updateRange = {
              offset: 0,
              count: -1
            };
            this.updateRanges = [];
            this.version = 0;
            this.uuid = generateUUID();
          }
          return _createClass(InterleavedBuffer, [{
            key: "onUploadCallback",
            value: function onUploadCallback() {}
          }, {
            key: "needsUpdate",
            set: function set(value) {
              if (value === true) this.version++;
            }
          }, {
            key: "updateRange",
            get: function get() {
              warnOnce('THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.'); // @deprecated, r159
              return this._updateRange;
            }
          }, {
            key: "setUsage",
            value: function setUsage(value) {
              this.usage = value;
              return this;
            }
          }, {
            key: "addUpdateRange",
            value: function addUpdateRange(start, count) {
              this.updateRanges.push({
                start: start,
                count: count
              });
            }
          }, {
            key: "clearUpdateRanges",
            value: function clearUpdateRanges() {
              this.updateRanges.length = 0;
            }
          }, {
            key: "copy",
            value: function copy(source) {
              this.array = new source.array.constructor(source.array);
              this.count = source.count;
              this.stride = source.stride;
              this.usage = source.usage;
              return this;
            }
          }, {
            key: "copyAt",
            value: function copyAt(index1, attribute, index2) {
              index1 *= this.stride;
              index2 *= attribute.stride;
              for (var i = 0, l = this.stride; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
              }
              return this;
            }
          }, {
            key: "set",
            value: function set(value) {
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              this.array.set(value, offset);
              return this;
            }
          }, {
            key: "clone",
            value: function clone(data) {
              if (data.arrayBuffers === undefined) {
                data.arrayBuffers = {};
              }
              if (this.array.buffer._uuid === undefined) {
                this.array.buffer._uuid = generateUUID();
              }
              if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
                data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
              }
              var array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
              var ib = new this.constructor(array, this.stride);
              ib.setUsage(this.usage);
              return ib;
            }
          }, {
            key: "onUpload",
            value: function onUpload(callback) {
              this.onUploadCallback = callback;
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON(data) {
              if (data.arrayBuffers === undefined) {
                data.arrayBuffers = {};
              }

              // generate UUID for array buffer if necessary

              if (this.array.buffer._uuid === undefined) {
                this.array.buffer._uuid = generateUUID();
              }
              if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
                data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
              }

              //

              return {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
              };
            }
          }]);
        }();
        var _vector$6 = /*@__PURE__*/new Vector3();
        var InterleavedBufferAttribute = /*#__PURE__*/function () {
          function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset) {
            var normalized = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            _classCallCheck2(this, InterleavedBufferAttribute);
            this.isInterleavedBufferAttribute = true;
            this.name = '';
            this.data = interleavedBuffer;
            this.itemSize = itemSize;
            this.offset = offset;
            this.normalized = normalized;
          }
          return _createClass(InterleavedBufferAttribute, [{
            key: "count",
            get: function get() {
              return this.data.count;
            }
          }, {
            key: "array",
            get: function get() {
              return this.data.array;
            }
          }, {
            key: "needsUpdate",
            set: function set(value) {
              this.data.needsUpdate = value;
            }
          }, {
            key: "applyMatrix4",
            value: function applyMatrix4(m) {
              for (var i = 0, l = this.data.count; i < l; i++) {
                _vector$6.fromBufferAttribute(this, i);
                _vector$6.applyMatrix4(m);
                this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
              }
              return this;
            }
          }, {
            key: "applyNormalMatrix",
            value: function applyNormalMatrix(m) {
              for (var i = 0, l = this.count; i < l; i++) {
                _vector$6.fromBufferAttribute(this, i);
                _vector$6.applyNormalMatrix(m);
                this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
              }
              return this;
            }
          }, {
            key: "transformDirection",
            value: function transformDirection(m) {
              for (var i = 0, l = this.count; i < l; i++) {
                _vector$6.fromBufferAttribute(this, i);
                _vector$6.transformDirection(m);
                this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
              }
              return this;
            }
          }, {
            key: "getComponent",
            value: function getComponent(index, component) {
              var value = this.array[index * this.data.stride + this.offset + component];
              if (this.normalized) value = denormalize(value, this.array);
              return value;
            }
          }, {
            key: "setComponent",
            value: function setComponent(index, component, value) {
              if (this.normalized) value = normalize(value, this.array);
              this.data.array[index * this.data.stride + this.offset + component] = value;
              return this;
            }
          }, {
            key: "setX",
            value: function setX(index, x) {
              if (this.normalized) x = normalize(x, this.array);
              this.data.array[index * this.data.stride + this.offset] = x;
              return this;
            }
          }, {
            key: "setY",
            value: function setY(index, y) {
              if (this.normalized) y = normalize(y, this.array);
              this.data.array[index * this.data.stride + this.offset + 1] = y;
              return this;
            }
          }, {
            key: "setZ",
            value: function setZ(index, z) {
              if (this.normalized) z = normalize(z, this.array);
              this.data.array[index * this.data.stride + this.offset + 2] = z;
              return this;
            }
          }, {
            key: "setW",
            value: function setW(index, w) {
              if (this.normalized) w = normalize(w, this.array);
              this.data.array[index * this.data.stride + this.offset + 3] = w;
              return this;
            }
          }, {
            key: "getX",
            value: function getX(index) {
              var x = this.data.array[index * this.data.stride + this.offset];
              if (this.normalized) x = denormalize(x, this.array);
              return x;
            }
          }, {
            key: "getY",
            value: function getY(index) {
              var y = this.data.array[index * this.data.stride + this.offset + 1];
              if (this.normalized) y = denormalize(y, this.array);
              return y;
            }
          }, {
            key: "getZ",
            value: function getZ(index) {
              var z = this.data.array[index * this.data.stride + this.offset + 2];
              if (this.normalized) z = denormalize(z, this.array);
              return z;
            }
          }, {
            key: "getW",
            value: function getW(index) {
              var w = this.data.array[index * this.data.stride + this.offset + 3];
              if (this.normalized) w = denormalize(w, this.array);
              return w;
            }
          }, {
            key: "setXY",
            value: function setXY(index, x, y) {
              index = index * this.data.stride + this.offset;
              if (this.normalized) {
                x = normalize(x, this.array);
                y = normalize(y, this.array);
              }
              this.data.array[index + 0] = x;
              this.data.array[index + 1] = y;
              return this;
            }
          }, {
            key: "setXYZ",
            value: function setXYZ(index, x, y, z) {
              index = index * this.data.stride + this.offset;
              if (this.normalized) {
                x = normalize(x, this.array);
                y = normalize(y, this.array);
                z = normalize(z, this.array);
              }
              this.data.array[index + 0] = x;
              this.data.array[index + 1] = y;
              this.data.array[index + 2] = z;
              return this;
            }
          }, {
            key: "setXYZW",
            value: function setXYZW(index, x, y, z, w) {
              index = index * this.data.stride + this.offset;
              if (this.normalized) {
                x = normalize(x, this.array);
                y = normalize(y, this.array);
                z = normalize(z, this.array);
                w = normalize(w, this.array);
              }
              this.data.array[index + 0] = x;
              this.data.array[index + 1] = y;
              this.data.array[index + 2] = z;
              this.data.array[index + 3] = w;
              return this;
            }
          }, {
            key: "clone",
            value: function clone(data) {
              if (data === undefined) {
                console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.');
                var array = [];
                for (var i = 0; i < this.count; i++) {
                  var _index8 = i * this.data.stride + this.offset;
                  for (var j = 0; j < this.itemSize; j++) {
                    array.push(this.data.array[_index8 + j]);
                  }
                }
                return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
              } else {
                if (data.interleavedBuffers === undefined) {
                  data.interleavedBuffers = {};
                }
                if (data.interleavedBuffers[this.data.uuid] === undefined) {
                  data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
                }
                return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
              }
            }
          }, {
            key: "toJSON",
            value: function toJSON(data) {
              if (data === undefined) {
                console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.');
                var array = [];
                for (var i = 0; i < this.count; i++) {
                  var _index9 = i * this.data.stride + this.offset;
                  for (var j = 0; j < this.itemSize; j++) {
                    array.push(this.data.array[_index9 + j]);
                  }
                }

                // de-interleave data and save it as an ordinary buffer attribute for now

                return {
                  itemSize: this.itemSize,
                  type: this.array.constructor.name,
                  array: array,
                  normalized: this.normalized
                };
              } else {
                // save as true interleaved attribute

                if (data.interleavedBuffers === undefined) {
                  data.interleavedBuffers = {};
                }
                if (data.interleavedBuffers[this.data.uuid] === undefined) {
                  data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
                }
                return {
                  isInterleavedBufferAttribute: true,
                  itemSize: this.itemSize,
                  data: this.data.uuid,
                  offset: this.offset,
                  normalized: this.normalized
                };
              }
            }
          }]);
        }();
        var SpriteMaterial = /*#__PURE__*/function (_Material5) {
          function SpriteMaterial(parameters) {
            var _this44;
            _classCallCheck2(this, SpriteMaterial);
            _this44 = _callSuper(this, SpriteMaterial);
            _this44.isSpriteMaterial = true;
            _this44.type = 'SpriteMaterial';
            _this44.color = new Color(0xffffff);
            _this44.map = null;
            _this44.alphaMap = null;
            _this44.rotation = 0;
            _this44.sizeAttenuation = true;
            _this44.transparent = true;
            _this44.fog = true;
            _this44.setValues(parameters);
            return _this44;
          }
          _inherits(SpriteMaterial, _Material5);
          return _createClass(SpriteMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(SpriteMaterial, "copy", this, 3)([source]);
              this.color.copy(source.color);
              this.map = source.map;
              this.alphaMap = source.alphaMap;
              this.rotation = source.rotation;
              this.sizeAttenuation = source.sizeAttenuation;
              this.fog = source.fog;
              return this;
            }
          }]);
        }(Material);
        var _geometry;
        var _intersectPoint = /*@__PURE__*/new Vector3();
        var _worldScale = /*@__PURE__*/new Vector3();
        var _mvPosition = /*@__PURE__*/new Vector3();
        var _alignedPosition = /*@__PURE__*/new Vector2();
        var _rotatedPosition = /*@__PURE__*/new Vector2();
        var _viewWorldMatrix = /*@__PURE__*/new Matrix4();
        var _vA = /*@__PURE__*/new Vector3();
        var _vB = /*@__PURE__*/new Vector3();
        var _vC = /*@__PURE__*/new Vector3();
        var _uvA = /*@__PURE__*/new Vector2();
        var _uvB = /*@__PURE__*/new Vector2();
        var _uvC = /*@__PURE__*/new Vector2();
        var Sprite = /*#__PURE__*/function (_Object3D6) {
          function Sprite() {
            var _this45;
            var material = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new SpriteMaterial();
            _classCallCheck2(this, Sprite);
            _this45 = _callSuper(this, Sprite);
            _this45.isSprite = true;
            _this45.type = 'Sprite';
            if (_geometry === undefined) {
              _geometry = new BufferGeometry();
              var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
              var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
              _geometry.setIndex([0, 1, 2, 0, 2, 3]);
              _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
              _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
            }
            _this45.geometry = _geometry;
            _this45.material = material;
            _this45.center = new Vector2(0.5, 0.5);
            return _this45;
          }
          _inherits(Sprite, _Object3D6);
          return _createClass(Sprite, [{
            key: "raycast",
            value: function raycast(raycaster, intersects) {
              if (raycaster.camera === null) {
                console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
              }
              _worldScale.setFromMatrixScale(this.matrixWorld);
              _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
              this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
              _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
              if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
                _worldScale.multiplyScalar(-_mvPosition.z);
              }
              var rotation = this.material.rotation;
              var sin, cos;
              if (rotation !== 0) {
                cos = Math.cos(rotation);
                sin = Math.sin(rotation);
              }
              var center = this.center;
              transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
              transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
              transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
              _uvA.set(0, 0);
              _uvB.set(1, 0);
              _uvC.set(1, 1);

              // check first triangle
              var intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
              if (intersect === null) {
                // check second triangle
                transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                _uvB.set(0, 1);
                intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
                if (intersect === null) {
                  return;
                }
              }
              var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
              if (distance < raycaster.near || distance > raycaster.far) return;
              intersects.push({
                distance: distance,
                point: _intersectPoint.clone(),
                uv: Triangle.getInterpolation(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
                face: null,
                object: this
              });
            }
          }, {
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(Sprite, "copy", this, 3)([source, recursive]);
              if (source.center !== undefined) this.center.copy(source.center);
              this.material = source.material;
              return this;
            }
          }]);
        }(Object3D);
        function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
          // compute position in camera space
          _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);

          // to check if rotation is not zero
          if (sin !== undefined) {
            _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
            _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
          } else {
            _rotatedPosition.copy(_alignedPosition);
          }
          vertexPosition.copy(mvPosition);
          vertexPosition.x += _rotatedPosition.x;
          vertexPosition.y += _rotatedPosition.y;

          // transform to world space
          vertexPosition.applyMatrix4(_viewWorldMatrix);
        }
        var _v1$2 = /*@__PURE__*/new Vector3();
        var _v2$1 = /*@__PURE__*/new Vector3();
        var LOD = /*#__PURE__*/function (_Object3D7) {
          function LOD() {
            var _this46;
            _classCallCheck2(this, LOD);
            _this46 = _callSuper(this, LOD);
            _this46._currentLevel = 0;
            _this46.type = 'LOD';
            Object.defineProperties(_this46, {
              levels: {
                enumerable: true,
                value: []
              },
              isLOD: {
                value: true
              }
            });
            _this46.autoUpdate = true;
            return _this46;
          }
          _inherits(LOD, _Object3D7);
          return _createClass(LOD, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(LOD, "copy", this, 3)([source, false]);
              var levels = source.levels;
              for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                this.addLevel(level.object.clone(), level.distance, level.hysteresis);
              }
              this.autoUpdate = source.autoUpdate;
              return this;
            }
          }, {
            key: "addLevel",
            value: function addLevel(object) {
              var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var hysteresis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              distance = Math.abs(distance);
              var levels = this.levels;
              var l;
              for (l = 0; l < levels.length; l++) {
                if (distance < levels[l].distance) {
                  break;
                }
              }
              levels.splice(l, 0, {
                distance: distance,
                hysteresis: hysteresis,
                object: object
              });
              this.add(object);
              return this;
            }
          }, {
            key: "getCurrentLevel",
            value: function getCurrentLevel() {
              return this._currentLevel;
            }
          }, {
            key: "getObjectForDistance",
            value: function getObjectForDistance(distance) {
              var levels = this.levels;
              if (levels.length > 0) {
                var i, l;
                for (i = 1, l = levels.length; i < l; i++) {
                  var levelDistance = levels[i].distance;
                  if (levels[i].object.visible) {
                    levelDistance -= levelDistance * levels[i].hysteresis;
                  }
                  if (distance < levelDistance) {
                    break;
                  }
                }
                return levels[i - 1].object;
              }
              return null;
            }
          }, {
            key: "raycast",
            value: function raycast(raycaster, intersects) {
              var levels = this.levels;
              if (levels.length > 0) {
                _v1$2.setFromMatrixPosition(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(_v1$2);
                this.getObjectForDistance(distance).raycast(raycaster, intersects);
              }
            }
          }, {
            key: "update",
            value: function update(camera) {
              var levels = this.levels;
              if (levels.length > 1) {
                _v1$2.setFromMatrixPosition(camera.matrixWorld);
                _v2$1.setFromMatrixPosition(this.matrixWorld);
                var distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
                levels[0].object.visible = true;
                var i, l;
                for (i = 1, l = levels.length; i < l; i++) {
                  var levelDistance = levels[i].distance;
                  if (levels[i].object.visible) {
                    levelDistance -= levelDistance * levels[i].hysteresis;
                  }
                  if (distance >= levelDistance) {
                    levels[i - 1].object.visible = false;
                    levels[i].object.visible = true;
                  } else {
                    break;
                  }
                }
                this._currentLevel = i - 1;
                for (; i < l; i++) {
                  levels[i].object.visible = false;
                }
              }
            }
          }, {
            key: "toJSON",
            value: function toJSON(meta) {
              var data = _superPropGet(LOD, "toJSON", this, 3)([meta]);
              if (this.autoUpdate === false) data.object.autoUpdate = false;
              data.object.levels = [];
              var levels = this.levels;
              for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                data.object.levels.push({
                  object: level.object.uuid,
                  distance: level.distance,
                  hysteresis: level.hysteresis
                });
              }
              return data;
            }
          }]);
        }(Object3D);
        var _basePosition = /*@__PURE__*/new Vector3();
        var _skinIndex = /*@__PURE__*/new Vector4();
        var _skinWeight = /*@__PURE__*/new Vector4();
        var _vector3 = /*@__PURE__*/new Vector3();
        var _matrix4 = /*@__PURE__*/new Matrix4();
        var _vertex = /*@__PURE__*/new Vector3();
        var _sphere$4 = /*@__PURE__*/new Sphere();
        var _inverseMatrix$2 = /*@__PURE__*/new Matrix4();
        var _ray$2 = /*@__PURE__*/new Ray();
        var SkinnedMesh = /*#__PURE__*/function (_Mesh) {
          function SkinnedMesh(geometry, material) {
            var _this47;
            _classCallCheck2(this, SkinnedMesh);
            _this47 = _callSuper(this, SkinnedMesh, [geometry, material]);
            _this47.isSkinnedMesh = true;
            _this47.type = 'SkinnedMesh';
            _this47.bindMode = AttachedBindMode;
            _this47.bindMatrix = new Matrix4();
            _this47.bindMatrixInverse = new Matrix4();
            _this47.boundingBox = null;
            _this47.boundingSphere = null;
            return _this47;
          }
          _inherits(SkinnedMesh, _Mesh);
          return _createClass(SkinnedMesh, [{
            key: "computeBoundingBox",
            value: function computeBoundingBox() {
              var geometry = this.geometry;
              if (this.boundingBox === null) {
                this.boundingBox = new Box3();
              }
              this.boundingBox.makeEmpty();
              var positionAttribute = geometry.getAttribute('position');
              for (var i = 0; i < positionAttribute.count; i++) {
                this.getVertexPosition(i, _vertex);
                this.boundingBox.expandByPoint(_vertex);
              }
            }
          }, {
            key: "computeBoundingSphere",
            value: function computeBoundingSphere() {
              var geometry = this.geometry;
              if (this.boundingSphere === null) {
                this.boundingSphere = new Sphere();
              }
              this.boundingSphere.makeEmpty();
              var positionAttribute = geometry.getAttribute('position');
              for (var i = 0; i < positionAttribute.count; i++) {
                this.getVertexPosition(i, _vertex);
                this.boundingSphere.expandByPoint(_vertex);
              }
            }
          }, {
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(SkinnedMesh, "copy", this, 3)([source, recursive]);
              this.bindMode = source.bindMode;
              this.bindMatrix.copy(source.bindMatrix);
              this.bindMatrixInverse.copy(source.bindMatrixInverse);
              this.skeleton = source.skeleton;
              if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
              if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
              return this;
            }
          }, {
            key: "raycast",
            value: function raycast(raycaster, intersects) {
              var material = this.material;
              var matrixWorld = this.matrixWorld;
              if (material === undefined) return;

              // test with bounding sphere in world space

              if (this.boundingSphere === null) this.computeBoundingSphere();
              _sphere$4.copy(this.boundingSphere);
              _sphere$4.applyMatrix4(matrixWorld);
              if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;

              // convert ray to local space of skinned mesh

              _inverseMatrix$2.copy(matrixWorld).invert();
              _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);

              // test with bounding box in local space

              if (this.boundingBox !== null) {
                if (_ray$2.intersectsBox(this.boundingBox) === false) return;
              }

              // test for intersections with geometry

              this._computeIntersections(raycaster, intersects, _ray$2);
            }
          }, {
            key: "getVertexPosition",
            value: function getVertexPosition(index, target) {
              _superPropGet(SkinnedMesh, "getVertexPosition", this, 3)([index, target]);
              this.applyBoneTransform(index, target);
              return target;
            }
          }, {
            key: "bind",
            value: function bind(skeleton, bindMatrix) {
              this.skeleton = skeleton;
              if (bindMatrix === undefined) {
                this.updateMatrixWorld(true);
                this.skeleton.calculateInverses();
                bindMatrix = this.matrixWorld;
              }
              this.bindMatrix.copy(bindMatrix);
              this.bindMatrixInverse.copy(bindMatrix).invert();
            }
          }, {
            key: "pose",
            value: function pose() {
              this.skeleton.pose();
            }
          }, {
            key: "normalizeSkinWeights",
            value: function normalizeSkinWeights() {
              var vector = new Vector4();
              var skinWeight = this.geometry.attributes.skinWeight;
              for (var i = 0, l = skinWeight.count; i < l; i++) {
                vector.fromBufferAttribute(skinWeight, i);
                var scale = 1.0 / vector.manhattanLength();
                if (scale !== Infinity) {
                  vector.multiplyScalar(scale);
                } else {
                  vector.set(1, 0, 0, 0); // do something reasonable
                }
                skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
              }
            }
          }, {
            key: "updateMatrixWorld",
            value: function updateMatrixWorld(force) {
              _superPropGet(SkinnedMesh, "updateMatrixWorld", this, 3)([force]);
              if (this.bindMode === AttachedBindMode) {
                this.bindMatrixInverse.copy(this.matrixWorld).invert();
              } else if (this.bindMode === DetachedBindMode) {
                this.bindMatrixInverse.copy(this.bindMatrix).invert();
              } else {
                console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
              }
            }
          }, {
            key: "applyBoneTransform",
            value: function applyBoneTransform(index, vector) {
              var skeleton = this.skeleton;
              var geometry = this.geometry;
              _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
              _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
              _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
              vector.set(0, 0, 0);
              for (var i = 0; i < 4; i++) {
                var weight = _skinWeight.getComponent(i);
                if (weight !== 0) {
                  var boneIndex = _skinIndex.getComponent(i);
                  _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
                  vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
                }
              }
              return vector.applyMatrix4(this.bindMatrixInverse);
            }
          }]);
        }(Mesh);
        var Bone = /*#__PURE__*/function (_Object3D8) {
          function Bone() {
            var _this48;
            _classCallCheck2(this, Bone);
            _this48 = _callSuper(this, Bone);
            _this48.isBone = true;
            _this48.type = 'Bone';
            return _this48;
          }
          _inherits(Bone, _Object3D8);
          return _createClass(Bone);
        }(Object3D);
        var DataTexture = /*#__PURE__*/function (_Texture5) {
          function DataTexture() {
            var _this49;
            var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var format = arguments.length > 3 ? arguments[3] : undefined;
            var type = arguments.length > 4 ? arguments[4] : undefined;
            var mapping = arguments.length > 5 ? arguments[5] : undefined;
            var wrapS = arguments.length > 6 ? arguments[6] : undefined;
            var wrapT = arguments.length > 7 ? arguments[7] : undefined;
            var magFilter = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : NearestFilter;
            var minFilter = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : NearestFilter;
            var anisotropy = arguments.length > 10 ? arguments[10] : undefined;
            var colorSpace = arguments.length > 11 ? arguments[11] : undefined;
            _classCallCheck2(this, DataTexture);
            _this49 = _callSuper(this, DataTexture, [null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace]);
            _this49.isDataTexture = true;
            _this49.image = {
              data: data,
              width: width,
              height: height
            };
            _this49.generateMipmaps = false;
            _this49.flipY = false;
            _this49.unpackAlignment = 1;
            return _this49;
          }
          _inherits(DataTexture, _Texture5);
          return _createClass(DataTexture);
        }(Texture);
        var _offsetMatrix = /*@__PURE__*/new Matrix4();
        var _identityMatrix$1 = /*@__PURE__*/new Matrix4();
        var Skeleton = /*#__PURE__*/function () {
          function Skeleton() {
            var bones = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var boneInverses = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            _classCallCheck2(this, Skeleton);
            this.uuid = generateUUID();
            this.bones = bones.slice(0);
            this.boneInverses = boneInverses;
            this.boneMatrices = null;
            this.boneTexture = null;
            this.init();
          }
          return _createClass(Skeleton, [{
            key: "init",
            value: function init() {
              var bones = this.bones;
              var boneInverses = this.boneInverses;
              this.boneMatrices = new Float32Array(bones.length * 16);

              // calculate inverse bone matrices if necessary

              if (boneInverses.length === 0) {
                this.calculateInverses();
              } else {
                // handle special case

                if (bones.length !== boneInverses.length) {
                  console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
                  this.boneInverses = [];
                  for (var i = 0, il = this.bones.length; i < il; i++) {
                    this.boneInverses.push(new Matrix4());
                  }
                }
              }
            }
          }, {
            key: "calculateInverses",
            value: function calculateInverses() {
              this.boneInverses.length = 0;
              for (var i = 0, il = this.bones.length; i < il; i++) {
                var inverse = new Matrix4();
                if (this.bones[i]) {
                  inverse.copy(this.bones[i].matrixWorld).invert();
                }
                this.boneInverses.push(inverse);
              }
            }
          }, {
            key: "pose",
            value: function pose() {
              // recover the bind-time world matrices

              for (var i = 0, il = this.bones.length; i < il; i++) {
                var bone = this.bones[i];
                if (bone) {
                  bone.matrixWorld.copy(this.boneInverses[i]).invert();
                }
              }

              // compute the local matrices, positions, rotations and scales

              for (var _i66 = 0, _il13 = this.bones.length; _i66 < _il13; _i66++) {
                var _bone = this.bones[_i66];
                if (_bone) {
                  if (_bone.parent && _bone.parent.isBone) {
                    _bone.matrix.copy(_bone.parent.matrixWorld).invert();
                    _bone.matrix.multiply(_bone.matrixWorld);
                  } else {
                    _bone.matrix.copy(_bone.matrixWorld);
                  }
                  _bone.matrix.decompose(_bone.position, _bone.quaternion, _bone.scale);
                }
              }
            }
          }, {
            key: "update",
            value: function update() {
              var bones = this.bones;
              var boneInverses = this.boneInverses;
              var boneMatrices = this.boneMatrices;
              var boneTexture = this.boneTexture;

              // flatten bone matrices to array

              for (var i = 0, il = bones.length; i < il; i++) {
                // compute the offset between the current and the original transform

                var matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix$1;
                _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
                _offsetMatrix.toArray(boneMatrices, i * 16);
              }
              if (boneTexture !== null) {
                boneTexture.needsUpdate = true;
              }
            }
          }, {
            key: "clone",
            value: function clone() {
              return new Skeleton(this.bones, this.boneInverses);
            }
          }, {
            key: "computeBoneTexture",
            value: function computeBoneTexture() {
              // layout (1 matrix = 4 pixels)
              //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
              //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
              //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
              //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
              //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

              var size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
              size = Math.ceil(size / 4) * 4;
              size = Math.max(size, 4);
              var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
              boneMatrices.set(this.boneMatrices); // copy current values

              var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
              boneTexture.needsUpdate = true;
              this.boneMatrices = boneMatrices;
              this.boneTexture = boneTexture;
              return this;
            }
          }, {
            key: "getBoneByName",
            value: function getBoneByName(name) {
              for (var i = 0, il = this.bones.length; i < il; i++) {
                var bone = this.bones[i];
                if (bone.name === name) {
                  return bone;
                }
              }
              return undefined;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              if (this.boneTexture !== null) {
                this.boneTexture.dispose();
                this.boneTexture = null;
              }
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json, bones) {
              this.uuid = json.uuid;
              for (var i = 0, l = json.bones.length; i < l; i++) {
                var uuid = json.bones[i];
                var bone = bones[uuid];
                if (bone === undefined) {
                  console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
                  bone = new Bone();
                }
                this.bones.push(bone);
                this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
              }
              this.init();
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = {
                metadata: {
                  version: 4.6,
                  type: 'Skeleton',
                  generator: 'Skeleton.toJSON'
                },
                bones: [],
                boneInverses: []
              };
              data.uuid = this.uuid;
              var bones = this.bones;
              var boneInverses = this.boneInverses;
              for (var i = 0, l = bones.length; i < l; i++) {
                var bone = bones[i];
                data.bones.push(bone.uuid);
                var boneInverse = boneInverses[i];
                data.boneInverses.push(boneInverse.toArray());
              }
              return data;
            }
          }]);
        }();
        var InstancedBufferAttribute = /*#__PURE__*/function (_BufferAttribute10) {
          function InstancedBufferAttribute(array, itemSize, normalized) {
            var _this50;
            var meshPerAttribute = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            _classCallCheck2(this, InstancedBufferAttribute);
            _this50 = _callSuper(this, InstancedBufferAttribute, [array, itemSize, normalized]);
            _this50.isInstancedBufferAttribute = true;
            _this50.meshPerAttribute = meshPerAttribute;
            return _this50;
          }
          _inherits(InstancedBufferAttribute, _BufferAttribute10);
          return _createClass(InstancedBufferAttribute, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(InstancedBufferAttribute, "copy", this, 3)([source]);
              this.meshPerAttribute = source.meshPerAttribute;
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(InstancedBufferAttribute, "toJSON", this, 3)([]);
              data.meshPerAttribute = this.meshPerAttribute;
              data.isInstancedBufferAttribute = true;
              return data;
            }
          }]);
        }(BufferAttribute);
        var _instanceLocalMatrix = /*@__PURE__*/new Matrix4();
        var _instanceWorldMatrix = /*@__PURE__*/new Matrix4();
        var _instanceIntersects = [];
        var _box3 = /*@__PURE__*/new Box3();
        var _identity = /*@__PURE__*/new Matrix4();
        var _mesh$1 = /*@__PURE__*/new Mesh();
        var _sphere$3 = /*@__PURE__*/new Sphere();
        var InstancedMesh = /*#__PURE__*/function (_Mesh2) {
          function InstancedMesh(geometry, material, count) {
            var _this51;
            _classCallCheck2(this, InstancedMesh);
            _this51 = _callSuper(this, InstancedMesh, [geometry, material]);
            _this51.isInstancedMesh = true;
            _this51.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
            _this51.instanceColor = null;
            _this51.morphTexture = null;
            _this51.count = count;
            _this51.boundingBox = null;
            _this51.boundingSphere = null;
            for (var i = 0; i < count; i++) {
              _this51.setMatrixAt(i, _identity);
            }
            return _this51;
          }
          _inherits(InstancedMesh, _Mesh2);
          return _createClass(InstancedMesh, [{
            key: "computeBoundingBox",
            value: function computeBoundingBox() {
              var geometry = this.geometry;
              var count = this.count;
              if (this.boundingBox === null) {
                this.boundingBox = new Box3();
              }
              if (geometry.boundingBox === null) {
                geometry.computeBoundingBox();
              }
              this.boundingBox.makeEmpty();
              for (var i = 0; i < count; i++) {
                this.getMatrixAt(i, _instanceLocalMatrix);
                _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
                this.boundingBox.union(_box3);
              }
            }
          }, {
            key: "computeBoundingSphere",
            value: function computeBoundingSphere() {
              var geometry = this.geometry;
              var count = this.count;
              if (this.boundingSphere === null) {
                this.boundingSphere = new Sphere();
              }
              if (geometry.boundingSphere === null) {
                geometry.computeBoundingSphere();
              }
              this.boundingSphere.makeEmpty();
              for (var i = 0; i < count; i++) {
                this.getMatrixAt(i, _instanceLocalMatrix);
                _sphere$3.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
                this.boundingSphere.union(_sphere$3);
              }
            }
          }, {
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(InstancedMesh, "copy", this, 3)([source, recursive]);
              this.instanceMatrix.copy(source.instanceMatrix);
              if (source.morphTexture !== null) this.morphTexture = source.morphTexture.clone();
              if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
              this.count = source.count;
              if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
              if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
              return this;
            }
          }, {
            key: "getColorAt",
            value: function getColorAt(index, color) {
              color.fromArray(this.instanceColor.array, index * 3);
            }
          }, {
            key: "getMatrixAt",
            value: function getMatrixAt(index, matrix) {
              matrix.fromArray(this.instanceMatrix.array, index * 16);
            }
          }, {
            key: "getMorphAt",
            value: function getMorphAt(index, object) {
              var objectInfluences = object.morphTargetInfluences;
              var array = this.morphTexture.source.data.data;
              var len = objectInfluences.length + 1; // All influences + the baseInfluenceSum

              var dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning

              for (var i = 0; i < objectInfluences.length; i++) {
                objectInfluences[i] = array[dataIndex + i];
              }
            }
          }, {
            key: "raycast",
            value: function raycast(raycaster, intersects) {
              var matrixWorld = this.matrixWorld;
              var raycastTimes = this.count;
              _mesh$1.geometry = this.geometry;
              _mesh$1.material = this.material;
              if (_mesh$1.material === undefined) return;

              // test with bounding sphere first

              if (this.boundingSphere === null) this.computeBoundingSphere();
              _sphere$3.copy(this.boundingSphere);
              _sphere$3.applyMatrix4(matrixWorld);
              if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;

              // now test each instance

              for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {
                // calculate the world matrix for each instance

                this.getMatrixAt(instanceId, _instanceLocalMatrix);
                _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);

                // the mesh represents this single instance

                _mesh$1.matrixWorld = _instanceWorldMatrix;
                _mesh$1.raycast(raycaster, _instanceIntersects);

                // process the result of raycast

                for (var i = 0, l = _instanceIntersects.length; i < l; i++) {
                  var _intersect = _instanceIntersects[i];
                  _intersect.instanceId = instanceId;
                  _intersect.object = this;
                  intersects.push(_intersect);
                }
                _instanceIntersects.length = 0;
              }
            }
          }, {
            key: "setColorAt",
            value: function setColorAt(index, color) {
              if (this.instanceColor === null) {
                this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
              }
              color.toArray(this.instanceColor.array, index * 3);
            }
          }, {
            key: "setMatrixAt",
            value: function setMatrixAt(index, matrix) {
              matrix.toArray(this.instanceMatrix.array, index * 16);
            }
          }, {
            key: "setMorphAt",
            value: function setMorphAt(index, object) {
              var objectInfluences = object.morphTargetInfluences;
              var len = objectInfluences.length + 1; // morphBaseInfluence + all influences

              if (this.morphTexture === null) {
                this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType);
              }
              var array = this.morphTexture.source.data.data;
              var morphInfluencesSum = 0;
              for (var i = 0; i < objectInfluences.length; i++) {
                morphInfluencesSum += objectInfluences[i];
              }
              var morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
              var dataIndex = len * index;
              array[dataIndex] = morphBaseInfluence;
              array.set(objectInfluences, dataIndex + 1);
            }
          }, {
            key: "updateMorphTargets",
            value: function updateMorphTargets() {}
          }, {
            key: "dispose",
            value: function dispose() {
              this.dispatchEvent({
                type: 'dispose'
              });
              if (this.morphTexture !== null) {
                this.morphTexture.dispose();
                this.morphTexture = null;
              }
              return this;
            }
          }]);
        }(Mesh);
        function sortOpaque(a, b) {
          return a.z - b.z;
        }
        function sortTransparent(a, b) {
          return b.z - a.z;
        }
        var MultiDrawRenderList = /*#__PURE__*/function () {
          function MultiDrawRenderList() {
            _classCallCheck2(this, MultiDrawRenderList);
            this.index = 0;
            this.pool = [];
            this.list = [];
          }
          return _createClass(MultiDrawRenderList, [{
            key: "push",
            value: function push(drawRange, z, index) {
              var pool = this.pool;
              var list = this.list;
              if (this.index >= pool.length) {
                pool.push({
                  start: -1,
                  count: -1,
                  z: -1,
                  index: -1
                });
              }
              var item = pool[this.index];
              list.push(item);
              this.index++;
              item.start = drawRange.start;
              item.count = drawRange.count;
              item.z = z;
              item.index = index;
            }
          }, {
            key: "reset",
            value: function reset() {
              this.list.length = 0;
              this.index = 0;
            }
          }]);
        }();
        var _matrix$1 = /*@__PURE__*/new Matrix4();
        var _invMatrixWorld = /*@__PURE__*/new Matrix4();
        var _identityMatrix = /*@__PURE__*/new Matrix4();
        var _whiteColor = /*@__PURE__*/new Color(1, 1, 1);
        var _projScreenMatrix$2 = /*@__PURE__*/new Matrix4();
        var _frustum = /*@__PURE__*/new Frustum();
        var _box$1 = /*@__PURE__*/new Box3();
        var _sphere$2 = /*@__PURE__*/new Sphere();
        var _vector$5 = /*@__PURE__*/new Vector3();
        var _forward = /*@__PURE__*/new Vector3();
        var _temp = /*@__PURE__*/new Vector3();
        var _renderList = /*@__PURE__*/new MultiDrawRenderList();
        var _mesh = /*@__PURE__*/new Mesh();
        var _batchIntersects = [];

        // @TODO: SkinnedMesh support?
        // @TODO: geometry.groups support?
        // @TODO: geometry.drawRange support?
        // @TODO: geometry.morphAttributes support?
        // @TODO: Support uniform parameter per geometry
        // @TODO: Add an "optimize" function to pack geometry and remove data gaps

        // copies data from attribute "src" into "target" starting at "targetOffset"
        function copyAttributeData(src, target) {
          var targetOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          var itemSize = target.itemSize;
          if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {
            // use the component getters and setters if the array data cannot
            // be copied directly
            var vertexCount = src.count;
            for (var i = 0; i < vertexCount; i++) {
              for (var _c11 = 0; _c11 < itemSize; _c11++) {
                target.setComponent(i + targetOffset, _c11, src.getComponent(i, _c11));
              }
            }
          } else {
            // faster copy approach using typed array set function
            target.array.set(src.array, targetOffset * itemSize);
          }
          target.needsUpdate = true;
        }
        var BatchedMesh = /*#__PURE__*/function (_Mesh3) {
          function BatchedMesh(maxInstanceCount, maxVertexCount) {
            var _this52;
            var maxIndexCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : maxVertexCount * 2;
            var material = arguments.length > 3 ? arguments[3] : undefined;
            _classCallCheck2(this, BatchedMesh);
            _this52 = _callSuper(this, BatchedMesh, [new BufferGeometry(), material]);
            _this52.isBatchedMesh = true;
            _this52.perObjectFrustumCulled = true;
            _this52.sortObjects = true;
            _this52.boundingBox = null;
            _this52.boundingSphere = null;
            _this52.customSort = null;

            // stores visible, active, and geometry id per object
            _this52._drawInfo = [];

            // geometry information
            _this52._drawRanges = [];
            _this52._reservedRanges = [];
            _this52._bounds = [];
            _this52._maxInstanceCount = maxInstanceCount;
            _this52._maxVertexCount = maxVertexCount;
            _this52._maxIndexCount = maxIndexCount;
            _this52._geometryInitialized = false;
            _this52._geometryCount = 0;
            _this52._multiDrawCounts = new Int32Array(maxInstanceCount);
            _this52._multiDrawStarts = new Int32Array(maxInstanceCount);
            _this52._multiDrawCount = 0;
            _this52._multiDrawInstances = null;
            _this52._visibilityChanged = true;

            // Local matrix per geometry by using data texture
            _this52._matricesTexture = null;
            _this52._indirectTexture = null;
            _this52._colorsTexture = null;
            _this52._initMatricesTexture();
            _this52._initIndirectTexture();
            return _this52;
          }
          _inherits(BatchedMesh, _Mesh3);
          return _createClass(BatchedMesh, [{
            key: "maxInstanceCount",
            get: function get() {
              return this._maxInstanceCount;
            }
          }, {
            key: "_initMatricesTexture",
            value: function _initMatricesTexture() {
              // layout (1 matrix = 4 pixels)
              //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
              //  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)
              //       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)
              //       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)
              //       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)

              var size = Math.sqrt(this._maxInstanceCount * 4); // 4 pixels needed for 1 matrix
              size = Math.ceil(size / 4) * 4;
              size = Math.max(size, 4);
              var matricesArray = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
              var matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);
              this._matricesTexture = matricesTexture;
            }
          }, {
            key: "_initIndirectTexture",
            value: function _initIndirectTexture() {
              var size = Math.sqrt(this._maxInstanceCount);
              size = Math.ceil(size);
              var indirectArray = new Uint32Array(size * size);
              var indirectTexture = new DataTexture(indirectArray, size, size, RedIntegerFormat, UnsignedIntType);
              this._indirectTexture = indirectTexture;
            }
          }, {
            key: "_initColorsTexture",
            value: function _initColorsTexture() {
              var size = Math.sqrt(this._maxIndexCount);
              size = Math.ceil(size);

              // 4 floats per RGBA pixel initialized to white
              var colorsArray = new Float32Array(size * size * 4).fill(1);
              var colorsTexture = new DataTexture(colorsArray, size, size, RGBAFormat, FloatType);
              colorsTexture.colorSpace = ColorManagement.workingColorSpace;
              this._colorsTexture = colorsTexture;
            }
          }, {
            key: "_initializeGeometry",
            value: function _initializeGeometry(reference) {
              var geometry = this.geometry;
              var maxVertexCount = this._maxVertexCount;
              var maxIndexCount = this._maxIndexCount;
              if (this._geometryInitialized === false) {
                for (var attributeName in reference.attributes) {
                  var srcAttribute = reference.getAttribute(attributeName);
                  var array = srcAttribute.array,
                    itemSize = srcAttribute.itemSize,
                    normalized = srcAttribute.normalized;
                  var dstArray = new array.constructor(maxVertexCount * itemSize);
                  var dstAttribute = new BufferAttribute(dstArray, itemSize, normalized);
                  geometry.setAttribute(attributeName, dstAttribute);
                }
                if (reference.getIndex() !== null) {
                  // Reserve last u16 index for primitive restart.
                  var indexArray = maxVertexCount > 65535 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);
                  geometry.setIndex(new BufferAttribute(indexArray, 1));
                }
                this._geometryInitialized = true;
              }
            }

            // Make sure the geometry is compatible with the existing combined geometry attributes
          }, {
            key: "_validateGeometry",
            value: function _validateGeometry(geometry) {
              // check to ensure the geometries are using consistent attributes and indices
              var batchGeometry = this.geometry;
              if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {
                throw new Error('BatchedMesh: All geometries must consistently have "index".');
              }
              for (var attributeName in batchGeometry.attributes) {
                if (!geometry.hasAttribute(attributeName)) {
                  throw new Error("BatchedMesh: Added geometry missing \"".concat(attributeName, "\". All geometries must have consistent attributes."));
                }
                var srcAttribute = geometry.getAttribute(attributeName);
                var dstAttribute = batchGeometry.getAttribute(attributeName);
                if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {
                  throw new Error('BatchedMesh: All attributes must have a consistent itemSize and normalized value.');
                }
              }
            }
          }, {
            key: "setCustomSort",
            value: function setCustomSort(func) {
              this.customSort = func;
              return this;
            }
          }, {
            key: "computeBoundingBox",
            value: function computeBoundingBox() {
              if (this.boundingBox === null) {
                this.boundingBox = new Box3();
              }
              var geometryCount = this._geometryCount;
              var boundingBox = this.boundingBox;
              var drawInfo = this._drawInfo;
              boundingBox.makeEmpty();
              for (var i = 0; i < geometryCount; i++) {
                if (drawInfo[i].active === false) continue;
                var geometryId = drawInfo[i].geometryIndex;
                this.getMatrixAt(i, _matrix$1);
                this.getBoundingBoxAt(geometryId, _box$1).applyMatrix4(_matrix$1);
                boundingBox.union(_box$1);
              }
            }
          }, {
            key: "computeBoundingSphere",
            value: function computeBoundingSphere() {
              if (this.boundingSphere === null) {
                this.boundingSphere = new Sphere();
              }
              var boundingSphere = this.boundingSphere;
              var drawInfo = this._drawInfo;
              boundingSphere.makeEmpty();
              for (var i = 0, l = drawInfo.length; i < l; i++) {
                if (drawInfo[i].active === false) continue;
                var geometryId = drawInfo[i].geometryIndex;
                this.getMatrixAt(i, _matrix$1);
                this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
                boundingSphere.union(_sphere$2);
              }
            }
          }, {
            key: "addInstance",
            value: function addInstance(geometryId) {
              // ensure we're not over geometry
              if (this._drawInfo.length >= this._maxInstanceCount) {
                throw new Error('BatchedMesh: Maximum item count reached.');
              }
              this._drawInfo.push({
                visible: true,
                active: true,
                geometryIndex: geometryId
              });

              // initialize the matrix
              var drawId = this._drawInfo.length - 1;
              var matricesTexture = this._matricesTexture;
              var matricesArray = matricesTexture.image.data;
              _identityMatrix.toArray(matricesArray, drawId * 16);
              matricesTexture.needsUpdate = true;
              var colorsTexture = this._colorsTexture;
              if (colorsTexture) {
                _whiteColor.toArray(colorsTexture.image.data, drawId * 4);
                colorsTexture.needsUpdate = true;
              }
              return drawId;
            }
          }, {
            key: "addGeometry",
            value: function addGeometry(geometry) {
              var vertexCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
              var indexCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
              this._initializeGeometry(geometry);
              this._validateGeometry(geometry);

              // ensure we're not over geometry
              if (this._drawInfo.length >= this._maxInstanceCount) {
                throw new Error('BatchedMesh: Maximum item count reached.');
              }

              // get the necessary range fo the geometry
              var reservedRange = {
                vertexStart: -1,
                vertexCount: -1,
                indexStart: -1,
                indexCount: -1
              };
              var lastRange = null;
              var reservedRanges = this._reservedRanges;
              var drawRanges = this._drawRanges;
              var bounds = this._bounds;
              if (this._geometryCount !== 0) {
                lastRange = reservedRanges[reservedRanges.length - 1];
              }
              if (vertexCount === -1) {
                reservedRange.vertexCount = geometry.getAttribute('position').count;
              } else {
                reservedRange.vertexCount = vertexCount;
              }
              if (lastRange === null) {
                reservedRange.vertexStart = 0;
              } else {
                reservedRange.vertexStart = lastRange.vertexStart + lastRange.vertexCount;
              }
              var index = geometry.getIndex();
              var hasIndex = index !== null;
              if (hasIndex) {
                if (indexCount === -1) {
                  reservedRange.indexCount = index.count;
                } else {
                  reservedRange.indexCount = indexCount;
                }
                if (lastRange === null) {
                  reservedRange.indexStart = 0;
                } else {
                  reservedRange.indexStart = lastRange.indexStart + lastRange.indexCount;
                }
              }
              if (reservedRange.indexStart !== -1 && reservedRange.indexStart + reservedRange.indexCount > this._maxIndexCount || reservedRange.vertexStart + reservedRange.vertexCount > this._maxVertexCount) {
                throw new Error('BatchedMesh: Reserved space request exceeds the maximum buffer size.');
              }

              // update id
              var geometryId = this._geometryCount;
              this._geometryCount++;

              // add the reserved range and draw range objects
              reservedRanges.push(reservedRange);
              drawRanges.push({
                start: hasIndex ? reservedRange.indexStart : reservedRange.vertexStart,
                count: -1
              });
              bounds.push({
                boxInitialized: false,
                box: new Box3(),
                sphereInitialized: false,
                sphere: new Sphere()
              });

              // update the geometry
              this.setGeometryAt(geometryId, geometry);
              return geometryId;
            }
          }, {
            key: "setGeometryAt",
            value: function setGeometryAt(geometryId, geometry) {
              if (geometryId >= this._geometryCount) {
                throw new Error('BatchedMesh: Maximum geometry count reached.');
              }
              this._validateGeometry(geometry);
              var batchGeometry = this.geometry;
              var hasIndex = batchGeometry.getIndex() !== null;
              var dstIndex = batchGeometry.getIndex();
              var srcIndex = geometry.getIndex();
              var reservedRange = this._reservedRanges[geometryId];
              if (hasIndex && srcIndex.count > reservedRange.indexCount || geometry.attributes.position.count > reservedRange.vertexCount) {
                throw new Error('BatchedMesh: Reserved space not large enough for provided geometry.');
              }

              // copy geometry over
              var vertexStart = reservedRange.vertexStart;
              var vertexCount = reservedRange.vertexCount;
              for (var attributeName in batchGeometry.attributes) {
                // copy attribute data
                var srcAttribute = geometry.getAttribute(attributeName);
                var dstAttribute = batchGeometry.getAttribute(attributeName);
                copyAttributeData(srcAttribute, dstAttribute, vertexStart);

                // fill the rest in with zeroes
                var itemSize = srcAttribute.itemSize;
                for (var i = srcAttribute.count, l = vertexCount; i < l; i++) {
                  var _index10 = vertexStart + i;
                  for (var _c12 = 0; _c12 < itemSize; _c12++) {
                    dstAttribute.setComponent(_index10, _c12, 0);
                  }
                }
                dstAttribute.needsUpdate = true;
                dstAttribute.addUpdateRange(vertexStart * itemSize, vertexCount * itemSize);
              }

              // copy index
              if (hasIndex) {
                var indexStart = reservedRange.indexStart;

                // copy index data over
                for (var _i67 = 0; _i67 < srcIndex.count; _i67++) {
                  dstIndex.setX(indexStart + _i67, vertexStart + srcIndex.getX(_i67));
                }

                // fill the rest in with zeroes
                for (var _i68 = srcIndex.count, _l9 = reservedRange.indexCount; _i68 < _l9; _i68++) {
                  dstIndex.setX(indexStart + _i68, vertexStart);
                }
                dstIndex.needsUpdate = true;
                dstIndex.addUpdateRange(indexStart, reservedRange.indexCount);
              }

              // store the bounding boxes
              var bound = this._bounds[geometryId];
              if (geometry.boundingBox !== null) {
                bound.box.copy(geometry.boundingBox);
                bound.boxInitialized = true;
              } else {
                bound.boxInitialized = false;
              }
              if (geometry.boundingSphere !== null) {
                bound.sphere.copy(geometry.boundingSphere);
                bound.sphereInitialized = true;
              } else {
                bound.sphereInitialized = false;
              }

              // set drawRange count
              var drawRange = this._drawRanges[geometryId];
              var posAttr = geometry.getAttribute('position');
              drawRange.count = hasIndex ? srcIndex.count : posAttr.count;
              this._visibilityChanged = true;
              return geometryId;
            }

            /*
            deleteGeometry( geometryId ) {
            		// TODO: delete geometry and associated instances
            	}
            */

            /*
            deleteInstance( instanceId ) {
            		// Note: User needs to call optimize() afterward to pack the data.
            		const drawInfo = this._drawInfo;
            	if ( instanceId >= drawInfo.length || drawInfo[ instanceId ].active === false ) {
            			return this;
            		}
            		drawInfo[ instanceId ].active = false;
            	this._visibilityChanged = true;
            		return this;
            	}
            */

            // get bounding box and compute it if it doesn't exist
          }, {
            key: "getBoundingBoxAt",
            value: function getBoundingBoxAt(geometryId, target) {
              if (geometryId >= this._geometryCount) {
                return null;
              }

              // compute bounding box
              var bound = this._bounds[geometryId];
              var box = bound.box;
              var geometry = this.geometry;
              if (bound.boxInitialized === false) {
                box.makeEmpty();
                var _index11 = geometry.index;
                var position = geometry.attributes.position;
                var drawRange = this._drawRanges[geometryId];
                for (var i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i++) {
                  var iv = i;
                  if (_index11) {
                    iv = _index11.getX(iv);
                  }
                  box.expandByPoint(_vector$5.fromBufferAttribute(position, iv));
                }
                bound.boxInitialized = true;
              }
              target.copy(box);
              return target;
            }

            // get bounding sphere and compute it if it doesn't exist
          }, {
            key: "getBoundingSphereAt",
            value: function getBoundingSphereAt(geometryId, target) {
              if (geometryId >= this._geometryCount) {
                return null;
              }

              // compute bounding sphere
              var bound = this._bounds[geometryId];
              var sphere = bound.sphere;
              var geometry = this.geometry;
              if (bound.sphereInitialized === false) {
                sphere.makeEmpty();
                this.getBoundingBoxAt(geometryId, _box$1);
                _box$1.getCenter(sphere.center);
                var _index12 = geometry.index;
                var position = geometry.attributes.position;
                var drawRange = this._drawRanges[geometryId];
                var maxRadiusSq = 0;
                for (var i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i++) {
                  var iv = i;
                  if (_index12) {
                    iv = _index12.getX(iv);
                  }
                  _vector$5.fromBufferAttribute(position, iv);
                  maxRadiusSq = Math.max(maxRadiusSq, sphere.center.distanceToSquared(_vector$5));
                }
                sphere.radius = Math.sqrt(maxRadiusSq);
                bound.sphereInitialized = true;
              }
              target.copy(sphere);
              return target;
            }
          }, {
            key: "setMatrixAt",
            value: function setMatrixAt(instanceId, matrix) {
              // @TODO: Map geometryId to index of the arrays because
              //        optimize() can make geometryId mismatch the index

              var drawInfo = this._drawInfo;
              var matricesTexture = this._matricesTexture;
              var matricesArray = this._matricesTexture.image.data;
              if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
                return this;
              }
              matrix.toArray(matricesArray, instanceId * 16);
              matricesTexture.needsUpdate = true;
              return this;
            }
          }, {
            key: "getMatrixAt",
            value: function getMatrixAt(instanceId, matrix) {
              var drawInfo = this._drawInfo;
              var matricesArray = this._matricesTexture.image.data;
              if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
                return null;
              }
              return matrix.fromArray(matricesArray, instanceId * 16);
            }
          }, {
            key: "setColorAt",
            value: function setColorAt(instanceId, color) {
              if (this._colorsTexture === null) {
                this._initColorsTexture();
              }

              // @TODO: Map id to index of the arrays because
              //        optimize() can make id mismatch the index

              var colorsTexture = this._colorsTexture;
              var colorsArray = this._colorsTexture.image.data;
              var drawInfo = this._drawInfo;
              if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
                return this;
              }
              color.toArray(colorsArray, instanceId * 4);
              colorsTexture.needsUpdate = true;
              return this;
            }
          }, {
            key: "getColorAt",
            value: function getColorAt(instanceId, color) {
              var colorsArray = this._colorsTexture.image.data;
              var drawInfo = this._drawInfo;
              if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
                return null;
              }
              return color.fromArray(colorsArray, instanceId * 4);
            }
          }, {
            key: "setVisibleAt",
            value: function setVisibleAt(instanceId, value) {
              // if the geometry is out of range, not active, or visibility state
              // does not change then return early
              var drawInfo = this._drawInfo;
              if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false || drawInfo[instanceId].visible === value) {
                return this;
              }
              drawInfo[instanceId].visible = value;
              this._visibilityChanged = true;
              return this;
            }
          }, {
            key: "getVisibleAt",
            value: function getVisibleAt(instanceId) {
              // return early if the geometry is out of range or not active
              var drawInfo = this._drawInfo;
              if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
                return false;
              }
              return drawInfo[instanceId].visible;
            }
          }, {
            key: "raycast",
            value: function raycast(raycaster, intersects) {
              var drawInfo = this._drawInfo;
              var drawRanges = this._drawRanges;
              var matrixWorld = this.matrixWorld;
              var batchGeometry = this.geometry;

              // iterate over each geometry
              _mesh.material = this.material;
              _mesh.geometry.index = batchGeometry.index;
              _mesh.geometry.attributes = batchGeometry.attributes;
              if (_mesh.geometry.boundingBox === null) {
                _mesh.geometry.boundingBox = new Box3();
              }
              if (_mesh.geometry.boundingSphere === null) {
                _mesh.geometry.boundingSphere = new Sphere();
              }
              for (var i = 0, l = drawInfo.length; i < l; i++) {
                if (!drawInfo[i].visible || !drawInfo[i].active) {
                  continue;
                }
                var geometryId = drawInfo[i].geometryIndex;
                var drawRange = drawRanges[geometryId];
                _mesh.geometry.setDrawRange(drawRange.start, drawRange.count);

                // ge the intersects
                this.getMatrixAt(i, _mesh.matrixWorld).premultiply(matrixWorld);
                this.getBoundingBoxAt(geometryId, _mesh.geometry.boundingBox);
                this.getBoundingSphereAt(geometryId, _mesh.geometry.boundingSphere);
                _mesh.raycast(raycaster, _batchIntersects);

                // add batch id to the intersects
                for (var j = 0, _l10 = _batchIntersects.length; j < _l10; j++) {
                  var _intersect2 = _batchIntersects[j];
                  _intersect2.object = this;
                  _intersect2.batchId = i;
                  intersects.push(_intersect2);
                }
                _batchIntersects.length = 0;
              }
              _mesh.material = null;
              _mesh.geometry.index = null;
              _mesh.geometry.attributes = {};
              _mesh.geometry.setDrawRange(0, Infinity);
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(BatchedMesh, "copy", this, 3)([source]);
              this.geometry = source.geometry.clone();
              this.perObjectFrustumCulled = source.perObjectFrustumCulled;
              this.sortObjects = source.sortObjects;
              this.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;
              this.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;
              this._drawRanges = source._drawRanges.map(function (range) {
                return _objectSpread({}, range);
              });
              this._reservedRanges = source._reservedRanges.map(function (range) {
                return _objectSpread({}, range);
              });
              this._drawInfo = source._drawInfo.map(function (inf) {
                return _objectSpread({}, inf);
              });
              this._bounds = source._bounds.map(function (bound) {
                return {
                  boxInitialized: bound.boxInitialized,
                  box: bound.box.clone(),
                  sphereInitialized: bound.sphereInitialized,
                  sphere: bound.sphere.clone()
                };
              });
              this._maxInstanceCount = source._maxInstanceCount;
              this._maxVertexCount = source._maxVertexCount;
              this._maxIndexCount = source._maxIndexCount;
              this._geometryInitialized = source._geometryInitialized;
              this._geometryCount = source._geometryCount;
              this._multiDrawCounts = source._multiDrawCounts.slice();
              this._multiDrawStarts = source._multiDrawStarts.slice();
              this._matricesTexture = source._matricesTexture.clone();
              this._matricesTexture.image.data = this._matricesTexture.image.slice();
              if (this._colorsTexture !== null) {
                this._colorsTexture = source._colorsTexture.clone();
                this._colorsTexture.image.data = this._colorsTexture.image.slice();
              }
              return this;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              // Assuming the geometry is not shared with other meshes
              this.geometry.dispose();
              this._matricesTexture.dispose();
              this._matricesTexture = null;
              this._indirectTexture.dispose();
              this._indirectTexture = null;
              if (this._colorsTexture !== null) {
                this._colorsTexture.dispose();
                this._colorsTexture = null;
              }
              return this;
            }
          }, {
            key: "onBeforeRender",
            value: function onBeforeRender(renderer, scene, camera, geometry, material /*, _group*/) {
              // if visibility has not changed and frustum culling and object sorting is not required
              // then skip iterating over all items
              if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) {
                return;
              }

              // the indexed version of the multi draw function requires specifying the start
              // offset in bytes.
              var index = geometry.getIndex();
              var bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;
              var drawInfo = this._drawInfo;
              var multiDrawStarts = this._multiDrawStarts;
              var multiDrawCounts = this._multiDrawCounts;
              var drawRanges = this._drawRanges;
              var perObjectFrustumCulled = this.perObjectFrustumCulled;
              var indirectTexture = this._indirectTexture;
              var indirectArray = indirectTexture.image.data;

              // prepare the frustum in the local frame
              if (perObjectFrustumCulled) {
                _projScreenMatrix$2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse).multiply(this.matrixWorld);
                _frustum.setFromProjectionMatrix(_projScreenMatrix$2, renderer.coordinateSystem);
              }
              var count = 0;
              if (this.sortObjects) {
                // get the camera position in the local frame
                _invMatrixWorld.copy(this.matrixWorld).invert();
                _vector$5.setFromMatrixPosition(camera.matrixWorld).applyMatrix4(_invMatrixWorld);
                _forward.set(0, 0, -1).transformDirection(camera.matrixWorld).transformDirection(_invMatrixWorld);
                for (var i = 0, l = drawInfo.length; i < l; i++) {
                  if (drawInfo[i].visible && drawInfo[i].active) {
                    var geometryId = drawInfo[i].geometryIndex;

                    // get the bounds in world space
                    this.getMatrixAt(i, _matrix$1);
                    this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);

                    // determine whether the batched geometry is within the frustum
                    var culled = false;
                    if (perObjectFrustumCulled) {
                      culled = !_frustum.intersectsSphere(_sphere$2);
                    }
                    if (!culled) {
                      // get the distance from camera used for sorting
                      var z = _temp.subVectors(_sphere$2.center, _vector$5).dot(_forward);
                      _renderList.push(drawRanges[geometryId], z, i);
                    }
                  }
                }

                // Sort the draw ranges and prep for rendering
                var list = _renderList.list;
                var customSort = this.customSort;
                if (customSort === null) {
                  list.sort(material.transparent ? sortTransparent : sortOpaque);
                } else {
                  customSort.call(this, list, camera);
                }
                for (var _i69 = 0, _l11 = list.length; _i69 < _l11; _i69++) {
                  var item = list[_i69];
                  multiDrawStarts[count] = item.start * bytesPerElement;
                  multiDrawCounts[count] = item.count;
                  indirectArray[count] = item.index;
                  count++;
                }
                _renderList.reset();
              } else {
                for (var _i70 = 0, _l12 = drawInfo.length; _i70 < _l12; _i70++) {
                  if (drawInfo[_i70].visible && drawInfo[_i70].active) {
                    var _geometryId = drawInfo[_i70].geometryIndex;

                    // determine whether the batched geometry is within the frustum
                    var _culled = false;
                    if (perObjectFrustumCulled) {
                      // get the bounds in world space
                      this.getMatrixAt(_i70, _matrix$1);
                      this.getBoundingSphereAt(_geometryId, _sphere$2).applyMatrix4(_matrix$1);
                      _culled = !_frustum.intersectsSphere(_sphere$2);
                    }
                    if (!_culled) {
                      var range = drawRanges[_geometryId];
                      multiDrawStarts[count] = range.start * bytesPerElement;
                      multiDrawCounts[count] = range.count;
                      indirectArray[count] = _i70;
                      count++;
                    }
                  }
                }
              }
              indirectTexture.needsUpdate = true;
              this._multiDrawCount = count;
              this._visibilityChanged = false;
            }
          }, {
            key: "onBeforeShadow",
            value: function onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial /* , group */) {
              this.onBeforeRender(renderer, null, shadowCamera, geometry, depthMaterial);
            }
          }]);
        }(Mesh);
        var LineBasicMaterial = /*#__PURE__*/function (_Material6) {
          function LineBasicMaterial(parameters) {
            var _this53;
            _classCallCheck2(this, LineBasicMaterial);
            _this53 = _callSuper(this, LineBasicMaterial);
            _this53.isLineBasicMaterial = true;
            _this53.type = 'LineBasicMaterial';
            _this53.color = new Color(0xffffff);
            _this53.map = null;
            _this53.linewidth = 1;
            _this53.linecap = 'round';
            _this53.linejoin = 'round';
            _this53.fog = true;
            _this53.setValues(parameters);
            return _this53;
          }
          _inherits(LineBasicMaterial, _Material6);
          return _createClass(LineBasicMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(LineBasicMaterial, "copy", this, 3)([source]);
              this.color.copy(source.color);
              this.map = source.map;
              this.linewidth = source.linewidth;
              this.linecap = source.linecap;
              this.linejoin = source.linejoin;
              this.fog = source.fog;
              return this;
            }
          }]);
        }(Material);
        var _vStart = /*@__PURE__*/new Vector3();
        var _vEnd = /*@__PURE__*/new Vector3();
        var _inverseMatrix$1 = /*@__PURE__*/new Matrix4();
        var _ray$1 = /*@__PURE__*/new Ray();
        var _sphere$1 = /*@__PURE__*/new Sphere();
        var _intersectPointOnRay = /*@__PURE__*/new Vector3();
        var _intersectPointOnSegment = /*@__PURE__*/new Vector3();
        var Line = /*#__PURE__*/function (_Object3D9) {
          function Line() {
            var _this54;
            var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();
            var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LineBasicMaterial();
            _classCallCheck2(this, Line);
            _this54 = _callSuper(this, Line);
            _this54.isLine = true;
            _this54.type = 'Line';
            _this54.geometry = geometry;
            _this54.material = material;
            _this54.updateMorphTargets();
            return _this54;
          }
          _inherits(Line, _Object3D9);
          return _createClass(Line, [{
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(Line, "copy", this, 3)([source, recursive]);
              this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
              this.geometry = source.geometry;
              return this;
            }
          }, {
            key: "computeLineDistances",
            value: function computeLineDistances() {
              var geometry = this.geometry;

              // we assume non-indexed geometry

              if (geometry.index === null) {
                var positionAttribute = geometry.attributes.position;
                var lineDistances = [0];
                for (var i = 1, l = positionAttribute.count; i < l; i++) {
                  _vStart.fromBufferAttribute(positionAttribute, i - 1);
                  _vEnd.fromBufferAttribute(positionAttribute, i);
                  lineDistances[i] = lineDistances[i - 1];
                  lineDistances[i] += _vStart.distanceTo(_vEnd);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
              } else {
                console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
              }
              return this;
            }
          }, {
            key: "raycast",
            value: function raycast(raycaster, intersects) {
              var geometry = this.geometry;
              var matrixWorld = this.matrixWorld;
              var threshold = raycaster.params.Line.threshold;
              var drawRange = geometry.drawRange;

              // Checking boundingSphere distance to ray

              if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
              _sphere$1.copy(geometry.boundingSphere);
              _sphere$1.applyMatrix4(matrixWorld);
              _sphere$1.radius += threshold;
              if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;

              //

              _inverseMatrix$1.copy(matrixWorld).invert();
              _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
              var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
              var localThresholdSq = localThreshold * localThreshold;
              var step = this.isLineSegments ? 2 : 1;
              var index = geometry.index;
              var attributes = geometry.attributes;
              var positionAttribute = attributes.position;
              if (index !== null) {
                var start = Math.max(0, drawRange.start);
                var end = Math.min(index.count, drawRange.start + drawRange.count);
                for (var i = start, l = end - 1; i < l; i += step) {
                  var a = index.getX(i);
                  var b = index.getX(i + 1);
                  var _intersect3 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
                  if (_intersect3) {
                    intersects.push(_intersect3);
                  }
                }
                if (this.isLineLoop) {
                  var _a7 = index.getX(end - 1);
                  var _b7 = index.getX(start);
                  var _intersect4 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, _a7, _b7);
                  if (_intersect4) {
                    intersects.push(_intersect4);
                  }
                }
              } else {
                var _start6 = Math.max(0, drawRange.start);
                var _end5 = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
                for (var _i71 = _start6, _l13 = _end5 - 1; _i71 < _l13; _i71 += step) {
                  var _intersect5 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, _i71, _i71 + 1);
                  if (_intersect5) {
                    intersects.push(_intersect5);
                  }
                }
                if (this.isLineLoop) {
                  var _intersect6 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, _end5 - 1, _start6);
                  if (_intersect6) {
                    intersects.push(_intersect6);
                  }
                }
              }
            }
          }, {
            key: "updateMorphTargets",
            value: function updateMorphTargets() {
              var geometry = this.geometry;
              var morphAttributes = geometry.morphAttributes;
              var keys = Object.keys(morphAttributes);
              if (keys.length > 0) {
                var morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                  this.morphTargetInfluences = [];
                  this.morphTargetDictionary = {};
                  for (var _m7 = 0, ml = morphAttribute.length; _m7 < ml; _m7++) {
                    var name = morphAttribute[_m7].name || String(_m7);
                    this.morphTargetInfluences.push(0);
                    this.morphTargetDictionary[name] = _m7;
                  }
                }
              }
            }
          }]);
        }(Object3D);
        function checkIntersection(object, raycaster, ray, thresholdSq, a, b) {
          var positionAttribute = object.geometry.attributes.position;
          _vStart.fromBufferAttribute(positionAttribute, a);
          _vEnd.fromBufferAttribute(positionAttribute, b);
          var distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);
          if (distSq > thresholdSq) return;
          _intersectPointOnRay.applyMatrix4(object.matrixWorld); // Move back to world space for distance calculation

          var distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
          if (distance < raycaster.near || distance > raycaster.far) return;
          return {
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
            index: a,
            face: null,
            faceIndex: null,
            object: object
          };
        }
        var _start = /*@__PURE__*/new Vector3();
        var _end = /*@__PURE__*/new Vector3();
        var LineSegments = /*#__PURE__*/function (_Line) {
          function LineSegments(geometry, material) {
            var _this55;
            _classCallCheck2(this, LineSegments);
            _this55 = _callSuper(this, LineSegments, [geometry, material]);
            _this55.isLineSegments = true;
            _this55.type = 'LineSegments';
            return _this55;
          }
          _inherits(LineSegments, _Line);
          return _createClass(LineSegments, [{
            key: "computeLineDistances",
            value: function computeLineDistances() {
              var geometry = this.geometry;

              // we assume non-indexed geometry

              if (geometry.index === null) {
                var positionAttribute = geometry.attributes.position;
                var lineDistances = [];
                for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
                  _start.fromBufferAttribute(positionAttribute, i);
                  _end.fromBufferAttribute(positionAttribute, i + 1);
                  lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
                  lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
              } else {
                console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
              }
              return this;
            }
          }]);
        }(Line);
        var LineLoop = /*#__PURE__*/function (_Line2) {
          function LineLoop(geometry, material) {
            var _this56;
            _classCallCheck2(this, LineLoop);
            _this56 = _callSuper(this, LineLoop, [geometry, material]);
            _this56.isLineLoop = true;
            _this56.type = 'LineLoop';
            return _this56;
          }
          _inherits(LineLoop, _Line2);
          return _createClass(LineLoop);
        }(Line);
        var PointsMaterial = /*#__PURE__*/function (_Material7) {
          function PointsMaterial(parameters) {
            var _this57;
            _classCallCheck2(this, PointsMaterial);
            _this57 = _callSuper(this, PointsMaterial);
            _this57.isPointsMaterial = true;
            _this57.type = 'PointsMaterial';
            _this57.color = new Color(0xffffff);
            _this57.map = null;
            _this57.alphaMap = null;
            _this57.size = 1;
            _this57.sizeAttenuation = true;
            _this57.fog = true;
            _this57.setValues(parameters);
            return _this57;
          }
          _inherits(PointsMaterial, _Material7);
          return _createClass(PointsMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(PointsMaterial, "copy", this, 3)([source]);
              this.color.copy(source.color);
              this.map = source.map;
              this.alphaMap = source.alphaMap;
              this.size = source.size;
              this.sizeAttenuation = source.sizeAttenuation;
              this.fog = source.fog;
              return this;
            }
          }]);
        }(Material);
        var _inverseMatrix = /*@__PURE__*/new Matrix4();
        var _ray = /*@__PURE__*/new Ray();
        var _sphere = /*@__PURE__*/new Sphere();
        var _position$2 = /*@__PURE__*/new Vector3();
        var Points = /*#__PURE__*/function (_Object3D10) {
          function Points() {
            var _this58;
            var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();
            var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new PointsMaterial();
            _classCallCheck2(this, Points);
            _this58 = _callSuper(this, Points);
            _this58.isPoints = true;
            _this58.type = 'Points';
            _this58.geometry = geometry;
            _this58.material = material;
            _this58.updateMorphTargets();
            return _this58;
          }
          _inherits(Points, _Object3D10);
          return _createClass(Points, [{
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(Points, "copy", this, 3)([source, recursive]);
              this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
              this.geometry = source.geometry;
              return this;
            }
          }, {
            key: "raycast",
            value: function raycast(raycaster, intersects) {
              var geometry = this.geometry;
              var matrixWorld = this.matrixWorld;
              var threshold = raycaster.params.Points.threshold;
              var drawRange = geometry.drawRange;

              // Checking boundingSphere distance to ray

              if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
              _sphere.copy(geometry.boundingSphere);
              _sphere.applyMatrix4(matrixWorld);
              _sphere.radius += threshold;
              if (raycaster.ray.intersectsSphere(_sphere) === false) return;

              //

              _inverseMatrix.copy(matrixWorld).invert();
              _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
              var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
              var localThresholdSq = localThreshold * localThreshold;
              var index = geometry.index;
              var attributes = geometry.attributes;
              var positionAttribute = attributes.position;
              if (index !== null) {
                var start = Math.max(0, drawRange.start);
                var end = Math.min(index.count, drawRange.start + drawRange.count);
                for (var i = start, il = end; i < il; i++) {
                  var a = index.getX(i);
                  _position$2.fromBufferAttribute(positionAttribute, a);
                  testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
                }
              } else {
                var _start7 = Math.max(0, drawRange.start);
                var _end6 = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
                for (var _i72 = _start7, l = _end6; _i72 < l; _i72++) {
                  _position$2.fromBufferAttribute(positionAttribute, _i72);
                  testPoint(_position$2, _i72, localThresholdSq, matrixWorld, raycaster, intersects, this);
                }
              }
            }
          }, {
            key: "updateMorphTargets",
            value: function updateMorphTargets() {
              var geometry = this.geometry;
              var morphAttributes = geometry.morphAttributes;
              var keys = Object.keys(morphAttributes);
              if (keys.length > 0) {
                var morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                  this.morphTargetInfluences = [];
                  this.morphTargetDictionary = {};
                  for (var _m8 = 0, ml = morphAttribute.length; _m8 < ml; _m8++) {
                    var name = morphAttribute[_m8].name || String(_m8);
                    this.morphTargetInfluences.push(0);
                    this.morphTargetDictionary[name] = _m8;
                  }
                }
              }
            }
          }]);
        }(Object3D);
        function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
          var rayPointDistanceSq = _ray.distanceSqToPoint(point);
          if (rayPointDistanceSq < localThresholdSq) {
            var intersectPoint = new Vector3();
            _ray.closestPointToPoint(point, intersectPoint);
            intersectPoint.applyMatrix4(matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far) return;
            intersects.push({
              distance: distance,
              distanceToRay: Math.sqrt(rayPointDistanceSq),
              point: intersectPoint,
              index: index,
              face: null,
              object: object
            });
          }
        }
        var VideoTexture = /*#__PURE__*/function (_Texture6) {
          function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            var _this59;
            _classCallCheck2(this, VideoTexture);
            _this59 = _callSuper(this, VideoTexture, [video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy]);
            _this59.isVideoTexture = true;
            _this59.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
            _this59.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
            _this59.generateMipmaps = false;
            var scope = _this59;
            function updateVideo() {
              scope.needsUpdate = true;
              video.requestVideoFrameCallback(updateVideo);
            }
            if ('requestVideoFrameCallback' in video) {
              video.requestVideoFrameCallback(updateVideo);
            }
            return _this59;
          }
          _inherits(VideoTexture, _Texture6);
          return _createClass(VideoTexture, [{
            key: "clone",
            value: function clone() {
              return new this.constructor(this.image).copy(this);
            }
          }, {
            key: "update",
            value: function update() {
              var video = this.image;
              var hasVideoFrameCallback = 'requestVideoFrameCallback' in video;
              if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
                this.needsUpdate = true;
              }
            }
          }]);
        }(Texture);
        var FramebufferTexture = /*#__PURE__*/function (_Texture7) {
          function FramebufferTexture(width, height) {
            var _this60;
            _classCallCheck2(this, FramebufferTexture);
            _this60 = _callSuper(this, FramebufferTexture, [{
              width: width,
              height: height
            }]);
            _this60.isFramebufferTexture = true;
            _this60.magFilter = NearestFilter;
            _this60.minFilter = NearestFilter;
            _this60.generateMipmaps = false;
            _this60.needsUpdate = true;
            return _this60;
          }
          _inherits(FramebufferTexture, _Texture7);
          return _createClass(FramebufferTexture);
        }(Texture);
        var CompressedTexture = /*#__PURE__*/function (_Texture8) {
          function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace) {
            var _this61;
            _classCallCheck2(this, CompressedTexture);
            _this61 = _callSuper(this, CompressedTexture, [null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace]);
            _this61.isCompressedTexture = true;
            _this61.image = {
              width: width,
              height: height
            };
            _this61.mipmaps = mipmaps;

            // no flipping for cube textures
            // (also flipping doesn't work for compressed textures )

            _this61.flipY = false;

            // can't generate mipmaps for compressed textures
            // mips must be embedded in DDS files

            _this61.generateMipmaps = false;
            return _this61;
          }
          _inherits(CompressedTexture, _Texture8);
          return _createClass(CompressedTexture);
        }(Texture);
        var CompressedArrayTexture = /*#__PURE__*/function (_CompressedTexture) {
          function CompressedArrayTexture(mipmaps, width, height, depth, format, type) {
            var _this62;
            _classCallCheck2(this, CompressedArrayTexture);
            _this62 = _callSuper(this, CompressedArrayTexture, [mipmaps, width, height, format, type]);
            _this62.isCompressedArrayTexture = true;
            _this62.image.depth = depth;
            _this62.wrapR = ClampToEdgeWrapping;
            _this62.layerUpdates = new Set();
            return _this62;
          }
          _inherits(CompressedArrayTexture, _CompressedTexture);
          return _createClass(CompressedArrayTexture, [{
            key: "addLayerUpdate",
            value: function addLayerUpdate(layerIndex) {
              this.layerUpdates.add(layerIndex);
            }
          }, {
            key: "clearLayerUpdates",
            value: function clearLayerUpdates() {
              this.layerUpdates.clear();
            }
          }]);
        }(CompressedTexture);
        var CompressedCubeTexture = /*#__PURE__*/function (_CompressedTexture2) {
          function CompressedCubeTexture(images, format, type) {
            var _this63;
            _classCallCheck2(this, CompressedCubeTexture);
            _this63 = _callSuper(this, CompressedCubeTexture, [undefined, images[0].width, images[0].height, format, type, CubeReflectionMapping]);
            _this63.isCompressedCubeTexture = true;
            _this63.isCubeTexture = true;
            _this63.image = images;
            return _this63;
          }
          _inherits(CompressedCubeTexture, _CompressedTexture2);
          return _createClass(CompressedCubeTexture);
        }(CompressedTexture);
        var CanvasTexture = /*#__PURE__*/function (_Texture9) {
          function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            var _this64;
            _classCallCheck2(this, CanvasTexture);
            _this64 = _callSuper(this, CanvasTexture, [canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy]);
            _this64.isCanvasTexture = true;
            _this64.needsUpdate = true;
            return _this64;
          }
          _inherits(CanvasTexture, _Texture9);
          return _createClass(CanvasTexture);
        }(Texture);
        /**
         * Extensible curve object.
         *
         * Some common of curve methods:
         * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
         * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
         * .getPoints(), .getSpacedPoints()
         * .getLength()
         * .updateArcLengths()
         *
         * This following curves inherit from THREE.Curve:
         *
         * -- 2D curves --
         * THREE.ArcCurve
         * THREE.CubicBezierCurve
         * THREE.EllipseCurve
         * THREE.LineCurve
         * THREE.QuadraticBezierCurve
         * THREE.SplineCurve
         *
         * -- 3D curves --
         * THREE.CatmullRomCurve3
         * THREE.CubicBezierCurve3
         * THREE.LineCurve3
         * THREE.QuadraticBezierCurve3
         *
         * A series of curves can be represented as a THREE.CurvePath.
         *
         **/
        var Curve = /*#__PURE__*/function () {
          function Curve() {
            _classCallCheck2(this, Curve);
            this.type = 'Curve';
            this.arcLengthDivisions = 200;
          }

          // Virtual base class method to overwrite and implement in subclasses
          //	- t [0 .. 1]
          return _createClass(Curve, [{
            key: "getPoint",
            value: function getPoint(/* t, optionalTarget */
            ) {
              console.warn('THREE.Curve: .getPoint() not implemented.');
              return null;
            }

            // Get point at relative position in curve according to arc length
            // - u [0 .. 1]
          }, {
            key: "getPointAt",
            value: function getPointAt(u, optionalTarget) {
              var t = this.getUtoTmapping(u);
              return this.getPoint(t, optionalTarget);
            }

            // Get sequence of points using getPoint( t )
          }, {
            key: "getPoints",
            value: function getPoints() {
              var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
              var points = [];
              for (var d = 0; d <= divisions; d++) {
                points.push(this.getPoint(d / divisions));
              }
              return points;
            }

            // Get sequence of points using getPointAt( u )
          }, {
            key: "getSpacedPoints",
            value: function getSpacedPoints() {
              var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
              var points = [];
              for (var d = 0; d <= divisions; d++) {
                points.push(this.getPointAt(d / divisions));
              }
              return points;
            }

            // Get total curve arc length
          }, {
            key: "getLength",
            value: function getLength() {
              var lengths = this.getLengths();
              return lengths[lengths.length - 1];
            }

            // Get list of cumulative segment lengths
          }, {
            key: "getLengths",
            value: function getLengths() {
              var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.arcLengthDivisions;
              if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
                return this.cacheArcLengths;
              }
              this.needsUpdate = false;
              var cache = [];
              var current,
                last = this.getPoint(0);
              var sum = 0;
              cache.push(0);
              for (var _p6 = 1; _p6 <= divisions; _p6++) {
                current = this.getPoint(_p6 / divisions);
                sum += current.distanceTo(last);
                cache.push(sum);
                last = current;
              }
              this.cacheArcLengths = cache;
              return cache; // { sums: cache, sum: sum }; Sum is in the last element.
            }
          }, {
            key: "updateArcLengths",
            value: function updateArcLengths() {
              this.needsUpdate = true;
              this.getLengths();
            }

            // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
          }, {
            key: "getUtoTmapping",
            value: function getUtoTmapping(u, distance) {
              var arcLengths = this.getLengths();
              var i = 0;
              var il = arcLengths.length;
              var targetArcLength; // The targeted u distance value to get

              if (distance) {
                targetArcLength = distance;
              } else {
                targetArcLength = u * arcLengths[il - 1];
              }

              // binary search for the index with largest value smaller than target u distance

              var low = 0,
                high = il - 1,
                comparison;
              while (low <= high) {
                i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

                comparison = arcLengths[i] - targetArcLength;
                if (comparison < 0) {
                  low = i + 1;
                } else if (comparison > 0) {
                  high = i - 1;
                } else {
                  high = i;
                  break;

                  // DONE
                }
              }
              i = high;
              if (arcLengths[i] === targetArcLength) {
                return i / (il - 1);
              }

              // we could get finer grain at lengths, or use simple interpolation between two points

              var lengthBefore = arcLengths[i];
              var lengthAfter = arcLengths[i + 1];
              var segmentLength = lengthAfter - lengthBefore;

              // determine where we are between the 'before' and 'after' points

              var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

              // add that fractional amount to t

              var t = (i + segmentFraction) / (il - 1);
              return t;
            }

            // Returns a unit vector tangent at t
            // In case any sub curve does not implement its tangent derivation,
            // 2 points a small delta apart will be used to find its gradient
            // which seems to give a reasonable approximation
          }, {
            key: "getTangent",
            value: function getTangent(t, optionalTarget) {
              var delta = 0.0001;
              var t1 = t - delta;
              var t2 = t + delta;

              // Capping in case of danger

              if (t1 < 0) t1 = 0;
              if (t2 > 1) t2 = 1;
              var pt1 = this.getPoint(t1);
              var pt2 = this.getPoint(t2);
              var tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
              tangent.copy(pt2).sub(pt1).normalize();
              return tangent;
            }
          }, {
            key: "getTangentAt",
            value: function getTangentAt(u, optionalTarget) {
              var t = this.getUtoTmapping(u);
              return this.getTangent(t, optionalTarget);
            }
          }, {
            key: "computeFrenetFrames",
            value: function computeFrenetFrames(segments, closed) {
              // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

              var normal = new Vector3();
              var tangents = [];
              var normals = [];
              var binormals = [];
              var vec = new Vector3();
              var mat = new Matrix4();

              // compute the tangent vectors for each segment on the curve

              for (var i = 0; i <= segments; i++) {
                var u = i / segments;
                tangents[i] = this.getTangentAt(u, new Vector3());
              }

              // select an initial normal vector perpendicular to the first tangent vector,
              // and in the direction of the minimum tangent xyz component

              normals[0] = new Vector3();
              binormals[0] = new Vector3();
              var min = Number.MAX_VALUE;
              var tx = Math.abs(tangents[0].x);
              var ty = Math.abs(tangents[0].y);
              var tz = Math.abs(tangents[0].z);
              if (tx <= min) {
                min = tx;
                normal.set(1, 0, 0);
              }
              if (ty <= min) {
                min = ty;
                normal.set(0, 1, 0);
              }
              if (tz <= min) {
                normal.set(0, 0, 1);
              }
              vec.crossVectors(tangents[0], normal).normalize();
              normals[0].crossVectors(tangents[0], vec);
              binormals[0].crossVectors(tangents[0], normals[0]);

              // compute the slowly-varying normal and binormal vectors for each segment on the curve

              for (var _i73 = 1; _i73 <= segments; _i73++) {
                normals[_i73] = normals[_i73 - 1].clone();
                binormals[_i73] = binormals[_i73 - 1].clone();
                vec.crossVectors(tangents[_i73 - 1], tangents[_i73]);
                if (vec.length() > Number.EPSILON) {
                  vec.normalize();
                  var theta = Math.acos(clamp(tangents[_i73 - 1].dot(tangents[_i73]), -1, 1)); // clamp for floating pt errors

                  normals[_i73].applyMatrix4(mat.makeRotationAxis(vec, theta));
                }
                binormals[_i73].crossVectors(tangents[_i73], normals[_i73]);
              }

              // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

              if (closed === true) {
                var _theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
                _theta /= segments;
                if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
                  _theta = -_theta;
                }
                for (var _i74 = 1; _i74 <= segments; _i74++) {
                  // twist a little...
                  normals[_i74].applyMatrix4(mat.makeRotationAxis(tangents[_i74], _theta * _i74));
                  binormals[_i74].crossVectors(tangents[_i74], normals[_i74]);
                }
              }
              return {
                tangents: tangents,
                normals: normals,
                binormals: binormals
              };
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }, {
            key: "copy",
            value: function copy(source) {
              this.arcLengthDivisions = source.arcLengthDivisions;
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = {
                metadata: {
                  version: 4.6,
                  type: 'Curve',
                  generator: 'Curve.toJSON'
                }
              };
              data.arcLengthDivisions = this.arcLengthDivisions;
              data.type = this.type;
              return data;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              this.arcLengthDivisions = json.arcLengthDivisions;
              return this;
            }
          }]);
        }();
        var EllipseCurve = /*#__PURE__*/function (_Curve) {
          function EllipseCurve() {
            var _this65;
            var aX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var aY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var xRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var yRadius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            var aStartAngle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
            var aEndAngle = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;
            var aClockwise = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
            var aRotation = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
            _classCallCheck2(this, EllipseCurve);
            _this65 = _callSuper(this, EllipseCurve);
            _this65.isEllipseCurve = true;
            _this65.type = 'EllipseCurve';
            _this65.aX = aX;
            _this65.aY = aY;
            _this65.xRadius = xRadius;
            _this65.yRadius = yRadius;
            _this65.aStartAngle = aStartAngle;
            _this65.aEndAngle = aEndAngle;
            _this65.aClockwise = aClockwise;
            _this65.aRotation = aRotation;
            return _this65;
          }
          _inherits(EllipseCurve, _Curve);
          return _createClass(EllipseCurve, [{
            key: "getPoint",
            value: function getPoint(t) {
              var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
              var point = optionalTarget;
              var twoPi = Math.PI * 2;
              var deltaAngle = this.aEndAngle - this.aStartAngle;
              var samePoints = Math.abs(deltaAngle) < Number.EPSILON;

              // ensures that deltaAngle is 0 .. 2 PI
              while (deltaAngle < 0) deltaAngle += twoPi;
              while (deltaAngle > twoPi) deltaAngle -= twoPi;
              if (deltaAngle < Number.EPSILON) {
                if (samePoints) {
                  deltaAngle = 0;
                } else {
                  deltaAngle = twoPi;
                }
              }
              if (this.aClockwise === true && !samePoints) {
                if (deltaAngle === twoPi) {
                  deltaAngle = -twoPi;
                } else {
                  deltaAngle = deltaAngle - twoPi;
                }
              }
              var angle = this.aStartAngle + t * deltaAngle;
              var x = this.aX + this.xRadius * Math.cos(angle);
              var y = this.aY + this.yRadius * Math.sin(angle);
              if (this.aRotation !== 0) {
                var cos = Math.cos(this.aRotation);
                var sin = Math.sin(this.aRotation);
                var tx = x - this.aX;
                var ty = y - this.aY;

                // Rotate the point about the center of the ellipse.
                x = tx * cos - ty * sin + this.aX;
                y = tx * sin + ty * cos + this.aY;
              }
              return point.set(x, y);
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(EllipseCurve, "copy", this, 3)([source]);
              this.aX = source.aX;
              this.aY = source.aY;
              this.xRadius = source.xRadius;
              this.yRadius = source.yRadius;
              this.aStartAngle = source.aStartAngle;
              this.aEndAngle = source.aEndAngle;
              this.aClockwise = source.aClockwise;
              this.aRotation = source.aRotation;
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(EllipseCurve, "toJSON", this, 3)([]);
              data.aX = this.aX;
              data.aY = this.aY;
              data.xRadius = this.xRadius;
              data.yRadius = this.yRadius;
              data.aStartAngle = this.aStartAngle;
              data.aEndAngle = this.aEndAngle;
              data.aClockwise = this.aClockwise;
              data.aRotation = this.aRotation;
              return data;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              _superPropGet(EllipseCurve, "fromJSON", this, 3)([json]);
              this.aX = json.aX;
              this.aY = json.aY;
              this.xRadius = json.xRadius;
              this.yRadius = json.yRadius;
              this.aStartAngle = json.aStartAngle;
              this.aEndAngle = json.aEndAngle;
              this.aClockwise = json.aClockwise;
              this.aRotation = json.aRotation;
              return this;
            }
          }]);
        }(Curve);
        var ArcCurve = /*#__PURE__*/function (_EllipseCurve) {
          function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            var _this66;
            _classCallCheck2(this, ArcCurve);
            _this66 = _callSuper(this, ArcCurve, [aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise]);
            _this66.isArcCurve = true;
            _this66.type = 'ArcCurve';
            return _this66;
          }
          _inherits(ArcCurve, _EllipseCurve);
          return _createClass(ArcCurve);
        }(EllipseCurve);
        /**
         * Centripetal CatmullRom Curve - which is useful for avoiding
         * cusps and self-intersections in non-uniform catmull rom curves.
         * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
         *
         * curve.type accepts centripetal(default), chordal and catmullrom
         * curve.tension is used for catmullrom which defaults to 0.5
         */
        /*
        Based on an optimized c++ solution in
         - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
         - http://ideone.com/NoEbVM
         This CubicPoly class could be used for reusing some variables and calculations,
        but for three.js curve use, it could be possible inlined and flatten into a single function call
        which can be placed in CurveUtils.
        */
        function CubicPoly() {
          var c0 = 0,
            c1 = 0,
            c2 = 0,
            c3 = 0;

          /*
           * Compute coefficients for a cubic polynomial
           *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
           * such that
           *   p(0) = x0, p(1) = x1
           *  and
           *   p'(0) = t0, p'(1) = t1.
           */
          function init(x0, x1, t0, t1) {
            c0 = x0;
            c1 = t0;
            c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
            c3 = 2 * x0 - 2 * x1 + t0 + t1;
          }
          return {
            initCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {
              init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
            },
            initNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
              // compute tangents when parameterized in [t1,t2]
              var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
              var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;

              // rescale tangents for parametrization in [0,1]
              t1 *= dt1;
              t2 *= dt1;
              init(x1, x2, t1, t2);
            },
            calc: function calc(t) {
              var t2 = t * t;
              var t3 = t2 * t;
              return c0 + c1 * t + c2 * t2 + c3 * t3;
            }
          };
        }

        //

        var tmp = /*@__PURE__*/new Vector3();
        var px = /*@__PURE__*/new CubicPoly();
        var py = /*@__PURE__*/new CubicPoly();
        var pz = /*@__PURE__*/new CubicPoly();
        var CatmullRomCurve3 = /*#__PURE__*/function (_Curve2) {
          function CatmullRomCurve3() {
            var _this67;
            var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var closed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var curveType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'centripetal';
            var tension = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
            _classCallCheck2(this, CatmullRomCurve3);
            _this67 = _callSuper(this, CatmullRomCurve3);
            _this67.isCatmullRomCurve3 = true;
            _this67.type = 'CatmullRomCurve3';
            _this67.points = points;
            _this67.closed = closed;
            _this67.curveType = curveType;
            _this67.tension = tension;
            return _this67;
          }
          _inherits(CatmullRomCurve3, _Curve2);
          return _createClass(CatmullRomCurve3, [{
            key: "getPoint",
            value: function getPoint(t) {
              var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
              var point = optionalTarget;
              var points = this.points;
              var l = points.length;
              var p = (l - (this.closed ? 0 : 1)) * t;
              var intPoint = Math.floor(p);
              var weight = p - intPoint;
              if (this.closed) {
                intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
              } else if (weight === 0 && intPoint === l - 1) {
                intPoint = l - 2;
                weight = 1;
              }
              var p0, p3; // 4 points (p1 & p2 defined below)

              if (this.closed || intPoint > 0) {
                p0 = points[(intPoint - 1) % l];
              } else {
                // extrapolate first point
                tmp.subVectors(points[0], points[1]).add(points[0]);
                p0 = tmp;
              }
              var p1 = points[intPoint % l];
              var p2 = points[(intPoint + 1) % l];
              if (this.closed || intPoint + 2 < l) {
                p3 = points[(intPoint + 2) % l];
              } else {
                // extrapolate last point
                tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
                p3 = tmp;
              }
              if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
                // init Centripetal / Chordal Catmull-Rom
                var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
                var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
                var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
                var dt2 = Math.pow(p2.distanceToSquared(p3), pow);

                // safety check for repeated points
                if (dt1 < 1e-4) dt1 = 1.0;
                if (dt0 < 1e-4) dt0 = dt1;
                if (dt2 < 1e-4) dt2 = dt1;
                px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
                py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
                pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
              } else if (this.curveType === 'catmullrom') {
                px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
                py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
                pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
              }
              point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
              return point;
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(CatmullRomCurve3, "copy", this, 3)([source]);
              this.points = [];
              for (var i = 0, l = source.points.length; i < l; i++) {
                var point = source.points[i];
                this.points.push(point.clone());
              }
              this.closed = source.closed;
              this.curveType = source.curveType;
              this.tension = source.tension;
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(CatmullRomCurve3, "toJSON", this, 3)([]);
              data.points = [];
              for (var i = 0, l = this.points.length; i < l; i++) {
                var point = this.points[i];
                data.points.push(point.toArray());
              }
              data.closed = this.closed;
              data.curveType = this.curveType;
              data.tension = this.tension;
              return data;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              _superPropGet(CatmullRomCurve3, "fromJSON", this, 3)([json]);
              this.points = [];
              for (var i = 0, l = json.points.length; i < l; i++) {
                var point = json.points[i];
                this.points.push(new Vector3().fromArray(point));
              }
              this.closed = json.closed;
              this.curveType = json.curveType;
              this.tension = json.tension;
              return this;
            }
          }]);
        }(Curve);
        /**
         * Bezier Curves formulas obtained from
         * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
         */
        function CatmullRom(t, p0, p1, p2, p3) {
          var v0 = (p2 - p0) * 0.5;
          var v1 = (p3 - p1) * 0.5;
          var t2 = t * t;
          var t3 = t * t2;
          return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        }

        //

        function QuadraticBezierP0(t, p) {
          var k = 1 - t;
          return k * k * p;
        }
        function QuadraticBezierP1(t, p) {
          return 2 * (1 - t) * t * p;
        }
        function QuadraticBezierP2(t, p) {
          return t * t * p;
        }
        function QuadraticBezier(t, p0, p1, p2) {
          return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
        }

        //

        function CubicBezierP0(t, p) {
          var k = 1 - t;
          return k * k * k * p;
        }
        function CubicBezierP1(t, p) {
          var k = 1 - t;
          return 3 * k * k * t * p;
        }
        function CubicBezierP2(t, p) {
          return 3 * (1 - t) * t * t * p;
        }
        function CubicBezierP3(t, p) {
          return t * t * t * p;
        }
        function CubicBezier(t, p0, p1, p2, p3) {
          return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
        }
        var CubicBezierCurve = /*#__PURE__*/function (_Curve3) {
          function CubicBezierCurve() {
            var _this68;
            var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
            var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
            var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector2();
            var v3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Vector2();
            _classCallCheck2(this, CubicBezierCurve);
            _this68 = _callSuper(this, CubicBezierCurve);
            _this68.isCubicBezierCurve = true;
            _this68.type = 'CubicBezierCurve';
            _this68.v0 = v0;
            _this68.v1 = v1;
            _this68.v2 = v2;
            _this68.v3 = v3;
            return _this68;
          }
          _inherits(CubicBezierCurve, _Curve3);
          return _createClass(CubicBezierCurve, [{
            key: "getPoint",
            value: function getPoint(t) {
              var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
              var point = optionalTarget;
              var v0 = this.v0,
                v1 = this.v1,
                v2 = this.v2,
                v3 = this.v3;
              point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
              return point;
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(CubicBezierCurve, "copy", this, 3)([source]);
              this.v0.copy(source.v0);
              this.v1.copy(source.v1);
              this.v2.copy(source.v2);
              this.v3.copy(source.v3);
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(CubicBezierCurve, "toJSON", this, 3)([]);
              data.v0 = this.v0.toArray();
              data.v1 = this.v1.toArray();
              data.v2 = this.v2.toArray();
              data.v3 = this.v3.toArray();
              return data;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              _superPropGet(CubicBezierCurve, "fromJSON", this, 3)([json]);
              this.v0.fromArray(json.v0);
              this.v1.fromArray(json.v1);
              this.v2.fromArray(json.v2);
              this.v3.fromArray(json.v3);
              return this;
            }
          }]);
        }(Curve);
        var CubicBezierCurve3 = /*#__PURE__*/function (_Curve4) {
          function CubicBezierCurve3() {
            var _this69;
            var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
            var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
            var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();
            var v3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Vector3();
            _classCallCheck2(this, CubicBezierCurve3);
            _this69 = _callSuper(this, CubicBezierCurve3);
            _this69.isCubicBezierCurve3 = true;
            _this69.type = 'CubicBezierCurve3';
            _this69.v0 = v0;
            _this69.v1 = v1;
            _this69.v2 = v2;
            _this69.v3 = v3;
            return _this69;
          }
          _inherits(CubicBezierCurve3, _Curve4);
          return _createClass(CubicBezierCurve3, [{
            key: "getPoint",
            value: function getPoint(t) {
              var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
              var point = optionalTarget;
              var v0 = this.v0,
                v1 = this.v1,
                v2 = this.v2,
                v3 = this.v3;
              point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
              return point;
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(CubicBezierCurve3, "copy", this, 3)([source]);
              this.v0.copy(source.v0);
              this.v1.copy(source.v1);
              this.v2.copy(source.v2);
              this.v3.copy(source.v3);
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(CubicBezierCurve3, "toJSON", this, 3)([]);
              data.v0 = this.v0.toArray();
              data.v1 = this.v1.toArray();
              data.v2 = this.v2.toArray();
              data.v3 = this.v3.toArray();
              return data;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              _superPropGet(CubicBezierCurve3, "fromJSON", this, 3)([json]);
              this.v0.fromArray(json.v0);
              this.v1.fromArray(json.v1);
              this.v2.fromArray(json.v2);
              this.v3.fromArray(json.v3);
              return this;
            }
          }]);
        }(Curve);
        var LineCurve = /*#__PURE__*/function (_Curve5) {
          function LineCurve() {
            var _this70;
            var v1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
            var v2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
            _classCallCheck2(this, LineCurve);
            _this70 = _callSuper(this, LineCurve);
            _this70.isLineCurve = true;
            _this70.type = 'LineCurve';
            _this70.v1 = v1;
            _this70.v2 = v2;
            return _this70;
          }
          _inherits(LineCurve, _Curve5);
          return _createClass(LineCurve, [{
            key: "getPoint",
            value: function getPoint(t) {
              var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
              var point = optionalTarget;
              if (t === 1) {
                point.copy(this.v2);
              } else {
                point.copy(this.v2).sub(this.v1);
                point.multiplyScalar(t).add(this.v1);
              }
              return point;
            }

            // Line curve is linear, so we can overwrite default getPointAt
          }, {
            key: "getPointAt",
            value: function getPointAt(u, optionalTarget) {
              return this.getPoint(u, optionalTarget);
            }
          }, {
            key: "getTangent",
            value: function getTangent(t) {
              var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
              return optionalTarget.subVectors(this.v2, this.v1).normalize();
            }
          }, {
            key: "getTangentAt",
            value: function getTangentAt(u, optionalTarget) {
              return this.getTangent(u, optionalTarget);
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(LineCurve, "copy", this, 3)([source]);
              this.v1.copy(source.v1);
              this.v2.copy(source.v2);
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(LineCurve, "toJSON", this, 3)([]);
              data.v1 = this.v1.toArray();
              data.v2 = this.v2.toArray();
              return data;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              _superPropGet(LineCurve, "fromJSON", this, 3)([json]);
              this.v1.fromArray(json.v1);
              this.v2.fromArray(json.v2);
              return this;
            }
          }]);
        }(Curve);
        var LineCurve3 = /*#__PURE__*/function (_Curve6) {
          function LineCurve3() {
            var _this71;
            var v1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
            var v2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
            _classCallCheck2(this, LineCurve3);
            _this71 = _callSuper(this, LineCurve3);
            _this71.isLineCurve3 = true;
            _this71.type = 'LineCurve3';
            _this71.v1 = v1;
            _this71.v2 = v2;
            return _this71;
          }
          _inherits(LineCurve3, _Curve6);
          return _createClass(LineCurve3, [{
            key: "getPoint",
            value: function getPoint(t) {
              var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
              var point = optionalTarget;
              if (t === 1) {
                point.copy(this.v2);
              } else {
                point.copy(this.v2).sub(this.v1);
                point.multiplyScalar(t).add(this.v1);
              }
              return point;
            }

            // Line curve is linear, so we can overwrite default getPointAt
          }, {
            key: "getPointAt",
            value: function getPointAt(u, optionalTarget) {
              return this.getPoint(u, optionalTarget);
            }
          }, {
            key: "getTangent",
            value: function getTangent(t) {
              var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
              return optionalTarget.subVectors(this.v2, this.v1).normalize();
            }
          }, {
            key: "getTangentAt",
            value: function getTangentAt(u, optionalTarget) {
              return this.getTangent(u, optionalTarget);
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(LineCurve3, "copy", this, 3)([source]);
              this.v1.copy(source.v1);
              this.v2.copy(source.v2);
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(LineCurve3, "toJSON", this, 3)([]);
              data.v1 = this.v1.toArray();
              data.v2 = this.v2.toArray();
              return data;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              _superPropGet(LineCurve3, "fromJSON", this, 3)([json]);
              this.v1.fromArray(json.v1);
              this.v2.fromArray(json.v2);
              return this;
            }
          }]);
        }(Curve);
        var QuadraticBezierCurve = /*#__PURE__*/function (_Curve7) {
          function QuadraticBezierCurve() {
            var _this72;
            var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
            var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
            var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector2();
            _classCallCheck2(this, QuadraticBezierCurve);
            _this72 = _callSuper(this, QuadraticBezierCurve);
            _this72.isQuadraticBezierCurve = true;
            _this72.type = 'QuadraticBezierCurve';
            _this72.v0 = v0;
            _this72.v1 = v1;
            _this72.v2 = v2;
            return _this72;
          }
          _inherits(QuadraticBezierCurve, _Curve7);
          return _createClass(QuadraticBezierCurve, [{
            key: "getPoint",
            value: function getPoint(t) {
              var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
              var point = optionalTarget;
              var v0 = this.v0,
                v1 = this.v1,
                v2 = this.v2;
              point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
              return point;
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(QuadraticBezierCurve, "copy", this, 3)([source]);
              this.v0.copy(source.v0);
              this.v1.copy(source.v1);
              this.v2.copy(source.v2);
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(QuadraticBezierCurve, "toJSON", this, 3)([]);
              data.v0 = this.v0.toArray();
              data.v1 = this.v1.toArray();
              data.v2 = this.v2.toArray();
              return data;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              _superPropGet(QuadraticBezierCurve, "fromJSON", this, 3)([json]);
              this.v0.fromArray(json.v0);
              this.v1.fromArray(json.v1);
              this.v2.fromArray(json.v2);
              return this;
            }
          }]);
        }(Curve);
        var QuadraticBezierCurve3 = /*#__PURE__*/function (_Curve8) {
          function QuadraticBezierCurve3() {
            var _this73;
            var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
            var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
            var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();
            _classCallCheck2(this, QuadraticBezierCurve3);
            _this73 = _callSuper(this, QuadraticBezierCurve3);
            _this73.isQuadraticBezierCurve3 = true;
            _this73.type = 'QuadraticBezierCurve3';
            _this73.v0 = v0;
            _this73.v1 = v1;
            _this73.v2 = v2;
            return _this73;
          }
          _inherits(QuadraticBezierCurve3, _Curve8);
          return _createClass(QuadraticBezierCurve3, [{
            key: "getPoint",
            value: function getPoint(t) {
              var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
              var point = optionalTarget;
              var v0 = this.v0,
                v1 = this.v1,
                v2 = this.v2;
              point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
              return point;
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(QuadraticBezierCurve3, "copy", this, 3)([source]);
              this.v0.copy(source.v0);
              this.v1.copy(source.v1);
              this.v2.copy(source.v2);
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(QuadraticBezierCurve3, "toJSON", this, 3)([]);
              data.v0 = this.v0.toArray();
              data.v1 = this.v1.toArray();
              data.v2 = this.v2.toArray();
              return data;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              _superPropGet(QuadraticBezierCurve3, "fromJSON", this, 3)([json]);
              this.v0.fromArray(json.v0);
              this.v1.fromArray(json.v1);
              this.v2.fromArray(json.v2);
              return this;
            }
          }]);
        }(Curve);
        var SplineCurve = /*#__PURE__*/function (_Curve9) {
          function SplineCurve() {
            var _this74;
            var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            _classCallCheck2(this, SplineCurve);
            _this74 = _callSuper(this, SplineCurve);
            _this74.isSplineCurve = true;
            _this74.type = 'SplineCurve';
            _this74.points = points;
            return _this74;
          }
          _inherits(SplineCurve, _Curve9);
          return _createClass(SplineCurve, [{
            key: "getPoint",
            value: function getPoint(t) {
              var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
              var point = optionalTarget;
              var points = this.points;
              var p = (points.length - 1) * t;
              var intPoint = Math.floor(p);
              var weight = p - intPoint;
              var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
              var p1 = points[intPoint];
              var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
              var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
              point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
              return point;
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(SplineCurve, "copy", this, 3)([source]);
              this.points = [];
              for (var i = 0, l = source.points.length; i < l; i++) {
                var point = source.points[i];
                this.points.push(point.clone());
              }
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(SplineCurve, "toJSON", this, 3)([]);
              data.points = [];
              for (var i = 0, l = this.points.length; i < l; i++) {
                var point = this.points[i];
                data.points.push(point.toArray());
              }
              return data;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              _superPropGet(SplineCurve, "fromJSON", this, 3)([json]);
              this.points = [];
              for (var i = 0, l = json.points.length; i < l; i++) {
                var point = json.points[i];
                this.points.push(new Vector2().fromArray(point));
              }
              return this;
            }
          }]);
        }(Curve);
        var Curves = /*#__PURE__*/Object.freeze({
          __proto__: null,
          ArcCurve: ArcCurve,
          CatmullRomCurve3: CatmullRomCurve3,
          CubicBezierCurve: CubicBezierCurve,
          CubicBezierCurve3: CubicBezierCurve3,
          EllipseCurve: EllipseCurve,
          LineCurve: LineCurve,
          LineCurve3: LineCurve3,
          QuadraticBezierCurve: QuadraticBezierCurve,
          QuadraticBezierCurve3: QuadraticBezierCurve3,
          SplineCurve: SplineCurve
        });

        /**************************************************************
         *	Curved Path - a curve path is simply a array of connected
         *  curves, but retains the api of a curve
         **************************************************************/
        var CurvePath = /*#__PURE__*/function (_Curve10) {
          function CurvePath() {
            var _this75;
            _classCallCheck2(this, CurvePath);
            _this75 = _callSuper(this, CurvePath);
            _this75.type = 'CurvePath';
            _this75.curves = [];
            _this75.autoClose = false; // Automatically closes the path
            return _this75;
          }
          _inherits(CurvePath, _Curve10);
          return _createClass(CurvePath, [{
            key: "add",
            value: function add(curve) {
              this.curves.push(curve);
            }
          }, {
            key: "closePath",
            value: function closePath() {
              // Add a line curve if start and end of lines are not connected
              var startPoint = this.curves[0].getPoint(0);
              var endPoint = this.curves[this.curves.length - 1].getPoint(1);
              if (!startPoint.equals(endPoint)) {
                var lineType = startPoint.isVector2 === true ? 'LineCurve' : 'LineCurve3';
                this.curves.push(new Curves[lineType](endPoint, startPoint));
              }
              return this;
            }

            // To get accurate point with reference to
            // entire path distance at time t,
            // following has to be done:

            // 1. Length of each sub path have to be known
            // 2. Locate and identify type of curve
            // 3. Get t for the curve
            // 4. Return curve.getPointAt(t')
          }, {
            key: "getPoint",
            value: function getPoint(t, optionalTarget) {
              var d = t * this.getLength();
              var curveLengths = this.getCurveLengths();
              var i = 0;

              // To think about boundaries points.

              while (i < curveLengths.length) {
                if (curveLengths[i] >= d) {
                  var diff = curveLengths[i] - d;
                  var curve = this.curves[i];
                  var segmentLength = curve.getLength();
                  var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                  return curve.getPointAt(u, optionalTarget);
                }
                i++;
              }
              return null;

              // loop where sum != 0, sum > d , sum+1 <d
            }

            // We cannot use the default THREE.Curve getPoint() with getLength() because in
            // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
            // getPoint() depends on getLength
          }, {
            key: "getLength",
            value: function getLength() {
              var lens = this.getCurveLengths();
              return lens[lens.length - 1];
            }

            // cacheLengths must be recalculated.
          }, {
            key: "updateArcLengths",
            value: function updateArcLengths() {
              this.needsUpdate = true;
              this.cacheLengths = null;
              this.getCurveLengths();
            }

            // Compute lengths and cache them
            // We cannot overwrite getLengths() because UtoT mapping uses it.
          }, {
            key: "getCurveLengths",
            value: function getCurveLengths() {
              // We use cache values if curves and cache array are same length

              if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
                return this.cacheLengths;
              }

              // Get length of sub-curve
              // Push sums into cached array

              var lengths = [];
              var sums = 0;
              for (var i = 0, l = this.curves.length; i < l; i++) {
                sums += this.curves[i].getLength();
                lengths.push(sums);
              }
              this.cacheLengths = lengths;
              return lengths;
            }
          }, {
            key: "getSpacedPoints",
            value: function getSpacedPoints() {
              var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 40;
              var points = [];
              for (var i = 0; i <= divisions; i++) {
                points.push(this.getPoint(i / divisions));
              }
              if (this.autoClose) {
                points.push(points[0]);
              }
              return points;
            }
          }, {
            key: "getPoints",
            value: function getPoints() {
              var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;
              var points = [];
              var last;
              for (var i = 0, curves = this.curves; i < curves.length; i++) {
                var curve = curves[i];
                var resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
                var pts = curve.getPoints(resolution);
                for (var j = 0; j < pts.length; j++) {
                  var point = pts[j];
                  if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

                  points.push(point);
                  last = point;
                }
              }
              if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                points.push(points[0]);
              }
              return points;
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(CurvePath, "copy", this, 3)([source]);
              this.curves = [];
              for (var i = 0, l = source.curves.length; i < l; i++) {
                var curve = source.curves[i];
                this.curves.push(curve.clone());
              }
              this.autoClose = source.autoClose;
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(CurvePath, "toJSON", this, 3)([]);
              data.autoClose = this.autoClose;
              data.curves = [];
              for (var i = 0, l = this.curves.length; i < l; i++) {
                var curve = this.curves[i];
                data.curves.push(curve.toJSON());
              }
              return data;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              _superPropGet(CurvePath, "fromJSON", this, 3)([json]);
              this.autoClose = json.autoClose;
              this.curves = [];
              for (var i = 0, l = json.curves.length; i < l; i++) {
                var curve = json.curves[i];
                this.curves.push(new Curves[curve.type]().fromJSON(curve));
              }
              return this;
            }
          }]);
        }(Curve);
        var Path = /*#__PURE__*/function (_CurvePath) {
          function Path(points) {
            var _this76;
            _classCallCheck2(this, Path);
            _this76 = _callSuper(this, Path);
            _this76.type = 'Path';
            _this76.currentPoint = new Vector2();
            if (points) {
              _this76.setFromPoints(points);
            }
            return _this76;
          }
          _inherits(Path, _CurvePath);
          return _createClass(Path, [{
            key: "setFromPoints",
            value: function setFromPoints(points) {
              this.moveTo(points[0].x, points[0].y);
              for (var i = 1, l = points.length; i < l; i++) {
                this.lineTo(points[i].x, points[i].y);
              }
              return this;
            }
          }, {
            key: "moveTo",
            value: function moveTo(x, y) {
              this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

              return this;
            }
          }, {
            key: "lineTo",
            value: function lineTo(x, y) {
              var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
              this.curves.push(curve);
              this.currentPoint.set(x, y);
              return this;
            }
          }, {
            key: "quadraticCurveTo",
            value: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
              var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
              this.curves.push(curve);
              this.currentPoint.set(aX, aY);
              return this;
            }
          }, {
            key: "bezierCurveTo",
            value: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
              var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
              this.curves.push(curve);
              this.currentPoint.set(aX, aY);
              return this;
            }
          }, {
            key: "splineThru",
            value: function splineThru(pts /*Array of Vector*/) {
              var npts = [this.currentPoint.clone()].concat(pts);
              var curve = new SplineCurve(npts);
              this.curves.push(curve);
              this.currentPoint.copy(pts[pts.length - 1]);
              return this;
            }
          }, {
            key: "arc",
            value: function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
              var x0 = this.currentPoint.x;
              var y0 = this.currentPoint.y;
              this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
              return this;
            }
          }, {
            key: "absarc",
            value: function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
              this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
              return this;
            }
          }, {
            key: "ellipse",
            value: function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
              var x0 = this.currentPoint.x;
              var y0 = this.currentPoint.y;
              this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
              return this;
            }
          }, {
            key: "absellipse",
            value: function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
              var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
              if (this.curves.length > 0) {
                // if a previous curve is present, attempt to join
                var firstPoint = curve.getPoint(0);
                if (!firstPoint.equals(this.currentPoint)) {
                  this.lineTo(firstPoint.x, firstPoint.y);
                }
              }
              this.curves.push(curve);
              var lastPoint = curve.getPoint(1);
              this.currentPoint.copy(lastPoint);
              return this;
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(Path, "copy", this, 3)([source]);
              this.currentPoint.copy(source.currentPoint);
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(Path, "toJSON", this, 3)([]);
              data.currentPoint = this.currentPoint.toArray();
              return data;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              _superPropGet(Path, "fromJSON", this, 3)([json]);
              this.currentPoint.fromArray(json.currentPoint);
              return this;
            }
          }]);
        }(CurvePath);
        var LatheGeometry = /*#__PURE__*/function (_BufferGeometry3) {
          function LatheGeometry() {
            var _this77;
            var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)];
            var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;
            var phiStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var phiLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI * 2;
            _classCallCheck2(this, LatheGeometry);
            _this77 = _callSuper(this, LatheGeometry);
            _this77.type = 'LatheGeometry';
            _this77.parameters = {
              points: points,
              segments: segments,
              phiStart: phiStart,
              phiLength: phiLength
            };
            segments = Math.floor(segments);

            // clamp phiLength so it's in range of [ 0, 2PI ]

            phiLength = clamp(phiLength, 0, Math.PI * 2);

            // buffers

            var indices = [];
            var vertices = [];
            var uvs = [];
            var initNormals = [];
            var normals = [];

            // helper variables

            var inverseSegments = 1.0 / segments;
            var vertex = new Vector3();
            var uv = new Vector2();
            var normal = new Vector3();
            var curNormal = new Vector3();
            var prevNormal = new Vector3();
            var dx = 0;
            var dy = 0;

            // pre-compute normals for initial "meridian"

            for (var j = 0; j <= points.length - 1; j++) {
              switch (j) {
                case 0:
                  // special handling for 1st vertex on path

                  dx = points[j + 1].x - points[j].x;
                  dy = points[j + 1].y - points[j].y;
                  normal.x = dy * 1.0;
                  normal.y = -dx;
                  normal.z = dy * 0.0;
                  prevNormal.copy(normal);
                  normal.normalize();
                  initNormals.push(normal.x, normal.y, normal.z);
                  break;
                case points.length - 1:
                  // special handling for last Vertex on path

                  initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
                  break;
                default:
                  // default handling for all vertices in between

                  dx = points[j + 1].x - points[j].x;
                  dy = points[j + 1].y - points[j].y;
                  normal.x = dy * 1.0;
                  normal.y = -dx;
                  normal.z = dy * 0.0;
                  curNormal.copy(normal);
                  normal.x += prevNormal.x;
                  normal.y += prevNormal.y;
                  normal.z += prevNormal.z;
                  normal.normalize();
                  initNormals.push(normal.x, normal.y, normal.z);
                  prevNormal.copy(curNormal);
              }
            }

            // generate vertices, uvs and normals

            for (var i = 0; i <= segments; i++) {
              var phi = phiStart + i * inverseSegments * phiLength;
              var sin = Math.sin(phi);
              var cos = Math.cos(phi);
              for (var _j5 = 0; _j5 <= points.length - 1; _j5++) {
                // vertex

                vertex.x = points[_j5].x * sin;
                vertex.y = points[_j5].y;
                vertex.z = points[_j5].x * cos;
                vertices.push(vertex.x, vertex.y, vertex.z);

                // uv

                uv.x = i / segments;
                uv.y = _j5 / (points.length - 1);
                uvs.push(uv.x, uv.y);

                // normal

                var x = initNormals[3 * _j5 + 0] * sin;
                var y = initNormals[3 * _j5 + 1];
                var z = initNormals[3 * _j5 + 0] * cos;
                normals.push(x, y, z);
              }
            }

            // indices

            for (var _i75 = 0; _i75 < segments; _i75++) {
              for (var _j6 = 0; _j6 < points.length - 1; _j6++) {
                var base = _j6 + _i75 * points.length;
                var a = base;
                var b = base + points.length;
                var _c13 = base + points.length + 1;
                var d = base + 1;

                // faces

                indices.push(a, b, d);
                indices.push(_c13, d, b);
              }
            }

            // build geometry

            _this77.setIndex(indices);
            _this77.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this77.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            _this77.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            return _this77;
          }
          _inherits(LatheGeometry, _BufferGeometry3);
          return _createClass(LatheGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(LatheGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
            }
          }]);
        }(BufferGeometry);
        var CapsuleGeometry = /*#__PURE__*/function (_LatheGeometry) {
          function CapsuleGeometry() {
            var _this78;
            var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var capSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
            var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
            _classCallCheck2(this, CapsuleGeometry);
            var path = new Path();
            path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
            path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
            _this78 = _callSuper(this, CapsuleGeometry, [path.getPoints(capSegments), radialSegments]);
            _this78.type = 'CapsuleGeometry';
            _this78.parameters = {
              radius: radius,
              length: length,
              capSegments: capSegments,
              radialSegments: radialSegments
            };
            return _this78;
          }
          _inherits(CapsuleGeometry, _LatheGeometry);
          return _createClass(CapsuleGeometry, null, [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
            }
          }]);
        }(LatheGeometry);
        var CircleGeometry = /*#__PURE__*/function (_BufferGeometry4) {
          function CircleGeometry() {
            var _this79;
            var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
            var thetaStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var thetaLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI * 2;
            _classCallCheck2(this, CircleGeometry);
            _this79 = _callSuper(this, CircleGeometry);
            _this79.type = 'CircleGeometry';
            _this79.parameters = {
              radius: radius,
              segments: segments,
              thetaStart: thetaStart,
              thetaLength: thetaLength
            };
            segments = Math.max(3, segments);

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // helper variables

            var vertex = new Vector3();
            var uv = new Vector2();

            // center point

            vertices.push(0, 0, 0);
            normals.push(0, 0, 1);
            uvs.push(0.5, 0.5);
            for (var s = 0, i = 3; s <= segments; s++, i += 3) {
              var segment = thetaStart + s / segments * thetaLength;

              // vertex

              vertex.x = radius * Math.cos(segment);
              vertex.y = radius * Math.sin(segment);
              vertices.push(vertex.x, vertex.y, vertex.z);

              // normal

              normals.push(0, 0, 1);

              // uvs

              uv.x = (vertices[i] / radius + 1) / 2;
              uv.y = (vertices[i + 1] / radius + 1) / 2;
              uvs.push(uv.x, uv.y);
            }

            // indices

            for (var _i76 = 1; _i76 <= segments; _i76++) {
              indices.push(_i76, _i76 + 1, 0);
            }

            // build geometry

            _this79.setIndex(indices);
            _this79.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this79.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this79.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            return _this79;
          }
          _inherits(CircleGeometry, _BufferGeometry4);
          return _createClass(CircleGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(CircleGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
            }
          }]);
        }(BufferGeometry);
        var CylinderGeometry = /*#__PURE__*/function (_BufferGeometry5) {
          function CylinderGeometry() {
            var _this80;
            var radiusTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var radiusBottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 32;
            var heightSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
            var openEnded = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
            var thetaStart = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
            var thetaLength = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Math.PI * 2;
            _classCallCheck2(this, CylinderGeometry);
            _this80 = _callSuper(this, CylinderGeometry);
            _this80.type = 'CylinderGeometry';
            _this80.parameters = {
              radiusTop: radiusTop,
              radiusBottom: radiusBottom,
              height: height,
              radialSegments: radialSegments,
              heightSegments: heightSegments,
              openEnded: openEnded,
              thetaStart: thetaStart,
              thetaLength: thetaLength
            };
            var scope = _this80;
            radialSegments = Math.floor(radialSegments);
            heightSegments = Math.floor(heightSegments);

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // helper variables

            var index = 0;
            var indexArray = [];
            var halfHeight = height / 2;
            var groupStart = 0;

            // generate geometry

            generateTorso();
            if (openEnded === false) {
              if (radiusTop > 0) generateCap(true);
              if (radiusBottom > 0) generateCap(false);
            }

            // build geometry

            _this80.setIndex(indices);
            _this80.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this80.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this80.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            function generateTorso() {
              var normal = new Vector3();
              var vertex = new Vector3();
              var groupCount = 0;

              // this will be used to calculate the normal
              var slope = (radiusBottom - radiusTop) / height;

              // generate vertices, normals and uvs

              for (var y = 0; y <= heightSegments; y++) {
                var indexRow = [];
                var v = y / heightSegments;

                // calculate the radius of the current row

                var radius = v * (radiusBottom - radiusTop) + radiusTop;
                for (var x = 0; x <= radialSegments; x++) {
                  var u = x / radialSegments;
                  var theta = u * thetaLength + thetaStart;
                  var sinTheta = Math.sin(theta);
                  var cosTheta = Math.cos(theta);

                  // vertex

                  vertex.x = radius * sinTheta;
                  vertex.y = -v * height + halfHeight;
                  vertex.z = radius * cosTheta;
                  vertices.push(vertex.x, vertex.y, vertex.z);

                  // normal

                  normal.set(sinTheta, slope, cosTheta).normalize();
                  normals.push(normal.x, normal.y, normal.z);

                  // uv

                  uvs.push(u, 1 - v);

                  // save index of vertex in respective row

                  indexRow.push(index++);
                }

                // now save vertices of the row in our index array

                indexArray.push(indexRow);
              }

              // generate indices

              for (var _x12 = 0; _x12 < radialSegments; _x12++) {
                for (var _y2 = 0; _y2 < heightSegments; _y2++) {
                  // we use the index array to access the correct indices

                  var a = indexArray[_y2][_x12];
                  var b = indexArray[_y2 + 1][_x12];
                  var _c14 = indexArray[_y2 + 1][_x12 + 1];
                  var d = indexArray[_y2][_x12 + 1];

                  // faces

                  indices.push(a, b, d);
                  indices.push(b, _c14, d);

                  // update group counter

                  groupCount += 6;
                }
              }

              // add a group to the geometry. this will ensure multi material support

              scope.addGroup(groupStart, groupCount, 0);

              // calculate new start value for groups

              groupStart += groupCount;
            }
            function generateCap(top) {
              // save the index of the first center vertex
              var centerIndexStart = index;
              var uv = new Vector2();
              var vertex = new Vector3();
              var groupCount = 0;
              var radius = top === true ? radiusTop : radiusBottom;
              var sign = top === true ? 1 : -1;

              // first we generate the center vertex data of the cap.
              // because the geometry needs one set of uvs per face,
              // we must generate a center vertex per face/segment

              for (var x = 1; x <= radialSegments; x++) {
                // vertex

                vertices.push(0, halfHeight * sign, 0);

                // normal

                normals.push(0, sign, 0);

                // uv

                uvs.push(0.5, 0.5);

                // increase index

                index++;
              }

              // save the index of the last center vertex
              var centerIndexEnd = index;

              // now we generate the surrounding vertices, normals and uvs

              for (var _x13 = 0; _x13 <= radialSegments; _x13++) {
                var u = _x13 / radialSegments;
                var theta = u * thetaLength + thetaStart;
                var cosTheta = Math.cos(theta);
                var sinTheta = Math.sin(theta);

                // vertex

                vertex.x = radius * sinTheta;
                vertex.y = halfHeight * sign;
                vertex.z = radius * cosTheta;
                vertices.push(vertex.x, vertex.y, vertex.z);

                // normal

                normals.push(0, sign, 0);

                // uv

                uv.x = cosTheta * 0.5 + 0.5;
                uv.y = sinTheta * 0.5 * sign + 0.5;
                uvs.push(uv.x, uv.y);

                // increase index

                index++;
              }

              // generate indices

              for (var _x14 = 0; _x14 < radialSegments; _x14++) {
                var _c15 = centerIndexStart + _x14;
                var i = centerIndexEnd + _x14;
                if (top === true) {
                  // face top

                  indices.push(i, i + 1, _c15);
                } else {
                  // face bottom

                  indices.push(i + 1, i, _c15);
                }
                groupCount += 3;
              }

              // add a group to the geometry. this will ensure multi material support

              scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);

              // calculate new start value for groups

              groupStart += groupCount;
            }
            return _this80;
          }
          _inherits(CylinderGeometry, _BufferGeometry5);
          return _createClass(CylinderGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(CylinderGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            }
          }]);
        }(BufferGeometry);
        var ConeGeometry = /*#__PURE__*/function (_CylinderGeometry) {
          function ConeGeometry() {
            var _this81;
            var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var radialSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;
            var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            var openEnded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
            var thetaStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
            var thetaLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Math.PI * 2;
            _classCallCheck2(this, ConeGeometry);
            _this81 = _callSuper(this, ConeGeometry, [0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength]);
            _this81.type = 'ConeGeometry';
            _this81.parameters = {
              radius: radius,
              height: height,
              radialSegments: radialSegments,
              heightSegments: heightSegments,
              openEnded: openEnded,
              thetaStart: thetaStart,
              thetaLength: thetaLength
            };
            return _this81;
          }
          _inherits(ConeGeometry, _CylinderGeometry);
          return _createClass(ConeGeometry, null, [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            }
          }]);
        }(CylinderGeometry);
        var PolyhedronGeometry = /*#__PURE__*/function (_BufferGeometry6) {
          function PolyhedronGeometry() {
            var _this82;
            var vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var detail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            _classCallCheck2(this, PolyhedronGeometry);
            _this82 = _callSuper(this, PolyhedronGeometry);
            _this82.type = 'PolyhedronGeometry';
            _this82.parameters = {
              vertices: vertices,
              indices: indices,
              radius: radius,
              detail: detail
            };

            // default buffer data

            var vertexBuffer = [];
            var uvBuffer = [];

            // the subdivision creates the vertex buffer data

            subdivide(detail);

            // all vertices should lie on a conceptual sphere with a given radius

            applyRadius(radius);

            // finally, create the uv data

            generateUVs();

            // build non-indexed geometry

            _this82.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
            _this82.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
            _this82.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
            if (detail === 0) {
              _this82.computeVertexNormals(); // flat normals
            } else {
              _this82.normalizeNormals(); // smooth normals
            }

            // helper functions

            function subdivide(detail) {
              var a = new Vector3();
              var b = new Vector3();
              var c = new Vector3();

              // iterate over all faces and apply a subdivision with the given detail value

              for (var i = 0; i < indices.length; i += 3) {
                // get the vertices of the face

                getVertexByIndex(indices[i + 0], a);
                getVertexByIndex(indices[i + 1], b);
                getVertexByIndex(indices[i + 2], c);

                // perform subdivision

                subdivideFace(a, b, c, detail);
              }
            }
            function subdivideFace(a, b, c, detail) {
              var cols = detail + 1;

              // we use this multidimensional array as a data structure for creating the subdivision

              var v = [];

              // construct all of the vertices for this subdivision

              for (var i = 0; i <= cols; i++) {
                v[i] = [];
                var aj = a.clone().lerp(c, i / cols);
                var bj = b.clone().lerp(c, i / cols);
                var rows = cols - i;
                for (var j = 0; j <= rows; j++) {
                  if (j === 0 && i === cols) {
                    v[i][j] = aj;
                  } else {
                    v[i][j] = aj.clone().lerp(bj, j / rows);
                  }
                }
              }

              // construct all of the faces

              for (var _i77 = 0; _i77 < cols; _i77++) {
                for (var _j7 = 0; _j7 < 2 * (cols - _i77) - 1; _j7++) {
                  var _k4 = Math.floor(_j7 / 2);
                  if (_j7 % 2 === 0) {
                    pushVertex(v[_i77][_k4 + 1]);
                    pushVertex(v[_i77 + 1][_k4]);
                    pushVertex(v[_i77][_k4]);
                  } else {
                    pushVertex(v[_i77][_k4 + 1]);
                    pushVertex(v[_i77 + 1][_k4 + 1]);
                    pushVertex(v[_i77 + 1][_k4]);
                  }
                }
              }
            }
            function applyRadius(radius) {
              var vertex = new Vector3();

              // iterate over the entire buffer and apply the radius to each vertex

              for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                vertex.normalize().multiplyScalar(radius);
                vertexBuffer[i + 0] = vertex.x;
                vertexBuffer[i + 1] = vertex.y;
                vertexBuffer[i + 2] = vertex.z;
              }
            }
            function generateUVs() {
              var vertex = new Vector3();
              for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                var u = azimuth(vertex) / 2 / Math.PI + 0.5;
                var v = inclination(vertex) / Math.PI + 0.5;
                uvBuffer.push(u, 1 - v);
              }
              correctUVs();
              correctSeam();
            }
            function correctSeam() {
              // handle case when face straddles the seam, see #3269

              for (var i = 0; i < uvBuffer.length; i += 6) {
                // uv data of a single face

                var x0 = uvBuffer[i + 0];
                var x1 = uvBuffer[i + 2];
                var x2 = uvBuffer[i + 4];
                var max = Math.max(x0, x1, x2);
                var min = Math.min(x0, x1, x2);

                // 0.9 is somewhat arbitrary

                if (max > 0.9 && min < 0.1) {
                  if (x0 < 0.2) uvBuffer[i + 0] += 1;
                  if (x1 < 0.2) uvBuffer[i + 2] += 1;
                  if (x2 < 0.2) uvBuffer[i + 4] += 1;
                }
              }
            }
            function pushVertex(vertex) {
              vertexBuffer.push(vertex.x, vertex.y, vertex.z);
            }
            function getVertexByIndex(index, vertex) {
              var stride = index * 3;
              vertex.x = vertices[stride + 0];
              vertex.y = vertices[stride + 1];
              vertex.z = vertices[stride + 2];
            }
            function correctUVs() {
              var a = new Vector3();
              var b = new Vector3();
              var c = new Vector3();
              var centroid = new Vector3();
              var uvA = new Vector2();
              var uvB = new Vector2();
              var uvC = new Vector2();
              for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                centroid.copy(a).add(b).add(c).divideScalar(3);
                var azi = azimuth(centroid);
                correctUV(uvA, j + 0, a, azi);
                correctUV(uvB, j + 2, b, azi);
                correctUV(uvC, j + 4, c, azi);
              }
            }
            function correctUV(uv, stride, vector, azimuth) {
              if (azimuth < 0 && uv.x === 1) {
                uvBuffer[stride] = uv.x - 1;
              }
              if (vector.x === 0 && vector.z === 0) {
                uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
              }
            }

            // Angle around the Y axis, counter-clockwise when looking from above.

            function azimuth(vector) {
              return Math.atan2(vector.z, -vector.x);
            }

            // Angle above the XZ plane.

            function inclination(vector) {
              return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
            }
            return _this82;
          }
          _inherits(PolyhedronGeometry, _BufferGeometry6);
          return _createClass(PolyhedronGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(PolyhedronGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
            }
          }]);
        }(BufferGeometry);
        var DodecahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry) {
          function DodecahedronGeometry() {
            var _this83;
            var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            _classCallCheck2(this, DodecahedronGeometry);
            var t = (1 + Math.sqrt(5)) / 2;
            var r = 1 / t;
            var vertices = [
            // (1, 1, 1)
            -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1,
            // (0, 1/, )
            0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t,
            // (1/, , 0)
            -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0,
            // (, 0, 1/)
            -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
            var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
            _this83 = _callSuper(this, DodecahedronGeometry, [vertices, indices, radius, detail]);
            _this83.type = 'DodecahedronGeometry';
            _this83.parameters = {
              radius: radius,
              detail: detail
            };
            return _this83;
          }
          _inherits(DodecahedronGeometry, _PolyhedronGeometry);
          return _createClass(DodecahedronGeometry, null, [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new DodecahedronGeometry(data.radius, data.detail);
            }
          }]);
        }(PolyhedronGeometry);
        var _v0 = /*@__PURE__*/new Vector3();
        var _v1$1 = /*@__PURE__*/new Vector3();
        var _normal = /*@__PURE__*/new Vector3();
        var _triangle = /*@__PURE__*/new Triangle();
        var EdgesGeometry = /*#__PURE__*/function (_BufferGeometry7) {
          function EdgesGeometry() {
            var _this84;
            var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var thresholdAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            _classCallCheck2(this, EdgesGeometry);
            _this84 = _callSuper(this, EdgesGeometry);
            _this84.type = 'EdgesGeometry';
            _this84.parameters = {
              geometry: geometry,
              thresholdAngle: thresholdAngle
            };
            if (geometry !== null) {
              var precisionPoints = 4;
              var precision = Math.pow(10, precisionPoints);
              var thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
              var indexAttr = geometry.getIndex();
              var positionAttr = geometry.getAttribute('position');
              var indexCount = indexAttr ? indexAttr.count : positionAttr.count;
              var indexArr = [0, 0, 0];
              var vertKeys = ['a', 'b', 'c'];
              var hashes = new Array(3);
              var edgeData = {};
              var vertices = [];
              for (var i = 0; i < indexCount; i += 3) {
                if (indexAttr) {
                  indexArr[0] = indexAttr.getX(i);
                  indexArr[1] = indexAttr.getX(i + 1);
                  indexArr[2] = indexAttr.getX(i + 2);
                } else {
                  indexArr[0] = i;
                  indexArr[1] = i + 1;
                  indexArr[2] = i + 2;
                }
                var a = _triangle.a,
                  b = _triangle.b,
                  _c16 = _triangle.c;
                a.fromBufferAttribute(positionAttr, indexArr[0]);
                b.fromBufferAttribute(positionAttr, indexArr[1]);
                _c16.fromBufferAttribute(positionAttr, indexArr[2]);
                _triangle.getNormal(_normal);

                // create hashes for the edge from the vertices
                hashes[0] = "".concat(Math.round(a.x * precision), ",").concat(Math.round(a.y * precision), ",").concat(Math.round(a.z * precision));
                hashes[1] = "".concat(Math.round(b.x * precision), ",").concat(Math.round(b.y * precision), ",").concat(Math.round(b.z * precision));
                hashes[2] = "".concat(Math.round(_c16.x * precision), ",").concat(Math.round(_c16.y * precision), ",").concat(Math.round(_c16.z * precision));

                // skip degenerate triangles
                if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
                  continue;
                }

                // iterate over every edge
                for (var j = 0; j < 3; j++) {
                  // get the first and next vertex making up the edge
                  var jNext = (j + 1) % 3;
                  var vecHash0 = hashes[j];
                  var vecHash1 = hashes[jNext];
                  var v0 = _triangle[vertKeys[j]];
                  var v1 = _triangle[vertKeys[jNext]];
                  var hash = "".concat(vecHash0, "_").concat(vecHash1);
                  var reverseHash = "".concat(vecHash1, "_").concat(vecHash0);
                  if (reverseHash in edgeData && edgeData[reverseHash]) {
                    // if we found a sibling edge add it into the vertex array if
                    // it meets the angle threshold and delete the edge from the map.
                    if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                      vertices.push(v0.x, v0.y, v0.z);
                      vertices.push(v1.x, v1.y, v1.z);
                    }
                    edgeData[reverseHash] = null;
                  } else if (!(hash in edgeData)) {
                    // if we've already got an edge here then skip adding a new one
                    edgeData[hash] = {
                      index0: indexArr[j],
                      index1: indexArr[jNext],
                      normal: _normal.clone()
                    };
                  }
                }
              }

              // iterate over all remaining, unmatched edges and add them to the vertex array
              for (var key in edgeData) {
                if (edgeData[key]) {
                  var _edgeData$key = edgeData[key],
                    index0 = _edgeData$key.index0,
                    index1 = _edgeData$key.index1;
                  _v0.fromBufferAttribute(positionAttr, index0);
                  _v1$1.fromBufferAttribute(positionAttr, index1);
                  vertices.push(_v0.x, _v0.y, _v0.z);
                  vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
                }
              }
              _this84.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            }
            return _this84;
          }
          _inherits(EdgesGeometry, _BufferGeometry7);
          return _createClass(EdgesGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(EdgesGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }]);
        }(BufferGeometry);
        var Shape = /*#__PURE__*/function (_Path) {
          function Shape(points) {
            var _this85;
            _classCallCheck2(this, Shape);
            _this85 = _callSuper(this, Shape, [points]);
            _this85.uuid = generateUUID();
            _this85.type = 'Shape';
            _this85.holes = [];
            return _this85;
          }
          _inherits(Shape, _Path);
          return _createClass(Shape, [{
            key: "getPointsHoles",
            value: function getPointsHoles(divisions) {
              var holesPts = [];
              for (var i = 0, l = this.holes.length; i < l; i++) {
                holesPts[i] = this.holes[i].getPoints(divisions);
              }
              return holesPts;
            }

            // get points of shape and holes (keypoints based on segments parameter)
          }, {
            key: "extractPoints",
            value: function extractPoints(divisions) {
              return {
                shape: this.getPoints(divisions),
                holes: this.getPointsHoles(divisions)
              };
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(Shape, "copy", this, 3)([source]);
              this.holes = [];
              for (var i = 0, l = source.holes.length; i < l; i++) {
                var hole = source.holes[i];
                this.holes.push(hole.clone());
              }
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(Shape, "toJSON", this, 3)([]);
              data.uuid = this.uuid;
              data.holes = [];
              for (var i = 0, l = this.holes.length; i < l; i++) {
                var hole = this.holes[i];
                data.holes.push(hole.toJSON());
              }
              return data;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              _superPropGet(Shape, "fromJSON", this, 3)([json]);
              this.uuid = json.uuid;
              this.holes = [];
              for (var i = 0, l = json.holes.length; i < l; i++) {
                var hole = json.holes[i];
                this.holes.push(new Path().fromJSON(hole));
              }
              return this;
            }
          }]);
        }(Path);
        /**
         * Port from https://github.com/mapbox/earcut (v2.2.4)
         */
        var Earcut = {
          triangulate: function triangulate(data, holeIndices) {
            var dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
            var hasHoles = holeIndices && holeIndices.length;
            var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
            var outerNode = linkedList(data, 0, outerLen, dim, true);
            var triangles = [];
            if (!outerNode || outerNode.next === outerNode.prev) return triangles;
            var minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

            // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
            if (data.length > 80 * dim) {
              minX = maxX = data[0];
              minY = maxY = data[1];
              for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
              }

              // minX, minY and invSize are later used to transform coords into integers for z-order calculation
              invSize = Math.max(maxX - minX, maxY - minY);
              invSize = invSize !== 0 ? 32767 / invSize : 0;
            }
            earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
            return triangles;
          }
        };

        // create a circular doubly linked list from polygon points in the specified winding order
        function linkedList(data, start, end, dim, clockwise) {
          var i, last;
          if (clockwise === signedArea(data, start, end, dim) > 0) {
            for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
          } else {
            for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
          }
          if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
          }
          return last;
        }

        // eliminate colinear or duplicate points
        function filterPoints(start, end) {
          if (!start) return start;
          if (!end) end = start;
          var p = start,
            again;
          do {
            again = false;
            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
              removeNode(p);
              p = end = p.prev;
              if (p === p.next) break;
              again = true;
            } else {
              p = p.next;
            }
          } while (again || p !== end);
          return end;
        }

        // main ear slicing loop which triangulates a polygon (given as a linked list)
        function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
          if (!ear) return;

          // interlink polygon nodes in z-order
          if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
          var stop = ear,
            prev,
            next;

          // iterate through ears, slicing them one by one
          while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;
            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
              // cut off the triangle
              triangles.push(prev.i / dim | 0);
              triangles.push(ear.i / dim | 0);
              triangles.push(next.i / dim | 0);
              removeNode(ear);

              // skipping the next vertex leads to less sliver triangles
              ear = next.next;
              stop = next.next;
              continue;
            }
            ear = next;

            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
              // try filtering points and slicing again
              if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

                // if this didn't work, try curing all small self-intersections locally
              } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

                // as a last resort, try splitting the remaining polygon into two
              } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
              }
              break;
            }
          }
        }

        // check whether a polygon node forms a valid ear with adjacent nodes
        function isEar(ear) {
          var a = ear.prev,
            b = ear,
            c = ear.next;
          if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

          // now make sure we don't have other points inside the potential ear
          var ax = a.x,
            bx = b.x,
            cx = c.x,
            ay = a.y,
            by = b.y,
            cy = c.y;

          // triangle bbox; min & max are calculated like this for speed
          var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
            y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
            x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
            y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
          var p = c.next;
          while (p !== a) {
            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.next;
          }
          return true;
        }
        function isEarHashed(ear, minX, minY, invSize) {
          var a = ear.prev,
            b = ear,
            c = ear.next;
          if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

          var ax = a.x,
            bx = b.x,
            cx = c.x,
            ay = a.y,
            by = b.y,
            cy = c.y;

          // triangle bbox; min & max are calculated like this for speed
          var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
            y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
            x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
            y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;

          // z-order range for the current triangle bbox;
          var minZ = zOrder(x0, y0, minX, minY, invSize),
            maxZ = zOrder(x1, y1, minX, minY, invSize);
          var p = ear.prevZ,
            n = ear.nextZ;

          // look for points inside the triangle in both directions
          while (p && p.z >= minZ && n && n.z <= maxZ) {
            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
            if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
          }

          // look for remaining points in decreasing z-order
          while (p && p.z >= minZ) {
            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
          }

          // look for remaining points in increasing z-order
          while (n && n.z <= maxZ) {
            if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
          }
          return true;
        }

        // go through all polygon nodes and cure small local self-intersections
        function cureLocalIntersections(start, triangles, dim) {
          var p = start;
          do {
            var a = p.prev,
              b = p.next.next;
            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
              triangles.push(a.i / dim | 0);
              triangles.push(p.i / dim | 0);
              triangles.push(b.i / dim | 0);

              // remove two nodes involved
              removeNode(p);
              removeNode(p.next);
              p = start = b;
            }
            p = p.next;
          } while (p !== start);
          return filterPoints(p);
        }

        // try splitting polygon into two and triangulate them independently
        function splitEarcut(start, triangles, dim, minX, minY, invSize) {
          // look for a valid diagonal that divides the polygon into two
          var a = start;
          do {
            var b = a.next.next;
            while (b !== a.prev) {
              if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var _c17 = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                _c17 = filterPoints(_c17, _c17.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(_c17, triangles, dim, minX, minY, invSize, 0);
                return;
              }
              b = b.next;
            }
            a = a.next;
          } while (a !== start);
        }

        // link every hole into the outer loop, producing a single-ring polygon without holes
        function eliminateHoles(data, holeIndices, outerNode, dim) {
          var queue = [];
          var i, len, start, end, list;
          for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next) list.steiner = true;
            queue.push(getLeftmost(list));
          }
          queue.sort(compareX);

          // process holes from left to right
          for (i = 0; i < queue.length; i++) {
            outerNode = eliminateHole(queue[i], outerNode);
          }
          return outerNode;
        }
        function compareX(a, b) {
          return a.x - b.x;
        }

        // find a bridge between vertices that connects hole with an outer ring and link it
        function eliminateHole(hole, outerNode) {
          var bridge = findHoleBridge(hole, outerNode);
          if (!bridge) {
            return outerNode;
          }
          var bridgeReverse = splitPolygon(bridge, hole);

          // filter collinear points around the cuts
          filterPoints(bridgeReverse, bridgeReverse.next);
          return filterPoints(bridge, bridge.next);
        }

        // David Eberly's algorithm for finding a bridge between hole and outer polygon
        function findHoleBridge(hole, outerNode) {
          var p = outerNode,
            qx = -Infinity,
            m;
          var hx = hole.x,
            hy = hole.y;

          // find a segment intersected by a ray from the hole's leftmost point to the left;
          // segment's endpoint with lesser x will be potential connection point
          do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
              var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
              if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
              }
            }
            p = p.next;
          } while (p !== outerNode);
          if (!m) return null;

          // look for points inside the triangle of hole point, segment intersection and endpoint;
          // if there are no points found, we have a valid connection;
          // otherwise choose the point of the minimum angle with the ray as connection point

          var stop = m,
            mx = m.x,
            my = m.y;
          var tanMin = Infinity,
            tan;
          p = m;
          do {
            if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
              tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

              if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
              }
            }
            p = p.next;
          } while (p !== stop);
          return m;
        }

        // whether sector in vertex m contains sector in vertex p in the same coordinates
        function sectorContainsSector(m, p) {
          return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
        }

        // interlink polygon nodes in z-order
        function indexCurve(start, minX, minY, invSize) {
          var p = start;
          do {
            if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
          } while (p !== start);
          p.prevZ.nextZ = null;
          p.prevZ = null;
          sortLinked(p);
        }

        // Simon Tatham's linked list merge sort algorithm
        // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
        function sortLinked(list) {
          var i,
            p,
            q,
            e,
            tail,
            numMerges,
            pSize,
            qSize,
            inSize = 1;
          do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
            while (p) {
              numMerges++;
              q = p;
              pSize = 0;
              for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
              }
              qSize = inSize;
              while (pSize > 0 || qSize > 0 && q) {
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                  e = p;
                  p = p.nextZ;
                  pSize--;
                } else {
                  e = q;
                  q = q.nextZ;
                  qSize--;
                }
                if (tail) tail.nextZ = e;else list = e;
                e.prevZ = tail;
                tail = e;
              }
              p = q;
            }
            tail.nextZ = null;
            inSize *= 2;
          } while (numMerges > 1);
          return list;
        }

        // z-order of a point given coords and inverse of the longer side of data bbox
        function zOrder(x, y, minX, minY, invSize) {
          // coords are transformed into non-negative 15-bit integer range
          x = (x - minX) * invSize | 0;
          y = (y - minY) * invSize | 0;
          x = (x | x << 8) & 0x00FF00FF;
          x = (x | x << 4) & 0x0F0F0F0F;
          x = (x | x << 2) & 0x33333333;
          x = (x | x << 1) & 0x55555555;
          y = (y | y << 8) & 0x00FF00FF;
          y = (y | y << 4) & 0x0F0F0F0F;
          y = (y | y << 2) & 0x33333333;
          y = (y | y << 1) & 0x55555555;
          return x | y << 1;
        }

        // find the leftmost node of a polygon ring
        function getLeftmost(start) {
          var p = start,
            leftmost = start;
          do {
            if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
            p = p.next;
          } while (p !== start);
          return leftmost;
        }

        // check if a point lies within a convex triangle
        function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
          return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
        }

        // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
        function isValidDiagonal(a, b) {
          return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (
          // dones't intersect other edges
          locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (
          // locally visible
          area(a.prev, a, b.prev) || area(a, b.prev, b)) ||
          // does not create opposite-facing sectors
          equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
        }

        // signed area of a triangle
        function area(p, q, r) {
          return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        }

        // check if two points are equal
        function equals(p1, p2) {
          return p1.x === p2.x && p1.y === p2.y;
        }

        // check if two segments intersect
        function intersects(p1, q1, p2, q2) {
          var o1 = sign(area(p1, q1, p2));
          var o2 = sign(area(p1, q1, q2));
          var o3 = sign(area(p2, q2, p1));
          var o4 = sign(area(p2, q2, q1));
          if (o1 !== o2 && o3 !== o4) return true; // general case

          if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
          if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
          if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
          if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

          return false;
        }

        // for collinear points p, q, r, check if point q lies on segment pr
        function onSegment(p, q, r) {
          return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
        }
        function sign(num) {
          return num > 0 ? 1 : num < 0 ? -1 : 0;
        }

        // check if a polygon diagonal intersects any polygon segments
        function intersectsPolygon(a, b) {
          var p = a;
          do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
            p = p.next;
          } while (p !== a);
          return false;
        }

        // check if a polygon diagonal is locally inside the polygon
        function locallyInside(a, b) {
          return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
        }

        // check if the middle point of a polygon diagonal is inside the polygon
        function middleInside(a, b) {
          var p = a,
            inside = false;
          var px = (a.x + b.x) / 2,
            py = (a.y + b.y) / 2;
          do {
            if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
            p = p.next;
          } while (p !== a);
          return inside;
        }

        // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
        // if one belongs to the outer ring and another to a hole, it merges it into a single ring
        function splitPolygon(a, b) {
          var a2 = new Node(a.i, a.x, a.y),
            b2 = new Node(b.i, b.x, b.y),
            an = a.next,
            bp = b.prev;
          a.next = b;
          b.prev = a;
          a2.next = an;
          an.prev = a2;
          b2.next = a2;
          a2.prev = b2;
          bp.next = b2;
          b2.prev = bp;
          return b2;
        }

        // create a node and optionally link it with previous one (in a circular doubly linked list)
        function insertNode(i, x, y, last) {
          var p = new Node(i, x, y);
          if (!last) {
            p.prev = p;
            p.next = p;
          } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
          }
          return p;
        }
        function removeNode(p) {
          p.next.prev = p.prev;
          p.prev.next = p.next;
          if (p.prevZ) p.prevZ.nextZ = p.nextZ;
          if (p.nextZ) p.nextZ.prevZ = p.prevZ;
        }
        function Node(i, x, y) {
          // vertex index in coordinates array
          this.i = i;

          // vertex coordinates
          this.x = x;
          this.y = y;

          // previous and next vertex nodes in a polygon ring
          this.prev = null;
          this.next = null;

          // z-order curve value
          this.z = 0;

          // previous and next nodes in z-order
          this.prevZ = null;
          this.nextZ = null;

          // indicates whether this is a steiner point
          this.steiner = false;
        }
        function signedArea(data, start, end, dim) {
          var sum = 0;
          for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
          }
          return sum;
        }
        var ShapeUtils = /*#__PURE__*/function () {
          function ShapeUtils() {
            _classCallCheck2(this, ShapeUtils);
          }
          return _createClass(ShapeUtils, null, [{
            key: "area",
            value:
            // calculate area of the contour polygon

            function area(contour) {
              var n = contour.length;
              var a = 0.0;
              for (var _p7 = n - 1, q = 0; q < n; _p7 = q++) {
                a += contour[_p7].x * contour[q].y - contour[q].x * contour[_p7].y;
              }
              return a * 0.5;
            }
          }, {
            key: "isClockWise",
            value: function isClockWise(pts) {
              return ShapeUtils.area(pts) < 0;
            }
          }, {
            key: "triangulateShape",
            value: function triangulateShape(contour, holes) {
              var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
              var holeIndices = []; // array of hole indices
              var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

              removeDupEndPts(contour);
              addContour(vertices, contour);

              //

              var holeIndex = contour.length;
              holes.forEach(removeDupEndPts);
              for (var i = 0; i < holes.length; i++) {
                holeIndices.push(holeIndex);
                holeIndex += holes[i].length;
                addContour(vertices, holes[i]);
              }

              //

              var triangles = Earcut.triangulate(vertices, holeIndices);

              //

              for (var _i78 = 0; _i78 < triangles.length; _i78 += 3) {
                faces.push(triangles.slice(_i78, _i78 + 3));
              }
              return faces;
            }
          }]);
        }();
        function removeDupEndPts(points) {
          var l = points.length;
          if (l > 2 && points[l - 1].equals(points[0])) {
            points.pop();
          }
        }
        function addContour(vertices, contour) {
          for (var i = 0; i < contour.length; i++) {
            vertices.push(contour[i].x);
            vertices.push(contour[i].y);
          }
        }

        /**
         * Creates extruded geometry from a path shape.
         *
         * parameters = {
         *
         *  curveSegments: <int>, // number of points on the curves
         *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
         *  depth: <float>, // Depth to extrude the shape
         *
         *  bevelEnabled: <bool>, // turn on bevel
         *  bevelThickness: <float>, // how deep into the original shape bevel goes
         *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
         *  bevelOffset: <float>, // how far from shape outline does bevel start
         *  bevelSegments: <int>, // number of bevel layers
         *
         *  extrudePath: <THREE.Curve> // curve to extrude shape along
         *
         *  UVGenerator: <Object> // object that provides UV generator functions
         *
         * }
         */
        var ExtrudeGeometry = /*#__PURE__*/function (_BufferGeometry8) {
          function ExtrudeGeometry() {
            var _this86;
            var shapes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck2(this, ExtrudeGeometry);
            _this86 = _callSuper(this, ExtrudeGeometry);
            _this86.type = 'ExtrudeGeometry';
            _this86.parameters = {
              shapes: shapes,
              options: options
            };
            shapes = Array.isArray(shapes) ? shapes : [shapes];
            var scope = _this86;
            var verticesArray = [];
            var uvArray = [];
            for (var i = 0, l = shapes.length; i < l; i++) {
              var shape = shapes[i];
              addShape(shape);
            }

            // build geometry

            _this86.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
            _this86.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
            _this86.computeVertexNormals();

            // functions

            function addShape(shape) {
              var placeholder = [];

              // options

              var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
              var steps = options.steps !== undefined ? options.steps : 1;
              var depth = options.depth !== undefined ? options.depth : 1;
              var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
              var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
              var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
              var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
              var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
              var extrudePath = options.extrudePath;
              var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

              //

              var extrudePts,
                extrudeByPath = false;
              var splineTube, binormal, normal, position2;
              if (extrudePath) {
                extrudePts = extrudePath.getSpacedPoints(steps);
                extrudeByPath = true;
                bevelEnabled = false; // bevels not supported for path extrusion

                // SETUP TNB variables

                // TODO1 - have a .isClosed in spline?

                splineTube = extrudePath.computeFrenetFrames(steps, false);

                // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

                binormal = new Vector3();
                normal = new Vector3();
                position2 = new Vector3();
              }

              // Safeguards if bevels are not enabled

              if (!bevelEnabled) {
                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;
                bevelOffset = 0;
              }

              // Variables initialization

              var shapePoints = shape.extractPoints(curveSegments);
              var vertices = shapePoints.shape;
              var holes = shapePoints.holes;
              var reverse = !ShapeUtils.isClockWise(vertices);
              if (reverse) {
                vertices = vertices.reverse();

                // Maybe we should also check if holes are in the opposite direction, just to be safe ...

                for (var _h = 0, hl = holes.length; _h < hl; _h++) {
                  var ahole = holes[_h];
                  if (ShapeUtils.isClockWise(ahole)) {
                    holes[_h] = ahole.reverse();
                  }
                }
              }
              var faces = ShapeUtils.triangulateShape(vertices, holes);

              /* Vertices */

              var contour = vertices; // vertices has all points but contour has only points of circumference

              for (var _h2 = 0, _hl = holes.length; _h2 < _hl; _h2++) {
                var _ahole = holes[_h2];
                vertices = vertices.concat(_ahole);
              }
              function scalePt2(pt, vec, size) {
                if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
                return pt.clone().addScaledVector(vec, size);
              }
              var vlen = vertices.length,
                flen = faces.length;

              // Find directions for point movement

              function getBevelVec(inPt, inPrev, inNext) {
                // computes for inPt the corresponding point inPt' on a new contour
                //   shifted by 1 unit (length of normalized vector) to the left
                // if we walk along contour clockwise, this new contour is outside the old one
                //
                // inPt' is the intersection of the two lines parallel to the two
                //  adjacent edges of inPt at a distance of 1 unit on the left side.

                var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

                // good reading for geometry algorithms (here: line-line intersection)
                // http://geomalgorithms.com/a05-_intersect-1.html

                var v_prev_x = inPt.x - inPrev.x,
                  v_prev_y = inPt.y - inPrev.y;
                var v_next_x = inNext.x - inPt.x,
                  v_next_y = inNext.y - inPt.y;
                var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;

                // check for collinear edges
                var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
                if (Math.abs(collinear0) > Number.EPSILON) {
                  // not collinear

                  // length of vectors for normalizing

                  var v_prev_len = Math.sqrt(v_prev_lensq);
                  var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);

                  // shift adjacent points by unit vectors to the left

                  var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                  var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                  var ptNextShift_x = inNext.x - v_next_y / v_next_len;
                  var ptNextShift_y = inNext.y + v_next_x / v_next_len;

                  // scaling factor for v_prev to intersection point

                  var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);

                  // vector from inPt to intersection point

                  v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                  v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;

                  // Don't normalize!, otherwise sharp corners become ugly
                  //  but prevent crazy spikes
                  var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                  if (v_trans_lensq <= 2) {
                    return new Vector2(v_trans_x, v_trans_y);
                  } else {
                    shrink_by = Math.sqrt(v_trans_lensq / 2);
                  }
                } else {
                  // handle special case of collinear edges

                  var direction_eq = false; // assumes: opposite

                  if (v_prev_x > Number.EPSILON) {
                    if (v_next_x > Number.EPSILON) {
                      direction_eq = true;
                    }
                  } else {
                    if (v_prev_x < -Number.EPSILON) {
                      if (v_next_x < -Number.EPSILON) {
                        direction_eq = true;
                      }
                    } else {
                      if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                        direction_eq = true;
                      }
                    }
                  }
                  if (direction_eq) {
                    // console.log("Warning: lines are a straight sequence");
                    v_trans_x = -v_prev_y;
                    v_trans_y = v_prev_x;
                    shrink_by = Math.sqrt(v_prev_lensq);
                  } else {
                    // console.log("Warning: lines are a straight spike");
                    v_trans_x = v_prev_x;
                    v_trans_y = v_prev_y;
                    shrink_by = Math.sqrt(v_prev_lensq / 2);
                  }
                }
                return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
              }
              var contourMovements = [];
              for (var _i79 = 0, il = contour.length, j = il - 1, _k5 = _i79 + 1; _i79 < il; _i79++, j++, _k5++) {
                if (j === il) j = 0;
                if (_k5 === il) _k5 = 0;

                //  (j)---(i)---(k)
                // console.log('i,j,k', i, j , k)

                contourMovements[_i79] = getBevelVec(contour[_i79], contour[j], contour[_k5]);
              }
              var holesMovements = [];
              var oneHoleMovements,
                verticesMovements = contourMovements.concat();
              for (var _h3 = 0, _hl2 = holes.length; _h3 < _hl2; _h3++) {
                var _ahole2 = holes[_h3];
                oneHoleMovements = [];
                for (var _i80 = 0, _il14 = _ahole2.length, _j8 = _il14 - 1, _k6 = _i80 + 1; _i80 < _il14; _i80++, _j8++, _k6++) {
                  if (_j8 === _il14) _j8 = 0;
                  if (_k6 === _il14) _k6 = 0;

                  //  (j)---(i)---(k)
                  oneHoleMovements[_i80] = getBevelVec(_ahole2[_i80], _ahole2[_j8], _ahole2[_k6]);
                }
                holesMovements.push(oneHoleMovements);
                verticesMovements = verticesMovements.concat(oneHoleMovements);
              }

              // Loop bevelSegments, 1 for the front, 1 for the back

              for (var b = 0; b < bevelSegments; b++) {
                //for ( b = bevelSegments; b > 0; b -- ) {

                var t = b / bevelSegments;
                var z = bevelThickness * Math.cos(t * Math.PI / 2);
                var _bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

                // contract shape

                for (var _i81 = 0, _il15 = contour.length; _i81 < _il15; _i81++) {
                  var vert = scalePt2(contour[_i81], contourMovements[_i81], _bs);
                  v(vert.x, vert.y, -z);
                }

                // expand holes

                for (var _h4 = 0, _hl3 = holes.length; _h4 < _hl3; _h4++) {
                  var _ahole3 = holes[_h4];
                  oneHoleMovements = holesMovements[_h4];
                  for (var _i82 = 0, _il16 = _ahole3.length; _i82 < _il16; _i82++) {
                    var _vert = scalePt2(_ahole3[_i82], oneHoleMovements[_i82], _bs);
                    v(_vert.x, _vert.y, -z);
                  }
                }
              }
              var bs = bevelSize + bevelOffset;

              // Back facing vertices

              for (var _i83 = 0; _i83 < vlen; _i83++) {
                var _vert2 = bevelEnabled ? scalePt2(vertices[_i83], verticesMovements[_i83], bs) : vertices[_i83];
                if (!extrudeByPath) {
                  v(_vert2.x, _vert2.y, 0);
                } else {
                  // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

                  normal.copy(splineTube.normals[0]).multiplyScalar(_vert2.x);
                  binormal.copy(splineTube.binormals[0]).multiplyScalar(_vert2.y);
                  position2.copy(extrudePts[0]).add(normal).add(binormal);
                  v(position2.x, position2.y, position2.z);
                }
              }

              // Add stepped vertices...
              // Including front facing vertices

              for (var s = 1; s <= steps; s++) {
                for (var _i84 = 0; _i84 < vlen; _i84++) {
                  var _vert3 = bevelEnabled ? scalePt2(vertices[_i84], verticesMovements[_i84], bs) : vertices[_i84];
                  if (!extrudeByPath) {
                    v(_vert3.x, _vert3.y, depth / steps * s);
                  } else {
                    // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

                    normal.copy(splineTube.normals[s]).multiplyScalar(_vert3.x);
                    binormal.copy(splineTube.binormals[s]).multiplyScalar(_vert3.y);
                    position2.copy(extrudePts[s]).add(normal).add(binormal);
                    v(position2.x, position2.y, position2.z);
                  }
                }
              }

              // Add bevel segments planes

              //for ( b = 1; b <= bevelSegments; b ++ ) {
              for (var _b8 = bevelSegments - 1; _b8 >= 0; _b8--) {
                var _t = _b8 / bevelSegments;
                var _z2 = bevelThickness * Math.cos(_t * Math.PI / 2);
                var _bs2 = bevelSize * Math.sin(_t * Math.PI / 2) + bevelOffset;

                // contract shape

                for (var _i85 = 0, _il17 = contour.length; _i85 < _il17; _i85++) {
                  var _vert4 = scalePt2(contour[_i85], contourMovements[_i85], _bs2);
                  v(_vert4.x, _vert4.y, depth + _z2);
                }

                // expand holes

                for (var _h5 = 0, _hl4 = holes.length; _h5 < _hl4; _h5++) {
                  var _ahole4 = holes[_h5];
                  oneHoleMovements = holesMovements[_h5];
                  for (var _i86 = 0, _il18 = _ahole4.length; _i86 < _il18; _i86++) {
                    var _vert5 = scalePt2(_ahole4[_i86], oneHoleMovements[_i86], _bs2);
                    if (!extrudeByPath) {
                      v(_vert5.x, _vert5.y, depth + _z2);
                    } else {
                      v(_vert5.x, _vert5.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + _z2);
                    }
                  }
                }
              }

              /* Faces */

              // Top and bottom faces

              buildLidFaces();

              // Sides faces

              buildSideFaces();

              /////  Internal functions

              function buildLidFaces() {
                var start = verticesArray.length / 3;
                if (bevelEnabled) {
                  var layer = 0; // steps + 1
                  var offset = vlen * layer;

                  // Bottom faces

                  for (var _i87 = 0; _i87 < flen; _i87++) {
                    var face = faces[_i87];
                    f3(face[2] + offset, face[1] + offset, face[0] + offset);
                  }
                  layer = steps + bevelSegments * 2;
                  offset = vlen * layer;

                  // Top faces

                  for (var _i88 = 0; _i88 < flen; _i88++) {
                    var _face = faces[_i88];
                    f3(_face[0] + offset, _face[1] + offset, _face[2] + offset);
                  }
                } else {
                  // Bottom faces

                  for (var _i89 = 0; _i89 < flen; _i89++) {
                    var _face2 = faces[_i89];
                    f3(_face2[2], _face2[1], _face2[0]);
                  }

                  // Top faces

                  for (var _i90 = 0; _i90 < flen; _i90++) {
                    var _face3 = faces[_i90];
                    f3(_face3[0] + vlen * steps, _face3[1] + vlen * steps, _face3[2] + vlen * steps);
                  }
                }
                scope.addGroup(start, verticesArray.length / 3 - start, 0);
              }

              // Create faces for the z-sides of the shape

              function buildSideFaces() {
                var start = verticesArray.length / 3;
                var layeroffset = 0;
                sidewalls(contour, layeroffset);
                layeroffset += contour.length;
                for (var _h6 = 0, _hl5 = holes.length; _h6 < _hl5; _h6++) {
                  var _ahole5 = holes[_h6];
                  sidewalls(_ahole5, layeroffset);

                  //, true
                  layeroffset += _ahole5.length;
                }
                scope.addGroup(start, verticesArray.length / 3 - start, 1);
              }
              function sidewalls(contour, layeroffset) {
                var i = contour.length;
                while (--i >= 0) {
                  var _j9 = i;
                  var _k7 = i - 1;
                  if (_k7 < 0) _k7 = contour.length - 1;

                  //console.log('b', i,j, i-1, k,vertices.length);

                  for (var _s4 = 0, sl = steps + bevelSegments * 2; _s4 < sl; _s4++) {
                    var slen1 = vlen * _s4;
                    var slen2 = vlen * (_s4 + 1);
                    var a = layeroffset + _j9 + slen1,
                      _b9 = layeroffset + _k7 + slen1,
                      _c18 = layeroffset + _k7 + slen2,
                      d = layeroffset + _j9 + slen2;
                    f4(a, _b9, _c18, d);
                  }
                }
              }
              function v(x, y, z) {
                placeholder.push(x);
                placeholder.push(y);
                placeholder.push(z);
              }
              function f3(a, b, c) {
                addVertex(a);
                addVertex(b);
                addVertex(c);
                var nextIndex = verticesArray.length / 3;
                var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[2]);
              }
              function f4(a, b, c, d) {
                addVertex(a);
                addVertex(b);
                addVertex(d);
                addVertex(b);
                addVertex(c);
                addVertex(d);
                var nextIndex = verticesArray.length / 3;
                var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[3]);
                addUV(uvs[1]);
                addUV(uvs[2]);
                addUV(uvs[3]);
              }
              function addVertex(index) {
                verticesArray.push(placeholder[index * 3 + 0]);
                verticesArray.push(placeholder[index * 3 + 1]);
                verticesArray.push(placeholder[index * 3 + 2]);
              }
              function addUV(vector2) {
                uvArray.push(vector2.x);
                uvArray.push(vector2.y);
              }
            }
            return _this86;
          }
          _inherits(ExtrudeGeometry, _BufferGeometry8);
          return _createClass(ExtrudeGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(ExtrudeGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(ExtrudeGeometry, "toJSON", this, 3)([]);
              var shapes = this.parameters.shapes;
              var options = this.parameters.options;
              return toJSON$1(shapes, options, data);
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(data, shapes) {
              var geometryShapes = [];
              for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                var shape = shapes[data.shapes[j]];
                geometryShapes.push(shape);
              }
              var extrudePath = data.options.extrudePath;
              if (extrudePath !== undefined) {
                data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
              }
              return new ExtrudeGeometry(geometryShapes, data.options);
            }
          }]);
        }(BufferGeometry);
        var WorldUVGenerator = {
          generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {
            var a_x = vertices[indexA * 3];
            var a_y = vertices[indexA * 3 + 1];
            var b_x = vertices[indexB * 3];
            var b_y = vertices[indexB * 3 + 1];
            var c_x = vertices[indexC * 3];
            var c_y = vertices[indexC * 3 + 1];
            return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
          },
          generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {
            var a_x = vertices[indexA * 3];
            var a_y = vertices[indexA * 3 + 1];
            var a_z = vertices[indexA * 3 + 2];
            var b_x = vertices[indexB * 3];
            var b_y = vertices[indexB * 3 + 1];
            var b_z = vertices[indexB * 3 + 2];
            var c_x = vertices[indexC * 3];
            var c_y = vertices[indexC * 3 + 1];
            var c_z = vertices[indexC * 3 + 2];
            var d_x = vertices[indexD * 3];
            var d_y = vertices[indexD * 3 + 1];
            var d_z = vertices[indexD * 3 + 2];
            if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
              return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
            } else {
              return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
            }
          }
        };
        function toJSON$1(shapes, options, data) {
          data.shapes = [];
          if (Array.isArray(shapes)) {
            for (var i = 0, l = shapes.length; i < l; i++) {
              var shape = shapes[i];
              data.shapes.push(shape.uuid);
            }
          } else {
            data.shapes.push(shapes.uuid);
          }
          data.options = Object.assign({}, options);
          if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
          return data;
        }
        var IcosahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry2) {
          function IcosahedronGeometry() {
            var _this87;
            var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            _classCallCheck2(this, IcosahedronGeometry);
            var t = (1 + Math.sqrt(5)) / 2;
            var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
            var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
            _this87 = _callSuper(this, IcosahedronGeometry, [vertices, indices, radius, detail]);
            _this87.type = 'IcosahedronGeometry';
            _this87.parameters = {
              radius: radius,
              detail: detail
            };
            return _this87;
          }
          _inherits(IcosahedronGeometry, _PolyhedronGeometry2);
          return _createClass(IcosahedronGeometry, null, [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new IcosahedronGeometry(data.radius, data.detail);
            }
          }]);
        }(PolyhedronGeometry);
        var OctahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry3) {
          function OctahedronGeometry() {
            var _this88;
            var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            _classCallCheck2(this, OctahedronGeometry);
            var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
            var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
            _this88 = _callSuper(this, OctahedronGeometry, [vertices, indices, radius, detail]);
            _this88.type = 'OctahedronGeometry';
            _this88.parameters = {
              radius: radius,
              detail: detail
            };
            return _this88;
          }
          _inherits(OctahedronGeometry, _PolyhedronGeometry3);
          return _createClass(OctahedronGeometry, null, [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new OctahedronGeometry(data.radius, data.detail);
            }
          }]);
        }(PolyhedronGeometry);
        var RingGeometry = /*#__PURE__*/function (_BufferGeometry9) {
          function RingGeometry() {
            var _this89;
            var innerRadius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
            var outerRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var thetaSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;
            var phiSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            var thetaStart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
            var thetaLength = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;
            _classCallCheck2(this, RingGeometry);
            _this89 = _callSuper(this, RingGeometry);
            _this89.type = 'RingGeometry';
            _this89.parameters = {
              innerRadius: innerRadius,
              outerRadius: outerRadius,
              thetaSegments: thetaSegments,
              phiSegments: phiSegments,
              thetaStart: thetaStart,
              thetaLength: thetaLength
            };
            thetaSegments = Math.max(3, thetaSegments);
            phiSegments = Math.max(1, phiSegments);

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // some helper variables

            var radius = innerRadius;
            var radiusStep = (outerRadius - innerRadius) / phiSegments;
            var vertex = new Vector3();
            var uv = new Vector2();

            // generate vertices, normals and uvs

            for (var j = 0; j <= phiSegments; j++) {
              for (var i = 0; i <= thetaSegments; i++) {
                // values are generate from the inside of the ring to the outside

                var segment = thetaStart + i / thetaSegments * thetaLength;

                // vertex

                vertex.x = radius * Math.cos(segment);
                vertex.y = radius * Math.sin(segment);
                vertices.push(vertex.x, vertex.y, vertex.z);

                // normal

                normals.push(0, 0, 1);

                // uv

                uv.x = (vertex.x / outerRadius + 1) / 2;
                uv.y = (vertex.y / outerRadius + 1) / 2;
                uvs.push(uv.x, uv.y);
              }

              // increase the radius for next row of vertices

              radius += radiusStep;
            }

            // indices

            for (var _j10 = 0; _j10 < phiSegments; _j10++) {
              var thetaSegmentLevel = _j10 * (thetaSegments + 1);
              for (var _i91 = 0; _i91 < thetaSegments; _i91++) {
                var _segment = _i91 + thetaSegmentLevel;
                var a = _segment;
                var b = _segment + thetaSegments + 1;
                var _c19 = _segment + thetaSegments + 2;
                var d = _segment + 1;

                // faces

                indices.push(a, b, d);
                indices.push(b, _c19, d);
              }
            }

            // build geometry

            _this89.setIndex(indices);
            _this89.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this89.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this89.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            return _this89;
          }
          _inherits(RingGeometry, _BufferGeometry9);
          return _createClass(RingGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(RingGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
            }
          }]);
        }(BufferGeometry);
        var ShapeGeometry = /*#__PURE__*/function (_BufferGeometry10) {
          function ShapeGeometry() {
            var _this90;
            var shapes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);
            var curveSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;
            _classCallCheck2(this, ShapeGeometry);
            _this90 = _callSuper(this, ShapeGeometry);
            _this90.type = 'ShapeGeometry';
            _this90.parameters = {
              shapes: shapes,
              curveSegments: curveSegments
            };

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // helper variables

            var groupStart = 0;
            var groupCount = 0;

            // allow single and array values for "shapes" parameter

            if (Array.isArray(shapes) === false) {
              addShape(shapes);
            } else {
              for (var i = 0; i < shapes.length; i++) {
                addShape(shapes[i]);
                _this90.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

                groupStart += groupCount;
                groupCount = 0;
              }
            }

            // build geometry

            _this90.setIndex(indices);
            _this90.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this90.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this90.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

            // helper functions

            function addShape(shape) {
              var indexOffset = vertices.length / 3;
              var points = shape.extractPoints(curveSegments);
              var shapeVertices = points.shape;
              var shapeHoles = points.holes;

              // check direction of vertices

              if (ShapeUtils.isClockWise(shapeVertices) === false) {
                shapeVertices = shapeVertices.reverse();
              }
              for (var _i92 = 0, l = shapeHoles.length; _i92 < l; _i92++) {
                var shapeHole = shapeHoles[_i92];
                if (ShapeUtils.isClockWise(shapeHole) === true) {
                  shapeHoles[_i92] = shapeHole.reverse();
                }
              }
              var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);

              // join vertices of inner and outer paths to a single array

              for (var _i93 = 0, _l14 = shapeHoles.length; _i93 < _l14; _i93++) {
                var _shapeHole = shapeHoles[_i93];
                shapeVertices = shapeVertices.concat(_shapeHole);
              }

              // vertices, normals, uvs

              for (var _i94 = 0, _l15 = shapeVertices.length; _i94 < _l15; _i94++) {
                var _vertex2 = shapeVertices[_i94];
                vertices.push(_vertex2.x, _vertex2.y, 0);
                normals.push(0, 0, 1);
                uvs.push(_vertex2.x, _vertex2.y); // world uvs
              }

              // indices

              for (var _i95 = 0, _l16 = faces.length; _i95 < _l16; _i95++) {
                var face = faces[_i95];
                var a = face[0] + indexOffset;
                var b = face[1] + indexOffset;
                var _c20 = face[2] + indexOffset;
                indices.push(a, b, _c20);
                groupCount += 3;
              }
            }
            return _this90;
          }
          _inherits(ShapeGeometry, _BufferGeometry10);
          return _createClass(ShapeGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(ShapeGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(ShapeGeometry, "toJSON", this, 3)([]);
              var shapes = this.parameters.shapes;
              return _toJSON(shapes, data);
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(data, shapes) {
              var geometryShapes = [];
              for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                var shape = shapes[data.shapes[j]];
                geometryShapes.push(shape);
              }
              return new ShapeGeometry(geometryShapes, data.curveSegments);
            }
          }]);
        }(BufferGeometry);
        function _toJSON(shapes, data) {
          data.shapes = [];
          if (Array.isArray(shapes)) {
            for (var i = 0, l = shapes.length; i < l; i++) {
              var shape = shapes[i];
              data.shapes.push(shape.uuid);
            }
          } else {
            data.shapes.push(shapes.uuid);
          }
          return data;
        }
        var SphereGeometry = /*#__PURE__*/function (_BufferGeometry11) {
          function SphereGeometry() {
            var _this91;
            var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var widthSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
            var heightSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;
            var phiStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            var phiLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI * 2;
            var thetaStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
            var thetaLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Math.PI;
            _classCallCheck2(this, SphereGeometry);
            _this91 = _callSuper(this, SphereGeometry);
            _this91.type = 'SphereGeometry';
            _this91.parameters = {
              radius: radius,
              widthSegments: widthSegments,
              heightSegments: heightSegments,
              phiStart: phiStart,
              phiLength: phiLength,
              thetaStart: thetaStart,
              thetaLength: thetaLength
            };
            widthSegments = Math.max(3, Math.floor(widthSegments));
            heightSegments = Math.max(2, Math.floor(heightSegments));
            var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
            var index = 0;
            var grid = [];
            var vertex = new Vector3();
            var normal = new Vector3();

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // generate vertices, normals and uvs

            for (var iy = 0; iy <= heightSegments; iy++) {
              var verticesRow = [];
              var v = iy / heightSegments;

              // special case for the poles

              var uOffset = 0;
              if (iy === 0 && thetaStart === 0) {
                uOffset = 0.5 / widthSegments;
              } else if (iy === heightSegments && thetaEnd === Math.PI) {
                uOffset = -0.5 / widthSegments;
              }
              for (var ix = 0; ix <= widthSegments; ix++) {
                var u = ix / widthSegments;

                // vertex

                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertices.push(vertex.x, vertex.y, vertex.z);

                // normal

                normal.copy(vertex).normalize();
                normals.push(normal.x, normal.y, normal.z);

                // uv

                uvs.push(u + uOffset, 1 - v);
                verticesRow.push(index++);
              }
              grid.push(verticesRow);
            }

            // indices

            for (var _iy3 = 0; _iy3 < heightSegments; _iy3++) {
              for (var _ix3 = 0; _ix3 < widthSegments; _ix3++) {
                var a = grid[_iy3][_ix3 + 1];
                var b = grid[_iy3][_ix3];
                var _c21 = grid[_iy3 + 1][_ix3];
                var d = grid[_iy3 + 1][_ix3 + 1];
                if (_iy3 !== 0 || thetaStart > 0) indices.push(a, b, d);
                if (_iy3 !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, _c21, d);
              }
            }

            // build geometry

            _this91.setIndex(indices);
            _this91.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this91.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this91.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            return _this91;
          }
          _inherits(SphereGeometry, _BufferGeometry11);
          return _createClass(SphereGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(SphereGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
            }
          }]);
        }(BufferGeometry);
        var TetrahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry4) {
          function TetrahedronGeometry() {
            var _this92;
            var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            _classCallCheck2(this, TetrahedronGeometry);
            var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
            var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
            _this92 = _callSuper(this, TetrahedronGeometry, [vertices, indices, radius, detail]);
            _this92.type = 'TetrahedronGeometry';
            _this92.parameters = {
              radius: radius,
              detail: detail
            };
            return _this92;
          }
          _inherits(TetrahedronGeometry, _PolyhedronGeometry4);
          return _createClass(TetrahedronGeometry, null, [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new TetrahedronGeometry(data.radius, data.detail);
            }
          }]);
        }(PolyhedronGeometry);
        var TorusGeometry = /*#__PURE__*/function (_BufferGeometry12) {
          function TorusGeometry() {
            var _this93;
            var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var tube = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.4;
            var radialSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 12;
            var tubularSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 48;
            var arc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI * 2;
            _classCallCheck2(this, TorusGeometry);
            _this93 = _callSuper(this, TorusGeometry);
            _this93.type = 'TorusGeometry';
            _this93.parameters = {
              radius: radius,
              tube: tube,
              radialSegments: radialSegments,
              tubularSegments: tubularSegments,
              arc: arc
            };
            radialSegments = Math.floor(radialSegments);
            tubularSegments = Math.floor(tubularSegments);

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // helper variables

            var center = new Vector3();
            var vertex = new Vector3();
            var normal = new Vector3();

            // generate vertices, normals and uvs

            for (var j = 0; j <= radialSegments; j++) {
              for (var i = 0; i <= tubularSegments; i++) {
                var u = i / tubularSegments * arc;
                var v = j / radialSegments * Math.PI * 2;

                // vertex

                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                vertex.z = tube * Math.sin(v);
                vertices.push(vertex.x, vertex.y, vertex.z);

                // normal

                center.x = radius * Math.cos(u);
                center.y = radius * Math.sin(u);
                normal.subVectors(vertex, center).normalize();
                normals.push(normal.x, normal.y, normal.z);

                // uv

                uvs.push(i / tubularSegments);
                uvs.push(j / radialSegments);
              }
            }

            // generate indices

            for (var _j11 = 1; _j11 <= radialSegments; _j11++) {
              for (var _i96 = 1; _i96 <= tubularSegments; _i96++) {
                // indices

                var a = (tubularSegments + 1) * _j11 + _i96 - 1;
                var b = (tubularSegments + 1) * (_j11 - 1) + _i96 - 1;
                var _c22 = (tubularSegments + 1) * (_j11 - 1) + _i96;
                var d = (tubularSegments + 1) * _j11 + _i96;

                // faces

                indices.push(a, b, d);
                indices.push(b, _c22, d);
              }
            }

            // build geometry

            _this93.setIndex(indices);
            _this93.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this93.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this93.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            return _this93;
          }
          _inherits(TorusGeometry, _BufferGeometry12);
          return _createClass(TorusGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(TorusGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
            }
          }]);
        }(BufferGeometry);
        var TorusKnotGeometry = /*#__PURE__*/function (_BufferGeometry13) {
          function TorusKnotGeometry() {
            var _this94;
            var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var tube = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.4;
            var tubularSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 64;
            var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
            var p = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;
            var q = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 3;
            _classCallCheck2(this, TorusKnotGeometry);
            _this94 = _callSuper(this, TorusKnotGeometry);
            _this94.type = 'TorusKnotGeometry';
            _this94.parameters = {
              radius: radius,
              tube: tube,
              tubularSegments: tubularSegments,
              radialSegments: radialSegments,
              p: p,
              q: q
            };
            tubularSegments = Math.floor(tubularSegments);
            radialSegments = Math.floor(radialSegments);

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // helper variables

            var vertex = new Vector3();
            var normal = new Vector3();
            var P1 = new Vector3();
            var P2 = new Vector3();
            var B = new Vector3();
            var T = new Vector3();
            var N = new Vector3();

            // generate vertices, normals and uvs

            for (var i = 0; i <= tubularSegments; ++i) {
              // the radian "u" is used to calculate the position on the torus curve of the current tubular segment

              var u = i / tubularSegments * p * Math.PI * 2;

              // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
              // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

              calculatePositionOnCurve(u, p, q, radius, P1);
              calculatePositionOnCurve(u + 0.01, p, q, radius, P2);

              // calculate orthonormal basis

              T.subVectors(P2, P1);
              N.addVectors(P2, P1);
              B.crossVectors(T, N);
              N.crossVectors(B, T);

              // normalize B, N. T can be ignored, we don't use it

              B.normalize();
              N.normalize();
              for (var j = 0; j <= radialSegments; ++j) {
                // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

                var v = j / radialSegments * Math.PI * 2;
                var cx = -tube * Math.cos(v);
                var cy = tube * Math.sin(v);

                // now calculate the final vertex position.
                // first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

                vertex.x = P1.x + (cx * N.x + cy * B.x);
                vertex.y = P1.y + (cx * N.y + cy * B.y);
                vertex.z = P1.z + (cx * N.z + cy * B.z);
                vertices.push(vertex.x, vertex.y, vertex.z);

                // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

                normal.subVectors(vertex, P1).normalize();
                normals.push(normal.x, normal.y, normal.z);

                // uv

                uvs.push(i / tubularSegments);
                uvs.push(j / radialSegments);
              }
            }

            // generate indices

            for (var _j12 = 1; _j12 <= tubularSegments; _j12++) {
              for (var _i97 = 1; _i97 <= radialSegments; _i97++) {
                // indices

                var a = (radialSegments + 1) * (_j12 - 1) + (_i97 - 1);
                var b = (radialSegments + 1) * _j12 + (_i97 - 1);
                var _c23 = (radialSegments + 1) * _j12 + _i97;
                var d = (radialSegments + 1) * (_j12 - 1) + _i97;

                // faces

                indices.push(a, b, d);
                indices.push(b, _c23, d);
              }
            }

            // build geometry

            _this94.setIndex(indices);
            _this94.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this94.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this94.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

            // this function calculates the current position on the torus curve

            function calculatePositionOnCurve(u, p, q, radius, position) {
              var cu = Math.cos(u);
              var su = Math.sin(u);
              var quOverP = q / p * u;
              var cs = Math.cos(quOverP);
              position.x = radius * (2 + cs) * 0.5 * cu;
              position.y = radius * (2 + cs) * su * 0.5;
              position.z = radius * Math.sin(quOverP) * 0.5;
            }
            return _this94;
          }
          _inherits(TorusKnotGeometry, _BufferGeometry13);
          return _createClass(TorusKnotGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(TorusKnotGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(data) {
              return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
            }
          }]);
        }(BufferGeometry);
        var TubeGeometry = /*#__PURE__*/function (_BufferGeometry14) {
          function TubeGeometry() {
            var _this95;
            var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0));
            var tubularSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;
            var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
            var closed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
            _classCallCheck2(this, TubeGeometry);
            _this95 = _callSuper(this, TubeGeometry);
            _this95.type = 'TubeGeometry';
            _this95.parameters = {
              path: path,
              tubularSegments: tubularSegments,
              radius: radius,
              radialSegments: radialSegments,
              closed: closed
            };
            var frames = path.computeFrenetFrames(tubularSegments, closed);

            // expose internals

            _this95.tangents = frames.tangents;
            _this95.normals = frames.normals;
            _this95.binormals = frames.binormals;

            // helper variables

            var vertex = new Vector3();
            var normal = new Vector3();
            var uv = new Vector2();
            var P = new Vector3();

            // buffer

            var vertices = [];
            var normals = [];
            var uvs = [];
            var indices = [];

            // create buffer data

            generateBufferData();

            // build geometry

            _this95.setIndex(indices);
            _this95.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this95.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this95.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

            // functions

            function generateBufferData() {
              for (var i = 0; i < tubularSegments; i++) {
                generateSegment(i);
              }

              // if the geometry is not closed, generate the last row of vertices and normals
              // at the regular position on the given path
              //
              // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

              generateSegment(closed === false ? tubularSegments : 0);

              // uvs are generated in a separate function.
              // this makes it easy compute correct values for closed geometries

              generateUVs();

              // finally create faces

              generateIndices();
            }
            function generateSegment(i) {
              // we use getPointAt to sample evenly distributed points from the given path

              P = path.getPointAt(i / tubularSegments, P);

              // retrieve corresponding normal and binormal

              var N = frames.normals[i];
              var B = frames.binormals[i];

              // generate normals and vertices for the current segment

              for (var j = 0; j <= radialSegments; j++) {
                var v = j / radialSegments * Math.PI * 2;
                var sin = Math.sin(v);
                var cos = -Math.cos(v);

                // normal

                normal.x = cos * N.x + sin * B.x;
                normal.y = cos * N.y + sin * B.y;
                normal.z = cos * N.z + sin * B.z;
                normal.normalize();
                normals.push(normal.x, normal.y, normal.z);

                // vertex

                vertex.x = P.x + radius * normal.x;
                vertex.y = P.y + radius * normal.y;
                vertex.z = P.z + radius * normal.z;
                vertices.push(vertex.x, vertex.y, vertex.z);
              }
            }
            function generateIndices() {
              for (var j = 1; j <= tubularSegments; j++) {
                for (var i = 1; i <= radialSegments; i++) {
                  var a = (radialSegments + 1) * (j - 1) + (i - 1);
                  var b = (radialSegments + 1) * j + (i - 1);
                  var _c24 = (radialSegments + 1) * j + i;
                  var d = (radialSegments + 1) * (j - 1) + i;

                  // faces

                  indices.push(a, b, d);
                  indices.push(b, _c24, d);
                }
              }
            }
            function generateUVs() {
              for (var i = 0; i <= tubularSegments; i++) {
                for (var j = 0; j <= radialSegments; j++) {
                  uv.x = i / tubularSegments;
                  uv.y = j / radialSegments;
                  uvs.push(uv.x, uv.y);
                }
              }
            }
            return _this95;
          }
          _inherits(TubeGeometry, _BufferGeometry14);
          return _createClass(TubeGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(TubeGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(TubeGeometry, "toJSON", this, 3)([]);
              data.path = this.parameters.path.toJSON();
              return data;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(data) {
              // This only works for built-in curves (e.g. CatmullRomCurve3).
              // User defined curves or instances of CurvePath will not be deserialized.
              return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
            }
          }]);
        }(BufferGeometry);
        var WireframeGeometry = /*#__PURE__*/function (_BufferGeometry15) {
          function WireframeGeometry() {
            var _this96;
            var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            _classCallCheck2(this, WireframeGeometry);
            _this96 = _callSuper(this, WireframeGeometry);
            _this96.type = 'WireframeGeometry';
            _this96.parameters = {
              geometry: geometry
            };
            if (geometry !== null) {
              // buffer

              var vertices = [];
              var edges = new Set();

              // helper variables

              var start = new Vector3();
              var end = new Vector3();
              if (geometry.index !== null) {
                // indexed BufferGeometry

                var position = geometry.attributes.position;
                var indices = geometry.index;
                var groups = geometry.groups;
                if (groups.length === 0) {
                  groups = [{
                    start: 0,
                    count: indices.count,
                    materialIndex: 0
                  }];
                }

                // create a data structure that contains all edges without duplicates

                for (var o = 0, ol = groups.length; o < ol; ++o) {
                  var group = groups[o];
                  var groupStart = group.start;
                  var groupCount = group.count;
                  for (var i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
                    for (var j = 0; j < 3; j++) {
                      var index1 = indices.getX(i + j);
                      var index2 = indices.getX(i + (j + 1) % 3);
                      start.fromBufferAttribute(position, index1);
                      end.fromBufferAttribute(position, index2);
                      if (isUniqueEdge(start, end, edges) === true) {
                        vertices.push(start.x, start.y, start.z);
                        vertices.push(end.x, end.y, end.z);
                      }
                    }
                  }
                }
              } else {
                // non-indexed BufferGeometry

                var _position2 = geometry.attributes.position;
                for (var _i98 = 0, _l17 = _position2.count / 3; _i98 < _l17; _i98++) {
                  for (var _j13 = 0; _j13 < 3; _j13++) {
                    // three edges per triangle, an edge is represented as (index1, index2)
                    // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

                    var _index13 = 3 * _i98 + _j13;
                    var _index14 = 3 * _i98 + (_j13 + 1) % 3;
                    start.fromBufferAttribute(_position2, _index13);
                    end.fromBufferAttribute(_position2, _index14);
                    if (isUniqueEdge(start, end, edges) === true) {
                      vertices.push(start.x, start.y, start.z);
                      vertices.push(end.x, end.y, end.z);
                    }
                  }
                }
              }

              // build geometry

              _this96.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            }
            return _this96;
          }
          _inherits(WireframeGeometry, _BufferGeometry15);
          return _createClass(WireframeGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(WireframeGeometry, "copy", this, 3)([source]);
              this.parameters = Object.assign({}, source.parameters);
              return this;
            }
          }]);
        }(BufferGeometry);
        function isUniqueEdge(start, end, edges) {
          var hash1 = "".concat(start.x, ",").concat(start.y, ",").concat(start.z, "-").concat(end.x, ",").concat(end.y, ",").concat(end.z);
          var hash2 = "".concat(end.x, ",").concat(end.y, ",").concat(end.z, "-").concat(start.x, ",").concat(start.y, ",").concat(start.z); // coincident edge

          if (edges.has(hash1) === true || edges.has(hash2) === true) {
            return false;
          } else {
            edges.add(hash1);
            edges.add(hash2);
            return true;
          }
        }
        var Geometries = /*#__PURE__*/Object.freeze({
          __proto__: null,
          BoxGeometry: BoxGeometry,
          CapsuleGeometry: CapsuleGeometry,
          CircleGeometry: CircleGeometry,
          ConeGeometry: ConeGeometry,
          CylinderGeometry: CylinderGeometry,
          DodecahedronGeometry: DodecahedronGeometry,
          EdgesGeometry: EdgesGeometry,
          ExtrudeGeometry: ExtrudeGeometry,
          IcosahedronGeometry: IcosahedronGeometry,
          LatheGeometry: LatheGeometry,
          OctahedronGeometry: OctahedronGeometry,
          PlaneGeometry: PlaneGeometry,
          PolyhedronGeometry: PolyhedronGeometry,
          RingGeometry: RingGeometry,
          ShapeGeometry: ShapeGeometry,
          SphereGeometry: SphereGeometry,
          TetrahedronGeometry: TetrahedronGeometry,
          TorusGeometry: TorusGeometry,
          TorusKnotGeometry: TorusKnotGeometry,
          TubeGeometry: TubeGeometry,
          WireframeGeometry: WireframeGeometry
        });
        var ShadowMaterial = /*#__PURE__*/function (_Material8) {
          function ShadowMaterial(parameters) {
            var _this97;
            _classCallCheck2(this, ShadowMaterial);
            _this97 = _callSuper(this, ShadowMaterial);
            _this97.isShadowMaterial = true;
            _this97.type = 'ShadowMaterial';
            _this97.color = new Color(0x000000);
            _this97.transparent = true;
            _this97.fog = true;
            _this97.setValues(parameters);
            return _this97;
          }
          _inherits(ShadowMaterial, _Material8);
          return _createClass(ShadowMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(ShadowMaterial, "copy", this, 3)([source]);
              this.color.copy(source.color);
              this.fog = source.fog;
              return this;
            }
          }]);
        }(Material);
        var RawShaderMaterial = /*#__PURE__*/function (_ShaderMaterial) {
          function RawShaderMaterial(parameters) {
            var _this98;
            _classCallCheck2(this, RawShaderMaterial);
            _this98 = _callSuper(this, RawShaderMaterial, [parameters]);
            _this98.isRawShaderMaterial = true;
            _this98.type = 'RawShaderMaterial';
            return _this98;
          }
          _inherits(RawShaderMaterial, _ShaderMaterial);
          return _createClass(RawShaderMaterial);
        }(ShaderMaterial);
        var MeshStandardMaterial = /*#__PURE__*/function (_Material9) {
          function MeshStandardMaterial(parameters) {
            var _this99;
            _classCallCheck2(this, MeshStandardMaterial);
            _this99 = _callSuper(this, MeshStandardMaterial);
            _this99.isMeshStandardMaterial = true;
            _this99.defines = {
              'STANDARD': ''
            };
            _this99.type = 'MeshStandardMaterial';
            _this99.color = new Color(0xffffff); // diffuse
            _this99.roughness = 1.0;
            _this99.metalness = 0.0;
            _this99.map = null;
            _this99.lightMap = null;
            _this99.lightMapIntensity = 1.0;
            _this99.aoMap = null;
            _this99.aoMapIntensity = 1.0;
            _this99.emissive = new Color(0x000000);
            _this99.emissiveIntensity = 1.0;
            _this99.emissiveMap = null;
            _this99.bumpMap = null;
            _this99.bumpScale = 1;
            _this99.normalMap = null;
            _this99.normalMapType = TangentSpaceNormalMap;
            _this99.normalScale = new Vector2(1, 1);
            _this99.displacementMap = null;
            _this99.displacementScale = 1;
            _this99.displacementBias = 0;
            _this99.roughnessMap = null;
            _this99.metalnessMap = null;
            _this99.alphaMap = null;
            _this99.envMap = null;
            _this99.envMapRotation = new Euler();
            _this99.envMapIntensity = 1.0;
            _this99.wireframe = false;
            _this99.wireframeLinewidth = 1;
            _this99.wireframeLinecap = 'round';
            _this99.wireframeLinejoin = 'round';
            _this99.flatShading = false;
            _this99.fog = true;
            _this99.setValues(parameters);
            return _this99;
          }
          _inherits(MeshStandardMaterial, _Material9);
          return _createClass(MeshStandardMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(MeshStandardMaterial, "copy", this, 3)([source]);
              this.defines = {
                'STANDARD': ''
              };
              this.color.copy(source.color);
              this.roughness = source.roughness;
              this.metalness = source.metalness;
              this.map = source.map;
              this.lightMap = source.lightMap;
              this.lightMapIntensity = source.lightMapIntensity;
              this.aoMap = source.aoMap;
              this.aoMapIntensity = source.aoMapIntensity;
              this.emissive.copy(source.emissive);
              this.emissiveMap = source.emissiveMap;
              this.emissiveIntensity = source.emissiveIntensity;
              this.bumpMap = source.bumpMap;
              this.bumpScale = source.bumpScale;
              this.normalMap = source.normalMap;
              this.normalMapType = source.normalMapType;
              this.normalScale.copy(source.normalScale);
              this.displacementMap = source.displacementMap;
              this.displacementScale = source.displacementScale;
              this.displacementBias = source.displacementBias;
              this.roughnessMap = source.roughnessMap;
              this.metalnessMap = source.metalnessMap;
              this.alphaMap = source.alphaMap;
              this.envMap = source.envMap;
              this.envMapRotation.copy(source.envMapRotation);
              this.envMapIntensity = source.envMapIntensity;
              this.wireframe = source.wireframe;
              this.wireframeLinewidth = source.wireframeLinewidth;
              this.wireframeLinecap = source.wireframeLinecap;
              this.wireframeLinejoin = source.wireframeLinejoin;
              this.flatShading = source.flatShading;
              this.fog = source.fog;
              return this;
            }
          }]);
        }(Material);
        var MeshPhysicalMaterial = /*#__PURE__*/function (_MeshStandardMaterial) {
          function MeshPhysicalMaterial(parameters) {
            var _this100;
            _classCallCheck2(this, MeshPhysicalMaterial);
            _this100 = _callSuper(this, MeshPhysicalMaterial);
            _this100.isMeshPhysicalMaterial = true;
            _this100.defines = {
              'STANDARD': '',
              'PHYSICAL': ''
            };
            _this100.type = 'MeshPhysicalMaterial';
            _this100.anisotropyRotation = 0;
            _this100.anisotropyMap = null;
            _this100.clearcoatMap = null;
            _this100.clearcoatRoughness = 0.0;
            _this100.clearcoatRoughnessMap = null;
            _this100.clearcoatNormalScale = new Vector2(1, 1);
            _this100.clearcoatNormalMap = null;
            _this100.ior = 1.5;
            Object.defineProperty(_this100, 'reflectivity', {
              get: function get() {
                return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
              },
              set: function set(reflectivity) {
                this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
              }
            });
            _this100.iridescenceMap = null;
            _this100.iridescenceIOR = 1.3;
            _this100.iridescenceThicknessRange = [100, 400];
            _this100.iridescenceThicknessMap = null;
            _this100.sheenColor = new Color(0x000000);
            _this100.sheenColorMap = null;
            _this100.sheenRoughness = 1.0;
            _this100.sheenRoughnessMap = null;
            _this100.transmissionMap = null;
            _this100.thickness = 0;
            _this100.thicknessMap = null;
            _this100.attenuationDistance = Infinity;
            _this100.attenuationColor = new Color(1, 1, 1);
            _this100.specularIntensity = 1.0;
            _this100.specularIntensityMap = null;
            _this100.specularColor = new Color(1, 1, 1);
            _this100.specularColorMap = null;
            _this100._anisotropy = 0;
            _this100._clearcoat = 0;
            _this100._dispersion = 0;
            _this100._iridescence = 0;
            _this100._sheen = 0.0;
            _this100._transmission = 0;
            _this100.setValues(parameters);
            return _this100;
          }
          _inherits(MeshPhysicalMaterial, _MeshStandardMaterial);
          return _createClass(MeshPhysicalMaterial, [{
            key: "anisotropy",
            get: function get() {
              return this._anisotropy;
            },
            set: function set(value) {
              if (this._anisotropy > 0 !== value > 0) {
                this.version++;
              }
              this._anisotropy = value;
            }
          }, {
            key: "clearcoat",
            get: function get() {
              return this._clearcoat;
            },
            set: function set(value) {
              if (this._clearcoat > 0 !== value > 0) {
                this.version++;
              }
              this._clearcoat = value;
            }
          }, {
            key: "iridescence",
            get: function get() {
              return this._iridescence;
            },
            set: function set(value) {
              if (this._iridescence > 0 !== value > 0) {
                this.version++;
              }
              this._iridescence = value;
            }
          }, {
            key: "dispersion",
            get: function get() {
              return this._dispersion;
            },
            set: function set(value) {
              if (this._dispersion > 0 !== value > 0) {
                this.version++;
              }
              this._dispersion = value;
            }
          }, {
            key: "sheen",
            get: function get() {
              return this._sheen;
            },
            set: function set(value) {
              if (this._sheen > 0 !== value > 0) {
                this.version++;
              }
              this._sheen = value;
            }
          }, {
            key: "transmission",
            get: function get() {
              return this._transmission;
            },
            set: function set(value) {
              if (this._transmission > 0 !== value > 0) {
                this.version++;
              }
              this._transmission = value;
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(MeshPhysicalMaterial, "copy", this, 3)([source]);
              this.defines = {
                'STANDARD': '',
                'PHYSICAL': ''
              };
              this.anisotropy = source.anisotropy;
              this.anisotropyRotation = source.anisotropyRotation;
              this.anisotropyMap = source.anisotropyMap;
              this.clearcoat = source.clearcoat;
              this.clearcoatMap = source.clearcoatMap;
              this.clearcoatRoughness = source.clearcoatRoughness;
              this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
              this.clearcoatNormalMap = source.clearcoatNormalMap;
              this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
              this.dispersion = source.dispersion;
              this.ior = source.ior;
              this.iridescence = source.iridescence;
              this.iridescenceMap = source.iridescenceMap;
              this.iridescenceIOR = source.iridescenceIOR;
              this.iridescenceThicknessRange = _toConsumableArray(source.iridescenceThicknessRange);
              this.iridescenceThicknessMap = source.iridescenceThicknessMap;
              this.sheen = source.sheen;
              this.sheenColor.copy(source.sheenColor);
              this.sheenColorMap = source.sheenColorMap;
              this.sheenRoughness = source.sheenRoughness;
              this.sheenRoughnessMap = source.sheenRoughnessMap;
              this.transmission = source.transmission;
              this.transmissionMap = source.transmissionMap;
              this.thickness = source.thickness;
              this.thicknessMap = source.thicknessMap;
              this.attenuationDistance = source.attenuationDistance;
              this.attenuationColor.copy(source.attenuationColor);
              this.specularIntensity = source.specularIntensity;
              this.specularIntensityMap = source.specularIntensityMap;
              this.specularColor.copy(source.specularColor);
              this.specularColorMap = source.specularColorMap;
              return this;
            }
          }]);
        }(MeshStandardMaterial);
        var MeshPhongMaterial = /*#__PURE__*/function (_Material10) {
          function MeshPhongMaterial(parameters) {
            var _this101;
            _classCallCheck2(this, MeshPhongMaterial);
            _this101 = _callSuper(this, MeshPhongMaterial);
            _this101.isMeshPhongMaterial = true;
            _this101.type = 'MeshPhongMaterial';
            _this101.color = new Color(0xffffff); // diffuse
            _this101.specular = new Color(0x111111);
            _this101.shininess = 30;
            _this101.map = null;
            _this101.lightMap = null;
            _this101.lightMapIntensity = 1.0;
            _this101.aoMap = null;
            _this101.aoMapIntensity = 1.0;
            _this101.emissive = new Color(0x000000);
            _this101.emissiveIntensity = 1.0;
            _this101.emissiveMap = null;
            _this101.bumpMap = null;
            _this101.bumpScale = 1;
            _this101.normalMap = null;
            _this101.normalMapType = TangentSpaceNormalMap;
            _this101.normalScale = new Vector2(1, 1);
            _this101.displacementMap = null;
            _this101.displacementScale = 1;
            _this101.displacementBias = 0;
            _this101.specularMap = null;
            _this101.alphaMap = null;
            _this101.envMap = null;
            _this101.envMapRotation = new Euler();
            _this101.combine = MultiplyOperation;
            _this101.reflectivity = 1;
            _this101.refractionRatio = 0.98;
            _this101.wireframe = false;
            _this101.wireframeLinewidth = 1;
            _this101.wireframeLinecap = 'round';
            _this101.wireframeLinejoin = 'round';
            _this101.flatShading = false;
            _this101.fog = true;
            _this101.setValues(parameters);
            return _this101;
          }
          _inherits(MeshPhongMaterial, _Material10);
          return _createClass(MeshPhongMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(MeshPhongMaterial, "copy", this, 3)([source]);
              this.color.copy(source.color);
              this.specular.copy(source.specular);
              this.shininess = source.shininess;
              this.map = source.map;
              this.lightMap = source.lightMap;
              this.lightMapIntensity = source.lightMapIntensity;
              this.aoMap = source.aoMap;
              this.aoMapIntensity = source.aoMapIntensity;
              this.emissive.copy(source.emissive);
              this.emissiveMap = source.emissiveMap;
              this.emissiveIntensity = source.emissiveIntensity;
              this.bumpMap = source.bumpMap;
              this.bumpScale = source.bumpScale;
              this.normalMap = source.normalMap;
              this.normalMapType = source.normalMapType;
              this.normalScale.copy(source.normalScale);
              this.displacementMap = source.displacementMap;
              this.displacementScale = source.displacementScale;
              this.displacementBias = source.displacementBias;
              this.specularMap = source.specularMap;
              this.alphaMap = source.alphaMap;
              this.envMap = source.envMap;
              this.envMapRotation.copy(source.envMapRotation);
              this.combine = source.combine;
              this.reflectivity = source.reflectivity;
              this.refractionRatio = source.refractionRatio;
              this.wireframe = source.wireframe;
              this.wireframeLinewidth = source.wireframeLinewidth;
              this.wireframeLinecap = source.wireframeLinecap;
              this.wireframeLinejoin = source.wireframeLinejoin;
              this.flatShading = source.flatShading;
              this.fog = source.fog;
              return this;
            }
          }]);
        }(Material);
        var MeshToonMaterial = /*#__PURE__*/function (_Material11) {
          function MeshToonMaterial(parameters) {
            var _this102;
            _classCallCheck2(this, MeshToonMaterial);
            _this102 = _callSuper(this, MeshToonMaterial);
            _this102.isMeshToonMaterial = true;
            _this102.defines = {
              'TOON': ''
            };
            _this102.type = 'MeshToonMaterial';
            _this102.color = new Color(0xffffff);
            _this102.map = null;
            _this102.gradientMap = null;
            _this102.lightMap = null;
            _this102.lightMapIntensity = 1.0;
            _this102.aoMap = null;
            _this102.aoMapIntensity = 1.0;
            _this102.emissive = new Color(0x000000);
            _this102.emissiveIntensity = 1.0;
            _this102.emissiveMap = null;
            _this102.bumpMap = null;
            _this102.bumpScale = 1;
            _this102.normalMap = null;
            _this102.normalMapType = TangentSpaceNormalMap;
            _this102.normalScale = new Vector2(1, 1);
            _this102.displacementMap = null;
            _this102.displacementScale = 1;
            _this102.displacementBias = 0;
            _this102.alphaMap = null;
            _this102.wireframe = false;
            _this102.wireframeLinewidth = 1;
            _this102.wireframeLinecap = 'round';
            _this102.wireframeLinejoin = 'round';
            _this102.fog = true;
            _this102.setValues(parameters);
            return _this102;
          }
          _inherits(MeshToonMaterial, _Material11);
          return _createClass(MeshToonMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(MeshToonMaterial, "copy", this, 3)([source]);
              this.color.copy(source.color);
              this.map = source.map;
              this.gradientMap = source.gradientMap;
              this.lightMap = source.lightMap;
              this.lightMapIntensity = source.lightMapIntensity;
              this.aoMap = source.aoMap;
              this.aoMapIntensity = source.aoMapIntensity;
              this.emissive.copy(source.emissive);
              this.emissiveMap = source.emissiveMap;
              this.emissiveIntensity = source.emissiveIntensity;
              this.bumpMap = source.bumpMap;
              this.bumpScale = source.bumpScale;
              this.normalMap = source.normalMap;
              this.normalMapType = source.normalMapType;
              this.normalScale.copy(source.normalScale);
              this.displacementMap = source.displacementMap;
              this.displacementScale = source.displacementScale;
              this.displacementBias = source.displacementBias;
              this.alphaMap = source.alphaMap;
              this.wireframe = source.wireframe;
              this.wireframeLinewidth = source.wireframeLinewidth;
              this.wireframeLinecap = source.wireframeLinecap;
              this.wireframeLinejoin = source.wireframeLinejoin;
              this.fog = source.fog;
              return this;
            }
          }]);
        }(Material);
        var MeshNormalMaterial = /*#__PURE__*/function (_Material12) {
          function MeshNormalMaterial(parameters) {
            var _this103;
            _classCallCheck2(this, MeshNormalMaterial);
            _this103 = _callSuper(this, MeshNormalMaterial);
            _this103.isMeshNormalMaterial = true;
            _this103.type = 'MeshNormalMaterial';
            _this103.bumpMap = null;
            _this103.bumpScale = 1;
            _this103.normalMap = null;
            _this103.normalMapType = TangentSpaceNormalMap;
            _this103.normalScale = new Vector2(1, 1);
            _this103.displacementMap = null;
            _this103.displacementScale = 1;
            _this103.displacementBias = 0;
            _this103.wireframe = false;
            _this103.wireframeLinewidth = 1;
            _this103.flatShading = false;
            _this103.setValues(parameters);
            return _this103;
          }
          _inherits(MeshNormalMaterial, _Material12);
          return _createClass(MeshNormalMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(MeshNormalMaterial, "copy", this, 3)([source]);
              this.bumpMap = source.bumpMap;
              this.bumpScale = source.bumpScale;
              this.normalMap = source.normalMap;
              this.normalMapType = source.normalMapType;
              this.normalScale.copy(source.normalScale);
              this.displacementMap = source.displacementMap;
              this.displacementScale = source.displacementScale;
              this.displacementBias = source.displacementBias;
              this.wireframe = source.wireframe;
              this.wireframeLinewidth = source.wireframeLinewidth;
              this.flatShading = source.flatShading;
              return this;
            }
          }]);
        }(Material);
        var MeshLambertMaterial = /*#__PURE__*/function (_Material13) {
          function MeshLambertMaterial(parameters) {
            var _this104;
            _classCallCheck2(this, MeshLambertMaterial);
            _this104 = _callSuper(this, MeshLambertMaterial);
            _this104.isMeshLambertMaterial = true;
            _this104.type = 'MeshLambertMaterial';
            _this104.color = new Color(0xffffff); // diffuse

            _this104.map = null;
            _this104.lightMap = null;
            _this104.lightMapIntensity = 1.0;
            _this104.aoMap = null;
            _this104.aoMapIntensity = 1.0;
            _this104.emissive = new Color(0x000000);
            _this104.emissiveIntensity = 1.0;
            _this104.emissiveMap = null;
            _this104.bumpMap = null;
            _this104.bumpScale = 1;
            _this104.normalMap = null;
            _this104.normalMapType = TangentSpaceNormalMap;
            _this104.normalScale = new Vector2(1, 1);
            _this104.displacementMap = null;
            _this104.displacementScale = 1;
            _this104.displacementBias = 0;
            _this104.specularMap = null;
            _this104.alphaMap = null;
            _this104.envMap = null;
            _this104.envMapRotation = new Euler();
            _this104.combine = MultiplyOperation;
            _this104.reflectivity = 1;
            _this104.refractionRatio = 0.98;
            _this104.wireframe = false;
            _this104.wireframeLinewidth = 1;
            _this104.wireframeLinecap = 'round';
            _this104.wireframeLinejoin = 'round';
            _this104.flatShading = false;
            _this104.fog = true;
            _this104.setValues(parameters);
            return _this104;
          }
          _inherits(MeshLambertMaterial, _Material13);
          return _createClass(MeshLambertMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(MeshLambertMaterial, "copy", this, 3)([source]);
              this.color.copy(source.color);
              this.map = source.map;
              this.lightMap = source.lightMap;
              this.lightMapIntensity = source.lightMapIntensity;
              this.aoMap = source.aoMap;
              this.aoMapIntensity = source.aoMapIntensity;
              this.emissive.copy(source.emissive);
              this.emissiveMap = source.emissiveMap;
              this.emissiveIntensity = source.emissiveIntensity;
              this.bumpMap = source.bumpMap;
              this.bumpScale = source.bumpScale;
              this.normalMap = source.normalMap;
              this.normalMapType = source.normalMapType;
              this.normalScale.copy(source.normalScale);
              this.displacementMap = source.displacementMap;
              this.displacementScale = source.displacementScale;
              this.displacementBias = source.displacementBias;
              this.specularMap = source.specularMap;
              this.alphaMap = source.alphaMap;
              this.envMap = source.envMap;
              this.envMapRotation.copy(source.envMapRotation);
              this.combine = source.combine;
              this.reflectivity = source.reflectivity;
              this.refractionRatio = source.refractionRatio;
              this.wireframe = source.wireframe;
              this.wireframeLinewidth = source.wireframeLinewidth;
              this.wireframeLinecap = source.wireframeLinecap;
              this.wireframeLinejoin = source.wireframeLinejoin;
              this.flatShading = source.flatShading;
              this.fog = source.fog;
              return this;
            }
          }]);
        }(Material);
        var MeshMatcapMaterial = /*#__PURE__*/function (_Material14) {
          function MeshMatcapMaterial(parameters) {
            var _this105;
            _classCallCheck2(this, MeshMatcapMaterial);
            _this105 = _callSuper(this, MeshMatcapMaterial);
            _this105.isMeshMatcapMaterial = true;
            _this105.defines = {
              'MATCAP': ''
            };
            _this105.type = 'MeshMatcapMaterial';
            _this105.color = new Color(0xffffff); // diffuse

            _this105.matcap = null;
            _this105.map = null;
            _this105.bumpMap = null;
            _this105.bumpScale = 1;
            _this105.normalMap = null;
            _this105.normalMapType = TangentSpaceNormalMap;
            _this105.normalScale = new Vector2(1, 1);
            _this105.displacementMap = null;
            _this105.displacementScale = 1;
            _this105.displacementBias = 0;
            _this105.alphaMap = null;
            _this105.flatShading = false;
            _this105.fog = true;
            _this105.setValues(parameters);
            return _this105;
          }
          _inherits(MeshMatcapMaterial, _Material14);
          return _createClass(MeshMatcapMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(MeshMatcapMaterial, "copy", this, 3)([source]);
              this.defines = {
                'MATCAP': ''
              };
              this.color.copy(source.color);
              this.matcap = source.matcap;
              this.map = source.map;
              this.bumpMap = source.bumpMap;
              this.bumpScale = source.bumpScale;
              this.normalMap = source.normalMap;
              this.normalMapType = source.normalMapType;
              this.normalScale.copy(source.normalScale);
              this.displacementMap = source.displacementMap;
              this.displacementScale = source.displacementScale;
              this.displacementBias = source.displacementBias;
              this.alphaMap = source.alphaMap;
              this.flatShading = source.flatShading;
              this.fog = source.fog;
              return this;
            }
          }]);
        }(Material);
        var LineDashedMaterial = /*#__PURE__*/function (_LineBasicMaterial) {
          function LineDashedMaterial(parameters) {
            var _this106;
            _classCallCheck2(this, LineDashedMaterial);
            _this106 = _callSuper(this, LineDashedMaterial);
            _this106.isLineDashedMaterial = true;
            _this106.type = 'LineDashedMaterial';
            _this106.scale = 1;
            _this106.dashSize = 3;
            _this106.gapSize = 1;
            _this106.setValues(parameters);
            return _this106;
          }
          _inherits(LineDashedMaterial, _LineBasicMaterial);
          return _createClass(LineDashedMaterial, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(LineDashedMaterial, "copy", this, 3)([source]);
              this.scale = source.scale;
              this.dashSize = source.dashSize;
              this.gapSize = source.gapSize;
              return this;
            }
          }]);
        }(LineBasicMaterial); // converts an array to a specific type
        function convertArray(array, type, forceClone) {
          if (!array ||
          // let 'undefined' and 'null' pass
          !forceClone && array.constructor === type) return array;
          if (typeof type.BYTES_PER_ELEMENT === 'number') {
            return new type(array); // create typed array
          }
          return Array.prototype.slice.call(array); // create Array
        }
        function isTypedArray(object) {
          return ArrayBuffer.isView(object) && !(object instanceof DataView);
        }

        // returns an array by which times and values can be sorted
        function getKeyframeOrder(times) {
          function compareTime(i, j) {
            return times[i] - times[j];
          }
          var n = times.length;
          var result = new Array(n);
          for (var i = 0; i !== n; ++i) result[i] = i;
          result.sort(compareTime);
          return result;
        }

        // uses the array previously returned by 'getKeyframeOrder' to sort data
        function sortedArray(values, stride, order) {
          var nValues = values.length;
          var result = new values.constructor(nValues);
          for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
            var srcOffset = order[i] * stride;
            for (var j = 0; j !== stride; ++j) {
              result[dstOffset++] = values[srcOffset + j];
            }
          }
          return result;
        }

        // function for parsing AOS keyframe formats
        function flattenJSON(jsonKeys, times, values, valuePropertyName) {
          var i = 1,
            key = jsonKeys[0];
          while (key !== undefined && key[valuePropertyName] === undefined) {
            key = jsonKeys[i++];
          }
          if (key === undefined) return; // no data

          var value = key[valuePropertyName];
          if (value === undefined) return; // no data

          if (Array.isArray(value)) {
            do {
              value = key[valuePropertyName];
              if (value !== undefined) {
                times.push(key.time);
                values.push.apply(values, value); // push all elements
              }
              key = jsonKeys[i++];
            } while (key !== undefined);
          } else if (value.toArray !== undefined) {
            // ...assume THREE.Math-ish

            do {
              value = key[valuePropertyName];
              if (value !== undefined) {
                times.push(key.time);
                value.toArray(values, values.length);
              }
              key = jsonKeys[i++];
            } while (key !== undefined);
          } else {
            // otherwise push as-is

            do {
              value = key[valuePropertyName];
              if (value !== undefined) {
                times.push(key.time);
                values.push(value);
              }
              key = jsonKeys[i++];
            } while (key !== undefined);
          }
        }
        function subclip(sourceClip, name, startFrame, endFrame) {
          var fps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 30;
          var clip = sourceClip.clone();
          clip.name = name;
          var tracks = [];
          for (var i = 0; i < clip.tracks.length; ++i) {
            var _track = clip.tracks[i];
            var valueSize = _track.getValueSize();
            var times = [];
            var values = [];
            for (var j = 0; j < _track.times.length; ++j) {
              var frame = _track.times[j] * fps;
              if (frame < startFrame || frame >= endFrame) continue;
              times.push(_track.times[j]);
              for (var _k8 = 0; _k8 < valueSize; ++_k8) {
                values.push(_track.values[j * valueSize + _k8]);
              }
            }
            if (times.length === 0) continue;
            _track.times = convertArray(times, _track.times.constructor);
            _track.values = convertArray(values, _track.values.constructor);
            tracks.push(_track);
          }
          clip.tracks = tracks;

          // find minimum .times value across all tracks in the trimmed clip

          var minStartTime = Infinity;
          for (var _i99 = 0; _i99 < clip.tracks.length; ++_i99) {
            if (minStartTime > clip.tracks[_i99].times[0]) {
              minStartTime = clip.tracks[_i99].times[0];
            }
          }

          // shift all tracks such that clip begins at t=0

          for (var _i100 = 0; _i100 < clip.tracks.length; ++_i100) {
            clip.tracks[_i100].shift(-1 * minStartTime);
          }
          clip.resetDuration();
          return clip;
        }
        function makeClipAdditive(targetClip) {
          var referenceFrame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var referenceClip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : targetClip;
          var fps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30;
          if (fps <= 0) fps = 30;
          var numTracks = referenceClip.tracks.length;
          var referenceTime = referenceFrame / fps;

          // Make each track's values relative to the values at the reference frame
          var _loop10 = function _loop10() {
              var referenceTrack = referenceClip.tracks[i];
              var referenceTrackType = referenceTrack.ValueTypeName;

              // Skip this track if it's non-numeric
              if (referenceTrackType === 'bool' || referenceTrackType === 'string') return 0; // continue

              // Find the track in the target clip whose name and type matches the reference track
              var targetTrack = targetClip.tracks.find(function (track) {
                return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
              });
              if (targetTrack === undefined) return 0; // continue
              var referenceOffset = 0;
              var referenceValueSize = referenceTrack.getValueSize();
              if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
                referenceOffset = referenceValueSize / 3;
              }
              var targetOffset = 0;
              var targetValueSize = targetTrack.getValueSize();
              if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
                targetOffset = targetValueSize / 3;
              }
              var lastIndex = referenceTrack.times.length - 1;
              var referenceValue;

              // Find the value to subtract out of the track
              if (referenceTime <= referenceTrack.times[0]) {
                // Reference frame is earlier than the first keyframe, so just use the first keyframe
                var startIndex = referenceOffset;
                var endIndex = referenceValueSize - referenceOffset;
                referenceValue = referenceTrack.values.slice(startIndex, endIndex);
              } else if (referenceTime >= referenceTrack.times[lastIndex]) {
                // Reference frame is after the last keyframe, so just use the last keyframe
                var _startIndex = lastIndex * referenceValueSize + referenceOffset;
                var _endIndex = _startIndex + referenceValueSize - referenceOffset;
                referenceValue = referenceTrack.values.slice(_startIndex, _endIndex);
              } else {
                // Interpolate to the reference value
                var interpolant = referenceTrack.createInterpolant();
                var _startIndex2 = referenceOffset;
                var _endIndex2 = referenceValueSize - referenceOffset;
                interpolant.evaluate(referenceTime);
                referenceValue = interpolant.resultBuffer.slice(_startIndex2, _endIndex2);
              }

              // Conjugate the quaternion
              if (referenceTrackType === 'quaternion') {
                var referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
                referenceQuat.toArray(referenceValue);
              }

              // Subtract the reference value from all of the track values

              var numTimes = targetTrack.times.length;
              for (var j = 0; j < numTimes; ++j) {
                var valueStart = j * targetValueSize + targetOffset;
                if (referenceTrackType === 'quaternion') {
                  // Multiply the conjugate for quaternion track types
                  Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
                } else {
                  var valueEnd = targetValueSize - targetOffset * 2;

                  // Subtract each value for all other numeric track types
                  for (var _k9 = 0; _k9 < valueEnd; ++_k9) {
                    targetTrack.values[valueStart + _k9] -= referenceValue[_k9];
                  }
                }
              }
            },
            _ret2;
          for (var i = 0; i < numTracks; ++i) {
            _ret2 = _loop10();
            if (_ret2 === 0) continue;
          }
          targetClip.blendMode = AdditiveAnimationBlendMode;
          return targetClip;
        }
        var AnimationUtils = {
          convertArray: convertArray,
          isTypedArray: isTypedArray,
          getKeyframeOrder: getKeyframeOrder,
          sortedArray: sortedArray,
          flattenJSON: flattenJSON,
          subclip: subclip,
          makeClipAdditive: makeClipAdditive
        };

        /**
         * Abstract base class of interpolants over parametric samples.
         *
         * The parameter domain is one dimensional, typically the time or a path
         * along a curve defined by the data.
         *
         * The sample values can have any dimensionality and derived classes may
         * apply special interpretations to the data.
         *
         * This class provides the interval seek in a Template Method, deferring
         * the actual interpolation to derived classes.
         *
         * Time complexity is O(1) for linear access crossing at most two points
         * and O(log N) for random access, where N is the number of positions.
         *
         * References:
         *
         * 		http://www.oodesign.com/template-method-pattern.html
         *
         */
        var Interpolant = /*#__PURE__*/function () {
          function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            _classCallCheck2(this, Interpolant);
            this.parameterPositions = parameterPositions;
            this._cachedIndex = 0;
            this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
            this.sampleValues = sampleValues;
            this.valueSize = sampleSize;
            this.settings = null;
            this.DefaultSettings_ = {};
          }
          return _createClass(Interpolant, [{
            key: "evaluate",
            value: function evaluate(t) {
              var pp = this.parameterPositions;
              var i1 = this._cachedIndex,
                t1 = pp[i1],
                t0 = pp[i1 - 1];
              validate_interval: {
                seek: {
                  var right;
                  linear_scan: {
                    //- See http://jsperf.com/comparison-to-undefined/3
                    //- slower code:
                    //-
                    //- 				if ( t >= t1 || t1 === undefined ) {
                    forward_scan: if (!(t < t1)) {
                      for (var giveUpAt = i1 + 2;;) {
                        if (t1 === undefined) {
                          if (t < t0) break forward_scan;

                          // after end

                          i1 = pp.length;
                          this._cachedIndex = i1;
                          return this.copySampleValue_(i1 - 1);
                        }
                        if (i1 === giveUpAt) break; // this loop

                        t0 = t1;
                        t1 = pp[++i1];
                        if (t < t1) {
                          // we have arrived at the sought interval
                          break seek;
                        }
                      }

                      // prepare binary search on the right side of the index
                      right = pp.length;
                      break linear_scan;
                    }

                    //- slower code:
                    //-					if ( t < t0 || t0 === undefined ) {
                    if (!(t >= t0)) {
                      // looping?

                      var t1global = pp[1];
                      if (t < t1global) {
                        i1 = 2; // + 1, using the scan for the details
                        t0 = t1global;
                      }

                      // linear reverse scan

                      for (var _giveUpAt = i1 - 2;;) {
                        if (t0 === undefined) {
                          // before start

                          this._cachedIndex = 0;
                          return this.copySampleValue_(0);
                        }
                        if (i1 === _giveUpAt) break; // this loop

                        t1 = t0;
                        t0 = pp[--i1 - 1];
                        if (t >= t0) {
                          // we have arrived at the sought interval
                          break seek;
                        }
                      }

                      // prepare binary search on the left side of the index
                      right = i1;
                      i1 = 0;
                      break linear_scan;
                    }

                    // the interval is valid

                    break validate_interval;
                  } // linear scan

                  // binary search

                  while (i1 < right) {
                    var mid = i1 + right >>> 1;
                    if (t < pp[mid]) {
                      right = mid;
                    } else {
                      i1 = mid + 1;
                    }
                  }
                  t1 = pp[i1];
                  t0 = pp[i1 - 1];

                  // check boundary cases, again

                  if (t0 === undefined) {
                    this._cachedIndex = 0;
                    return this.copySampleValue_(0);
                  }
                  if (t1 === undefined) {
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.copySampleValue_(i1 - 1);
                  }
                } // seek

                this._cachedIndex = i1;
                this.intervalChanged_(i1, t0, t1);
              } // validate_interval

              return this.interpolate_(i1, t0, t, t1);
            }
          }, {
            key: "getSettings_",
            value: function getSettings_() {
              return this.settings || this.DefaultSettings_;
            }
          }, {
            key: "copySampleValue_",
            value: function copySampleValue_(index) {
              // copies a sample value to the result buffer

              var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                offset = index * stride;
              for (var i = 0; i !== stride; ++i) {
                result[i] = values[offset + i];
              }
              return result;
            }

            // Template methods for derived classes:
          }, {
            key: "interpolate_",
            value: function interpolate_(/* i1, t0, t, t1 */
            ) {
              throw new Error('call to abstract method');
              // implementations shall return this.resultBuffer
            }
          }, {
            key: "intervalChanged_",
            value: function intervalChanged_(/* i1, t0, t1 */
            ) {

              // empty
            }
          }]);
        }();
        /**
         * Fast and simple cubic spline interpolant.
         *
         * It was derived from a Hermitian construction setting the first derivative
         * at each sample position to the linear slope between neighboring positions
         * over their parameter interval.
         */
        var CubicInterpolant = /*#__PURE__*/function (_Interpolant) {
          function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            var _this107;
            _classCallCheck2(this, CubicInterpolant);
            _this107 = _callSuper(this, CubicInterpolant, [parameterPositions, sampleValues, sampleSize, resultBuffer]);
            _this107._weightPrev = -0;
            _this107._offsetPrev = -0;
            _this107._weightNext = -0;
            _this107._offsetNext = -0;
            _this107.DefaultSettings_ = {
              endingStart: ZeroCurvatureEnding,
              endingEnd: ZeroCurvatureEnding
            };
            return _this107;
          }
          _inherits(CubicInterpolant, _Interpolant);
          return _createClass(CubicInterpolant, [{
            key: "intervalChanged_",
            value: function intervalChanged_(i1, t0, t1) {
              var pp = this.parameterPositions;
              var iPrev = i1 - 2,
                iNext = i1 + 1,
                tPrev = pp[iPrev],
                tNext = pp[iNext];
              if (tPrev === undefined) {
                switch (this.getSettings_().endingStart) {
                  case ZeroSlopeEnding:
                    // f'(t0) = 0
                    iPrev = i1;
                    tPrev = 2 * t0 - t1;
                    break;
                  case WrapAroundEnding:
                    // use the other end of the curve
                    iPrev = pp.length - 2;
                    tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                    break;
                  default:
                    // ZeroCurvatureEnding

                    // f''(t0) = 0 a.k.a. Natural Spline
                    iPrev = i1;
                    tPrev = t1;
                }
              }
              if (tNext === undefined) {
                switch (this.getSettings_().endingEnd) {
                  case ZeroSlopeEnding:
                    // f'(tN) = 0
                    iNext = i1;
                    tNext = 2 * t1 - t0;
                    break;
                  case WrapAroundEnding:
                    // use the other end of the curve
                    iNext = 1;
                    tNext = t1 + pp[1] - pp[0];
                    break;
                  default:
                    // ZeroCurvatureEnding

                    // f''(tN) = 0, a.k.a. Natural Spline
                    iNext = i1 - 1;
                    tNext = t0;
                }
              }
              var halfDt = (t1 - t0) * 0.5,
                stride = this.valueSize;
              this._weightPrev = halfDt / (t0 - tPrev);
              this._weightNext = halfDt / (tNext - t1);
              this._offsetPrev = iPrev * stride;
              this._offsetNext = iNext * stride;
            }
          }, {
            key: "interpolate_",
            value: function interpolate_(i1, t0, t, t1) {
              var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                o1 = i1 * stride,
                o0 = o1 - stride,
                oP = this._offsetPrev,
                oN = this._offsetNext,
                wP = this._weightPrev,
                wN = this._weightNext,
                p = (t - t0) / (t1 - t0),
                pp = p * p,
                ppp = pp * p;

              // evaluate polynomials

              var sP = -wP * ppp + 2 * wP * pp - wP * p;
              var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
              var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
              var sN = wN * ppp - wN * pp;

              // combine data linearly

              for (var i = 0; i !== stride; ++i) {
                result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
              }
              return result;
            }
          }]);
        }(Interpolant);
        var LinearInterpolant = /*#__PURE__*/function (_Interpolant2) {
          function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            _classCallCheck2(this, LinearInterpolant);
            return _callSuper(this, LinearInterpolant, [parameterPositions, sampleValues, sampleSize, resultBuffer]);
          }
          _inherits(LinearInterpolant, _Interpolant2);
          return _createClass(LinearInterpolant, [{
            key: "interpolate_",
            value: function interpolate_(i1, t0, t, t1) {
              var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                offset1 = i1 * stride,
                offset0 = offset1 - stride,
                weight1 = (t - t0) / (t1 - t0),
                weight0 = 1 - weight1;
              for (var i = 0; i !== stride; ++i) {
                result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
              }
              return result;
            }
          }]);
        }(Interpolant);
        /**
         *
         * Interpolant that evaluates to the sample value at the position preceding
         * the parameter.
         */
        var DiscreteInterpolant = /*#__PURE__*/function (_Interpolant3) {
          function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            _classCallCheck2(this, DiscreteInterpolant);
            return _callSuper(this, DiscreteInterpolant, [parameterPositions, sampleValues, sampleSize, resultBuffer]);
          }
          _inherits(DiscreteInterpolant, _Interpolant3);
          return _createClass(DiscreteInterpolant, [{
            key: "interpolate_",
            value: function interpolate_(i1 /*, t0, t, t1 */) {
              return this.copySampleValue_(i1 - 1);
            }
          }]);
        }(Interpolant);
        var KeyframeTrack = /*#__PURE__*/function () {
          function KeyframeTrack(name, times, values, interpolation) {
            _classCallCheck2(this, KeyframeTrack);
            if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
            if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
            this.name = name;
            this.times = convertArray(times, this.TimeBufferType);
            this.values = convertArray(values, this.ValueBufferType);
            this.setInterpolation(interpolation || this.DefaultInterpolation);
          }

          // Serialization (in static context, because of constructor invocation
          // and automatic invocation of .toJSON):
          return _createClass(KeyframeTrack, [{
            key: "InterpolantFactoryMethodDiscrete",
            value: function InterpolantFactoryMethodDiscrete(result) {
              return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
            }
          }, {
            key: "InterpolantFactoryMethodLinear",
            value: function InterpolantFactoryMethodLinear(result) {
              return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
            }
          }, {
            key: "InterpolantFactoryMethodSmooth",
            value: function InterpolantFactoryMethodSmooth(result) {
              return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
            }
          }, {
            key: "setInterpolation",
            value: function setInterpolation(interpolation) {
              var factoryMethod;
              switch (interpolation) {
                case InterpolateDiscrete:
                  factoryMethod = this.InterpolantFactoryMethodDiscrete;
                  break;
                case InterpolateLinear:
                  factoryMethod = this.InterpolantFactoryMethodLinear;
                  break;
                case InterpolateSmooth:
                  factoryMethod = this.InterpolantFactoryMethodSmooth;
                  break;
              }
              if (factoryMethod === undefined) {
                var message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
                if (this.createInterpolant === undefined) {
                  // fall back to default, unless the default itself is messed up
                  if (interpolation !== this.DefaultInterpolation) {
                    this.setInterpolation(this.DefaultInterpolation);
                  } else {
                    throw new Error(message); // fatal, in this case
                  }
                }
                console.warn('THREE.KeyframeTrack:', message);
                return this;
              }
              this.createInterpolant = factoryMethod;
              return this;
            }
          }, {
            key: "getInterpolation",
            value: function getInterpolation() {
              switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                  return InterpolateDiscrete;
                case this.InterpolantFactoryMethodLinear:
                  return InterpolateLinear;
                case this.InterpolantFactoryMethodSmooth:
                  return InterpolateSmooth;
              }
            }
          }, {
            key: "getValueSize",
            value: function getValueSize() {
              return this.values.length / this.times.length;
            }

            // move all keyframes either forwards or backwards in time
          }, {
            key: "shift",
            value: function shift(timeOffset) {
              if (timeOffset !== 0.0) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                  times[i] += timeOffset;
                }
              }
              return this;
            }

            // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
          }, {
            key: "scale",
            value: function scale(timeScale) {
              if (timeScale !== 1.0) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                  times[i] *= timeScale;
                }
              }
              return this;
            }

            // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
            // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
          }, {
            key: "trim",
            value: function trim(startTime, endTime) {
              var times = this.times,
                nKeys = times.length;
              var from = 0,
                to = nKeys - 1;
              while (from !== nKeys && times[from] < startTime) {
                ++from;
              }
              while (to !== -1 && times[to] > endTime) {
                --to;
              }
              ++to; // inclusive -> exclusive bound

              if (from !== 0 || to !== nKeys) {
                // empty tracks are forbidden, so keep at least one keyframe
                if (from >= to) {
                  to = Math.max(to, 1);
                  from = to - 1;
                }
                var stride = this.getValueSize();
                this.times = times.slice(from, to);
                this.values = this.values.slice(from * stride, to * stride);
              }
              return this;
            }

            // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
          }, {
            key: "validate",
            value: function validate() {
              var valid = true;
              var valueSize = this.getValueSize();
              if (valueSize - Math.floor(valueSize) !== 0) {
                console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
                valid = false;
              }
              var times = this.times,
                values = this.values,
                nKeys = times.length;
              if (nKeys === 0) {
                console.error('THREE.KeyframeTrack: Track is empty.', this);
                valid = false;
              }
              var prevTime = null;
              for (var i = 0; i !== nKeys; i++) {
                var currTime = times[i];
                if (typeof currTime === 'number' && isNaN(currTime)) {
                  console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
                  valid = false;
                  break;
                }
                if (prevTime !== null && prevTime > currTime) {
                  console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
                  valid = false;
                  break;
                }
                prevTime = currTime;
              }
              if (values !== undefined) {
                if (isTypedArray(values)) {
                  for (var _i101 = 0, n = values.length; _i101 !== n; ++_i101) {
                    var value = values[_i101];
                    if (isNaN(value)) {
                      console.error('THREE.KeyframeTrack: Value is not a valid number.', this, _i101, value);
                      valid = false;
                      break;
                    }
                  }
                }
              }
              return valid;
            }

            // removes equivalent sequential keys as common in morph target sequences
            // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
          }, {
            key: "optimize",
            value: function optimize() {
              // times or values may be shared with other tracks, so overwriting is unsafe
              var times = this.times.slice(),
                values = this.values.slice(),
                stride = this.getValueSize(),
                smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
                lastIndex = times.length - 1;
              var writeIndex = 1;
              for (var i = 1; i < lastIndex; ++i) {
                var keep = false;
                var time = times[i];
                var timeNext = times[i + 1];

                // remove adjacent keyframes scheduled at the same time

                if (time !== timeNext && (i !== 1 || time !== times[0])) {
                  if (!smoothInterpolation) {
                    // remove unnecessary keyframes same as their neighbors

                    var offset = i * stride,
                      offsetP = offset - stride,
                      offsetN = offset + stride;
                    for (var j = 0; j !== stride; ++j) {
                      var value = values[offset + j];
                      if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                        keep = true;
                        break;
                      }
                    }
                  } else {
                    keep = true;
                  }
                }

                // in-place compaction

                if (keep) {
                  if (i !== writeIndex) {
                    times[writeIndex] = times[i];
                    var readOffset = i * stride,
                      writeOffset = writeIndex * stride;
                    for (var _j14 = 0; _j14 !== stride; ++_j14) {
                      values[writeOffset + _j14] = values[readOffset + _j14];
                    }
                  }
                  ++writeIndex;
                }
              }

              // flush last keyframe (compaction looks ahead)

              if (lastIndex > 0) {
                times[writeIndex] = times[lastIndex];
                for (var _readOffset = lastIndex * stride, _writeOffset = writeIndex * stride, _j15 = 0; _j15 !== stride; ++_j15) {
                  values[_writeOffset + _j15] = values[_readOffset + _j15];
                }
                ++writeIndex;
              }
              if (writeIndex !== times.length) {
                this.times = times.slice(0, writeIndex);
                this.values = values.slice(0, writeIndex * stride);
              } else {
                this.times = times;
                this.values = values;
              }
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              var times = this.times.slice();
              var values = this.values.slice();
              var TypedKeyframeTrack = this.constructor;
              var track = new TypedKeyframeTrack(this.name, times, values);

              // Interpolant argument to constructor is not saved, so copy the factory method directly.
              track.createInterpolant = this.createInterpolant;
              return track;
            }
          }], [{
            key: "toJSON",
            value: function toJSON(track) {
              var trackType = track.constructor;
              var json;

              // derived classes can define a static toJSON method
              if (trackType.toJSON !== this.toJSON) {
                json = trackType.toJSON(track);
              } else {
                // by default, we assume the data can be serialized as-is
                json = {
                  'name': track.name,
                  'times': convertArray(track.times, Array),
                  'values': convertArray(track.values, Array)
                };
                var interpolation = track.getInterpolation();
                if (interpolation !== track.DefaultInterpolation) {
                  json.interpolation = interpolation;
                }
              }
              json.type = track.ValueTypeName; // mandatory

              return json;
            }
          }]);
        }();
        KeyframeTrack.prototype.TimeBufferType = Float32Array;
        KeyframeTrack.prototype.ValueBufferType = Float32Array;
        KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

        /**
         * A Track of Boolean keyframe values.
         */
        var BooleanKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack) {
          // No interpolation parameter because only InterpolateDiscrete is valid.
          function BooleanKeyframeTrack(name, times, values) {
            _classCallCheck2(this, BooleanKeyframeTrack);
            return _callSuper(this, BooleanKeyframeTrack, [name, times, values]);
          }
          _inherits(BooleanKeyframeTrack, _KeyframeTrack);
          return _createClass(BooleanKeyframeTrack);
        }(KeyframeTrack);
        BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
        BooleanKeyframeTrack.prototype.ValueBufferType = Array;
        BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
        BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
        BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

        /**
         * A Track of keyframe values that represent color.
         */
        var ColorKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack2) {
          function ColorKeyframeTrack() {
            _classCallCheck2(this, ColorKeyframeTrack);
            return _callSuper(this, ColorKeyframeTrack, arguments);
          }
          _inherits(ColorKeyframeTrack, _KeyframeTrack2);
          return _createClass(ColorKeyframeTrack);
        }(KeyframeTrack);
        ColorKeyframeTrack.prototype.ValueTypeName = 'color';

        /**
         * A Track of numeric keyframe values.
         */
        var NumberKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack3) {
          function NumberKeyframeTrack() {
            _classCallCheck2(this, NumberKeyframeTrack);
            return _callSuper(this, NumberKeyframeTrack, arguments);
          }
          _inherits(NumberKeyframeTrack, _KeyframeTrack3);
          return _createClass(NumberKeyframeTrack);
        }(KeyframeTrack);
        NumberKeyframeTrack.prototype.ValueTypeName = 'number';

        /**
         * Spherical linear unit quaternion interpolant.
         */
        var QuaternionLinearInterpolant = /*#__PURE__*/function (_Interpolant4) {
          function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            _classCallCheck2(this, QuaternionLinearInterpolant);
            return _callSuper(this, QuaternionLinearInterpolant, [parameterPositions, sampleValues, sampleSize, resultBuffer]);
          }
          _inherits(QuaternionLinearInterpolant, _Interpolant4);
          return _createClass(QuaternionLinearInterpolant, [{
            key: "interpolate_",
            value: function interpolate_(i1, t0, t, t1) {
              var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                alpha = (t - t0) / (t1 - t0);
              var offset = i1 * stride;
              for (var end = offset + stride; offset !== end; offset += 4) {
                Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
              }
              return result;
            }
          }]);
        }(Interpolant);
        /**
         * A Track of quaternion keyframe values.
         */
        var QuaternionKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack4) {
          function QuaternionKeyframeTrack() {
            _classCallCheck2(this, QuaternionKeyframeTrack);
            return _callSuper(this, QuaternionKeyframeTrack, arguments);
          }
          _inherits(QuaternionKeyframeTrack, _KeyframeTrack4);
          return _createClass(QuaternionKeyframeTrack, [{
            key: "InterpolantFactoryMethodLinear",
            value: function InterpolantFactoryMethodLinear(result) {
              return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
            }
          }]);
        }(KeyframeTrack);
        QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
        // ValueBufferType is inherited
        // DefaultInterpolation is inherited;
        QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

        /**
         * A Track that interpolates Strings
         */
        var StringKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack5) {
          // No interpolation parameter because only InterpolateDiscrete is valid.
          function StringKeyframeTrack(name, times, values) {
            _classCallCheck2(this, StringKeyframeTrack);
            return _callSuper(this, StringKeyframeTrack, [name, times, values]);
          }
          _inherits(StringKeyframeTrack, _KeyframeTrack5);
          return _createClass(StringKeyframeTrack);
        }(KeyframeTrack);
        StringKeyframeTrack.prototype.ValueTypeName = 'string';
        StringKeyframeTrack.prototype.ValueBufferType = Array;
        StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
        StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
        StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

        /**
         * A Track of vectored keyframe values.
         */
        var VectorKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack6) {
          function VectorKeyframeTrack() {
            _classCallCheck2(this, VectorKeyframeTrack);
            return _callSuper(this, VectorKeyframeTrack, arguments);
          }
          _inherits(VectorKeyframeTrack, _KeyframeTrack6);
          return _createClass(VectorKeyframeTrack);
        }(KeyframeTrack);
        VectorKeyframeTrack.prototype.ValueTypeName = 'vector';
        var AnimationClip = /*#__PURE__*/function () {
          function AnimationClip() {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
            var tracks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            var blendMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NormalAnimationBlendMode;
            _classCallCheck2(this, AnimationClip);
            this.name = name;
            this.tracks = tracks;
            this.duration = duration;
            this.blendMode = blendMode;
            this.uuid = generateUUID();

            // this means it should figure out its duration by scanning the tracks
            if (this.duration < 0) {
              this.resetDuration();
            }
          }
          return _createClass(AnimationClip, [{
            key: "resetDuration",
            value: function resetDuration() {
              var tracks = this.tracks;
              var duration = 0;
              for (var i = 0, n = tracks.length; i !== n; ++i) {
                var _track2 = this.tracks[i];
                duration = Math.max(duration, _track2.times[_track2.times.length - 1]);
              }
              this.duration = duration;
              return this;
            }
          }, {
            key: "trim",
            value: function trim() {
              for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].trim(0, this.duration);
              }
              return this;
            }
          }, {
            key: "validate",
            value: function validate() {
              var valid = true;
              for (var i = 0; i < this.tracks.length; i++) {
                valid = valid && this.tracks[i].validate();
              }
              return valid;
            }
          }, {
            key: "optimize",
            value: function optimize() {
              for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].optimize();
              }
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              var tracks = [];
              for (var i = 0; i < this.tracks.length; i++) {
                tracks.push(this.tracks[i].clone());
              }
              return new this.constructor(this.name, this.duration, tracks, this.blendMode);
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              return this.constructor.toJSON(this);
            }
          }], [{
            key: "parse",
            value: function parse(json) {
              var tracks = [],
                jsonTracks = json.tracks,
                frameTime = 1.0 / (json.fps || 1.0);
              for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
                tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
              }
              var clip = new this(json.name, json.duration, tracks, json.blendMode);
              clip.uuid = json.uuid;
              return clip;
            }
          }, {
            key: "toJSON",
            value: function toJSON(clip) {
              var tracks = [],
                clipTracks = clip.tracks;
              var json = {
                'name': clip.name,
                'duration': clip.duration,
                'tracks': tracks,
                'uuid': clip.uuid,
                'blendMode': clip.blendMode
              };
              for (var i = 0, n = clipTracks.length; i !== n; ++i) {
                tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
              }
              return json;
            }
          }, {
            key: "CreateFromMorphTargetSequence",
            value: function CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
              var numMorphTargets = morphTargetSequence.length;
              var tracks = [];
              for (var i = 0; i < numMorphTargets; i++) {
                var times = [];
                var values = [];
                times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
                values.push(0, 1, 0);
                var order = getKeyframeOrder(times);
                times = sortedArray(times, 1, order);
                values = sortedArray(values, 1, order);

                // if there is a key at the first frame, duplicate it as the
                // last frame as well for perfect loop.
                if (!noLoop && times[0] === 0) {
                  times.push(numMorphTargets);
                  values.push(values[0]);
                }
                tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
              }
              return new this(name, -1, tracks);
            }
          }, {
            key: "findByName",
            value: function findByName(objectOrClipArray, name) {
              var clipArray = objectOrClipArray;
              if (!Array.isArray(objectOrClipArray)) {
                var o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
              }
              for (var i = 0; i < clipArray.length; i++) {
                if (clipArray[i].name === name) {
                  return clipArray[i];
                }
              }
              return null;
            }
          }, {
            key: "CreateClipsFromMorphTargetSequences",
            value: function CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
              var animationToMorphTargets = {};

              // tested with https://regex101.com/ on trick sequences
              // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
              var pattern = /^([\w-]*?)([\d]+)$/;

              // sort morph target names into animation groups based
              // patterns like Walk_001, Walk_002, Run_001, Run_002
              for (var i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = morphTargets[i];
                var parts = morphTarget.name.match(pattern);
                if (parts && parts.length > 1) {
                  var name = parts[1];
                  var animationMorphTargets = animationToMorphTargets[name];
                  if (!animationMorphTargets) {
                    animationToMorphTargets[name] = animationMorphTargets = [];
                  }
                  animationMorphTargets.push(morphTarget);
                }
              }
              var clips = [];
              for (var _name6 in animationToMorphTargets) {
                clips.push(this.CreateFromMorphTargetSequence(_name6, animationToMorphTargets[_name6], fps, noLoop));
              }
              return clips;
            }

            // parse the animation.hierarchy format
          }, {
            key: "parseAnimation",
            value: function parseAnimation(animation, bones) {
              if (!animation) {
                console.error('THREE.AnimationClip: No animation in JSONLoader data.');
                return null;
              }
              var addNonemptyTrack = function addNonemptyTrack(trackType, trackName, animationKeys, propertyName, destTracks) {
                // only return track if there are actually keys.
                if (animationKeys.length !== 0) {
                  var times = [];
                  var values = [];
                  flattenJSON(animationKeys, times, values, propertyName);

                  // empty keys are filtered out, so check again
                  if (times.length !== 0) {
                    destTracks.push(new trackType(trackName, times, values));
                  }
                }
              };
              var tracks = [];
              var clipName = animation.name || 'default';
              var fps = animation.fps || 30;
              var blendMode = animation.blendMode;

              // automatic length determination in AnimationClip.
              var duration = animation.length || -1;
              var hierarchyTracks = animation.hierarchy || [];
              for (var _h7 = 0; _h7 < hierarchyTracks.length; _h7++) {
                var animationKeys = hierarchyTracks[_h7].keys;

                // skip empty tracks
                if (!animationKeys || animationKeys.length === 0) continue;

                // process morph targets
                if (animationKeys[0].morphTargets) {
                  // figure out all morph targets used in this track
                  var morphTargetNames = {};
                  var _k10 = void 0;
                  for (_k10 = 0; _k10 < animationKeys.length; _k10++) {
                    if (animationKeys[_k10].morphTargets) {
                      for (var _m9 = 0; _m9 < animationKeys[_k10].morphTargets.length; _m9++) {
                        morphTargetNames[animationKeys[_k10].morphTargets[_m9]] = -1;
                      }
                    }
                  }

                  // create a track for each morph target with all zero
                  // morphTargetInfluences except for the keys in which
                  // the morphTarget is named.
                  for (var morphTargetName in morphTargetNames) {
                    var times = [];
                    var values = [];
                    for (var _m10 = 0; _m10 !== animationKeys[_k10].morphTargets.length; ++_m10) {
                      var animationKey = animationKeys[_k10];
                      times.push(animationKey.time);
                      values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                    }
                    tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                  }
                  duration = morphTargetNames.length * fps;
                } else {
                  // ...assume skeletal animation

                  var boneName = '.bones[' + bones[_h7].name + ']';
                  addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                  addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                  addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
                }
              }
              if (tracks.length === 0) {
                return null;
              }
              var clip = new this(clipName, duration, tracks, blendMode);
              return clip;
            }
          }]);
        }();
        function getTrackTypeForValueTypeName(typeName) {
          switch (typeName.toLowerCase()) {
            case 'scalar':
            case 'double':
            case 'float':
            case 'number':
            case 'integer':
              return NumberKeyframeTrack;
            case 'vector':
            case 'vector2':
            case 'vector3':
            case 'vector4':
              return VectorKeyframeTrack;
            case 'color':
              return ColorKeyframeTrack;
            case 'quaternion':
              return QuaternionKeyframeTrack;
            case 'bool':
            case 'boolean':
              return BooleanKeyframeTrack;
            case 'string':
              return StringKeyframeTrack;
          }
          throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
        }
        function parseKeyframeTrack(json) {
          if (json.type === undefined) {
            throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
          }
          var trackType = getTrackTypeForValueTypeName(json.type);
          if (json.times === undefined) {
            var times = [],
              values = [];
            flattenJSON(json.keys, times, values, 'value');
            json.times = times;
            json.values = values;
          }

          // derived classes can define a static parse method
          if (trackType.parse !== undefined) {
            return trackType.parse(json);
          } else {
            // by default, we assume a constructor compatible with the base
            return new trackType(json.name, json.times, json.values, json.interpolation);
          }
        }
        var Cache = {
          enabled: false,
          files: {},
          add: function add(key, file) {
            if (this.enabled === false) return;

            // console.log( 'THREE.Cache', 'Adding key:', key );

            this.files[key] = file;
          },
          get: function get(key) {
            if (this.enabled === false) return;

            // console.log( 'THREE.Cache', 'Checking key:', key );

            return this.files[key];
          },
          remove: function remove(key) {
            delete this.files[key];
          },
          clear: function clear() {
            this.files = {};
          }
        };
        var LoadingManager = /*#__PURE__*/_createClass(function LoadingManager(onLoad, onProgress, onError) {
          _classCallCheck2(this, LoadingManager);
          var scope = this;
          var isLoading = false;
          var itemsLoaded = 0;
          var itemsTotal = 0;
          var urlModifier = undefined;
          var handlers = [];

          // Refer to #5689 for the reason why we don't set .onStart
          // in the constructor

          this.onStart = undefined;
          this.onLoad = onLoad;
          this.onProgress = onProgress;
          this.onError = onError;
          this.itemStart = function (url) {
            itemsTotal++;
            if (isLoading === false) {
              if (scope.onStart !== undefined) {
                scope.onStart(url, itemsLoaded, itemsTotal);
              }
            }
            isLoading = true;
          };
          this.itemEnd = function (url) {
            itemsLoaded++;
            if (scope.onProgress !== undefined) {
              scope.onProgress(url, itemsLoaded, itemsTotal);
            }
            if (itemsLoaded === itemsTotal) {
              isLoading = false;
              if (scope.onLoad !== undefined) {
                scope.onLoad();
              }
            }
          };
          this.itemError = function (url) {
            if (scope.onError !== undefined) {
              scope.onError(url);
            }
          };
          this.resolveURL = function (url) {
            if (urlModifier) {
              return urlModifier(url);
            }
            return url;
          };
          this.setURLModifier = function (transform) {
            urlModifier = transform;
            return this;
          };
          this.addHandler = function (regex, loader) {
            handlers.push(regex, loader);
            return this;
          };
          this.removeHandler = function (regex) {
            var index = handlers.indexOf(regex);
            if (index !== -1) {
              handlers.splice(index, 2);
            }
            return this;
          };
          this.getHandler = function (file) {
            for (var i = 0, l = handlers.length; i < l; i += 2) {
              var regex = handlers[i];
              var loader = handlers[i + 1];
              if (regex.global) regex.lastIndex = 0; // see #17920

              if (regex.test(file)) {
                return loader;
              }
            }
            return null;
          };
        });
        var DefaultLoadingManager = /*@__PURE__*/new LoadingManager();
        var Loader = /*#__PURE__*/function () {
          function Loader(manager) {
            _classCallCheck2(this, Loader);
            this.manager = manager !== undefined ? manager : DefaultLoadingManager;
            this.crossOrigin = 'anonymous';
            this.withCredentials = false;
            this.path = '';
            this.resourcePath = '';
            this.requestHeader = {};
          }
          return _createClass(Loader, [{
            key: "load",
            value: function load(/* url, onLoad, onProgress, onError */) {}
          }, {
            key: "loadAsync",
            value: function loadAsync(url, onProgress) {
              var scope = this;
              return new Promise(function (resolve, reject) {
                scope.load(url, resolve, onProgress, reject);
              });
            }
          }, {
            key: "parse",
            value: function parse(/* data */) {}
          }, {
            key: "setCrossOrigin",
            value: function setCrossOrigin(crossOrigin) {
              this.crossOrigin = crossOrigin;
              return this;
            }
          }, {
            key: "setWithCredentials",
            value: function setWithCredentials(value) {
              this.withCredentials = value;
              return this;
            }
          }, {
            key: "setPath",
            value: function setPath(path) {
              this.path = path;
              return this;
            }
          }, {
            key: "setResourcePath",
            value: function setResourcePath(resourcePath) {
              this.resourcePath = resourcePath;
              return this;
            }
          }, {
            key: "setRequestHeader",
            value: function setRequestHeader(requestHeader) {
              this.requestHeader = requestHeader;
              return this;
            }
          }]);
        }();
        Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';
        var loading = {};
        var HttpError = /*#__PURE__*/function (_Error) {
          function HttpError(message, response) {
            var _this108;
            _classCallCheck2(this, HttpError);
            _this108 = _callSuper(this, HttpError, [message]);
            _this108.response = response;
            return _this108;
          }
          _inherits(HttpError, _Error);
          return _createClass(HttpError);
        }(/*#__PURE__*/_wrapNativeSuper(Error));
        var FileLoader = /*#__PURE__*/function (_Loader) {
          function FileLoader(manager) {
            _classCallCheck2(this, FileLoader);
            return _callSuper(this, FileLoader, [manager]);
          }
          _inherits(FileLoader, _Loader);
          return _createClass(FileLoader, [{
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
              var _this109 = this;
              if (url === undefined) url = '';
              if (this.path !== undefined) url = this.path + url;
              url = this.manager.resolveURL(url);
              var cached = Cache.get(url);
              if (cached !== undefined) {
                this.manager.itemStart(url);
                setTimeout(function () {
                  if (onLoad) onLoad(cached);
                  _this109.manager.itemEnd(url);
                }, 0);
                return cached;
              }

              // Check if request is duplicate

              if (loading[url] !== undefined) {
                loading[url].push({
                  onLoad: onLoad,
                  onProgress: onProgress,
                  onError: onError
                });
                return;
              }

              // Initialise array for duplicate requests
              loading[url] = [];
              loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
              });

              // create request
              var req = new Request(url, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? 'include' : 'same-origin'
                // An abort controller could be added within a future PR
              });

              // record states ( avoid data race )
              var mimeType = this.mimeType;
              var responseType = this.responseType;

              // start the fetch
              fetch(req).then(function (response) {
                if (response.status === 200 || response.status === 0) {
                  // Some browsers return HTTP Status 0 when using non-http protocol
                  // e.g. 'file://' or 'data://'. Handle as success.

                  if (response.status === 0) {
                    console.warn('THREE.FileLoader: HTTP Status 0 received.');
                  }

                  // Workaround: Checking if response.body === undefined for Alipay browser #23548

                  if (typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined) {
                    return response;
                  }
                  var callbacks = loading[url];
                  var reader = response.body.getReader();

                  // Nginx needs X-File-Size check
                  // https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content
                  var contentLength = response.headers.get('X-File-Size') || response.headers.get('Content-Length');
                  var total = contentLength ? parseInt(contentLength) : 0;
                  var lengthComputable = total !== 0;
                  var loaded = 0;

                  // periodically read data into the new stream tracking while download progress
                  var stream = new ReadableStream({
                    start: function start(controller) {
                      readData();
                      function readData() {
                        reader.read().then(function (_ref70) {
                          var done = _ref70.done,
                            value = _ref70.value;
                          if (done) {
                            controller.close();
                          } else {
                            loaded += value.byteLength;
                            var event = new ProgressEvent('progress', {
                              lengthComputable: lengthComputable,
                              loaded: loaded,
                              total: total
                            });
                            for (var i = 0, il = callbacks.length; i < il; i++) {
                              var callback = callbacks[i];
                              if (callback.onProgress) callback.onProgress(event);
                            }
                            controller.enqueue(value);
                            readData();
                          }
                        }, function (e) {
                          controller.error(e);
                        });
                      }
                    }
                  });
                  return new Response(stream);
                } else {
                  throw new HttpError("fetch for \"".concat(response.url, "\" responded with ").concat(response.status, ": ").concat(response.statusText), response);
                }
              }).then(function (response) {
                switch (responseType) {
                  case 'arraybuffer':
                    return response.arrayBuffer();
                  case 'blob':
                    return response.blob();
                  case 'document':
                    return response.text().then(function (text) {
                      var parser = new DOMParser();
                      return parser.parseFromString(text, mimeType);
                    });
                  case 'json':
                    return response.json();
                  default:
                    if (mimeType === undefined) {
                      return response.text();
                    } else {
                      // sniff encoding
                      var re = /charset="?([^;"\s]*)"?/i;
                      var exec = re.exec(mimeType);
                      var label = exec && exec[1] ? exec[1].toLowerCase() : undefined;
                      var decoder = new TextDecoder(label);
                      return response.arrayBuffer().then(function (ab) {
                        return decoder.decode(ab);
                      });
                    }
                }
              }).then(function (data) {
                // Add to cache only on HTTP success, so that we do not cache
                // error response bodies as proper responses to requests.
                Cache.add(url, data);
                var callbacks = loading[url];
                delete loading[url];
                for (var i = 0, il = callbacks.length; i < il; i++) {
                  var callback = callbacks[i];
                  if (callback.onLoad) callback.onLoad(data);
                }
              }).catch(function (err) {
                // Abort errors and other errors are handled the same

                var callbacks = loading[url];
                if (callbacks === undefined) {
                  // When onLoad was called and url was deleted in `loading`
                  _this109.manager.itemError(url);
                  throw err;
                }
                delete loading[url];
                for (var i = 0, il = callbacks.length; i < il; i++) {
                  var callback = callbacks[i];
                  if (callback.onError) callback.onError(err);
                }
                _this109.manager.itemError(url);
              }).finally(function () {
                _this109.manager.itemEnd(url);
              });
              this.manager.itemStart(url);
            }
          }, {
            key: "setResponseType",
            value: function setResponseType(value) {
              this.responseType = value;
              return this;
            }
          }, {
            key: "setMimeType",
            value: function setMimeType(value) {
              this.mimeType = value;
              return this;
            }
          }]);
        }(Loader);
        var AnimationLoader = /*#__PURE__*/function (_Loader2) {
          function AnimationLoader(manager) {
            _classCallCheck2(this, AnimationLoader);
            return _callSuper(this, AnimationLoader, [manager]);
          }
          _inherits(AnimationLoader, _Loader2);
          return _createClass(AnimationLoader, [{
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
              var scope = this;
              var loader = new FileLoader(this.manager);
              loader.setPath(this.path);
              loader.setRequestHeader(this.requestHeader);
              loader.setWithCredentials(this.withCredentials);
              loader.load(url, function (text) {
                try {
                  onLoad(scope.parse(JSON.parse(text)));
                } catch (e) {
                  if (onError) {
                    onError(e);
                  } else {
                    console.error(e);
                  }
                  scope.manager.itemError(url);
                }
              }, onProgress, onError);
            }
          }, {
            key: "parse",
            value: function parse(json) {
              var animations = [];
              for (var i = 0; i < json.length; i++) {
                var clip = AnimationClip.parse(json[i]);
                animations.push(clip);
              }
              return animations;
            }
          }]);
        }(Loader);
        /**
         * Abstract Base class to block based textures loader (dds, pvr, ...)
         *
         * Sub classes have to implement the parse() method which will be used in load().
         */
        var CompressedTextureLoader = /*#__PURE__*/function (_Loader3) {
          function CompressedTextureLoader(manager) {
            _classCallCheck2(this, CompressedTextureLoader);
            return _callSuper(this, CompressedTextureLoader, [manager]);
          }
          _inherits(CompressedTextureLoader, _Loader3);
          return _createClass(CompressedTextureLoader, [{
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
              var scope = this;
              var images = [];
              var texture = new CompressedTexture();
              var loader = new FileLoader(this.manager);
              loader.setPath(this.path);
              loader.setResponseType('arraybuffer');
              loader.setRequestHeader(this.requestHeader);
              loader.setWithCredentials(scope.withCredentials);
              var loaded = 0;
              function loadTexture(i) {
                loader.load(url[i], function (buffer) {
                  var texDatas = scope.parse(buffer, true);
                  images[i] = {
                    width: texDatas.width,
                    height: texDatas.height,
                    format: texDatas.format,
                    mipmaps: texDatas.mipmaps
                  };
                  loaded += 1;
                  if (loaded === 6) {
                    if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
                    texture.image = images;
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                  }
                }, onProgress, onError);
              }
              if (Array.isArray(url)) {
                for (var i = 0, il = url.length; i < il; ++i) {
                  loadTexture(i);
                }
              } else {
                // compressed cubemap texture stored in a single DDS file

                loader.load(url, function (buffer) {
                  var texDatas = scope.parse(buffer, true);
                  if (texDatas.isCubemap) {
                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                    for (var f = 0; f < faces; f++) {
                      images[f] = {
                        mipmaps: []
                      };
                      for (var _i102 = 0; _i102 < texDatas.mipmapCount; _i102++) {
                        images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + _i102]);
                        images[f].format = texDatas.format;
                        images[f].width = texDatas.width;
                        images[f].height = texDatas.height;
                      }
                    }
                    texture.image = images;
                  } else {
                    texture.image.width = texDatas.width;
                    texture.image.height = texDatas.height;
                    texture.mipmaps = texDatas.mipmaps;
                  }
                  if (texDatas.mipmapCount === 1) {
                    texture.minFilter = LinearFilter;
                  }
                  texture.format = texDatas.format;
                  texture.needsUpdate = true;
                  if (onLoad) onLoad(texture);
                }, onProgress, onError);
              }
              return texture;
            }
          }]);
        }(Loader);
        var ImageLoader = /*#__PURE__*/function (_Loader4) {
          function ImageLoader(manager) {
            _classCallCheck2(this, ImageLoader);
            return _callSuper(this, ImageLoader, [manager]);
          }
          _inherits(ImageLoader, _Loader4);
          return _createClass(ImageLoader, [{
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
              if (this.path !== undefined) url = this.path + url;
              url = this.manager.resolveURL(url);
              var scope = this;
              var cached = Cache.get(url);
              if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function () {
                  if (onLoad) onLoad(cached);
                  scope.manager.itemEnd(url);
                }, 0);
                return cached;
              }
              var image = createElementNS('img');
              function onImageLoad() {
                removeEventListeners();
                Cache.add(url, this);
                if (onLoad) onLoad(this);
                scope.manager.itemEnd(url);
              }
              function onImageError(event) {
                removeEventListeners();
                if (onError) onError(event);
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
              }
              function removeEventListeners() {
                image.removeEventListener('load', onImageLoad, false);
                image.removeEventListener('error', onImageError, false);
              }
              image.addEventListener('load', onImageLoad, false);
              image.addEventListener('error', onImageError, false);
              if (url.slice(0, 5) !== 'data:') {
                if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
              }
              scope.manager.itemStart(url);
              image.src = url;
              return image;
            }
          }]);
        }(Loader);
        var CubeTextureLoader = /*#__PURE__*/function (_Loader5) {
          function CubeTextureLoader(manager) {
            _classCallCheck2(this, CubeTextureLoader);
            return _callSuper(this, CubeTextureLoader, [manager]);
          }
          _inherits(CubeTextureLoader, _Loader5);
          return _createClass(CubeTextureLoader, [{
            key: "load",
            value: function load(urls, onLoad, onProgress, onError) {
              var texture = new CubeTexture();
              texture.colorSpace = SRGBColorSpace;
              var loader = new ImageLoader(this.manager);
              loader.setCrossOrigin(this.crossOrigin);
              loader.setPath(this.path);
              var loaded = 0;
              function loadTexture(i) {
                loader.load(urls[i], function (image) {
                  texture.images[i] = image;
                  loaded++;
                  if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                  }
                }, undefined, onError);
              }
              for (var i = 0; i < urls.length; ++i) {
                loadTexture(i);
              }
              return texture;
            }
          }]);
        }(Loader);
        /**
         * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
         *
         * Sub classes have to implement the parse() method which will be used in load().
         */
        var DataTextureLoader = /*#__PURE__*/function (_Loader6) {
          function DataTextureLoader(manager) {
            _classCallCheck2(this, DataTextureLoader);
            return _callSuper(this, DataTextureLoader, [manager]);
          }
          _inherits(DataTextureLoader, _Loader6);
          return _createClass(DataTextureLoader, [{
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
              var scope = this;
              var texture = new DataTexture();
              var loader = new FileLoader(this.manager);
              loader.setResponseType('arraybuffer');
              loader.setRequestHeader(this.requestHeader);
              loader.setPath(this.path);
              loader.setWithCredentials(scope.withCredentials);
              loader.load(url, function (buffer) {
                var texData;
                try {
                  texData = scope.parse(buffer);
                } catch (error) {
                  if (onError !== undefined) {
                    onError(error);
                  } else {
                    console.error(error);
                    return;
                  }
                }
                if (texData.image !== undefined) {
                  texture.image = texData.image;
                } else if (texData.data !== undefined) {
                  texture.image.width = texData.width;
                  texture.image.height = texData.height;
                  texture.image.data = texData.data;
                }
                texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
                texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
                texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
                texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
                texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
                if (texData.colorSpace !== undefined) {
                  texture.colorSpace = texData.colorSpace;
                }
                if (texData.flipY !== undefined) {
                  texture.flipY = texData.flipY;
                }
                if (texData.format !== undefined) {
                  texture.format = texData.format;
                }
                if (texData.type !== undefined) {
                  texture.type = texData.type;
                }
                if (texData.mipmaps !== undefined) {
                  texture.mipmaps = texData.mipmaps;
                  texture.minFilter = LinearMipmapLinearFilter; // presumably...
                }
                if (texData.mipmapCount === 1) {
                  texture.minFilter = LinearFilter;
                }
                if (texData.generateMipmaps !== undefined) {
                  texture.generateMipmaps = texData.generateMipmaps;
                }
                texture.needsUpdate = true;
                if (onLoad) onLoad(texture, texData);
              }, onProgress, onError);
              return texture;
            }
          }]);
        }(Loader);
        var TextureLoader = /*#__PURE__*/function (_Loader7) {
          function TextureLoader(manager) {
            _classCallCheck2(this, TextureLoader);
            return _callSuper(this, TextureLoader, [manager]);
          }
          _inherits(TextureLoader, _Loader7);
          return _createClass(TextureLoader, [{
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
              var texture = new Texture();
              var loader = new ImageLoader(this.manager);
              loader.setCrossOrigin(this.crossOrigin);
              loader.setPath(this.path);
              loader.load(url, function (image) {
                texture.image = image;
                texture.needsUpdate = true;
                if (onLoad !== undefined) {
                  onLoad(texture);
                }
              }, onProgress, onError);
              return texture;
            }
          }]);
        }(Loader);
        var Light = /*#__PURE__*/function (_Object3D11) {
          function Light(color) {
            var _this110;
            var intensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            _classCallCheck2(this, Light);
            _this110 = _callSuper(this, Light);
            _this110.isLight = true;
            _this110.type = 'Light';
            _this110.color = new Color(color);
            _this110.intensity = intensity;
            return _this110;
          }
          _inherits(Light, _Object3D11);
          return _createClass(Light, [{
            key: "dispose",
            value: function dispose() {

              // Empty here in base class; some subclasses override.
            }
          }, {
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(Light, "copy", this, 3)([source, recursive]);
              this.color.copy(source.color);
              this.intensity = source.intensity;
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON(meta) {
              var data = _superPropGet(Light, "toJSON", this, 3)([meta]);
              data.object.color = this.color.getHex();
              data.object.intensity = this.intensity;
              if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
              if (this.distance !== undefined) data.object.distance = this.distance;
              if (this.angle !== undefined) data.object.angle = this.angle;
              if (this.decay !== undefined) data.object.decay = this.decay;
              if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
              if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
              if (this.target !== undefined) data.object.target = this.target.uuid;
              return data;
            }
          }]);
        }(Object3D);
        var HemisphereLight = /*#__PURE__*/function (_Light) {
          function HemisphereLight(skyColor, groundColor, intensity) {
            var _this111;
            _classCallCheck2(this, HemisphereLight);
            _this111 = _callSuper(this, HemisphereLight, [skyColor, intensity]);
            _this111.isHemisphereLight = true;
            _this111.type = 'HemisphereLight';
            _this111.position.copy(Object3D.DEFAULT_UP);
            _this111.updateMatrix();
            _this111.groundColor = new Color(groundColor);
            return _this111;
          }
          _inherits(HemisphereLight, _Light);
          return _createClass(HemisphereLight, [{
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(HemisphereLight, "copy", this, 3)([source, recursive]);
              this.groundColor.copy(source.groundColor);
              return this;
            }
          }]);
        }(Light);
        var _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();
        var _lightPositionWorld$1 = /*@__PURE__*/new Vector3();
        var _lookTarget$1 = /*@__PURE__*/new Vector3();
        var LightShadow = /*#__PURE__*/function () {
          function LightShadow(camera) {
            _classCallCheck2(this, LightShadow);
            this.camera = camera;
            this.intensity = 1;
            this.bias = 0;
            this.normalBias = 0;
            this.radius = 1;
            this.blurSamples = 8;
            this.mapSize = new Vector2(512, 512);
            this.map = null;
            this.mapPass = null;
            this.matrix = new Matrix4();
            this.autoUpdate = true;
            this.needsUpdate = false;
            this._frustum = new Frustum();
            this._frameExtents = new Vector2(1, 1);
            this._viewportCount = 1;
            this._viewports = [new Vector4(0, 0, 1, 1)];
          }
          return _createClass(LightShadow, [{
            key: "getViewportCount",
            value: function getViewportCount() {
              return this._viewportCount;
            }
          }, {
            key: "getFrustum",
            value: function getFrustum() {
              return this._frustum;
            }
          }, {
            key: "updateMatrices",
            value: function updateMatrices(light) {
              var shadowCamera = this.camera;
              var shadowMatrix = this.matrix;
              _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
              shadowCamera.position.copy(_lightPositionWorld$1);
              _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
              shadowCamera.lookAt(_lookTarget$1);
              shadowCamera.updateMatrixWorld();
              _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
              this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
              shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
              shadowMatrix.multiply(_projScreenMatrix$1);
            }
          }, {
            key: "getViewport",
            value: function getViewport(viewportIndex) {
              return this._viewports[viewportIndex];
            }
          }, {
            key: "getFrameExtents",
            value: function getFrameExtents() {
              return this._frameExtents;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              if (this.map) {
                this.map.dispose();
              }
              if (this.mapPass) {
                this.mapPass.dispose();
              }
            }
          }, {
            key: "copy",
            value: function copy(source) {
              this.camera = source.camera.clone();
              this.intensity = source.intensity;
              this.bias = source.bias;
              this.radius = source.radius;
              this.mapSize.copy(source.mapSize);
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var object = {};
              if (this.intensity !== 1) object.intensity = this.intensity;
              if (this.bias !== 0) object.bias = this.bias;
              if (this.normalBias !== 0) object.normalBias = this.normalBias;
              if (this.radius !== 1) object.radius = this.radius;
              if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
              object.camera = this.camera.toJSON(false).object;
              delete object.camera.matrix;
              return object;
            }
          }]);
        }();
        var SpotLightShadow = /*#__PURE__*/function (_LightShadow) {
          function SpotLightShadow() {
            var _this112;
            _classCallCheck2(this, SpotLightShadow);
            _this112 = _callSuper(this, SpotLightShadow, [new PerspectiveCamera(50, 1, 0.5, 500)]);
            _this112.isSpotLightShadow = true;
            _this112.focus = 1;
            return _this112;
          }
          _inherits(SpotLightShadow, _LightShadow);
          return _createClass(SpotLightShadow, [{
            key: "updateMatrices",
            value: function updateMatrices(light) {
              var camera = this.camera;
              var fov = RAD2DEG * 2 * light.angle * this.focus;
              var aspect = this.mapSize.width / this.mapSize.height;
              var far = light.distance || camera.far;
              if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
                camera.fov = fov;
                camera.aspect = aspect;
                camera.far = far;
                camera.updateProjectionMatrix();
              }
              _superPropGet(SpotLightShadow, "updateMatrices", this, 3)([light]);
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(SpotLightShadow, "copy", this, 3)([source]);
              this.focus = source.focus;
              return this;
            }
          }]);
        }(LightShadow);
        var SpotLight = /*#__PURE__*/function (_Light2) {
          function SpotLight(color, intensity) {
            var _this113;
            var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var angle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI / 3;
            var penumbra = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
            var decay = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2;
            _classCallCheck2(this, SpotLight);
            _this113 = _callSuper(this, SpotLight, [color, intensity]);
            _this113.isSpotLight = true;
            _this113.type = 'SpotLight';
            _this113.position.copy(Object3D.DEFAULT_UP);
            _this113.updateMatrix();
            _this113.target = new Object3D();
            _this113.distance = distance;
            _this113.angle = angle;
            _this113.penumbra = penumbra;
            _this113.decay = decay;
            _this113.map = null;
            _this113.shadow = new SpotLightShadow();
            return _this113;
          }
          _inherits(SpotLight, _Light2);
          return _createClass(SpotLight, [{
            key: "power",
            get: function get() {
              // compute the light's luminous power (in lumens) from its intensity (in candela)
              // by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
              return this.intensity * Math.PI;
            },
            set: function set(power) {
              // set the light's intensity (in candela) from the desired luminous power (in lumens)
              this.intensity = power / Math.PI;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.shadow.dispose();
            }
          }, {
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(SpotLight, "copy", this, 3)([source, recursive]);
              this.distance = source.distance;
              this.angle = source.angle;
              this.penumbra = source.penumbra;
              this.decay = source.decay;
              this.target = source.target.clone();
              this.shadow = source.shadow.clone();
              return this;
            }
          }]);
        }(Light);
        var _projScreenMatrix = /*@__PURE__*/new Matrix4();
        var _lightPositionWorld = /*@__PURE__*/new Vector3();
        var _lookTarget = /*@__PURE__*/new Vector3();
        var PointLightShadow = /*#__PURE__*/function (_LightShadow2) {
          function PointLightShadow() {
            var _this114;
            _classCallCheck2(this, PointLightShadow);
            _this114 = _callSuper(this, PointLightShadow, [new PerspectiveCamera(90, 1, 0.5, 500)]);
            _this114.isPointLightShadow = true;
            _this114._frameExtents = new Vector2(4, 2);
            _this114._viewportCount = 6;
            _this114._viewports = [
            // These viewports map a cube-map onto a 2D texture with the
            // following orientation:
            //
            //  xzXZ
            //   y Y
            //
            // X - Positive x direction
            // x - Negative x direction
            // Y - Positive y direction
            // y - Negative y direction
            // Z - Positive z direction
            // z - Negative z direction

            // positive X
            new Vector4(2, 1, 1, 1),
            // negative X
            new Vector4(0, 1, 1, 1),
            // positive Z
            new Vector4(3, 1, 1, 1),
            // negative Z
            new Vector4(1, 1, 1, 1),
            // positive Y
            new Vector4(3, 0, 1, 1),
            // negative Y
            new Vector4(1, 0, 1, 1)];
            _this114._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
            _this114._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
            return _this114;
          }
          _inherits(PointLightShadow, _LightShadow2);
          return _createClass(PointLightShadow, [{
            key: "updateMatrices",
            value: function updateMatrices(light) {
              var viewportIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var camera = this.camera;
              var shadowMatrix = this.matrix;
              var far = light.distance || camera.far;
              if (far !== camera.far) {
                camera.far = far;
                camera.updateProjectionMatrix();
              }
              _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
              camera.position.copy(_lightPositionWorld);
              _lookTarget.copy(camera.position);
              _lookTarget.add(this._cubeDirections[viewportIndex]);
              camera.up.copy(this._cubeUps[viewportIndex]);
              camera.lookAt(_lookTarget);
              camera.updateMatrixWorld();
              shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
              _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
              this._frustum.setFromProjectionMatrix(_projScreenMatrix);
            }
          }]);
        }(LightShadow);
        var PointLight = /*#__PURE__*/function (_Light3) {
          function PointLight(color, intensity) {
            var _this115;
            var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var decay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;
            _classCallCheck2(this, PointLight);
            _this115 = _callSuper(this, PointLight, [color, intensity]);
            _this115.isPointLight = true;
            _this115.type = 'PointLight';
            _this115.distance = distance;
            _this115.decay = decay;
            _this115.shadow = new PointLightShadow();
            return _this115;
          }
          _inherits(PointLight, _Light3);
          return _createClass(PointLight, [{
            key: "power",
            get: function get() {
              // compute the light's luminous power (in lumens) from its intensity (in candela)
              // for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
              return this.intensity * 4 * Math.PI;
            },
            set: function set(power) {
              // set the light's intensity (in candela) from the desired luminous power (in lumens)
              this.intensity = power / (4 * Math.PI);
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.shadow.dispose();
            }
          }, {
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(PointLight, "copy", this, 3)([source, recursive]);
              this.distance = source.distance;
              this.decay = source.decay;
              this.shadow = source.shadow.clone();
              return this;
            }
          }]);
        }(Light);
        var DirectionalLightShadow = /*#__PURE__*/function (_LightShadow3) {
          function DirectionalLightShadow() {
            var _this116;
            _classCallCheck2(this, DirectionalLightShadow);
            _this116 = _callSuper(this, DirectionalLightShadow, [new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)]);
            _this116.isDirectionalLightShadow = true;
            return _this116;
          }
          _inherits(DirectionalLightShadow, _LightShadow3);
          return _createClass(DirectionalLightShadow);
        }(LightShadow);
        var DirectionalLight = /*#__PURE__*/function (_Light4) {
          function DirectionalLight(color, intensity) {
            var _this117;
            _classCallCheck2(this, DirectionalLight);
            _this117 = _callSuper(this, DirectionalLight, [color, intensity]);
            _this117.isDirectionalLight = true;
            _this117.type = 'DirectionalLight';
            _this117.position.copy(Object3D.DEFAULT_UP);
            _this117.updateMatrix();
            _this117.target = new Object3D();
            _this117.shadow = new DirectionalLightShadow();
            return _this117;
          }
          _inherits(DirectionalLight, _Light4);
          return _createClass(DirectionalLight, [{
            key: "dispose",
            value: function dispose() {
              this.shadow.dispose();
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(DirectionalLight, "copy", this, 3)([source]);
              this.target = source.target.clone();
              this.shadow = source.shadow.clone();
              return this;
            }
          }]);
        }(Light);
        var AmbientLight = /*#__PURE__*/function (_Light5) {
          function AmbientLight(color, intensity) {
            var _this118;
            _classCallCheck2(this, AmbientLight);
            _this118 = _callSuper(this, AmbientLight, [color, intensity]);
            _this118.isAmbientLight = true;
            _this118.type = 'AmbientLight';
            return _this118;
          }
          _inherits(AmbientLight, _Light5);
          return _createClass(AmbientLight);
        }(Light);
        var RectAreaLight = /*#__PURE__*/function (_Light6) {
          function RectAreaLight(color, intensity) {
            var _this119;
            var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
            var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
            _classCallCheck2(this, RectAreaLight);
            _this119 = _callSuper(this, RectAreaLight, [color, intensity]);
            _this119.isRectAreaLight = true;
            _this119.type = 'RectAreaLight';
            _this119.width = width;
            _this119.height = height;
            return _this119;
          }
          _inherits(RectAreaLight, _Light6);
          return _createClass(RectAreaLight, [{
            key: "power",
            get: function get() {
              // compute the light's luminous power (in lumens) from its intensity (in nits)
              return this.intensity * this.width * this.height * Math.PI;
            },
            set: function set(power) {
              // set the light's intensity (in nits) from the desired luminous power (in lumens)
              this.intensity = power / (this.width * this.height * Math.PI);
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(RectAreaLight, "copy", this, 3)([source]);
              this.width = source.width;
              this.height = source.height;
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON(meta) {
              var data = _superPropGet(RectAreaLight, "toJSON", this, 3)([meta]);
              data.object.width = this.width;
              data.object.height = this.height;
              return data;
            }
          }]);
        }(Light);
        /**
         * Primary reference:
         *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
         *
         * Secondary reference:
         *   https://www.ppsloan.org/publications/StupidSH36.pdf
         */
        // 3-band SH defined by 9 coefficients
        var SphericalHarmonics3 = /*#__PURE__*/function () {
          function SphericalHarmonics3() {
            _classCallCheck2(this, SphericalHarmonics3);
            this.isSphericalHarmonics3 = true;
            this.coefficients = [];
            for (var i = 0; i < 9; i++) {
              this.coefficients.push(new Vector3());
            }
          }
          return _createClass(SphericalHarmonics3, [{
            key: "set",
            value: function set(coefficients) {
              for (var i = 0; i < 9; i++) {
                this.coefficients[i].copy(coefficients[i]);
              }
              return this;
            }
          }, {
            key: "zero",
            value: function zero() {
              for (var i = 0; i < 9; i++) {
                this.coefficients[i].set(0, 0, 0);
              }
              return this;
            }

            // get the radiance in the direction of the normal
            // target is a Vector3
          }, {
            key: "getAt",
            value: function getAt(normal, target) {
              // normal is assumed to be unit length

              var x = normal.x,
                y = normal.y,
                z = normal.z;
              var coeff = this.coefficients;

              // band 0
              target.copy(coeff[0]).multiplyScalar(0.282095);

              // band 1
              target.addScaledVector(coeff[1], 0.488603 * y);
              target.addScaledVector(coeff[2], 0.488603 * z);
              target.addScaledVector(coeff[3], 0.488603 * x);

              // band 2
              target.addScaledVector(coeff[4], 1.092548 * (x * y));
              target.addScaledVector(coeff[5], 1.092548 * (y * z));
              target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
              target.addScaledVector(coeff[7], 1.092548 * (x * z));
              target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
              return target;
            }

            // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
            // target is a Vector3
            // https://graphics.stanford.edu/papers/envmap/envmap.pdf
          }, {
            key: "getIrradianceAt",
            value: function getIrradianceAt(normal, target) {
              // normal is assumed to be unit length

              var x = normal.x,
                y = normal.y,
                z = normal.z;
              var coeff = this.coefficients;

              // band 0
              target.copy(coeff[0]).multiplyScalar(0.886227); //  * 0.282095

              // band 1
              target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 *  / 3 ) * 0.488603
              target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
              target.addScaledVector(coeff[3], 2.0 * 0.511664 * x);

              // band 2
              target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // (  / 4 ) * 1.092548
              target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
              target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // (  / 4 ) * 0.315392 * 3
              target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
              target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // (  / 4 ) * 0.546274

              return target;
            }
          }, {
            key: "add",
            value: function add(sh) {
              for (var i = 0; i < 9; i++) {
                this.coefficients[i].add(sh.coefficients[i]);
              }
              return this;
            }
          }, {
            key: "addScaledSH",
            value: function addScaledSH(sh, s) {
              for (var i = 0; i < 9; i++) {
                this.coefficients[i].addScaledVector(sh.coefficients[i], s);
              }
              return this;
            }
          }, {
            key: "scale",
            value: function scale(s) {
              for (var i = 0; i < 9; i++) {
                this.coefficients[i].multiplyScalar(s);
              }
              return this;
            }
          }, {
            key: "lerp",
            value: function lerp(sh, alpha) {
              for (var i = 0; i < 9; i++) {
                this.coefficients[i].lerp(sh.coefficients[i], alpha);
              }
              return this;
            }
          }, {
            key: "equals",
            value: function equals(sh) {
              for (var i = 0; i < 9; i++) {
                if (!this.coefficients[i].equals(sh.coefficients[i])) {
                  return false;
                }
              }
              return true;
            }
          }, {
            key: "copy",
            value: function copy(sh) {
              return this.set(sh.coefficients);
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }, {
            key: "fromArray",
            value: function fromArray(array) {
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var coefficients = this.coefficients;
              for (var i = 0; i < 9; i++) {
                coefficients[i].fromArray(array, offset + i * 3);
              }
              return this;
            }
          }, {
            key: "toArray",
            value: function toArray() {
              var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var coefficients = this.coefficients;
              for (var i = 0; i < 9; i++) {
                coefficients[i].toArray(array, offset + i * 3);
              }
              return array;
            }

            // evaluate the basis functions
            // shBasis is an Array[ 9 ]
          }], [{
            key: "getBasisAt",
            value: function getBasisAt(normal, shBasis) {
              // normal is assumed to be unit length

              var x = normal.x,
                y = normal.y,
                z = normal.z;

              // band 0
              shBasis[0] = 0.282095;

              // band 1
              shBasis[1] = 0.488603 * y;
              shBasis[2] = 0.488603 * z;
              shBasis[3] = 0.488603 * x;

              // band 2
              shBasis[4] = 1.092548 * x * y;
              shBasis[5] = 1.092548 * y * z;
              shBasis[6] = 0.315392 * (3 * z * z - 1);
              shBasis[7] = 1.092548 * x * z;
              shBasis[8] = 0.546274 * (x * x - y * y);
            }
          }]);
        }();
        var LightProbe = /*#__PURE__*/function (_Light7) {
          function LightProbe() {
            var _this120;
            var sh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new SphericalHarmonics3();
            var intensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            _classCallCheck2(this, LightProbe);
            _this120 = _callSuper(this, LightProbe, [undefined, intensity]);
            _this120.isLightProbe = true;
            _this120.sh = sh;
            return _this120;
          }
          _inherits(LightProbe, _Light7);
          return _createClass(LightProbe, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(LightProbe, "copy", this, 3)([source]);
              this.sh.copy(source.sh);
              return this;
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
              this.sh.fromArray(json.sh);
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON(meta) {
              var data = _superPropGet(LightProbe, "toJSON", this, 3)([meta]);
              data.object.sh = this.sh.toArray();
              return data;
            }
          }]);
        }(Light);
        var MaterialLoader = /*#__PURE__*/function (_Loader8) {
          function MaterialLoader(manager) {
            var _this121;
            _classCallCheck2(this, MaterialLoader);
            _this121 = _callSuper(this, MaterialLoader, [manager]);
            _this121.textures = {};
            return _this121;
          }
          _inherits(MaterialLoader, _Loader8);
          return _createClass(MaterialLoader, [{
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
              var scope = this;
              var loader = new FileLoader(scope.manager);
              loader.setPath(scope.path);
              loader.setRequestHeader(scope.requestHeader);
              loader.setWithCredentials(scope.withCredentials);
              loader.load(url, function (text) {
                try {
                  onLoad(scope.parse(JSON.parse(text)));
                } catch (e) {
                  if (onError) {
                    onError(e);
                  } else {
                    console.error(e);
                  }
                  scope.manager.itemError(url);
                }
              }, onProgress, onError);
            }
          }, {
            key: "parse",
            value: function parse(json) {
              var textures = this.textures;
              function getTexture(name) {
                if (textures[name] === undefined) {
                  console.warn('THREE.MaterialLoader: Undefined texture', name);
                }
                return textures[name];
              }
              var material = MaterialLoader.createMaterialFromType(json.type);
              if (json.uuid !== undefined) material.uuid = json.uuid;
              if (json.name !== undefined) material.name = json.name;
              if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
              if (json.roughness !== undefined) material.roughness = json.roughness;
              if (json.metalness !== undefined) material.metalness = json.metalness;
              if (json.sheen !== undefined) material.sheen = json.sheen;
              if (json.sheenColor !== undefined) material.sheenColor = new Color().setHex(json.sheenColor);
              if (json.sheenRoughness !== undefined) material.sheenRoughness = json.sheenRoughness;
              if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
              if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
              if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
              if (json.specularColor !== undefined && material.specularColor !== undefined) material.specularColor.setHex(json.specularColor);
              if (json.shininess !== undefined) material.shininess = json.shininess;
              if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
              if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
              if (json.dispersion !== undefined) material.dispersion = json.dispersion;
              if (json.iridescence !== undefined) material.iridescence = json.iridescence;
              if (json.iridescenceIOR !== undefined) material.iridescenceIOR = json.iridescenceIOR;
              if (json.iridescenceThicknessRange !== undefined) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
              if (json.transmission !== undefined) material.transmission = json.transmission;
              if (json.thickness !== undefined) material.thickness = json.thickness;
              if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
              if (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);
              if (json.anisotropy !== undefined) material.anisotropy = json.anisotropy;
              if (json.anisotropyRotation !== undefined) material.anisotropyRotation = json.anisotropyRotation;
              if (json.fog !== undefined) material.fog = json.fog;
              if (json.flatShading !== undefined) material.flatShading = json.flatShading;
              if (json.blending !== undefined) material.blending = json.blending;
              if (json.combine !== undefined) material.combine = json.combine;
              if (json.side !== undefined) material.side = json.side;
              if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
              if (json.opacity !== undefined) material.opacity = json.opacity;
              if (json.transparent !== undefined) material.transparent = json.transparent;
              if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
              if (json.alphaHash !== undefined) material.alphaHash = json.alphaHash;
              if (json.depthFunc !== undefined) material.depthFunc = json.depthFunc;
              if (json.depthTest !== undefined) material.depthTest = json.depthTest;
              if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
              if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
              if (json.blendSrc !== undefined) material.blendSrc = json.blendSrc;
              if (json.blendDst !== undefined) material.blendDst = json.blendDst;
              if (json.blendEquation !== undefined) material.blendEquation = json.blendEquation;
              if (json.blendSrcAlpha !== undefined) material.blendSrcAlpha = json.blendSrcAlpha;
              if (json.blendDstAlpha !== undefined) material.blendDstAlpha = json.blendDstAlpha;
              if (json.blendEquationAlpha !== undefined) material.blendEquationAlpha = json.blendEquationAlpha;
              if (json.blendColor !== undefined && material.blendColor !== undefined) material.blendColor.setHex(json.blendColor);
              if (json.blendAlpha !== undefined) material.blendAlpha = json.blendAlpha;
              if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
              if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
              if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
              if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
              if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
              if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
              if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
              if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
              if (json.wireframe !== undefined) material.wireframe = json.wireframe;
              if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
              if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
              if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
              if (json.rotation !== undefined) material.rotation = json.rotation;
              if (json.linewidth !== undefined) material.linewidth = json.linewidth;
              if (json.dashSize !== undefined) material.dashSize = json.dashSize;
              if (json.gapSize !== undefined) material.gapSize = json.gapSize;
              if (json.scale !== undefined) material.scale = json.scale;
              if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
              if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
              if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
              if (json.dithering !== undefined) material.dithering = json.dithering;
              if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
              if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
              if (json.forceSinglePass !== undefined) material.forceSinglePass = json.forceSinglePass;
              if (json.visible !== undefined) material.visible = json.visible;
              if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
              if (json.userData !== undefined) material.userData = json.userData;
              if (json.vertexColors !== undefined) {
                if (typeof json.vertexColors === 'number') {
                  material.vertexColors = json.vertexColors > 0 ? true : false;
                } else {
                  material.vertexColors = json.vertexColors;
                }
              }

              // Shader Material

              if (json.uniforms !== undefined) {
                for (var name in json.uniforms) {
                  var uniform = json.uniforms[name];
                  material.uniforms[name] = {};
                  switch (uniform.type) {
                    case 't':
                      material.uniforms[name].value = getTexture(uniform.value);
                      break;
                    case 'c':
                      material.uniforms[name].value = new Color().setHex(uniform.value);
                      break;
                    case 'v2':
                      material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                      break;
                    case 'v3':
                      material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                      break;
                    case 'v4':
                      material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                      break;
                    case 'm3':
                      material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                      break;
                    case 'm4':
                      material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                      break;
                    default:
                      material.uniforms[name].value = uniform.value;
                  }
                }
              }
              if (json.defines !== undefined) material.defines = json.defines;
              if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
              if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
              if (json.glslVersion !== undefined) material.glslVersion = json.glslVersion;
              if (json.extensions !== undefined) {
                for (var key in json.extensions) {
                  material.extensions[key] = json.extensions[key];
                }
              }
              if (json.lights !== undefined) material.lights = json.lights;
              if (json.clipping !== undefined) material.clipping = json.clipping;

              // for PointsMaterial

              if (json.size !== undefined) material.size = json.size;
              if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;

              // maps

              if (json.map !== undefined) material.map = getTexture(json.map);
              if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
              if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
              if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
              if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
              if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
              if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
              if (json.normalScale !== undefined) {
                var normalScale = json.normalScale;
                if (Array.isArray(normalScale) === false) {
                  // Blender exporter used to export a scalar. See #7459

                  normalScale = [normalScale, normalScale];
                }
                material.normalScale = new Vector2().fromArray(normalScale);
              }
              if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
              if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
              if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
              if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
              if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
              if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
              if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
              if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
              if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
              if (json.specularColorMap !== undefined) material.specularColorMap = getTexture(json.specularColorMap);
              if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
              if (json.envMapRotation !== undefined) material.envMapRotation.fromArray(json.envMapRotation);
              if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
              if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
              if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
              if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
              if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
              if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
              if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
              if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
              if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
              if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
              if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
              if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
              if (json.iridescenceMap !== undefined) material.iridescenceMap = getTexture(json.iridescenceMap);
              if (json.iridescenceThicknessMap !== undefined) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);
              if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
              if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
              if (json.anisotropyMap !== undefined) material.anisotropyMap = getTexture(json.anisotropyMap);
              if (json.sheenColorMap !== undefined) material.sheenColorMap = getTexture(json.sheenColorMap);
              if (json.sheenRoughnessMap !== undefined) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
              return material;
            }
          }, {
            key: "setTextures",
            value: function setTextures(value) {
              this.textures = value;
              return this;
            }
          }], [{
            key: "createMaterialFromType",
            value: function createMaterialFromType(type) {
              var materialLib = {
                ShadowMaterial: ShadowMaterial,
                SpriteMaterial: SpriteMaterial,
                RawShaderMaterial: RawShaderMaterial,
                ShaderMaterial: ShaderMaterial,
                PointsMaterial: PointsMaterial,
                MeshPhysicalMaterial: MeshPhysicalMaterial,
                MeshStandardMaterial: MeshStandardMaterial,
                MeshPhongMaterial: MeshPhongMaterial,
                MeshToonMaterial: MeshToonMaterial,
                MeshNormalMaterial: MeshNormalMaterial,
                MeshLambertMaterial: MeshLambertMaterial,
                MeshDepthMaterial: MeshDepthMaterial,
                MeshDistanceMaterial: MeshDistanceMaterial,
                MeshBasicMaterial: MeshBasicMaterial,
                MeshMatcapMaterial: MeshMatcapMaterial,
                LineDashedMaterial: LineDashedMaterial,
                LineBasicMaterial: LineBasicMaterial,
                Material: Material
              };
              return new materialLib[type]();
            }
          }]);
        }(Loader);
        var LoaderUtils = /*#__PURE__*/function () {
          function LoaderUtils() {
            _classCallCheck2(this, LoaderUtils);
          }
          return _createClass(LoaderUtils, null, [{
            key: "decodeText",
            value: function decodeText(array) {
              // @deprecated, r165

              console.warn('THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.');
              if (typeof TextDecoder !== 'undefined') {
                return new TextDecoder().decode(array);
              }

              // Avoid the String.fromCharCode.apply(null, array) shortcut, which
              // throws a "maximum call stack size exceeded" error for large arrays.

              var s = '';
              for (var i = 0, il = array.length; i < il; i++) {
                // Implicitly assumes little-endian.
                s += String.fromCharCode(array[i]);
              }
              try {
                // merges multi-byte utf-8 characters.

                return decodeURIComponent(escape(s));
              } catch (e) {
                // see #16358

                return s;
              }
            }
          }, {
            key: "extractUrlBase",
            value: function extractUrlBase(url) {
              var index = url.lastIndexOf('/');
              if (index === -1) return './';
              return url.slice(0, index + 1);
            }
          }, {
            key: "resolveURL",
            value: function resolveURL(url, path) {
              // Invalid URL
              if (typeof url !== 'string' || url === '') return '';

              // Host Relative URL
              if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
                path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
              }

              // Absolute URL http://,https://,//
              if (/^(https?:)?\/\//i.test(url)) return url;

              // Data URI
              if (/^data:.*,.*$/i.test(url)) return url;

              // Blob URL
              if (/^blob:.*$/i.test(url)) return url;

              // Relative URL
              return path + url;
            }
          }]);
        }();
        var InstancedBufferGeometry = /*#__PURE__*/function (_BufferGeometry16) {
          function InstancedBufferGeometry() {
            var _this122;
            _classCallCheck2(this, InstancedBufferGeometry);
            _this122 = _callSuper(this, InstancedBufferGeometry);
            _this122.isInstancedBufferGeometry = true;
            _this122.type = 'InstancedBufferGeometry';
            _this122.instanceCount = Infinity;
            return _this122;
          }
          _inherits(InstancedBufferGeometry, _BufferGeometry16);
          return _createClass(InstancedBufferGeometry, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(InstancedBufferGeometry, "copy", this, 3)([source]);
              this.instanceCount = source.instanceCount;
              return this;
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var data = _superPropGet(InstancedBufferGeometry, "toJSON", this, 3)([]);
              data.instanceCount = this.instanceCount;
              data.isInstancedBufferGeometry = true;
              return data;
            }
          }]);
        }(BufferGeometry);
        var BufferGeometryLoader = /*#__PURE__*/function (_Loader9) {
          function BufferGeometryLoader(manager) {
            _classCallCheck2(this, BufferGeometryLoader);
            return _callSuper(this, BufferGeometryLoader, [manager]);
          }
          _inherits(BufferGeometryLoader, _Loader9);
          return _createClass(BufferGeometryLoader, [{
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
              var scope = this;
              var loader = new FileLoader(scope.manager);
              loader.setPath(scope.path);
              loader.setRequestHeader(scope.requestHeader);
              loader.setWithCredentials(scope.withCredentials);
              loader.load(url, function (text) {
                try {
                  onLoad(scope.parse(JSON.parse(text)));
                } catch (e) {
                  if (onError) {
                    onError(e);
                  } else {
                    console.error(e);
                  }
                  scope.manager.itemError(url);
                }
              }, onProgress, onError);
            }
          }, {
            key: "parse",
            value: function parse(json) {
              var interleavedBufferMap = {};
              var arrayBufferMap = {};
              function getInterleavedBuffer(json, uuid) {
                if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
                var interleavedBuffers = json.interleavedBuffers;
                var interleavedBuffer = interleavedBuffers[uuid];
                var buffer = getArrayBuffer(json, interleavedBuffer.buffer);
                var array = getTypedArray(interleavedBuffer.type, buffer);
                var ib = new InterleavedBuffer(array, interleavedBuffer.stride);
                ib.uuid = interleavedBuffer.uuid;
                interleavedBufferMap[uuid] = ib;
                return ib;
              }
              function getArrayBuffer(json, uuid) {
                if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
                var arrayBuffers = json.arrayBuffers;
                var arrayBuffer = arrayBuffers[uuid];
                var ab = new Uint32Array(arrayBuffer).buffer;
                arrayBufferMap[uuid] = ab;
                return ab;
              }
              var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
              var index = json.data.index;
              if (index !== undefined) {
                var typedArray = getTypedArray(index.type, index.array);
                geometry.setIndex(new BufferAttribute(typedArray, 1));
              }
              var attributes = json.data.attributes;
              for (var key in attributes) {
                var attribute = attributes[key];
                var bufferAttribute = void 0;
                if (attribute.isInterleavedBufferAttribute) {
                  var interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                  bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                  var _typedArray = getTypedArray(attribute.type, attribute.array);
                  var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                  bufferAttribute = new bufferAttributeConstr(_typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);
                geometry.setAttribute(key, bufferAttribute);
              }
              var morphAttributes = json.data.morphAttributes;
              if (morphAttributes) {
                for (var _key58 in morphAttributes) {
                  var attributeArray = morphAttributes[_key58];
                  var array = [];
                  for (var i = 0, il = attributeArray.length; i < il; i++) {
                    var _attribute3 = attributeArray[i];
                    var _bufferAttribute = void 0;
                    if (_attribute3.isInterleavedBufferAttribute) {
                      var _interleavedBuffer = getInterleavedBuffer(json.data, _attribute3.data);
                      _bufferAttribute = new InterleavedBufferAttribute(_interleavedBuffer, _attribute3.itemSize, _attribute3.offset, _attribute3.normalized);
                    } else {
                      var _typedArray2 = getTypedArray(_attribute3.type, _attribute3.array);
                      _bufferAttribute = new BufferAttribute(_typedArray2, _attribute3.itemSize, _attribute3.normalized);
                    }
                    if (_attribute3.name !== undefined) _bufferAttribute.name = _attribute3.name;
                    array.push(_bufferAttribute);
                  }
                  geometry.morphAttributes[_key58] = array;
                }
              }
              var morphTargetsRelative = json.data.morphTargetsRelative;
              if (morphTargetsRelative) {
                geometry.morphTargetsRelative = true;
              }
              var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
              if (groups !== undefined) {
                for (var _i103 = 0, n = groups.length; _i103 !== n; ++_i103) {
                  var group = groups[_i103];
                  geometry.addGroup(group.start, group.count, group.materialIndex);
                }
              }
              var boundingSphere = json.data.boundingSphere;
              if (boundingSphere !== undefined) {
                var center = new Vector3();
                if (boundingSphere.center !== undefined) {
                  center.fromArray(boundingSphere.center);
                }
                geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
              }
              if (json.name) geometry.name = json.name;
              if (json.userData) geometry.userData = json.userData;
              return geometry;
            }
          }]);
        }(Loader);
        var ObjectLoader = /*#__PURE__*/function (_Loader10) {
          function ObjectLoader(manager) {
            _classCallCheck2(this, ObjectLoader);
            return _callSuper(this, ObjectLoader, [manager]);
          }
          _inherits(ObjectLoader, _Loader10);
          return _createClass(ObjectLoader, [{
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
              var scope = this;
              var path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
              this.resourcePath = this.resourcePath || path;
              var loader = new FileLoader(this.manager);
              loader.setPath(this.path);
              loader.setRequestHeader(this.requestHeader);
              loader.setWithCredentials(this.withCredentials);
              loader.load(url, function (text) {
                var json = null;
                try {
                  json = JSON.parse(text);
                } catch (error) {
                  if (onError !== undefined) onError(error);
                  console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                  return;
                }
                var metadata = json.metadata;
                if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                  if (onError !== undefined) onError(new Error('THREE.ObjectLoader: Can\'t load ' + url));
                  console.error('THREE.ObjectLoader: Can\'t load ' + url);
                  return;
                }
                scope.parse(json, onLoad);
              }, onProgress, onError);
            }
          }, {
            key: "loadAsync",
            value: function () {
              var _loadAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(url, onProgress) {
                var scope, path, loader, text, json, metadata;
                return _regeneratorRuntime().wrap(function _callee8$(_context16) {
                  while (1) switch (_context16.prev = _context16.next) {
                    case 0:
                      scope = this;
                      path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
                      this.resourcePath = this.resourcePath || path;
                      loader = new FileLoader(this.manager);
                      loader.setPath(this.path);
                      loader.setRequestHeader(this.requestHeader);
                      loader.setWithCredentials(this.withCredentials);
                      _context16.next = 9;
                      return loader.loadAsync(url, onProgress);
                    case 9:
                      text = _context16.sent;
                      json = JSON.parse(text);
                      metadata = json.metadata;
                      if (!(metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry')) {
                        _context16.next = 14;
                        break;
                      }
                      throw new Error('THREE.ObjectLoader: Can\'t load ' + url);
                    case 14:
                      _context16.next = 16;
                      return scope.parseAsync(json);
                    case 16:
                      return _context16.abrupt("return", _context16.sent);
                    case 17:
                    case "end":
                      return _context16.stop();
                  }
                }, _callee8, this);
              }));
              function loadAsync(_x15, _x16) {
                return _loadAsync.apply(this, arguments);
              }
              return loadAsync;
            }()
          }, {
            key: "parse",
            value: function parse(json, onLoad) {
              var animations = this.parseAnimations(json.animations);
              var shapes = this.parseShapes(json.shapes);
              var geometries = this.parseGeometries(json.geometries, shapes);
              var images = this.parseImages(json.images, function () {
                if (onLoad !== undefined) onLoad(object);
              });
              var textures = this.parseTextures(json.textures, images);
              var materials = this.parseMaterials(json.materials, textures);
              var object = this.parseObject(json.object, geometries, materials, textures, animations);
              var skeletons = this.parseSkeletons(json.skeletons, object);
              this.bindSkeletons(object, skeletons);
              this.bindLightTargets(object);

              //

              if (onLoad !== undefined) {
                var hasImages = false;
                for (var uuid in images) {
                  if (images[uuid].data instanceof HTMLImageElement) {
                    hasImages = true;
                    break;
                  }
                }
                if (hasImages === false) onLoad(object);
              }
              return object;
            }
          }, {
            key: "parseAsync",
            value: function () {
              var _parseAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(json) {
                var animations, shapes, geometries, images, textures, materials, object, skeletons;
                return _regeneratorRuntime().wrap(function _callee9$(_context17) {
                  while (1) switch (_context17.prev = _context17.next) {
                    case 0:
                      animations = this.parseAnimations(json.animations);
                      shapes = this.parseShapes(json.shapes);
                      geometries = this.parseGeometries(json.geometries, shapes);
                      _context17.next = 5;
                      return this.parseImagesAsync(json.images);
                    case 5:
                      images = _context17.sent;
                      textures = this.parseTextures(json.textures, images);
                      materials = this.parseMaterials(json.materials, textures);
                      object = this.parseObject(json.object, geometries, materials, textures, animations);
                      skeletons = this.parseSkeletons(json.skeletons, object);
                      this.bindSkeletons(object, skeletons);
                      return _context17.abrupt("return", object);
                    case 12:
                    case "end":
                      return _context17.stop();
                  }
                }, _callee9, this);
              }));
              function parseAsync(_x17) {
                return _parseAsync.apply(this, arguments);
              }
              return parseAsync;
            }()
          }, {
            key: "parseShapes",
            value: function parseShapes(json) {
              var shapes = {};
              if (json !== undefined) {
                for (var i = 0, l = json.length; i < l; i++) {
                  var shape = new Shape().fromJSON(json[i]);
                  shapes[shape.uuid] = shape;
                }
              }
              return shapes;
            }
          }, {
            key: "parseSkeletons",
            value: function parseSkeletons(json, object) {
              var skeletons = {};
              var bones = {};

              // generate bone lookup table

              object.traverse(function (child) {
                if (child.isBone) bones[child.uuid] = child;
              });

              // create skeletons

              if (json !== undefined) {
                for (var i = 0, l = json.length; i < l; i++) {
                  var skeleton = new Skeleton().fromJSON(json[i], bones);
                  skeletons[skeleton.uuid] = skeleton;
                }
              }
              return skeletons;
            }
          }, {
            key: "parseGeometries",
            value: function parseGeometries(json, shapes) {
              var geometries = {};
              if (json !== undefined) {
                var bufferGeometryLoader = new BufferGeometryLoader();
                for (var i = 0, l = json.length; i < l; i++) {
                  var geometry = void 0;
                  var data = json[i];
                  switch (data.type) {
                    case 'BufferGeometry':
                    case 'InstancedBufferGeometry':
                      geometry = bufferGeometryLoader.parse(data);
                      break;
                    default:
                      if (data.type in Geometries) {
                        geometry = Geometries[data.type].fromJSON(data, shapes);
                      } else {
                        console.warn("THREE.ObjectLoader: Unsupported geometry type \"".concat(data.type, "\""));
                      }
                  }
                  geometry.uuid = data.uuid;
                  if (data.name !== undefined) geometry.name = data.name;
                  if (data.userData !== undefined) geometry.userData = data.userData;
                  geometries[data.uuid] = geometry;
                }
              }
              return geometries;
            }
          }, {
            key: "parseMaterials",
            value: function parseMaterials(json, textures) {
              var cache = {}; // MultiMaterial
              var materials = {};
              if (json !== undefined) {
                var loader = new MaterialLoader();
                loader.setTextures(textures);
                for (var i = 0, l = json.length; i < l; i++) {
                  var data = json[i];
                  if (cache[data.uuid] === undefined) {
                    cache[data.uuid] = loader.parse(data);
                  }
                  materials[data.uuid] = cache[data.uuid];
                }
              }
              return materials;
            }
          }, {
            key: "parseAnimations",
            value: function parseAnimations(json) {
              var animations = {};
              if (json !== undefined) {
                for (var i = 0; i < json.length; i++) {
                  var data = json[i];
                  var clip = AnimationClip.parse(data);
                  animations[clip.uuid] = clip;
                }
              }
              return animations;
            }
          }, {
            key: "parseImages",
            value: function parseImages(json, onLoad) {
              var scope = this;
              var images = {};
              var loader;
              function loadImage(url) {
                scope.manager.itemStart(url);
                return loader.load(url, function () {
                  scope.manager.itemEnd(url);
                }, undefined, function () {
                  scope.manager.itemError(url);
                  scope.manager.itemEnd(url);
                });
              }
              function deserializeImage(image) {
                if (typeof image === 'string') {
                  var url = image;
                  var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                  return loadImage(path);
                } else {
                  if (image.data) {
                    return {
                      data: getTypedArray(image.type, image.data),
                      width: image.width,
                      height: image.height
                    };
                  } else {
                    return null;
                  }
                }
              }
              if (json !== undefined && json.length > 0) {
                var manager = new LoadingManager(onLoad);
                loader = new ImageLoader(manager);
                loader.setCrossOrigin(this.crossOrigin);
                for (var i = 0, il = json.length; i < il; i++) {
                  var image = json[i];
                  var url = image.url;
                  if (Array.isArray(url)) {
                    // load array of images e.g CubeTexture

                    var imageArray = [];
                    for (var j = 0, jl = url.length; j < jl; j++) {
                      var currentUrl = url[j];
                      var deserializedImage = deserializeImage(currentUrl);
                      if (deserializedImage !== null) {
                        if (deserializedImage instanceof HTMLImageElement) {
                          imageArray.push(deserializedImage);
                        } else {
                          // special case: handle array of data textures for cube textures

                          imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                        }
                      }
                    }
                    images[image.uuid] = new Source(imageArray);
                  } else {
                    // load single image

                    var _deserializedImage = deserializeImage(image.url);
                    images[image.uuid] = new Source(_deserializedImage);
                  }
                }
              }
              return images;
            }
          }, {
            key: "parseImagesAsync",
            value: function () {
              var _parseImagesAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(json) {
                var scope, images, loader, deserializeImage, _deserializeImage, i, il, image, url, imageArray, j, jl, currentUrl, deserializedImage, _deserializedImage2;
                return _regeneratorRuntime().wrap(function _callee11$(_context19) {
                  while (1) switch (_context19.prev = _context19.next) {
                    case 0:
                      _deserializeImage = function _deserializeImage3() {
                        _deserializeImage = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(image) {
                          var _url, path;
                          return _regeneratorRuntime().wrap(function _callee10$(_context18) {
                            while (1) switch (_context18.prev = _context18.next) {
                              case 0:
                                if (!(typeof image === 'string')) {
                                  _context18.next = 8;
                                  break;
                                }
                                _url = image;
                                path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(_url) ? _url : scope.resourcePath + _url;
                                _context18.next = 5;
                                return loader.loadAsync(path);
                              case 5:
                                return _context18.abrupt("return", _context18.sent);
                              case 8:
                                if (!image.data) {
                                  _context18.next = 12;
                                  break;
                                }
                                return _context18.abrupt("return", {
                                  data: getTypedArray(image.type, image.data),
                                  width: image.width,
                                  height: image.height
                                });
                              case 12:
                                return _context18.abrupt("return", null);
                              case 13:
                              case "end":
                                return _context18.stop();
                            }
                          }, _callee10);
                        }));
                        return _deserializeImage.apply(this, arguments);
                      };
                      deserializeImage = function _deserializeImage2(_x19) {
                        return _deserializeImage.apply(this, arguments);
                      };
                      scope = this;
                      images = {};
                      if (!(json !== undefined && json.length > 0)) {
                        _context19.next = 33;
                        break;
                      }
                      loader = new ImageLoader(this.manager);
                      loader.setCrossOrigin(this.crossOrigin);
                      i = 0, il = json.length;
                    case 8:
                      if (!(i < il)) {
                        _context19.next = 33;
                        break;
                      }
                      image = json[i];
                      url = image.url;
                      if (!Array.isArray(url)) {
                        _context19.next = 26;
                        break;
                      }
                      // load array of images e.g CubeTexture
                      imageArray = [];
                      j = 0, jl = url.length;
                    case 14:
                      if (!(j < jl)) {
                        _context19.next = 23;
                        break;
                      }
                      currentUrl = url[j];
                      _context19.next = 18;
                      return deserializeImage(currentUrl);
                    case 18:
                      deserializedImage = _context19.sent;
                      if (deserializedImage !== null) {
                        if (deserializedImage instanceof HTMLImageElement) {
                          imageArray.push(deserializedImage);
                        } else {
                          // special case: handle array of data textures for cube textures

                          imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                        }
                      }
                    case 20:
                      j++;
                      _context19.next = 14;
                      break;
                    case 23:
                      images[image.uuid] = new Source(imageArray);
                      _context19.next = 30;
                      break;
                    case 26:
                      _context19.next = 28;
                      return deserializeImage(image.url);
                    case 28:
                      _deserializedImage2 = _context19.sent;
                      images[image.uuid] = new Source(_deserializedImage2);
                    case 30:
                      i++;
                      _context19.next = 8;
                      break;
                    case 33:
                      return _context19.abrupt("return", images);
                    case 34:
                    case "end":
                      return _context19.stop();
                  }
                }, _callee11, this);
              }));
              function parseImagesAsync(_x18) {
                return _parseImagesAsync.apply(this, arguments);
              }
              return parseImagesAsync;
            }()
          }, {
            key: "parseTextures",
            value: function parseTextures(json, images) {
              function parseConstant(value, type) {
                if (typeof value === 'number') return value;
                console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
                return type[value];
              }
              var textures = {};
              if (json !== undefined) {
                for (var i = 0, l = json.length; i < l; i++) {
                  var data = json[i];
                  if (data.image === undefined) {
                    console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
                  }
                  if (images[data.image] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined image', data.image);
                  }
                  var source = images[data.image];
                  var image = source.data;
                  var texture = void 0;
                  if (Array.isArray(image)) {
                    texture = new CubeTexture();
                    if (image.length === 6) texture.needsUpdate = true;
                  } else {
                    if (image && image.data) {
                      texture = new DataTexture();
                    } else {
                      texture = new Texture();
                    }
                    if (image) texture.needsUpdate = true; // textures can have undefined image data
                  }
                  texture.source = source;
                  texture.uuid = data.uuid;
                  if (data.name !== undefined) texture.name = data.name;
                  if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
                  if (data.channel !== undefined) texture.channel = data.channel;
                  if (data.offset !== undefined) texture.offset.fromArray(data.offset);
                  if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
                  if (data.center !== undefined) texture.center.fromArray(data.center);
                  if (data.rotation !== undefined) texture.rotation = data.rotation;
                  if (data.wrap !== undefined) {
                    texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                    texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
                  }
                  if (data.format !== undefined) texture.format = data.format;
                  if (data.internalFormat !== undefined) texture.internalFormat = data.internalFormat;
                  if (data.type !== undefined) texture.type = data.type;
                  if (data.colorSpace !== undefined) texture.colorSpace = data.colorSpace;
                  if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
                  if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
                  if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
                  if (data.flipY !== undefined) texture.flipY = data.flipY;
                  if (data.generateMipmaps !== undefined) texture.generateMipmaps = data.generateMipmaps;
                  if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
                  if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
                  if (data.compareFunction !== undefined) texture.compareFunction = data.compareFunction;
                  if (data.userData !== undefined) texture.userData = data.userData;
                  textures[data.uuid] = texture;
                }
              }
              return textures;
            }
          }, {
            key: "parseObject",
            value: function parseObject(data, geometries, materials, textures, animations) {
              var object;
              function getGeometry(name) {
                if (geometries[name] === undefined) {
                  console.warn('THREE.ObjectLoader: Undefined geometry', name);
                }
                return geometries[name];
              }
              function getMaterial(name) {
                if (name === undefined) return undefined;
                if (Array.isArray(name)) {
                  var array = [];
                  for (var i = 0, l = name.length; i < l; i++) {
                    var uuid = name[i];
                    if (materials[uuid] === undefined) {
                      console.warn('THREE.ObjectLoader: Undefined material', uuid);
                    }
                    array.push(materials[uuid]);
                  }
                  return array;
                }
                if (materials[name] === undefined) {
                  console.warn('THREE.ObjectLoader: Undefined material', name);
                }
                return materials[name];
              }
              function getTexture(uuid) {
                if (textures[uuid] === undefined) {
                  console.warn('THREE.ObjectLoader: Undefined texture', uuid);
                }
                return textures[uuid];
              }
              var geometry, material;
              switch (data.type) {
                case 'Scene':
                  object = new Scene();
                  if (data.background !== undefined) {
                    if (Number.isInteger(data.background)) {
                      object.background = new Color(data.background);
                    } else {
                      object.background = getTexture(data.background);
                    }
                  }
                  if (data.environment !== undefined) {
                    object.environment = getTexture(data.environment);
                  }
                  if (data.fog !== undefined) {
                    if (data.fog.type === 'Fog') {
                      object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                    } else if (data.fog.type === 'FogExp2') {
                      object.fog = new FogExp2(data.fog.color, data.fog.density);
                    }
                    if (data.fog.name !== '') {
                      object.fog.name = data.fog.name;
                    }
                  }
                  if (data.backgroundBlurriness !== undefined) object.backgroundBlurriness = data.backgroundBlurriness;
                  if (data.backgroundIntensity !== undefined) object.backgroundIntensity = data.backgroundIntensity;
                  if (data.backgroundRotation !== undefined) object.backgroundRotation.fromArray(data.backgroundRotation);
                  if (data.environmentIntensity !== undefined) object.environmentIntensity = data.environmentIntensity;
                  if (data.environmentRotation !== undefined) object.environmentRotation.fromArray(data.environmentRotation);
                  break;
                case 'PerspectiveCamera':
                  object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                  if (data.focus !== undefined) object.focus = data.focus;
                  if (data.zoom !== undefined) object.zoom = data.zoom;
                  if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                  if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                  if (data.view !== undefined) object.view = Object.assign({}, data.view);
                  break;
                case 'OrthographicCamera':
                  object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                  if (data.zoom !== undefined) object.zoom = data.zoom;
                  if (data.view !== undefined) object.view = Object.assign({}, data.view);
                  break;
                case 'AmbientLight':
                  object = new AmbientLight(data.color, data.intensity);
                  break;
                case 'DirectionalLight':
                  object = new DirectionalLight(data.color, data.intensity);
                  object.target = data.target || '';
                  break;
                case 'PointLight':
                  object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                  break;
                case 'RectAreaLight':
                  object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                  break;
                case 'SpotLight':
                  object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                  object.target = data.target || '';
                  break;
                case 'HemisphereLight':
                  object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                  break;
                case 'LightProbe':
                  object = new LightProbe().fromJSON(data);
                  break;
                case 'SkinnedMesh':
                  geometry = getGeometry(data.geometry);
                  material = getMaterial(data.material);
                  object = new SkinnedMesh(geometry, material);
                  if (data.bindMode !== undefined) object.bindMode = data.bindMode;
                  if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
                  if (data.skeleton !== undefined) object.skeleton = data.skeleton;
                  break;
                case 'Mesh':
                  geometry = getGeometry(data.geometry);
                  material = getMaterial(data.material);
                  object = new Mesh(geometry, material);
                  break;
                case 'InstancedMesh':
                  geometry = getGeometry(data.geometry);
                  material = getMaterial(data.material);
                  var count = data.count;
                  var instanceMatrix = data.instanceMatrix;
                  var instanceColor = data.instanceColor;
                  object = new InstancedMesh(geometry, material, count);
                  object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
                  if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
                  break;
                case 'BatchedMesh':
                  geometry = getGeometry(data.geometry);
                  material = getMaterial(data.material);
                  object = new BatchedMesh(data.maxInstanceCount, data.maxVertexCount, data.maxIndexCount, material);
                  object.geometry = geometry;
                  object.perObjectFrustumCulled = data.perObjectFrustumCulled;
                  object.sortObjects = data.sortObjects;
                  object._drawRanges = data.drawRanges;
                  object._reservedRanges = data.reservedRanges;
                  object._visibility = data.visibility;
                  object._active = data.active;
                  object._bounds = data.bounds.map(function (bound) {
                    var box = new Box3();
                    box.min.fromArray(bound.boxMin);
                    box.max.fromArray(bound.boxMax);
                    var sphere = new Sphere();
                    sphere.radius = bound.sphereRadius;
                    sphere.center.fromArray(bound.sphereCenter);
                    return {
                      boxInitialized: bound.boxInitialized,
                      box: box,
                      sphereInitialized: bound.sphereInitialized,
                      sphere: sphere
                    };
                  });
                  object._maxInstanceCount = data.maxInstanceCount;
                  object._maxVertexCount = data.maxVertexCount;
                  object._maxIndexCount = data.maxIndexCount;
                  object._geometryInitialized = data.geometryInitialized;
                  object._geometryCount = data.geometryCount;
                  object._matricesTexture = getTexture(data.matricesTexture.uuid);
                  if (data.colorsTexture !== undefined) object._colorsTexture = getTexture(data.colorsTexture.uuid);
                  break;
                case 'LOD':
                  object = new LOD();
                  break;
                case 'Line':
                  object = new Line(getGeometry(data.geometry), getMaterial(data.material));
                  break;
                case 'LineLoop':
                  object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                  break;
                case 'LineSegments':
                  object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                  break;
                case 'PointCloud':
                case 'Points':
                  object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                  break;
                case 'Sprite':
                  object = new Sprite(getMaterial(data.material));
                  break;
                case 'Group':
                  object = new Group();
                  break;
                case 'Bone':
                  object = new Bone();
                  break;
                default:
                  object = new Object3D();
              }
              object.uuid = data.uuid;
              if (data.name !== undefined) object.name = data.name;
              if (data.matrix !== undefined) {
                object.matrix.fromArray(data.matrix);
                if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
                if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
              } else {
                if (data.position !== undefined) object.position.fromArray(data.position);
                if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
                if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
                if (data.scale !== undefined) object.scale.fromArray(data.scale);
              }
              if (data.up !== undefined) object.up.fromArray(data.up);
              if (data.castShadow !== undefined) object.castShadow = data.castShadow;
              if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
              if (data.shadow) {
                if (data.shadow.intensity !== undefined) object.shadow.intensity = data.shadow.intensity;
                if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
                if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
                if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
                if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
                if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
              }
              if (data.visible !== undefined) object.visible = data.visible;
              if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
              if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
              if (data.userData !== undefined) object.userData = data.userData;
              if (data.layers !== undefined) object.layers.mask = data.layers;
              if (data.children !== undefined) {
                var children = data.children;
                for (var i = 0; i < children.length; i++) {
                  object.add(this.parseObject(children[i], geometries, materials, textures, animations));
                }
              }
              if (data.animations !== undefined) {
                var objectAnimations = data.animations;
                for (var _i104 = 0; _i104 < objectAnimations.length; _i104++) {
                  var uuid = objectAnimations[_i104];
                  object.animations.push(animations[uuid]);
                }
              }
              if (data.type === 'LOD') {
                if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
                var levels = data.levels;
                for (var l = 0; l < levels.length; l++) {
                  var level = levels[l];
                  var child = object.getObjectByProperty('uuid', level.object);
                  if (child !== undefined) {
                    object.addLevel(child, level.distance, level.hysteresis);
                  }
                }
              }
              return object;
            }
          }, {
            key: "bindSkeletons",
            value: function bindSkeletons(object, skeletons) {
              if (Object.keys(skeletons).length === 0) return;
              object.traverse(function (child) {
                if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
                  var skeleton = skeletons[child.skeleton];
                  if (skeleton === undefined) {
                    console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
                  } else {
                    child.bind(skeleton, child.bindMatrix);
                  }
                }
              });
            }
          }, {
            key: "bindLightTargets",
            value: function bindLightTargets(object) {
              object.traverse(function (child) {
                if (child.isDirectionalLight || child.isSpotLight) {
                  var uuid = child.target;
                  var _target3 = object.getObjectByProperty('uuid', uuid);
                  if (_target3 !== undefined) {
                    child.target = _target3;
                  } else {
                    child.target = new Object3D();
                  }
                }
              });
            }
          }]);
        }(Loader);
        var TEXTURE_MAPPING = {
          UVMapping: UVMapping,
          CubeReflectionMapping: CubeReflectionMapping,
          CubeRefractionMapping: CubeRefractionMapping,
          EquirectangularReflectionMapping: EquirectangularReflectionMapping,
          EquirectangularRefractionMapping: EquirectangularRefractionMapping,
          CubeUVReflectionMapping: CubeUVReflectionMapping
        };
        var TEXTURE_WRAPPING = {
          RepeatWrapping: RepeatWrapping,
          ClampToEdgeWrapping: ClampToEdgeWrapping,
          MirroredRepeatWrapping: MirroredRepeatWrapping
        };
        var TEXTURE_FILTER = {
          NearestFilter: NearestFilter,
          NearestMipmapNearestFilter: NearestMipmapNearestFilter,
          NearestMipmapLinearFilter: NearestMipmapLinearFilter,
          LinearFilter: LinearFilter,
          LinearMipmapNearestFilter: LinearMipmapNearestFilter,
          LinearMipmapLinearFilter: LinearMipmapLinearFilter
        };
        var ImageBitmapLoader = /*#__PURE__*/function (_Loader11) {
          function ImageBitmapLoader(manager) {
            var _this123;
            _classCallCheck2(this, ImageBitmapLoader);
            _this123 = _callSuper(this, ImageBitmapLoader, [manager]);
            _this123.isImageBitmapLoader = true;
            if (typeof createImageBitmap === 'undefined') {
              console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
            }
            if (typeof fetch === 'undefined') {
              console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
            }
            _this123.options = {
              premultiplyAlpha: 'none'
            };
            return _this123;
          }
          _inherits(ImageBitmapLoader, _Loader11);
          return _createClass(ImageBitmapLoader, [{
            key: "setOptions",
            value: function setOptions(options) {
              this.options = options;
              return this;
            }
          }, {
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
              if (url === undefined) url = '';
              if (this.path !== undefined) url = this.path + url;
              url = this.manager.resolveURL(url);
              var scope = this;
              var cached = Cache.get(url);
              if (cached !== undefined) {
                scope.manager.itemStart(url);

                // If cached is a promise, wait for it to resolve
                if (cached.then) {
                  cached.then(function (imageBitmap) {
                    if (onLoad) onLoad(imageBitmap);
                    scope.manager.itemEnd(url);
                  }).catch(function (e) {
                    if (onError) onError(e);
                  });
                  return;
                }

                // If cached is not a promise (i.e., it's already an imageBitmap)
                setTimeout(function () {
                  if (onLoad) onLoad(cached);
                  scope.manager.itemEnd(url);
                }, 0);
                return cached;
              }
              var fetchOptions = {};
              fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
              fetchOptions.headers = this.requestHeader;
              var promise = fetch(url, fetchOptions).then(function (res) {
                return res.blob();
              }).then(function (blob) {
                return createImageBitmap(blob, Object.assign(scope.options, {
                  colorSpaceConversion: 'none'
                }));
              }).then(function (imageBitmap) {
                Cache.add(url, imageBitmap);
                if (onLoad) onLoad(imageBitmap);
                scope.manager.itemEnd(url);
                return imageBitmap;
              }).catch(function (e) {
                if (onError) onError(e);
                Cache.remove(url);
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
              });
              Cache.add(url, promise);
              scope.manager.itemStart(url);
            }
          }]);
        }(Loader);
        var _context;
        var AudioContext = /*#__PURE__*/function () {
          function AudioContext() {
            _classCallCheck2(this, AudioContext);
          }
          return _createClass(AudioContext, null, [{
            key: "getContext",
            value: function getContext() {
              if (_context === undefined) {
                _context = new (window.AudioContext || window.webkitAudioContext)();
              }
              return _context;
            }
          }, {
            key: "setContext",
            value: function setContext(value) {
              _context = value;
            }
          }]);
        }();
        var AudioLoader = /*#__PURE__*/function (_Loader12) {
          function AudioLoader(manager) {
            _classCallCheck2(this, AudioLoader);
            return _callSuper(this, AudioLoader, [manager]);
          }
          _inherits(AudioLoader, _Loader12);
          return _createClass(AudioLoader, [{
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
              var scope = this;
              var loader = new FileLoader(this.manager);
              loader.setResponseType('arraybuffer');
              loader.setPath(this.path);
              loader.setRequestHeader(this.requestHeader);
              loader.setWithCredentials(this.withCredentials);
              loader.load(url, function (buffer) {
                try {
                  // Create a copy of the buffer. The `decodeAudioData` method
                  // detaches the buffer when complete, preventing reuse.
                  var bufferCopy = buffer.slice(0);
                  var context = AudioContext.getContext();
                  context.decodeAudioData(bufferCopy, function (audioBuffer) {
                    onLoad(audioBuffer);
                  }).catch(handleError);
                } catch (e) {
                  handleError(e);
                }
              }, onProgress, onError);
              function handleError(e) {
                if (onError) {
                  onError(e);
                } else {
                  console.error(e);
                }
                scope.manager.itemError(url);
              }
            }
          }]);
        }(Loader);
        var _eyeRight = /*@__PURE__*/new Matrix4();
        var _eyeLeft = /*@__PURE__*/new Matrix4();
        var _projectionMatrix = /*@__PURE__*/new Matrix4();
        var StereoCamera = /*#__PURE__*/function () {
          function StereoCamera() {
            _classCallCheck2(this, StereoCamera);
            this.type = 'StereoCamera';
            this.aspect = 1;
            this.eyeSep = 0.064;
            this.cameraL = new PerspectiveCamera();
            this.cameraL.layers.enable(1);
            this.cameraL.matrixAutoUpdate = false;
            this.cameraR = new PerspectiveCamera();
            this.cameraR.layers.enable(2);
            this.cameraR.matrixAutoUpdate = false;
            this._cache = {
              focus: null,
              fov: null,
              aspect: null,
              near: null,
              far: null,
              zoom: null,
              eyeSep: null
            };
          }
          return _createClass(StereoCamera, [{
            key: "update",
            value: function update(camera) {
              var cache = this._cache;
              var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
              if (needsUpdate) {
                cache.focus = camera.focus;
                cache.fov = camera.fov;
                cache.aspect = camera.aspect * this.aspect;
                cache.near = camera.near;
                cache.far = camera.far;
                cache.zoom = camera.zoom;
                cache.eyeSep = this.eyeSep;

                // Off-axis stereoscopic effect based on
                // http://paulbourke.net/stereographics/stereorender/

                _projectionMatrix.copy(camera.projectionMatrix);
                var eyeSepHalf = cache.eyeSep / 2;
                var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
                var ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
                var xmin, xmax;

                // translate xOffset

                _eyeLeft.elements[12] = -eyeSepHalf;
                _eyeRight.elements[12] = eyeSepHalf;

                // for left eye

                xmin = -ymax * cache.aspect + eyeSepOnProjection;
                xmax = ymax * cache.aspect + eyeSepOnProjection;
                _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
                _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraL.projectionMatrix.copy(_projectionMatrix);

                // for right eye

                xmin = -ymax * cache.aspect - eyeSepOnProjection;
                xmax = ymax * cache.aspect - eyeSepOnProjection;
                _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
                _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraR.projectionMatrix.copy(_projectionMatrix);
              }
              this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
              this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
            }
          }]);
        }();
        var Clock = /*#__PURE__*/function () {
          function Clock() {
            var autoStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            _classCallCheck2(this, Clock);
            this.autoStart = autoStart;
            this.startTime = 0;
            this.oldTime = 0;
            this.elapsedTime = 0;
            this.running = false;
          }
          return _createClass(Clock, [{
            key: "start",
            value: function start() {
              this.startTime = now();
              this.oldTime = this.startTime;
              this.elapsedTime = 0;
              this.running = true;
            }
          }, {
            key: "stop",
            value: function stop() {
              this.getElapsedTime();
              this.running = false;
              this.autoStart = false;
            }
          }, {
            key: "getElapsedTime",
            value: function getElapsedTime() {
              this.getDelta();
              return this.elapsedTime;
            }
          }, {
            key: "getDelta",
            value: function getDelta() {
              var diff = 0;
              if (this.autoStart && !this.running) {
                this.start();
                return 0;
              }
              if (this.running) {
                var newTime = now();
                diff = (newTime - this.oldTime) / 1000;
                this.oldTime = newTime;
                this.elapsedTime += diff;
              }
              return diff;
            }
          }]);
        }();
        function now() {
          return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
        }
        var _position$1 = /*@__PURE__*/new Vector3();
        var _quaternion$1 = /*@__PURE__*/new Quaternion();
        var _scale$1 = /*@__PURE__*/new Vector3();
        var _orientation$1 = /*@__PURE__*/new Vector3();
        var AudioListener = /*#__PURE__*/function (_Object3D12) {
          function AudioListener() {
            var _this124;
            _classCallCheck2(this, AudioListener);
            _this124 = _callSuper(this, AudioListener);
            _this124.type = 'AudioListener';
            _this124.context = AudioContext.getContext();
            _this124.gain = _this124.context.createGain();
            _this124.gain.connect(_this124.context.destination);
            _this124.filter = null;
            _this124.timeDelta = 0;

            // private

            _this124._clock = new Clock();
            return _this124;
          }
          _inherits(AudioListener, _Object3D12);
          return _createClass(AudioListener, [{
            key: "getInput",
            value: function getInput() {
              return this.gain;
            }
          }, {
            key: "removeFilter",
            value: function removeFilter() {
              if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
                this.gain.connect(this.context.destination);
                this.filter = null;
              }
              return this;
            }
          }, {
            key: "getFilter",
            value: function getFilter() {
              return this.filter;
            }
          }, {
            key: "setFilter",
            value: function setFilter(value) {
              if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
              } else {
                this.gain.disconnect(this.context.destination);
              }
              this.filter = value;
              this.gain.connect(this.filter);
              this.filter.connect(this.context.destination);
              return this;
            }
          }, {
            key: "getMasterVolume",
            value: function getMasterVolume() {
              return this.gain.gain.value;
            }
          }, {
            key: "setMasterVolume",
            value: function setMasterVolume(value) {
              this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
              return this;
            }
          }, {
            key: "updateMatrixWorld",
            value: function updateMatrixWorld(force) {
              _superPropGet(AudioListener, "updateMatrixWorld", this, 3)([force]);
              var listener = this.context.listener;
              var up = this.up;
              this.timeDelta = this._clock.getDelta();
              this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
              _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
              if (listener.positionX) {
                // code path for Chrome (see #14393)

                var endTime = this.context.currentTime + this.timeDelta;
                listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
                listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
                listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
                listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
                listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
                listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
                listener.upX.linearRampToValueAtTime(up.x, endTime);
                listener.upY.linearRampToValueAtTime(up.y, endTime);
                listener.upZ.linearRampToValueAtTime(up.z, endTime);
              } else {
                listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
                listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
              }
            }
          }]);
        }(Object3D);
        var Audio$1 = /*#__PURE__*/function (_Object3D13) {
          function Audio(listener) {
            var _this125;
            _classCallCheck2(this, Audio);
            _this125 = _callSuper(this, Audio);
            _this125.type = 'Audio';
            _this125.listener = listener;
            _this125.context = listener.context;
            _this125.gain = _this125.context.createGain();
            _this125.gain.connect(listener.getInput());
            _this125.autoplay = false;
            _this125.buffer = null;
            _this125.detune = 0;
            _this125.loop = false;
            _this125.loopStart = 0;
            _this125.loopEnd = 0;
            _this125.offset = 0;
            _this125.duration = undefined;
            _this125.playbackRate = 1;
            _this125.isPlaying = false;
            _this125.hasPlaybackControl = true;
            _this125.source = null;
            _this125.sourceType = 'empty';
            _this125._startedAt = 0;
            _this125._progress = 0;
            _this125._connected = false;
            _this125.filters = [];
            return _this125;
          }
          _inherits(Audio, _Object3D13);
          return _createClass(Audio, [{
            key: "getOutput",
            value: function getOutput() {
              return this.gain;
            }
          }, {
            key: "setNodeSource",
            value: function setNodeSource(audioNode) {
              this.hasPlaybackControl = false;
              this.sourceType = 'audioNode';
              this.source = audioNode;
              this.connect();
              return this;
            }
          }, {
            key: "setMediaElementSource",
            value: function setMediaElementSource(mediaElement) {
              this.hasPlaybackControl = false;
              this.sourceType = 'mediaNode';
              this.source = this.context.createMediaElementSource(mediaElement);
              this.connect();
              return this;
            }
          }, {
            key: "setMediaStreamSource",
            value: function setMediaStreamSource(mediaStream) {
              this.hasPlaybackControl = false;
              this.sourceType = 'mediaStreamNode';
              this.source = this.context.createMediaStreamSource(mediaStream);
              this.connect();
              return this;
            }
          }, {
            key: "setBuffer",
            value: function setBuffer(audioBuffer) {
              this.buffer = audioBuffer;
              this.sourceType = 'buffer';
              if (this.autoplay) this.play();
              return this;
            }
          }, {
            key: "play",
            value: function play() {
              var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              if (this.isPlaying === true) {
                console.warn('THREE.Audio: Audio is already playing.');
                return;
              }
              if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
              }
              this._startedAt = this.context.currentTime + delay;
              var source = this.context.createBufferSource();
              source.buffer = this.buffer;
              source.loop = this.loop;
              source.loopStart = this.loopStart;
              source.loopEnd = this.loopEnd;
              source.onended = this.onEnded.bind(this);
              source.start(this._startedAt, this._progress + this.offset, this.duration);
              this.isPlaying = true;
              this.source = source;
              this.setDetune(this.detune);
              this.setPlaybackRate(this.playbackRate);
              return this.connect();
            }
          }, {
            key: "pause",
            value: function pause() {
              if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
              }
              if (this.isPlaying === true) {
                // update current progress

                this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
                if (this.loop === true) {
                  // ensure _progress does not exceed duration with looped audios

                  this._progress = this._progress % (this.duration || this.buffer.duration);
                }
                this.source.stop();
                this.source.onended = null;
                this.isPlaying = false;
              }
              return this;
            }
          }, {
            key: "stop",
            value: function stop() {
              if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
              }
              this._progress = 0;
              if (this.source !== null) {
                this.source.stop();
                this.source.onended = null;
              }
              this.isPlaying = false;
              return this;
            }
          }, {
            key: "connect",
            value: function connect() {
              if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                  this.filters[i - 1].connect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].connect(this.getOutput());
              } else {
                this.source.connect(this.getOutput());
              }
              this._connected = true;
              return this;
            }
          }, {
            key: "disconnect",
            value: function disconnect() {
              if (this._connected === false) {
                return;
              }
              if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                  this.filters[i - 1].disconnect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
              } else {
                this.source.disconnect(this.getOutput());
              }
              this._connected = false;
              return this;
            }
          }, {
            key: "getFilters",
            value: function getFilters() {
              return this.filters;
            }
          }, {
            key: "setFilters",
            value: function setFilters(value) {
              if (!value) value = [];
              if (this._connected === true) {
                this.disconnect();
                this.filters = value.slice();
                this.connect();
              } else {
                this.filters = value.slice();
              }
              return this;
            }
          }, {
            key: "setDetune",
            value: function setDetune(value) {
              this.detune = value;
              if (this.isPlaying === true && this.source.detune !== undefined) {
                this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
              }
              return this;
            }
          }, {
            key: "getDetune",
            value: function getDetune() {
              return this.detune;
            }
          }, {
            key: "getFilter",
            value: function getFilter() {
              return this.getFilters()[0];
            }
          }, {
            key: "setFilter",
            value: function setFilter(filter) {
              return this.setFilters(filter ? [filter] : []);
            }
          }, {
            key: "setPlaybackRate",
            value: function setPlaybackRate(value) {
              if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
              }
              this.playbackRate = value;
              if (this.isPlaying === true) {
                this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
              }
              return this;
            }
          }, {
            key: "getPlaybackRate",
            value: function getPlaybackRate() {
              return this.playbackRate;
            }
          }, {
            key: "onEnded",
            value: function onEnded() {
              this.isPlaying = false;
            }
          }, {
            key: "getLoop",
            value: function getLoop() {
              if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return false;
              }
              return this.loop;
            }
          }, {
            key: "setLoop",
            value: function setLoop(value) {
              if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
              }
              this.loop = value;
              if (this.isPlaying === true) {
                this.source.loop = this.loop;
              }
              return this;
            }
          }, {
            key: "setLoopStart",
            value: function setLoopStart(value) {
              this.loopStart = value;
              return this;
            }
          }, {
            key: "setLoopEnd",
            value: function setLoopEnd(value) {
              this.loopEnd = value;
              return this;
            }
          }, {
            key: "getVolume",
            value: function getVolume() {
              return this.gain.gain.value;
            }
          }, {
            key: "setVolume",
            value: function setVolume(value) {
              this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
              return this;
            }
          }]);
        }(Object3D);
        var _position = /*@__PURE__*/new Vector3();
        var _quaternion = /*@__PURE__*/new Quaternion();
        var _scale = /*@__PURE__*/new Vector3();
        var _orientation = /*@__PURE__*/new Vector3();
        var PositionalAudio = /*#__PURE__*/function (_Audio$) {
          function PositionalAudio(listener) {
            var _this126;
            _classCallCheck2(this, PositionalAudio);
            _this126 = _callSuper(this, PositionalAudio, [listener]);
            _this126.panner = _this126.context.createPanner();
            _this126.panner.panningModel = 'HRTF';
            _this126.panner.connect(_this126.gain);
            return _this126;
          }
          _inherits(PositionalAudio, _Audio$);
          return _createClass(PositionalAudio, [{
            key: "connect",
            value: function connect() {
              _superPropGet(PositionalAudio, "connect", this, 3)([]);
              this.panner.connect(this.gain);
            }
          }, {
            key: "disconnect",
            value: function disconnect() {
              _superPropGet(PositionalAudio, "disconnect", this, 3)([]);
              this.panner.disconnect(this.gain);
            }
          }, {
            key: "getOutput",
            value: function getOutput() {
              return this.panner;
            }
          }, {
            key: "getRefDistance",
            value: function getRefDistance() {
              return this.panner.refDistance;
            }
          }, {
            key: "setRefDistance",
            value: function setRefDistance(value) {
              this.panner.refDistance = value;
              return this;
            }
          }, {
            key: "getRolloffFactor",
            value: function getRolloffFactor() {
              return this.panner.rolloffFactor;
            }
          }, {
            key: "setRolloffFactor",
            value: function setRolloffFactor(value) {
              this.panner.rolloffFactor = value;
              return this;
            }
          }, {
            key: "getDistanceModel",
            value: function getDistanceModel() {
              return this.panner.distanceModel;
            }
          }, {
            key: "setDistanceModel",
            value: function setDistanceModel(value) {
              this.panner.distanceModel = value;
              return this;
            }
          }, {
            key: "getMaxDistance",
            value: function getMaxDistance() {
              return this.panner.maxDistance;
            }
          }, {
            key: "setMaxDistance",
            value: function setMaxDistance(value) {
              this.panner.maxDistance = value;
              return this;
            }
          }, {
            key: "setDirectionalCone",
            value: function setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
              this.panner.coneInnerAngle = coneInnerAngle;
              this.panner.coneOuterAngle = coneOuterAngle;
              this.panner.coneOuterGain = coneOuterGain;
              return this;
            }
          }, {
            key: "updateMatrixWorld",
            value: function updateMatrixWorld(force) {
              _superPropGet(PositionalAudio, "updateMatrixWorld", this, 3)([force]);
              if (this.hasPlaybackControl === true && this.isPlaying === false) return;
              this.matrixWorld.decompose(_position, _quaternion, _scale);
              _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
              var panner = this.panner;
              if (panner.positionX) {
                // code path for Chrome and Firefox (see #14393)

                var endTime = this.context.currentTime + this.listener.timeDelta;
                panner.positionX.linearRampToValueAtTime(_position.x, endTime);
                panner.positionY.linearRampToValueAtTime(_position.y, endTime);
                panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
                panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
                panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
                panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
              } else {
                panner.setPosition(_position.x, _position.y, _position.z);
                panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
              }
            }
          }]);
        }(Audio$1);
        var AudioAnalyser = /*#__PURE__*/function () {
          function AudioAnalyser(audio) {
            var fftSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2048;
            _classCallCheck2(this, AudioAnalyser);
            this.analyser = audio.context.createAnalyser();
            this.analyser.fftSize = fftSize;
            this.data = new Uint8Array(this.analyser.frequencyBinCount);
            audio.getOutput().connect(this.analyser);
          }
          return _createClass(AudioAnalyser, [{
            key: "getFrequencyData",
            value: function getFrequencyData() {
              this.analyser.getByteFrequencyData(this.data);
              return this.data;
            }
          }, {
            key: "getAverageFrequency",
            value: function getAverageFrequency() {
              var value = 0;
              var data = this.getFrequencyData();
              for (var i = 0; i < data.length; i++) {
                value += data[i];
              }
              return value / data.length;
            }
          }]);
        }();
        var PropertyMixer = /*#__PURE__*/function () {
          function PropertyMixer(binding, typeName, valueSize) {
            _classCallCheck2(this, PropertyMixer);
            this.binding = binding;
            this.valueSize = valueSize;
            var mixFunction, mixFunctionAdditive, setIdentity;

            // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
            //
            // interpolators can use .buffer as their .result
            // the data then goes to 'incoming'
            //
            // 'accu0' and 'accu1' are used frame-interleaved for
            // the cumulative result and are compared to detect
            // changes
            //
            // 'orig' stores the original state of the property
            //
            // 'add' is used for additive cumulative results
            //
            // 'work' is optional and is only present for quaternion types. It is used
            // to store intermediate quaternion multiplication results

            switch (typeName) {
              case 'quaternion':
                mixFunction = this._slerp;
                mixFunctionAdditive = this._slerpAdditive;
                setIdentity = this._setAdditiveIdentityQuaternion;
                this.buffer = new Float64Array(valueSize * 6);
                this._workIndex = 5;
                break;
              case 'string':
              case 'bool':
                mixFunction = this._select;

                // Use the regular mix function and for additive on these types,
                // additive is not relevant for non-numeric types
                mixFunctionAdditive = this._select;
                setIdentity = this._setAdditiveIdentityOther;
                this.buffer = new Array(valueSize * 5);
                break;
              default:
                mixFunction = this._lerp;
                mixFunctionAdditive = this._lerpAdditive;
                setIdentity = this._setAdditiveIdentityNumeric;
                this.buffer = new Float64Array(valueSize * 5);
            }
            this._mixBufferRegion = mixFunction;
            this._mixBufferRegionAdditive = mixFunctionAdditive;
            this._setIdentity = setIdentity;
            this._origIndex = 3;
            this._addIndex = 4;
            this.cumulativeWeight = 0;
            this.cumulativeWeightAdditive = 0;
            this.useCount = 0;
            this.referenceCount = 0;
          }

          // accumulate data in the 'incoming' region into 'accu<i>'
          return _createClass(PropertyMixer, [{
            key: "accumulate",
            value: function accumulate(accuIndex, weight) {
              // note: happily accumulating nothing when weight = 0, the caller knows
              // the weight and shouldn't have made the call in the first place

              var buffer = this.buffer,
                stride = this.valueSize,
                offset = accuIndex * stride + stride;
              var currentWeight = this.cumulativeWeight;
              if (currentWeight === 0) {
                // accuN := incoming * weight

                for (var i = 0; i !== stride; ++i) {
                  buffer[offset + i] = buffer[i];
                }
                currentWeight = weight;
              } else {
                // accuN := accuN + incoming * weight

                currentWeight += weight;
                var mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
              }
              this.cumulativeWeight = currentWeight;
            }

            // accumulate data in the 'incoming' region into 'add'
          }, {
            key: "accumulateAdditive",
            value: function accumulateAdditive(weight) {
              var buffer = this.buffer,
                stride = this.valueSize,
                offset = stride * this._addIndex;
              if (this.cumulativeWeightAdditive === 0) {
                // add = identity

                this._setIdentity();
              }

              // add := add + incoming * weight

              this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
              this.cumulativeWeightAdditive += weight;
            }

            // apply the state of 'accu<i>' to the binding when accus differ
          }, {
            key: "apply",
            value: function apply(accuIndex) {
              var stride = this.valueSize,
                buffer = this.buffer,
                offset = accuIndex * stride + stride,
                weight = this.cumulativeWeight,
                weightAdditive = this.cumulativeWeightAdditive,
                binding = this.binding;
              this.cumulativeWeight = 0;
              this.cumulativeWeightAdditive = 0;
              if (weight < 1) {
                // accuN := accuN + original * ( 1 - cumulativeWeight )

                var originalValueOffset = stride * this._origIndex;
                this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
              }
              if (weightAdditive > 0) {
                // accuN := accuN + additive accuN

                this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
              }
              for (var i = stride, e = stride + stride; i !== e; ++i) {
                if (buffer[i] !== buffer[i + stride]) {
                  // value has changed -> update scene graph

                  binding.setValue(buffer, offset);
                  break;
                }
              }
            }

            // remember the state of the bound property and copy it to both accus
          }, {
            key: "saveOriginalState",
            value: function saveOriginalState() {
              var binding = this.binding;
              var buffer = this.buffer,
                stride = this.valueSize,
                originalValueOffset = stride * this._origIndex;
              binding.getValue(buffer, originalValueOffset);

              // accu[0..1] := orig -- initially detect changes against the original
              for (var i = stride, e = originalValueOffset; i !== e; ++i) {
                buffer[i] = buffer[originalValueOffset + i % stride];
              }

              // Add to identity for additive
              this._setIdentity();
              this.cumulativeWeight = 0;
              this.cumulativeWeightAdditive = 0;
            }

            // apply the state previously taken via 'saveOriginalState' to the binding
          }, {
            key: "restoreOriginalState",
            value: function restoreOriginalState() {
              var originalValueOffset = this.valueSize * 3;
              this.binding.setValue(this.buffer, originalValueOffset);
            }
          }, {
            key: "_setAdditiveIdentityNumeric",
            value: function _setAdditiveIdentityNumeric() {
              var startIndex = this._addIndex * this.valueSize;
              var endIndex = startIndex + this.valueSize;
              for (var i = startIndex; i < endIndex; i++) {
                this.buffer[i] = 0;
              }
            }
          }, {
            key: "_setAdditiveIdentityQuaternion",
            value: function _setAdditiveIdentityQuaternion() {
              this._setAdditiveIdentityNumeric();
              this.buffer[this._addIndex * this.valueSize + 3] = 1;
            }
          }, {
            key: "_setAdditiveIdentityOther",
            value: function _setAdditiveIdentityOther() {
              var startIndex = this._origIndex * this.valueSize;
              var targetIndex = this._addIndex * this.valueSize;
              for (var i = 0; i < this.valueSize; i++) {
                this.buffer[targetIndex + i] = this.buffer[startIndex + i];
              }
            }

            // mix functions
          }, {
            key: "_select",
            value: function _select(buffer, dstOffset, srcOffset, t, stride) {
              if (t >= 0.5) {
                for (var i = 0; i !== stride; ++i) {
                  buffer[dstOffset + i] = buffer[srcOffset + i];
                }
              }
            }
          }, {
            key: "_slerp",
            value: function _slerp(buffer, dstOffset, srcOffset, t) {
              Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
            }
          }, {
            key: "_slerpAdditive",
            value: function _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
              var workOffset = this._workIndex * stride;

              // Store result in intermediate buffer offset
              Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);

              // Slerp to the intermediate result
              Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
            }
          }, {
            key: "_lerp",
            value: function _lerp(buffer, dstOffset, srcOffset, t, stride) {
              var s = 1 - t;
              for (var i = 0; i !== stride; ++i) {
                var j = dstOffset + i;
                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
              }
            }
          }, {
            key: "_lerpAdditive",
            value: function _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
              for (var i = 0; i !== stride; ++i) {
                var j = dstOffset + i;
                buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
              }
            }
          }]);
        }(); // Characters [].:/ are reserved for track binding syntax.
        var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
        var _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');

        // Attempts to allow node names from any language. ES5's `\w` regexp matches
        // only latin characters, and the unicode \p{L} is not yet supported. So
        // instead, we exclude reserved characters and match everything else.
        var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
        var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';

        // Parent directories, delimited by '/' or ':'. Currently unused, but must
        // be matched to parse the rest of the track name.
        var _directoryRe = /*@__PURE__*//((?:WC+[\/:])*)/.source.replace('WC', _wordChar);

        // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
        var _nodeRe = /*@__PURE__*//(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);

        // Object on target node, and accessor. May not contain reserved
        // characters. Accessor may contain any character except closing bracket.
        var _objectRe = /*@__PURE__*//(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);

        // Property and accessor. May not contain reserved characters. Accessor may
        // contain any non-bracket characters.
        var _propertyRe = /*@__PURE__*//\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
        var _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');
        var _supportedObjectNames = ['material', 'materials', 'bones', 'map'];
        var Composite = /*#__PURE__*/function () {
          function Composite(targetGroup, path, optionalParsedPath) {
            _classCallCheck2(this, Composite);
            var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
            this._targetGroup = targetGroup;
            this._bindings = targetGroup.subscribe_(path, parsedPath);
          }
          return _createClass(Composite, [{
            key: "getValue",
            value: function getValue(array, offset) {
              this.bind(); // bind all binding

              var firstValidIndex = this._targetGroup.nCachedObjects_,
                binding = this._bindings[firstValidIndex];

              // and only call .getValue on the first
              if (binding !== undefined) binding.getValue(array, offset);
            }
          }, {
            key: "setValue",
            value: function setValue(array, offset) {
              var bindings = this._bindings;
              for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].setValue(array, offset);
              }
            }
          }, {
            key: "bind",
            value: function bind() {
              var bindings = this._bindings;
              for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].bind();
              }
            }
          }, {
            key: "unbind",
            value: function unbind() {
              var bindings = this._bindings;
              for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].unbind();
              }
            }
          }]);
        }(); // Note: This class uses a State pattern on a per-method basis:
        // 'bind' sets 'this.getValue' / 'setValue' and shadows the
        // prototype version of these methods with one that represents
        // the bound state. When the property is not found, the methods
        // become no-ops.
        var PropertyBinding = /*#__PURE__*/function () {
          function PropertyBinding(rootNode, path, parsedPath) {
            _classCallCheck2(this, PropertyBinding);
            this.path = path;
            this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
            this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
            this.rootNode = rootNode;

            // initial state of these methods that calls 'bind'
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound;
          }
          return _createClass(PropertyBinding, [{
            key: "_getValue_unavailable",
            value:
            // these are used to "bind" a nonexistent property
            function _getValue_unavailable() {}
          }, {
            key: "_setValue_unavailable",
            value: function _setValue_unavailable() {}

            // Getters
          }, {
            key: "_getValue_direct",
            value: function _getValue_direct(buffer, offset) {
              buffer[offset] = this.targetObject[this.propertyName];
            }
          }, {
            key: "_getValue_array",
            value: function _getValue_array(buffer, offset) {
              var source = this.resolvedProperty;
              for (var i = 0, n = source.length; i !== n; ++i) {
                buffer[offset++] = source[i];
              }
            }
          }, {
            key: "_getValue_arrayElement",
            value: function _getValue_arrayElement(buffer, offset) {
              buffer[offset] = this.resolvedProperty[this.propertyIndex];
            }
          }, {
            key: "_getValue_toArray",
            value: function _getValue_toArray(buffer, offset) {
              this.resolvedProperty.toArray(buffer, offset);
            }

            // Direct
          }, {
            key: "_setValue_direct",
            value: function _setValue_direct(buffer, offset) {
              this.targetObject[this.propertyName] = buffer[offset];
            }
          }, {
            key: "_setValue_direct_setNeedsUpdate",
            value: function _setValue_direct_setNeedsUpdate(buffer, offset) {
              this.targetObject[this.propertyName] = buffer[offset];
              this.targetObject.needsUpdate = true;
            }
          }, {
            key: "_setValue_direct_setMatrixWorldNeedsUpdate",
            value: function _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
              this.targetObject[this.propertyName] = buffer[offset];
              this.targetObject.matrixWorldNeedsUpdate = true;
            }

            // EntireArray
          }, {
            key: "_setValue_array",
            value: function _setValue_array(buffer, offset) {
              var dest = this.resolvedProperty;
              for (var i = 0, n = dest.length; i !== n; ++i) {
                dest[i] = buffer[offset++];
              }
            }
          }, {
            key: "_setValue_array_setNeedsUpdate",
            value: function _setValue_array_setNeedsUpdate(buffer, offset) {
              var dest = this.resolvedProperty;
              for (var i = 0, n = dest.length; i !== n; ++i) {
                dest[i] = buffer[offset++];
              }
              this.targetObject.needsUpdate = true;
            }
          }, {
            key: "_setValue_array_setMatrixWorldNeedsUpdate",
            value: function _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
              var dest = this.resolvedProperty;
              for (var i = 0, n = dest.length; i !== n; ++i) {
                dest[i] = buffer[offset++];
              }
              this.targetObject.matrixWorldNeedsUpdate = true;
            }

            // ArrayElement
          }, {
            key: "_setValue_arrayElement",
            value: function _setValue_arrayElement(buffer, offset) {
              this.resolvedProperty[this.propertyIndex] = buffer[offset];
            }
          }, {
            key: "_setValue_arrayElement_setNeedsUpdate",
            value: function _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
              this.resolvedProperty[this.propertyIndex] = buffer[offset];
              this.targetObject.needsUpdate = true;
            }
          }, {
            key: "_setValue_arrayElement_setMatrixWorldNeedsUpdate",
            value: function _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
              this.resolvedProperty[this.propertyIndex] = buffer[offset];
              this.targetObject.matrixWorldNeedsUpdate = true;
            }

            // HasToFromArray
          }, {
            key: "_setValue_fromArray",
            value: function _setValue_fromArray(buffer, offset) {
              this.resolvedProperty.fromArray(buffer, offset);
            }
          }, {
            key: "_setValue_fromArray_setNeedsUpdate",
            value: function _setValue_fromArray_setNeedsUpdate(buffer, offset) {
              this.resolvedProperty.fromArray(buffer, offset);
              this.targetObject.needsUpdate = true;
            }
          }, {
            key: "_setValue_fromArray_setMatrixWorldNeedsUpdate",
            value: function _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
              this.resolvedProperty.fromArray(buffer, offset);
              this.targetObject.matrixWorldNeedsUpdate = true;
            }
          }, {
            key: "_getValue_unbound",
            value: function _getValue_unbound(targetArray, offset) {
              this.bind();
              this.getValue(targetArray, offset);
            }
          }, {
            key: "_setValue_unbound",
            value: function _setValue_unbound(sourceArray, offset) {
              this.bind();
              this.setValue(sourceArray, offset);
            }

            // create getter / setter pair for a property in the scene graph
          }, {
            key: "bind",
            value: function bind() {
              var targetObject = this.node;
              var parsedPath = this.parsedPath;
              var objectName = parsedPath.objectName;
              var propertyName = parsedPath.propertyName;
              var propertyIndex = parsedPath.propertyIndex;
              if (!targetObject) {
                targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
                this.node = targetObject;
              }

              // set fail state so we can just 'return' on error
              this.getValue = this._getValue_unavailable;
              this.setValue = this._setValue_unavailable;

              // ensure there is a value node
              if (!targetObject) {
                console.warn('THREE.PropertyBinding: No target node found for track: ' + this.path + '.');
                return;
              }
              if (objectName) {
                var objectIndex = parsedPath.objectIndex;

                // special cases were we need to reach deeper into the hierarchy to get the face materials....
                switch (objectName) {
                  case 'materials':
                    if (!targetObject.material) {
                      console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                      return;
                    }
                    if (!targetObject.material.materials) {
                      console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                      return;
                    }
                    targetObject = targetObject.material.materials;
                    break;
                  case 'bones':
                    if (!targetObject.skeleton) {
                      console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                      return;
                    }

                    // potential future optimization: skip this if propertyIndex is already an integer
                    // and convert the integer string to a true integer.

                    targetObject = targetObject.skeleton.bones;

                    // support resolving morphTarget names into indices.
                    for (var i = 0; i < targetObject.length; i++) {
                      if (targetObject[i].name === objectIndex) {
                        objectIndex = i;
                        break;
                      }
                    }
                    break;
                  case 'map':
                    if ('map' in targetObject) {
                      targetObject = targetObject.map;
                      break;
                    }
                    if (!targetObject.material) {
                      console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                      return;
                    }
                    if (!targetObject.material.map) {
                      console.error('THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this);
                      return;
                    }
                    targetObject = targetObject.material.map;
                    break;
                  default:
                    if (targetObject[objectName] === undefined) {
                      console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                      return;
                    }
                    targetObject = targetObject[objectName];
                }
                if (objectIndex !== undefined) {
                  if (targetObject[objectIndex] === undefined) {
                    console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                    return;
                  }
                  targetObject = targetObject[objectIndex];
                }
              }

              // resolve property
              var nodeProperty = targetObject[propertyName];
              if (nodeProperty === undefined) {
                var nodeName = parsedPath.nodeName;
                console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
                return;
              }

              // determine versioning scheme
              var versioning = this.Versioning.None;
              this.targetObject = targetObject;
              if (targetObject.needsUpdate !== undefined) {
                // material

                versioning = this.Versioning.NeedsUpdate;
              } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
                // node transform

                versioning = this.Versioning.MatrixWorldNeedsUpdate;
              }

              // determine how the property gets bound
              var bindingType = this.BindingType.Direct;
              if (propertyIndex !== undefined) {
                // access a sub element of the property array (only primitives are supported right now)

                if (propertyName === 'morphTargetInfluences') {
                  // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

                  // support resolving morphTarget names into indices.
                  if (!targetObject.geometry) {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                    return;
                  }
                  if (!targetObject.geometry.morphAttributes) {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                    return;
                  }
                  if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
                    propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                  }
                }
                bindingType = this.BindingType.ArrayElement;
                this.resolvedProperty = nodeProperty;
                this.propertyIndex = propertyIndex;
              } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
                // must use copy for Object3D.Euler/Quaternion

                bindingType = this.BindingType.HasFromToArray;
                this.resolvedProperty = nodeProperty;
              } else if (Array.isArray(nodeProperty)) {
                bindingType = this.BindingType.EntireArray;
                this.resolvedProperty = nodeProperty;
              } else {
                this.propertyName = propertyName;
              }

              // select getter / setter
              this.getValue = this.GetterByBindingType[bindingType];
              this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
            }
          }, {
            key: "unbind",
            value: function unbind() {
              this.node = null;

              // back to the prototype version of getValue / setValue
              // note: avoiding to mutate the shape of 'this' via 'delete'
              this.getValue = this._getValue_unbound;
              this.setValue = this._setValue_unbound;
            }
          }], [{
            key: "create",
            value: function create(root, path, parsedPath) {
              if (!(root && root.isAnimationObjectGroup)) {
                return new PropertyBinding(root, path, parsedPath);
              } else {
                return new PropertyBinding.Composite(root, path, parsedPath);
              }
            }

            /**
             * Replaces spaces with underscores and removes unsupported characters from
             * node names, to ensure compatibility with parseTrackName().
             *
             * @param {string} name Node name to be sanitized.
             * @return {string}
             */
          }, {
            key: "sanitizeNodeName",
            value: function sanitizeNodeName(name) {
              return name.replace(/\s/g, '_').replace(_reservedRe, '');
            }
          }, {
            key: "parseTrackName",
            value: function parseTrackName(trackName) {
              var matches = _trackRe.exec(trackName);
              if (matches === null) {
                throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
              }
              var results = {
                // directoryName: matches[ 1 ], // (tschw) currently unused
                nodeName: matches[2],
                objectName: matches[3],
                objectIndex: matches[4],
                propertyName: matches[5],
                // required
                propertyIndex: matches[6]
              };
              var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
              if (lastDot !== undefined && lastDot !== -1) {
                var objectName = results.nodeName.substring(lastDot + 1);

                // Object names must be checked against an allowlist. Otherwise, there
                // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
                // 'bar' could be the objectName, or part of a nodeName (which can
                // include '.' characters).
                if (_supportedObjectNames.indexOf(objectName) !== -1) {
                  results.nodeName = results.nodeName.substring(0, lastDot);
                  results.objectName = objectName;
                }
              }
              if (results.propertyName === null || results.propertyName.length === 0) {
                throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
              }
              return results;
            }
          }, {
            key: "findNode",
            value: function findNode(root, nodeName) {
              if (nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
                return root;
              }

              // search into skeleton bones.
              if (root.skeleton) {
                var bone = root.skeleton.getBoneByName(nodeName);
                if (bone !== undefined) {
                  return bone;
                }
              }

              // search into node subtree.
              if (root.children) {
                var _searchNodeSubtree = function searchNodeSubtree(children) {
                  for (var i = 0; i < children.length; i++) {
                    var childNode = children[i];
                    if (childNode.name === nodeName || childNode.uuid === nodeName) {
                      return childNode;
                    }
                    var result = _searchNodeSubtree(childNode.children);
                    if (result) return result;
                  }
                  return null;
                };
                var subTreeNode = _searchNodeSubtree(root.children);
                if (subTreeNode) {
                  return subTreeNode;
                }
              }
              return null;
            }
          }]);
        }();
        PropertyBinding.Composite = Composite;
        PropertyBinding.prototype.BindingType = {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3
        };
        PropertyBinding.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2
        };
        PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
        PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[
        // Direct
        PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [
        // EntireArray

        PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [
        // ArrayElement
        PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [
        // HasToFromArray
        PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

        /**
         *
         * A group of objects that receives a shared animation state.
         *
         * Usage:
         *
         *  - Add objects you would otherwise pass as 'root' to the
         *    constructor or the .clipAction method of AnimationMixer.
         *
         *  - Instead pass this object as 'root'.
         *
         *  - You can also add and remove objects later when the mixer
         *    is running.
         *
         * Note:
         *
         *    Objects of this class appear as one object to the mixer,
         *    so cache control of the individual objects must be done
         *    on the group.
         *
         * Limitation:
         *
         *  - The animated properties must be compatible among the
         *    all objects in the group.
         *
         *  - A single property can either be controlled through a
         *    target group or directly, but not both.
         */
        var AnimationObjectGroup = /*#__PURE__*/function () {
          function AnimationObjectGroup() {
            _classCallCheck2(this, AnimationObjectGroup);
            this.isAnimationObjectGroup = true;
            this.uuid = generateUUID();

            // cached objects followed by the active ones
            this._objects = Array.prototype.slice.call(arguments);
            this.nCachedObjects_ = 0; // threshold
            // note: read by PropertyBinding.Composite

            var indices = {};
            this._indicesByUUID = indices; // for bookkeeping

            for (var i = 0, n = arguments.length; i !== n; ++i) {
              indices[arguments[i].uuid] = i;
            }
            this._paths = []; // inside: string
            this._parsedPaths = []; // inside: { we don't care, here }
            this._bindings = []; // inside: Array< PropertyBinding >
            this._bindingsIndicesByPath = {}; // inside: indices in these arrays

            var scope = this;
            this.stats = {
              objects: {
                get total() {
                  return scope._objects.length;
                },
                get inUse() {
                  return this.total - scope.nCachedObjects_;
                }
              },
              get bindingsPerObject() {
                return scope._bindings.length;
              }
            };
          }
          return _createClass(AnimationObjectGroup, [{
            key: "add",
            value: function add() {
              var objects = this._objects,
                indicesByUUID = this._indicesByUUID,
                paths = this._paths,
                parsedPaths = this._parsedPaths,
                bindings = this._bindings,
                nBindings = bindings.length;
              var knownObject = undefined,
                nObjects = objects.length,
                nCachedObjects = this.nCachedObjects_;
              for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i],
                  uuid = object.uuid;
                var _index15 = indicesByUUID[uuid];
                if (_index15 === undefined) {
                  // unknown object -> add it to the ACTIVE region

                  _index15 = nObjects++;
                  indicesByUUID[uuid] = _index15;
                  objects.push(object);

                  // accounting is done, now do the same for all bindings

                  for (var j = 0, _m11 = nBindings; j !== _m11; ++j) {
                    bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                  }
                } else if (_index15 < nCachedObjects) {
                  knownObject = objects[_index15];

                  // move existing object to the ACTIVE region

                  var firstActiveIndex = --nCachedObjects,
                    lastCachedObject = objects[firstActiveIndex];
                  indicesByUUID[lastCachedObject.uuid] = _index15;
                  objects[_index15] = lastCachedObject;
                  indicesByUUID[uuid] = firstActiveIndex;
                  objects[firstActiveIndex] = object;

                  // accounting is done, now do the same for all bindings

                  for (var _j16 = 0, _m12 = nBindings; _j16 !== _m12; ++_j16) {
                    var bindingsForPath = bindings[_j16],
                      lastCached = bindingsForPath[firstActiveIndex];
                    var binding = bindingsForPath[_index15];
                    bindingsForPath[_index15] = lastCached;
                    if (binding === undefined) {
                      // since we do not bother to create new bindings
                      // for objects that are cached, the binding may
                      // or may not exist

                      binding = new PropertyBinding(object, paths[_j16], parsedPaths[_j16]);
                    }
                    bindingsForPath[firstActiveIndex] = binding;
                  }
                } else if (objects[_index15] !== knownObject) {
                  console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
                } // else the object is already where we want it to be
              } // for arguments

              this.nCachedObjects_ = nCachedObjects;
            }
          }, {
            key: "remove",
            value: function remove() {
              var objects = this._objects,
                indicesByUUID = this._indicesByUUID,
                bindings = this._bindings,
                nBindings = bindings.length;
              var nCachedObjects = this.nCachedObjects_;
              for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i],
                  uuid = object.uuid,
                  _index16 = indicesByUUID[uuid];
                if (_index16 !== undefined && _index16 >= nCachedObjects) {
                  // move existing object into the CACHED region

                  var lastCachedIndex = nCachedObjects++,
                    firstActiveObject = objects[lastCachedIndex];
                  indicesByUUID[firstActiveObject.uuid] = _index16;
                  objects[_index16] = firstActiveObject;
                  indicesByUUID[uuid] = lastCachedIndex;
                  objects[lastCachedIndex] = object;

                  // accounting is done, now do the same for all bindings

                  for (var j = 0, _m13 = nBindings; j !== _m13; ++j) {
                    var bindingsForPath = bindings[j],
                      firstActive = bindingsForPath[lastCachedIndex],
                      binding = bindingsForPath[_index16];
                    bindingsForPath[_index16] = firstActive;
                    bindingsForPath[lastCachedIndex] = binding;
                  }
                }
              } // for arguments

              this.nCachedObjects_ = nCachedObjects;
            }

            // remove & forget
          }, {
            key: "uncache",
            value: function uncache() {
              var objects = this._objects,
                indicesByUUID = this._indicesByUUID,
                bindings = this._bindings,
                nBindings = bindings.length;
              var nCachedObjects = this.nCachedObjects_,
                nObjects = objects.length;
              for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i],
                  uuid = object.uuid,
                  _index17 = indicesByUUID[uuid];
                if (_index17 !== undefined) {
                  delete indicesByUUID[uuid];
                  if (_index17 < nCachedObjects) {
                    // object is cached, shrink the CACHED region

                    var firstActiveIndex = --nCachedObjects,
                      lastCachedObject = objects[firstActiveIndex],
                      lastIndex = --nObjects,
                      lastObject = objects[lastIndex];

                    // last cached object takes this object's place
                    indicesByUUID[lastCachedObject.uuid] = _index17;
                    objects[_index17] = lastCachedObject;

                    // last object goes to the activated slot and pop
                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = lastObject;
                    objects.pop();

                    // accounting is done, now do the same for all bindings

                    for (var j = 0, _m14 = nBindings; j !== _m14; ++j) {
                      var bindingsForPath = bindings[j],
                        lastCached = bindingsForPath[firstActiveIndex],
                        last = bindingsForPath[lastIndex];
                      bindingsForPath[_index17] = lastCached;
                      bindingsForPath[firstActiveIndex] = last;
                      bindingsForPath.pop();
                    }
                  } else {
                    // object is active, just swap with the last and pop

                    var _lastIndex = --nObjects,
                      _lastObject = objects[_lastIndex];
                    if (_lastIndex > 0) {
                      indicesByUUID[_lastObject.uuid] = _index17;
                    }
                    objects[_index17] = _lastObject;
                    objects.pop();

                    // accounting is done, now do the same for all bindings

                    for (var _j17 = 0, _m15 = nBindings; _j17 !== _m15; ++_j17) {
                      var _bindingsForPath = bindings[_j17];
                      _bindingsForPath[_index17] = _bindingsForPath[_lastIndex];
                      _bindingsForPath.pop();
                    }
                  } // cached or active
                } // if object is known
              } // for arguments

              this.nCachedObjects_ = nCachedObjects;
            }

            // Internal interface used by befriended PropertyBinding.Composite:
          }, {
            key: "subscribe_",
            value: function subscribe_(path, parsedPath) {
              // returns an array of bindings for the given path that is changed
              // according to the contained objects in the group

              var indicesByPath = this._bindingsIndicesByPath;
              var index = indicesByPath[path];
              var bindings = this._bindings;
              if (index !== undefined) return bindings[index];
              var paths = this._paths,
                parsedPaths = this._parsedPaths,
                objects = this._objects,
                nObjects = objects.length,
                nCachedObjects = this.nCachedObjects_,
                bindingsForPath = new Array(nObjects);
              index = bindings.length;
              indicesByPath[path] = index;
              paths.push(path);
              parsedPaths.push(parsedPath);
              bindings.push(bindingsForPath);
              for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                var object = objects[i];
                bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
              }
              return bindingsForPath;
            }
          }, {
            key: "unsubscribe_",
            value: function unsubscribe_(path) {
              // tells the group to forget about a property path and no longer
              // update the array previously obtained with 'subscribe_'

              var indicesByPath = this._bindingsIndicesByPath,
                index = indicesByPath[path];
              if (index !== undefined) {
                var paths = this._paths,
                  parsedPaths = this._parsedPaths,
                  bindings = this._bindings,
                  lastBindingsIndex = bindings.length - 1,
                  lastBindings = bindings[lastBindingsIndex],
                  lastBindingsPath = path[lastBindingsIndex];
                indicesByPath[lastBindingsPath] = index;
                bindings[index] = lastBindings;
                bindings.pop();
                parsedPaths[index] = parsedPaths[lastBindingsIndex];
                parsedPaths.pop();
                paths[index] = paths[lastBindingsIndex];
                paths.pop();
              }
            }
          }]);
        }();
        var AnimationAction = /*#__PURE__*/function () {
          function AnimationAction(mixer, clip) {
            var localRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            var blendMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : clip.blendMode;
            _classCallCheck2(this, AnimationAction);
            this._mixer = mixer;
            this._clip = clip;
            this._localRoot = localRoot;
            this.blendMode = blendMode;
            var tracks = clip.tracks,
              nTracks = tracks.length,
              interpolants = new Array(nTracks);
            var interpolantSettings = {
              endingStart: ZeroCurvatureEnding,
              endingEnd: ZeroCurvatureEnding
            };
            for (var i = 0; i !== nTracks; ++i) {
              var interpolant = tracks[i].createInterpolant(null);
              interpolants[i] = interpolant;
              interpolant.settings = interpolantSettings;
            }
            this._interpolantSettings = interpolantSettings;
            this._interpolants = interpolants; // bound by the mixer

            // inside: PropertyMixer (managed by the mixer)
            this._propertyBindings = new Array(nTracks);
            this._cacheIndex = null; // for the memory manager
            this._byClipCacheIndex = null; // for the memory manager

            this._timeScaleInterpolant = null;
            this._weightInterpolant = null;
            this.loop = LoopRepeat;
            this._loopCount = -1;

            // global mixer time when the action is to be started
            // it's set back to 'null' upon start of the action
            this._startTime = null;

            // scaled local time of the action
            // gets clamped or wrapped to 0..clip.duration according to loop
            this.time = 0;
            this.timeScale = 1;
            this._effectiveTimeScale = 1;
            this.weight = 1;
            this._effectiveWeight = 1;
            this.repetitions = Infinity; // no. of repetitions when looping

            this.paused = false; // true -> zero effective time scale
            this.enabled = true; // false -> zero effective weight

            this.clampWhenFinished = false; // keep feeding the last frame?

            this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
            this.zeroSlopeAtEnd = true; // clips for start, loop and end
          }

          // State & Scheduling
          return _createClass(AnimationAction, [{
            key: "play",
            value: function play() {
              this._mixer._activateAction(this);
              return this;
            }
          }, {
            key: "stop",
            value: function stop() {
              this._mixer._deactivateAction(this);
              return this.reset();
            }
          }, {
            key: "reset",
            value: function reset() {
              this.paused = false;
              this.enabled = true;
              this.time = 0; // restart clip
              this._loopCount = -1; // forget previous loops
              this._startTime = null; // forget scheduling

              return this.stopFading().stopWarping();
            }
          }, {
            key: "isRunning",
            value: function isRunning() {
              return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
            }

            // return true when play has been called
          }, {
            key: "isScheduled",
            value: function isScheduled() {
              return this._mixer._isActiveAction(this);
            }
          }, {
            key: "startAt",
            value: function startAt(time) {
              this._startTime = time;
              return this;
            }
          }, {
            key: "setLoop",
            value: function setLoop(mode, repetitions) {
              this.loop = mode;
              this.repetitions = repetitions;
              return this;
            }

            // Weight

            // set the weight stopping any scheduled fading
            // although .enabled = false yields an effective weight of zero, this
            // method does *not* change .enabled, because it would be confusing
          }, {
            key: "setEffectiveWeight",
            value: function setEffectiveWeight(weight) {
              this.weight = weight;

              // note: same logic as when updated at runtime
              this._effectiveWeight = this.enabled ? weight : 0;
              return this.stopFading();
            }

            // return the weight considering fading and .enabled
          }, {
            key: "getEffectiveWeight",
            value: function getEffectiveWeight() {
              return this._effectiveWeight;
            }
          }, {
            key: "fadeIn",
            value: function fadeIn(duration) {
              return this._scheduleFading(duration, 0, 1);
            }
          }, {
            key: "fadeOut",
            value: function fadeOut(duration) {
              return this._scheduleFading(duration, 1, 0);
            }
          }, {
            key: "crossFadeFrom",
            value: function crossFadeFrom(fadeOutAction, duration, warp) {
              fadeOutAction.fadeOut(duration);
              this.fadeIn(duration);
              if (warp) {
                var fadeInDuration = this._clip.duration,
                  fadeOutDuration = fadeOutAction._clip.duration,
                  startEndRatio = fadeOutDuration / fadeInDuration,
                  endStartRatio = fadeInDuration / fadeOutDuration;
                fadeOutAction.warp(1.0, startEndRatio, duration);
                this.warp(endStartRatio, 1.0, duration);
              }
              return this;
            }
          }, {
            key: "crossFadeTo",
            value: function crossFadeTo(fadeInAction, duration, warp) {
              return fadeInAction.crossFadeFrom(this, duration, warp);
            }
          }, {
            key: "stopFading",
            value: function stopFading() {
              var weightInterpolant = this._weightInterpolant;
              if (weightInterpolant !== null) {
                this._weightInterpolant = null;
                this._mixer._takeBackControlInterpolant(weightInterpolant);
              }
              return this;
            }

            // Time Scale Control

            // set the time scale stopping any scheduled warping
            // although .paused = true yields an effective time scale of zero, this
            // method does *not* change .paused, because it would be confusing
          }, {
            key: "setEffectiveTimeScale",
            value: function setEffectiveTimeScale(timeScale) {
              this.timeScale = timeScale;
              this._effectiveTimeScale = this.paused ? 0 : timeScale;
              return this.stopWarping();
            }

            // return the time scale considering warping and .paused
          }, {
            key: "getEffectiveTimeScale",
            value: function getEffectiveTimeScale() {
              return this._effectiveTimeScale;
            }
          }, {
            key: "setDuration",
            value: function setDuration(duration) {
              this.timeScale = this._clip.duration / duration;
              return this.stopWarping();
            }
          }, {
            key: "syncWith",
            value: function syncWith(action) {
              this.time = action.time;
              this.timeScale = action.timeScale;
              return this.stopWarping();
            }
          }, {
            key: "halt",
            value: function halt(duration) {
              return this.warp(this._effectiveTimeScale, 0, duration);
            }
          }, {
            key: "warp",
            value: function warp(startTimeScale, endTimeScale, duration) {
              var mixer = this._mixer,
                now = mixer.time,
                timeScale = this.timeScale;
              var interpolant = this._timeScaleInterpolant;
              if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._timeScaleInterpolant = interpolant;
              }
              var times = interpolant.parameterPositions,
                values = interpolant.sampleValues;
              times[0] = now;
              times[1] = now + duration;
              values[0] = startTimeScale / timeScale;
              values[1] = endTimeScale / timeScale;
              return this;
            }
          }, {
            key: "stopWarping",
            value: function stopWarping() {
              var timeScaleInterpolant = this._timeScaleInterpolant;
              if (timeScaleInterpolant !== null) {
                this._timeScaleInterpolant = null;
                this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
              }
              return this;
            }

            // Object Accessors
          }, {
            key: "getMixer",
            value: function getMixer() {
              return this._mixer;
            }
          }, {
            key: "getClip",
            value: function getClip() {
              return this._clip;
            }
          }, {
            key: "getRoot",
            value: function getRoot() {
              return this._localRoot || this._mixer._root;
            }

            // Interna
          }, {
            key: "_update",
            value: function _update(time, deltaTime, timeDirection, accuIndex) {
              // called by the mixer

              if (!this.enabled) {
                // call ._updateWeight() to update ._effectiveWeight

                this._updateWeight(time);
                return;
              }
              var startTime = this._startTime;
              if (startTime !== null) {
                // check for scheduled start of action

                var timeRunning = (time - startTime) * timeDirection;
                if (timeRunning < 0 || timeDirection === 0) {
                  deltaTime = 0;
                } else {
                  this._startTime = null; // unschedule
                  deltaTime = timeDirection * timeRunning;
                }
              }

              // apply time scale and advance time

              deltaTime *= this._updateTimeScale(time);
              var clipTime = this._updateTime(deltaTime);

              // note: _updateTime may disable the action resulting in
              // an effective weight of 0

              var weight = this._updateWeight(time);
              if (weight > 0) {
                var interpolants = this._interpolants;
                var propertyMixers = this._propertyBindings;
                switch (this.blendMode) {
                  case AdditiveAnimationBlendMode:
                    for (var j = 0, _m16 = interpolants.length; j !== _m16; ++j) {
                      interpolants[j].evaluate(clipTime);
                      propertyMixers[j].accumulateAdditive(weight);
                    }
                    break;
                  case NormalAnimationBlendMode:
                  default:
                    for (var _j18 = 0, _m17 = interpolants.length; _j18 !== _m17; ++_j18) {
                      interpolants[_j18].evaluate(clipTime);
                      propertyMixers[_j18].accumulate(accuIndex, weight);
                    }
                }
              }
            }
          }, {
            key: "_updateWeight",
            value: function _updateWeight(time) {
              var weight = 0;
              if (this.enabled) {
                weight = this.weight;
                var interpolant = this._weightInterpolant;
                if (interpolant !== null) {
                  var interpolantValue = interpolant.evaluate(time)[0];
                  weight *= interpolantValue;
                  if (time > interpolant.parameterPositions[1]) {
                    this.stopFading();
                    if (interpolantValue === 0) {
                      // faded out, disable
                      this.enabled = false;
                    }
                  }
                }
              }
              this._effectiveWeight = weight;
              return weight;
            }
          }, {
            key: "_updateTimeScale",
            value: function _updateTimeScale(time) {
              var timeScale = 0;
              if (!this.paused) {
                timeScale = this.timeScale;
                var interpolant = this._timeScaleInterpolant;
                if (interpolant !== null) {
                  var interpolantValue = interpolant.evaluate(time)[0];
                  timeScale *= interpolantValue;
                  if (time > interpolant.parameterPositions[1]) {
                    this.stopWarping();
                    if (timeScale === 0) {
                      // motion has halted, pause
                      this.paused = true;
                    } else {
                      // warp done - apply final time scale
                      this.timeScale = timeScale;
                    }
                  }
                }
              }
              this._effectiveTimeScale = timeScale;
              return timeScale;
            }
          }, {
            key: "_updateTime",
            value: function _updateTime(deltaTime) {
              var duration = this._clip.duration;
              var loop = this.loop;
              var time = this.time + deltaTime;
              var loopCount = this._loopCount;
              var pingPong = loop === LoopPingPong;
              if (deltaTime === 0) {
                if (loopCount === -1) return time;
                return pingPong && (loopCount & 1) === 1 ? duration - time : time;
              }
              if (loop === LoopOnce) {
                if (loopCount === -1) {
                  // just started

                  this._loopCount = 0;
                  this._setEndings(true, true, false);
                }
                handle_stop: {
                  if (time >= duration) {
                    time = duration;
                  } else if (time < 0) {
                    time = 0;
                  } else {
                    this.time = time;
                    break handle_stop;
                  }
                  if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
                  this.time = time;
                  this._mixer.dispatchEvent({
                    type: 'finished',
                    action: this,
                    direction: deltaTime < 0 ? -1 : 1
                  });
                }
              } else {
                // repetitive Repeat or PingPong

                if (loopCount === -1) {
                  // just started

                  if (deltaTime >= 0) {
                    loopCount = 0;
                    this._setEndings(true, this.repetitions === 0, pingPong);
                  } else {
                    // when looping in reverse direction, the initial
                    // transition through zero counts as a repetition,
                    // so leave loopCount at -1

                    this._setEndings(this.repetitions === 0, true, pingPong);
                  }
                }
                if (time >= duration || time < 0) {
                  // wrap around

                  var loopDelta = Math.floor(time / duration); // signed
                  time -= duration * loopDelta;
                  loopCount += Math.abs(loopDelta);
                  var pending = this.repetitions - loopCount;
                  if (pending <= 0) {
                    // have to stop (switch state, clamp time, fire event)

                    if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
                    time = deltaTime > 0 ? duration : 0;
                    this.time = time;
                    this._mixer.dispatchEvent({
                      type: 'finished',
                      action: this,
                      direction: deltaTime > 0 ? 1 : -1
                    });
                  } else {
                    // keep running

                    if (pending === 1) {
                      // entering the last round

                      var atStart = deltaTime < 0;
                      this._setEndings(atStart, !atStart, pingPong);
                    } else {
                      this._setEndings(false, false, pingPong);
                    }
                    this._loopCount = loopCount;
                    this.time = time;
                    this._mixer.dispatchEvent({
                      type: 'loop',
                      action: this,
                      loopDelta: loopDelta
                    });
                  }
                } else {
                  this.time = time;
                }
                if (pingPong && (loopCount & 1) === 1) {
                  // invert time for the "pong round"

                  return duration - time;
                }
              }
              return time;
            }
          }, {
            key: "_setEndings",
            value: function _setEndings(atStart, atEnd, pingPong) {
              var settings = this._interpolantSettings;
              if (pingPong) {
                settings.endingStart = ZeroSlopeEnding;
                settings.endingEnd = ZeroSlopeEnding;
              } else {
                // assuming for LoopOnce atStart == atEnd == true

                if (atStart) {
                  settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {
                  settings.endingStart = WrapAroundEnding;
                }
                if (atEnd) {
                  settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {
                  settings.endingEnd = WrapAroundEnding;
                }
              }
            }
          }, {
            key: "_scheduleFading",
            value: function _scheduleFading(duration, weightNow, weightThen) {
              var mixer = this._mixer,
                now = mixer.time;
              var interpolant = this._weightInterpolant;
              if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._weightInterpolant = interpolant;
              }
              var times = interpolant.parameterPositions,
                values = interpolant.sampleValues;
              times[0] = now;
              values[0] = weightNow;
              times[1] = now + duration;
              values[1] = weightThen;
              return this;
            }
          }]);
        }();
        var _controlInterpolantsResultBuffer = new Float32Array(1);
        var AnimationMixer = /*#__PURE__*/function (_EventDispatcher7) {
          function AnimationMixer(root) {
            var _this127;
            _classCallCheck2(this, AnimationMixer);
            _this127 = _callSuper(this, AnimationMixer);
            _this127._root = root;
            _this127._initMemoryManager();
            _this127._accuIndex = 0;
            _this127.time = 0;
            _this127.timeScale = 1.0;
            return _this127;
          }
          _inherits(AnimationMixer, _EventDispatcher7);
          return _createClass(AnimationMixer, [{
            key: "_bindAction",
            value: function _bindAction(action, prototypeAction) {
              var root = action._localRoot || this._root,
                tracks = action._clip.tracks,
                nTracks = tracks.length,
                bindings = action._propertyBindings,
                interpolants = action._interpolants,
                rootUuid = root.uuid,
                bindingsByRoot = this._bindingsByRootAndName;
              var bindingsByName = bindingsByRoot[rootUuid];
              if (bindingsByName === undefined) {
                bindingsByName = {};
                bindingsByRoot[rootUuid] = bindingsByName;
              }
              for (var i = 0; i !== nTracks; ++i) {
                var _track3 = tracks[i],
                  trackName = _track3.name;
                var binding = bindingsByName[trackName];
                if (binding !== undefined) {
                  ++binding.referenceCount;
                  bindings[i] = binding;
                } else {
                  binding = bindings[i];
                  if (binding !== undefined) {
                    // existing binding, make sure the cache knows

                    if (binding._cacheIndex === null) {
                      ++binding.referenceCount;
                      this._addInactiveBinding(binding, rootUuid, trackName);
                    }
                    continue;
                  }
                  var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                  binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), _track3.ValueTypeName, _track3.getValueSize());
                  ++binding.referenceCount;
                  this._addInactiveBinding(binding, rootUuid, trackName);
                  bindings[i] = binding;
                }
                interpolants[i].resultBuffer = binding.buffer;
              }
            }
          }, {
            key: "_activateAction",
            value: function _activateAction(action) {
              if (!this._isActiveAction(action)) {
                if (action._cacheIndex === null) {
                  // this action has been forgotten by the cache, but the user
                  // appears to be still using it -> rebind

                  var rootUuid = (action._localRoot || this._root).uuid,
                    clipUuid = action._clip.uuid,
                    actionsForClip = this._actionsByClip[clipUuid];
                  this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                  this._addInactiveAction(action, clipUuid, rootUuid);
                }
                var bindings = action._propertyBindings;

                // increment reference counts / sort out state
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                  var binding = bindings[i];
                  if (binding.useCount++ === 0) {
                    this._lendBinding(binding);
                    binding.saveOriginalState();
                  }
                }
                this._lendAction(action);
              }
            }
          }, {
            key: "_deactivateAction",
            value: function _deactivateAction(action) {
              if (this._isActiveAction(action)) {
                var bindings = action._propertyBindings;

                // decrement reference counts / sort out state
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                  var binding = bindings[i];
                  if (--binding.useCount === 0) {
                    binding.restoreOriginalState();
                    this._takeBackBinding(binding);
                  }
                }
                this._takeBackAction(action);
              }
            }

            // Memory manager
          }, {
            key: "_initMemoryManager",
            value: function _initMemoryManager() {
              this._actions = []; // 'nActiveActions' followed by inactive ones
              this._nActiveActions = 0;
              this._actionsByClip = {};
              // inside:
              // {
              // 	knownActions: Array< AnimationAction > - used as prototypes
              // 	actionByRoot: AnimationAction - lookup
              // }

              this._bindings = []; // 'nActiveBindings' followed by inactive ones
              this._nActiveBindings = 0;
              this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

              this._controlInterpolants = []; // same game as above
              this._nActiveControlInterpolants = 0;
              var scope = this;
              this.stats = {
                actions: {
                  get total() {
                    return scope._actions.length;
                  },
                  get inUse() {
                    return scope._nActiveActions;
                  }
                },
                bindings: {
                  get total() {
                    return scope._bindings.length;
                  },
                  get inUse() {
                    return scope._nActiveBindings;
                  }
                },
                controlInterpolants: {
                  get total() {
                    return scope._controlInterpolants.length;
                  },
                  get inUse() {
                    return scope._nActiveControlInterpolants;
                  }
                }
              };
            }

            // Memory management for AnimationAction objects
          }, {
            key: "_isActiveAction",
            value: function _isActiveAction(action) {
              var index = action._cacheIndex;
              return index !== null && index < this._nActiveActions;
            }
          }, {
            key: "_addInactiveAction",
            value: function _addInactiveAction(action, clipUuid, rootUuid) {
              var actions = this._actions,
                actionsByClip = this._actionsByClip;
              var actionsForClip = actionsByClip[clipUuid];
              if (actionsForClip === undefined) {
                actionsForClip = {
                  knownActions: [action],
                  actionByRoot: {}
                };
                action._byClipCacheIndex = 0;
                actionsByClip[clipUuid] = actionsForClip;
              } else {
                var knownActions = actionsForClip.knownActions;
                action._byClipCacheIndex = knownActions.length;
                knownActions.push(action);
              }
              action._cacheIndex = actions.length;
              actions.push(action);
              actionsForClip.actionByRoot[rootUuid] = action;
            }
          }, {
            key: "_removeInactiveAction",
            value: function _removeInactiveAction(action) {
              var actions = this._actions,
                lastInactiveAction = actions[actions.length - 1],
                cacheIndex = action._cacheIndex;
              lastInactiveAction._cacheIndex = cacheIndex;
              actions[cacheIndex] = lastInactiveAction;
              actions.pop();
              action._cacheIndex = null;
              var clipUuid = action._clip.uuid,
                actionsByClip = this._actionsByClip,
                actionsForClip = actionsByClip[clipUuid],
                knownActionsForClip = actionsForClip.knownActions,
                lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
                byClipCacheIndex = action._byClipCacheIndex;
              lastKnownAction._byClipCacheIndex = byClipCacheIndex;
              knownActionsForClip[byClipCacheIndex] = lastKnownAction;
              knownActionsForClip.pop();
              action._byClipCacheIndex = null;
              var actionByRoot = actionsForClip.actionByRoot,
                rootUuid = (action._localRoot || this._root).uuid;
              delete actionByRoot[rootUuid];
              if (knownActionsForClip.length === 0) {
                delete actionsByClip[clipUuid];
              }
              this._removeInactiveBindingsForAction(action);
            }
          }, {
            key: "_removeInactiveBindingsForAction",
            value: function _removeInactiveBindingsForAction(action) {
              var bindings = action._propertyBindings;
              for (var i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                if (--binding.referenceCount === 0) {
                  this._removeInactiveBinding(binding);
                }
              }
            }
          }, {
            key: "_lendAction",
            value: function _lendAction(action) {
              // [ active actions |  inactive actions  ]
              // [  active actions >| inactive actions ]
              //                 s        a
              //                  <-swap->
              //                 a        s

              var actions = this._actions,
                prevIndex = action._cacheIndex,
                lastActiveIndex = this._nActiveActions++,
                firstInactiveAction = actions[lastActiveIndex];
              action._cacheIndex = lastActiveIndex;
              actions[lastActiveIndex] = action;
              firstInactiveAction._cacheIndex = prevIndex;
              actions[prevIndex] = firstInactiveAction;
            }
          }, {
            key: "_takeBackAction",
            value: function _takeBackAction(action) {
              // [  active actions  | inactive actions ]
              // [ active actions |< inactive actions  ]
              //        a        s
              //         <-swap->
              //        s        a

              var actions = this._actions,
                prevIndex = action._cacheIndex,
                firstInactiveIndex = --this._nActiveActions,
                lastActiveAction = actions[firstInactiveIndex];
              action._cacheIndex = firstInactiveIndex;
              actions[firstInactiveIndex] = action;
              lastActiveAction._cacheIndex = prevIndex;
              actions[prevIndex] = lastActiveAction;
            }

            // Memory management for PropertyMixer objects
          }, {
            key: "_addInactiveBinding",
            value: function _addInactiveBinding(binding, rootUuid, trackName) {
              var bindingsByRoot = this._bindingsByRootAndName,
                bindings = this._bindings;
              var bindingByName = bindingsByRoot[rootUuid];
              if (bindingByName === undefined) {
                bindingByName = {};
                bindingsByRoot[rootUuid] = bindingByName;
              }
              bindingByName[trackName] = binding;
              binding._cacheIndex = bindings.length;
              bindings.push(binding);
            }
          }, {
            key: "_removeInactiveBinding",
            value: function _removeInactiveBinding(binding) {
              var bindings = this._bindings,
                propBinding = binding.binding,
                rootUuid = propBinding.rootNode.uuid,
                trackName = propBinding.path,
                bindingsByRoot = this._bindingsByRootAndName,
                bindingByName = bindingsByRoot[rootUuid],
                lastInactiveBinding = bindings[bindings.length - 1],
                cacheIndex = binding._cacheIndex;
              lastInactiveBinding._cacheIndex = cacheIndex;
              bindings[cacheIndex] = lastInactiveBinding;
              bindings.pop();
              delete bindingByName[trackName];
              if (Object.keys(bindingByName).length === 0) {
                delete bindingsByRoot[rootUuid];
              }
            }
          }, {
            key: "_lendBinding",
            value: function _lendBinding(binding) {
              var bindings = this._bindings,
                prevIndex = binding._cacheIndex,
                lastActiveIndex = this._nActiveBindings++,
                firstInactiveBinding = bindings[lastActiveIndex];
              binding._cacheIndex = lastActiveIndex;
              bindings[lastActiveIndex] = binding;
              firstInactiveBinding._cacheIndex = prevIndex;
              bindings[prevIndex] = firstInactiveBinding;
            }
          }, {
            key: "_takeBackBinding",
            value: function _takeBackBinding(binding) {
              var bindings = this._bindings,
                prevIndex = binding._cacheIndex,
                firstInactiveIndex = --this._nActiveBindings,
                lastActiveBinding = bindings[firstInactiveIndex];
              binding._cacheIndex = firstInactiveIndex;
              bindings[firstInactiveIndex] = binding;
              lastActiveBinding._cacheIndex = prevIndex;
              bindings[prevIndex] = lastActiveBinding;
            }

            // Memory management of Interpolants for weight and time scale
          }, {
            key: "_lendControlInterpolant",
            value: function _lendControlInterpolant() {
              var interpolants = this._controlInterpolants,
                lastActiveIndex = this._nActiveControlInterpolants++;
              var interpolant = interpolants[lastActiveIndex];
              if (interpolant === undefined) {
                interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, _controlInterpolantsResultBuffer);
                interpolant.__cacheIndex = lastActiveIndex;
                interpolants[lastActiveIndex] = interpolant;
              }
              return interpolant;
            }
          }, {
            key: "_takeBackControlInterpolant",
            value: function _takeBackControlInterpolant(interpolant) {
              var interpolants = this._controlInterpolants,
                prevIndex = interpolant.__cacheIndex,
                firstInactiveIndex = --this._nActiveControlInterpolants,
                lastActiveInterpolant = interpolants[firstInactiveIndex];
              interpolant.__cacheIndex = firstInactiveIndex;
              interpolants[firstInactiveIndex] = interpolant;
              lastActiveInterpolant.__cacheIndex = prevIndex;
              interpolants[prevIndex] = lastActiveInterpolant;
            }

            // return an action for a clip optionally using a custom root target
            // object (this method allocates a lot of dynamic memory in case a
            // previously unknown clip/root combination is specified)
          }, {
            key: "clipAction",
            value: function clipAction(clip, optionalRoot, blendMode) {
              var root = optionalRoot || this._root,
                rootUuid = root.uuid;
              var clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
              var clipUuid = clipObject !== null ? clipObject.uuid : clip;
              var actionsForClip = this._actionsByClip[clipUuid];
              var prototypeAction = null;
              if (blendMode === undefined) {
                if (clipObject !== null) {
                  blendMode = clipObject.blendMode;
                } else {
                  blendMode = NormalAnimationBlendMode;
                }
              }
              if (actionsForClip !== undefined) {
                var existingAction = actionsForClip.actionByRoot[rootUuid];
                if (existingAction !== undefined && existingAction.blendMode === blendMode) {
                  return existingAction;
                }

                // we know the clip, so we don't have to parse all
                // the bindings again but can just copy
                prototypeAction = actionsForClip.knownActions[0];

                // also, take the clip from the prototype action
                if (clipObject === null) clipObject = prototypeAction._clip;
              }

              // clip must be known when specified via string
              if (clipObject === null) return null;

              // allocate all resources required to run it
              var newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
              this._bindAction(newAction, prototypeAction);

              // and make the action known to the memory manager
              this._addInactiveAction(newAction, clipUuid, rootUuid);
              return newAction;
            }

            // get an existing action
          }, {
            key: "existingAction",
            value: function existingAction(clip, optionalRoot) {
              var root = optionalRoot || this._root,
                rootUuid = root.uuid,
                clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
                clipUuid = clipObject ? clipObject.uuid : clip,
                actionsForClip = this._actionsByClip[clipUuid];
              if (actionsForClip !== undefined) {
                return actionsForClip.actionByRoot[rootUuid] || null;
              }
              return null;
            }

            // deactivates all previously scheduled actions
          }, {
            key: "stopAllAction",
            value: function stopAllAction() {
              var actions = this._actions,
                nActions = this._nActiveActions;
              for (var i = nActions - 1; i >= 0; --i) {
                actions[i].stop();
              }
              return this;
            }

            // advance the time and update apply the animation
          }, {
            key: "update",
            value: function update(deltaTime) {
              deltaTime *= this.timeScale;
              var actions = this._actions,
                nActions = this._nActiveActions,
                time = this.time += deltaTime,
                timeDirection = Math.sign(deltaTime),
                accuIndex = this._accuIndex ^= 1;

              // run active actions

              for (var i = 0; i !== nActions; ++i) {
                var action = actions[i];
                action._update(time, deltaTime, timeDirection, accuIndex);
              }

              // update scene graph

              var bindings = this._bindings,
                nBindings = this._nActiveBindings;
              for (var _i105 = 0; _i105 !== nBindings; ++_i105) {
                bindings[_i105].apply(accuIndex);
              }
              return this;
            }

            // Allows you to seek to a specific time in an animation.
          }, {
            key: "setTime",
            value: function setTime(timeInSeconds) {
              this.time = 0; // Zero out time attribute for AnimationMixer object;
              for (var i = 0; i < this._actions.length; i++) {
                this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
              }
              return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
            }

            // return this mixer's root target object
          }, {
            key: "getRoot",
            value: function getRoot() {
              return this._root;
            }

            // free all resources specific to a particular clip
          }, {
            key: "uncacheClip",
            value: function uncacheClip(clip) {
              var actions = this._actions,
                clipUuid = clip.uuid,
                actionsByClip = this._actionsByClip,
                actionsForClip = actionsByClip[clipUuid];
              if (actionsForClip !== undefined) {
                // note: just calling _removeInactiveAction would mess up the
                // iteration state and also require updating the state we can
                // just throw away

                var actionsToRemove = actionsForClip.knownActions;
                for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
                  var action = actionsToRemove[i];
                  this._deactivateAction(action);
                  var cacheIndex = action._cacheIndex,
                    lastInactiveAction = actions[actions.length - 1];
                  action._cacheIndex = null;
                  action._byClipCacheIndex = null;
                  lastInactiveAction._cacheIndex = cacheIndex;
                  actions[cacheIndex] = lastInactiveAction;
                  actions.pop();
                  this._removeInactiveBindingsForAction(action);
                }
                delete actionsByClip[clipUuid];
              }
            }

            // free all resources specific to a particular root target object
          }, {
            key: "uncacheRoot",
            value: function uncacheRoot(root) {
              var rootUuid = root.uuid,
                actionsByClip = this._actionsByClip;
              for (var clipUuid in actionsByClip) {
                var actionByRoot = actionsByClip[clipUuid].actionByRoot,
                  action = actionByRoot[rootUuid];
                if (action !== undefined) {
                  this._deactivateAction(action);
                  this._removeInactiveAction(action);
                }
              }
              var bindingsByRoot = this._bindingsByRootAndName,
                bindingByName = bindingsByRoot[rootUuid];
              if (bindingByName !== undefined) {
                for (var trackName in bindingByName) {
                  var binding = bindingByName[trackName];
                  binding.restoreOriginalState();
                  this._removeInactiveBinding(binding);
                }
              }
            }

            // remove a targeted clip from the cache
          }, {
            key: "uncacheAction",
            value: function uncacheAction(clip, optionalRoot) {
              var action = this.existingAction(clip, optionalRoot);
              if (action !== null) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
              }
            }
          }]);
        }(EventDispatcher);
        var Uniform = /*#__PURE__*/function () {
          function Uniform(value) {
            _classCallCheck2(this, Uniform);
            this.value = value;
          }
          return _createClass(Uniform, [{
            key: "clone",
            value: function clone() {
              return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
            }
          }]);
        }();
        var _id = 0;
        var UniformsGroup = /*#__PURE__*/function (_EventDispatcher8) {
          function UniformsGroup() {
            var _this128;
            _classCallCheck2(this, UniformsGroup);
            _this128 = _callSuper(this, UniformsGroup);
            _this128.isUniformsGroup = true;
            Object.defineProperty(_this128, 'id', {
              value: _id++
            });
            _this128.name = '';
            _this128.usage = StaticDrawUsage;
            _this128.uniforms = [];
            return _this128;
          }
          _inherits(UniformsGroup, _EventDispatcher8);
          return _createClass(UniformsGroup, [{
            key: "add",
            value: function add(uniform) {
              this.uniforms.push(uniform);
              return this;
            }
          }, {
            key: "remove",
            value: function remove(uniform) {
              var index = this.uniforms.indexOf(uniform);
              if (index !== -1) this.uniforms.splice(index, 1);
              return this;
            }
          }, {
            key: "setName",
            value: function setName(name) {
              this.name = name;
              return this;
            }
          }, {
            key: "setUsage",
            value: function setUsage(value) {
              this.usage = value;
              return this;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.dispatchEvent({
                type: 'dispose'
              });
              return this;
            }
          }, {
            key: "copy",
            value: function copy(source) {
              this.name = source.name;
              this.usage = source.usage;
              var uniformsSource = source.uniforms;
              this.uniforms.length = 0;
              for (var i = 0, l = uniformsSource.length; i < l; i++) {
                var uniforms = Array.isArray(uniformsSource[i]) ? uniformsSource[i] : [uniformsSource[i]];
                for (var j = 0; j < uniforms.length; j++) {
                  this.uniforms.push(uniforms[j].clone());
                }
              }
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }]);
        }(EventDispatcher);
        var InstancedInterleavedBuffer = /*#__PURE__*/function (_InterleavedBuffer) {
          function InstancedInterleavedBuffer(array, stride) {
            var _this129;
            var meshPerAttribute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            _classCallCheck2(this, InstancedInterleavedBuffer);
            _this129 = _callSuper(this, InstancedInterleavedBuffer, [array, stride]);
            _this129.isInstancedInterleavedBuffer = true;
            _this129.meshPerAttribute = meshPerAttribute;
            return _this129;
          }
          _inherits(InstancedInterleavedBuffer, _InterleavedBuffer);
          return _createClass(InstancedInterleavedBuffer, [{
            key: "copy",
            value: function copy(source) {
              _superPropGet(InstancedInterleavedBuffer, "copy", this, 3)([source]);
              this.meshPerAttribute = source.meshPerAttribute;
              return this;
            }
          }, {
            key: "clone",
            value: function clone(data) {
              var ib = _superPropGet(InstancedInterleavedBuffer, "clone", this, 3)([data]);
              ib.meshPerAttribute = this.meshPerAttribute;
              return ib;
            }
          }, {
            key: "toJSON",
            value: function toJSON(data) {
              var json = _superPropGet(InstancedInterleavedBuffer, "toJSON", this, 3)([data]);
              json.isInstancedInterleavedBuffer = true;
              json.meshPerAttribute = this.meshPerAttribute;
              return json;
            }
          }]);
        }(InterleavedBuffer);
        var GLBufferAttribute = /*#__PURE__*/function () {
          function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
            _classCallCheck2(this, GLBufferAttribute);
            this.isGLBufferAttribute = true;
            this.name = '';
            this.buffer = buffer;
            this.type = type;
            this.itemSize = itemSize;
            this.elementSize = elementSize;
            this.count = count;
            this.version = 0;
          }
          return _createClass(GLBufferAttribute, [{
            key: "needsUpdate",
            set: function set(value) {
              if (value === true) this.version++;
            }
          }, {
            key: "setBuffer",
            value: function setBuffer(buffer) {
              this.buffer = buffer;
              return this;
            }
          }, {
            key: "setType",
            value: function setType(type, elementSize) {
              this.type = type;
              this.elementSize = elementSize;
              return this;
            }
          }, {
            key: "setItemSize",
            value: function setItemSize(itemSize) {
              this.itemSize = itemSize;
              return this;
            }
          }, {
            key: "setCount",
            value: function setCount(count) {
              this.count = count;
              return this;
            }
          }]);
        }();
        var _matrix = /*@__PURE__*/new Matrix4();
        var Raycaster = /*#__PURE__*/function () {
          function Raycaster(origin, direction) {
            var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;
            _classCallCheck2(this, Raycaster);
            this.ray = new Ray(origin, direction);
            // direction is assumed to be normalized (for accurate distance calculations)

            this.near = near;
            this.far = far;
            this.camera = null;
            this.layers = new Layers();
            this.params = {
              Mesh: {},
              Line: {
                threshold: 1
              },
              LOD: {},
              Points: {
                threshold: 1
              },
              Sprite: {}
            };
          }
          return _createClass(Raycaster, [{
            key: "set",
            value: function set(origin, direction) {
              // direction is assumed to be normalized (for accurate distance calculations)

              this.ray.set(origin, direction);
            }
          }, {
            key: "setFromCamera",
            value: function setFromCamera(coords, camera) {
              if (camera.isPerspectiveCamera) {
                this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
                this.camera = camera;
              } else if (camera.isOrthographicCamera) {
                this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
                this.camera = camera;
              } else {
                console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
              }
            }
          }, {
            key: "setFromXRController",
            value: function setFromXRController(controller) {
              _matrix.identity().extractRotation(controller.matrixWorld);
              this.ray.origin.setFromMatrixPosition(controller.matrixWorld);
              this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);
              return this;
            }
          }, {
            key: "intersectObject",
            value: function intersectObject(object) {
              var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
              var intersects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
              intersect(object, this, intersects, recursive);
              intersects.sort(ascSort);
              return intersects;
            }
          }, {
            key: "intersectObjects",
            value: function intersectObjects(objects) {
              var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
              var intersects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
              for (var i = 0, l = objects.length; i < l; i++) {
                intersect(objects[i], this, intersects, recursive);
              }
              intersects.sort(ascSort);
              return intersects;
            }
          }]);
        }();
        function ascSort(a, b) {
          return a.distance - b.distance;
        }
        function intersect(object, raycaster, intersects, recursive) {
          var propagate = true;
          if (object.layers.test(raycaster.layers)) {
            var result = object.raycast(raycaster, intersects);
            if (result === false) propagate = false;
          }
          if (propagate === true && recursive === true) {
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
              intersect(children[i], raycaster, intersects, true);
            }
          }
        }

        /**
         * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
         *
         * phi (the polar angle) is measured from the positive y-axis. The positive y-axis is up.
         * theta (the azimuthal angle) is measured from the positive z-axis.
         */
        var Spherical = /*#__PURE__*/function () {
          function Spherical() {
            var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var phi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var theta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            _classCallCheck2(this, Spherical);
            this.radius = radius;
            this.phi = phi; // polar angle
            this.theta = theta; // azimuthal angle

            return this;
          }
          return _createClass(Spherical, [{
            key: "set",
            value: function set(radius, phi, theta) {
              this.radius = radius;
              this.phi = phi;
              this.theta = theta;
              return this;
            }
          }, {
            key: "copy",
            value: function copy(other) {
              this.radius = other.radius;
              this.phi = other.phi;
              this.theta = other.theta;
              return this;
            }

            // restrict phi to be between EPS and PI-EPS
          }, {
            key: "makeSafe",
            value: function makeSafe() {
              var EPS = 0.000001;
              this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
              return this;
            }
          }, {
            key: "setFromVector3",
            value: function setFromVector3(v) {
              return this.setFromCartesianCoords(v.x, v.y, v.z);
            }
          }, {
            key: "setFromCartesianCoords",
            value: function setFromCartesianCoords(x, y, z) {
              this.radius = Math.sqrt(x * x + y * y + z * z);
              if (this.radius === 0) {
                this.theta = 0;
                this.phi = 0;
              } else {
                this.theta = Math.atan2(x, z);
                this.phi = Math.acos(clamp(y / this.radius, -1, 1));
              }
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }]);
        }();
        /**
         * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
         */
        var Cylindrical = /*#__PURE__*/function () {
          function Cylindrical() {
            var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var theta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            _classCallCheck2(this, Cylindrical);
            this.radius = radius; // distance from the origin to a point in the x-z plane
            this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
            this.y = y; // height above the x-z plane

            return this;
          }
          return _createClass(Cylindrical, [{
            key: "set",
            value: function set(radius, theta, y) {
              this.radius = radius;
              this.theta = theta;
              this.y = y;
              return this;
            }
          }, {
            key: "copy",
            value: function copy(other) {
              this.radius = other.radius;
              this.theta = other.theta;
              this.y = other.y;
              return this;
            }
          }, {
            key: "setFromVector3",
            value: function setFromVector3(v) {
              return this.setFromCartesianCoords(v.x, v.y, v.z);
            }
          }, {
            key: "setFromCartesianCoords",
            value: function setFromCartesianCoords(x, y, z) {
              this.radius = Math.sqrt(x * x + z * z);
              this.theta = Math.atan2(x, z);
              this.y = y;
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }]);
        }();
        var _vector$4 = /*@__PURE__*/new Vector2();
        var Box2 = /*#__PURE__*/function () {
          function Box2() {
            var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2(+Infinity, +Infinity);
            var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2(-Infinity, -Infinity);
            _classCallCheck2(this, Box2);
            this.isBox2 = true;
            this.min = min;
            this.max = max;
          }
          return _createClass(Box2, [{
            key: "set",
            value: function set(min, max) {
              this.min.copy(min);
              this.max.copy(max);
              return this;
            }
          }, {
            key: "setFromPoints",
            value: function setFromPoints(points) {
              this.makeEmpty();
              for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
              }
              return this;
            }
          }, {
            key: "setFromCenterAndSize",
            value: function setFromCenterAndSize(center, size) {
              var halfSize = _vector$4.copy(size).multiplyScalar(0.5);
              this.min.copy(center).sub(halfSize);
              this.max.copy(center).add(halfSize);
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }, {
            key: "copy",
            value: function copy(box) {
              this.min.copy(box.min);
              this.max.copy(box.max);
              return this;
            }
          }, {
            key: "makeEmpty",
            value: function makeEmpty() {
              this.min.x = this.min.y = +Infinity;
              this.max.x = this.max.y = -Infinity;
              return this;
            }
          }, {
            key: "isEmpty",
            value: function isEmpty() {
              // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

              return this.max.x < this.min.x || this.max.y < this.min.y;
            }
          }, {
            key: "getCenter",
            value: function getCenter(target) {
              return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
            }
          }, {
            key: "getSize",
            value: function getSize(target) {
              return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
            }
          }, {
            key: "expandByPoint",
            value: function expandByPoint(point) {
              this.min.min(point);
              this.max.max(point);
              return this;
            }
          }, {
            key: "expandByVector",
            value: function expandByVector(vector) {
              this.min.sub(vector);
              this.max.add(vector);
              return this;
            }
          }, {
            key: "expandByScalar",
            value: function expandByScalar(scalar) {
              this.min.addScalar(-scalar);
              this.max.addScalar(scalar);
              return this;
            }
          }, {
            key: "containsPoint",
            value: function containsPoint(point) {
              return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
            }
          }, {
            key: "containsBox",
            value: function containsBox(box) {
              return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
            }
          }, {
            key: "getParameter",
            value: function getParameter(point, target) {
              // This can potentially have a divide by zero if the box
              // has a size dimension of 0.

              return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
            }
          }, {
            key: "intersectsBox",
            value: function intersectsBox(box) {
              // using 4 splitting planes to rule out intersections

              return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
            }
          }, {
            key: "clampPoint",
            value: function clampPoint(point, target) {
              return target.copy(point).clamp(this.min, this.max);
            }
          }, {
            key: "distanceToPoint",
            value: function distanceToPoint(point) {
              return this.clampPoint(point, _vector$4).distanceTo(point);
            }
          }, {
            key: "intersect",
            value: function intersect(box) {
              this.min.max(box.min);
              this.max.min(box.max);
              if (this.isEmpty()) this.makeEmpty();
              return this;
            }
          }, {
            key: "union",
            value: function union(box) {
              this.min.min(box.min);
              this.max.max(box.max);
              return this;
            }
          }, {
            key: "translate",
            value: function translate(offset) {
              this.min.add(offset);
              this.max.add(offset);
              return this;
            }
          }, {
            key: "equals",
            value: function equals(box) {
              return box.min.equals(this.min) && box.max.equals(this.max);
            }
          }]);
        }();
        var _startP = /*@__PURE__*/new Vector3();
        var _startEnd = /*@__PURE__*/new Vector3();
        var Line3 = /*#__PURE__*/function () {
          function Line3() {
            var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
            var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
            _classCallCheck2(this, Line3);
            this.start = start;
            this.end = end;
          }
          return _createClass(Line3, [{
            key: "set",
            value: function set(start, end) {
              this.start.copy(start);
              this.end.copy(end);
              return this;
            }
          }, {
            key: "copy",
            value: function copy(line) {
              this.start.copy(line.start);
              this.end.copy(line.end);
              return this;
            }
          }, {
            key: "getCenter",
            value: function getCenter(target) {
              return target.addVectors(this.start, this.end).multiplyScalar(0.5);
            }
          }, {
            key: "delta",
            value: function delta(target) {
              return target.subVectors(this.end, this.start);
            }
          }, {
            key: "distanceSq",
            value: function distanceSq() {
              return this.start.distanceToSquared(this.end);
            }
          }, {
            key: "distance",
            value: function distance() {
              return this.start.distanceTo(this.end);
            }
          }, {
            key: "at",
            value: function at(t, target) {
              return this.delta(target).multiplyScalar(t).add(this.start);
            }
          }, {
            key: "closestPointToPointParameter",
            value: function closestPointToPointParameter(point, clampToLine) {
              _startP.subVectors(point, this.start);
              _startEnd.subVectors(this.end, this.start);
              var startEnd2 = _startEnd.dot(_startEnd);
              var startEnd_startP = _startEnd.dot(_startP);
              var t = startEnd_startP / startEnd2;
              if (clampToLine) {
                t = clamp(t, 0, 1);
              }
              return t;
            }
          }, {
            key: "closestPointToPoint",
            value: function closestPointToPoint(point, clampToLine, target) {
              var t = this.closestPointToPointParameter(point, clampToLine);
              return this.delta(target).multiplyScalar(t).add(this.start);
            }
          }, {
            key: "applyMatrix4",
            value: function applyMatrix4(matrix) {
              this.start.applyMatrix4(matrix);
              this.end.applyMatrix4(matrix);
              return this;
            }
          }, {
            key: "equals",
            value: function equals(line) {
              return line.start.equals(this.start) && line.end.equals(this.end);
            }
          }, {
            key: "clone",
            value: function clone() {
              return new this.constructor().copy(this);
            }
          }]);
        }();
        var _vector$3 = /*@__PURE__*/new Vector3();
        var SpotLightHelper = /*#__PURE__*/function (_Object3D14) {
          function SpotLightHelper(light, color) {
            var _this130;
            _classCallCheck2(this, SpotLightHelper);
            _this130 = _callSuper(this, SpotLightHelper);
            _this130.light = light;
            _this130.matrixAutoUpdate = false;
            _this130.color = color;
            _this130.type = 'SpotLightHelper';
            var geometry = new BufferGeometry();
            var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
            for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
              var p1 = i / l * Math.PI * 2;
              var p2 = j / l * Math.PI * 2;
              positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
            }
            geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
            var material = new LineBasicMaterial({
              fog: false,
              toneMapped: false
            });
            _this130.cone = new LineSegments(geometry, material);
            _this130.add(_this130.cone);
            _this130.update();
            return _this130;
          }
          _inherits(SpotLightHelper, _Object3D14);
          return _createClass(SpotLightHelper, [{
            key: "dispose",
            value: function dispose() {
              this.cone.geometry.dispose();
              this.cone.material.dispose();
            }
          }, {
            key: "update",
            value: function update() {
              this.light.updateWorldMatrix(true, false);
              this.light.target.updateWorldMatrix(true, false);

              // update the local matrix based on the parent and light target transforms
              if (this.parent) {
                this.parent.updateWorldMatrix(true);
                this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld);
              } else {
                this.matrix.copy(this.light.matrixWorld);
              }
              this.matrixWorld.copy(this.light.matrixWorld);
              var coneLength = this.light.distance ? this.light.distance : 1000;
              var coneWidth = coneLength * Math.tan(this.light.angle);
              this.cone.scale.set(coneWidth, coneWidth, coneLength);
              _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
              this.cone.lookAt(_vector$3);
              if (this.color !== undefined) {
                this.cone.material.color.set(this.color);
              } else {
                this.cone.material.color.copy(this.light.color);
              }
            }
          }]);
        }(Object3D);
        var _vector$2 = /*@__PURE__*/new Vector3();
        var _boneMatrix = /*@__PURE__*/new Matrix4();
        var _matrixWorldInv = /*@__PURE__*/new Matrix4();
        var SkeletonHelper = /*#__PURE__*/function (_LineSegments) {
          function SkeletonHelper(object) {
            var _this131;
            _classCallCheck2(this, SkeletonHelper);
            var bones = getBoneList(object);
            var geometry = new BufferGeometry();
            var vertices = [];
            var colors = [];
            var color1 = new Color(0, 0, 1);
            var color2 = new Color(0, 1, 0);
            for (var i = 0; i < bones.length; i++) {
              var bone = bones[i];
              if (bone.parent && bone.parent.isBone) {
                vertices.push(0, 0, 0);
                vertices.push(0, 0, 0);
                colors.push(color1.r, color1.g, color1.b);
                colors.push(color2.r, color2.g, color2.b);
              }
            }
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            var material = new LineBasicMaterial({
              vertexColors: true,
              depthTest: false,
              depthWrite: false,
              toneMapped: false,
              transparent: true
            });
            _this131 = _callSuper(this, SkeletonHelper, [geometry, material]);
            _this131.isSkeletonHelper = true;
            _this131.type = 'SkeletonHelper';
            _this131.root = object;
            _this131.bones = bones;
            _this131.matrix = object.matrixWorld;
            _this131.matrixAutoUpdate = false;
            return _this131;
          }
          _inherits(SkeletonHelper, _LineSegments);
          return _createClass(SkeletonHelper, [{
            key: "updateMatrixWorld",
            value: function updateMatrixWorld(force) {
              var bones = this.bones;
              var geometry = this.geometry;
              var position = geometry.getAttribute('position');
              _matrixWorldInv.copy(this.root.matrixWorld).invert();
              for (var i = 0, j = 0; i < bones.length; i++) {
                var bone = bones[i];
                if (bone.parent && bone.parent.isBone) {
                  _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
                  _vector$2.setFromMatrixPosition(_boneMatrix);
                  position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
                  _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
                  _vector$2.setFromMatrixPosition(_boneMatrix);
                  position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
                  j += 2;
                }
              }
              geometry.getAttribute('position').needsUpdate = true;
              _superPropGet(SkeletonHelper, "updateMatrixWorld", this, 3)([force]);
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.geometry.dispose();
              this.material.dispose();
            }
          }]);
        }(LineSegments);
        function getBoneList(object) {
          var boneList = [];
          if (object.isBone === true) {
            boneList.push(object);
          }
          for (var i = 0; i < object.children.length; i++) {
            boneList.push.apply(boneList, getBoneList(object.children[i]));
          }
          return boneList;
        }
        var PointLightHelper = /*#__PURE__*/function (_Mesh4) {
          function PointLightHelper(light, sphereSize, color) {
            var _this132;
            _classCallCheck2(this, PointLightHelper);
            var geometry = new SphereGeometry(sphereSize, 4, 2);
            var material = new MeshBasicMaterial({
              wireframe: true,
              fog: false,
              toneMapped: false
            });
            _this132 = _callSuper(this, PointLightHelper, [geometry, material]);
            _this132.light = light;
            _this132.color = color;
            _this132.type = 'PointLightHelper';
            _this132.matrix = _this132.light.matrixWorld;
            _this132.matrixAutoUpdate = false;
            _this132.update();

            /*
            // TODO: delete this comment?
            const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
            const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
            this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
            this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
            const d = light.distance;
            if ( d === 0.0 ) {
            	this.lightDistance.visible = false;
            } else {
            	this.lightDistance.scale.set( d, d, d );
            }
            this.add( this.lightDistance );
            */
            return _this132;
          }
          _inherits(PointLightHelper, _Mesh4);
          return _createClass(PointLightHelper, [{
            key: "dispose",
            value: function dispose() {
              this.geometry.dispose();
              this.material.dispose();
            }
          }, {
            key: "update",
            value: function update() {
              this.light.updateWorldMatrix(true, false);
              if (this.color !== undefined) {
                this.material.color.set(this.color);
              } else {
                this.material.color.copy(this.light.color);
              }

              /*
              const d = this.light.distance;
              	if ( d === 0.0 ) {
              		this.lightDistance.visible = false;
              	} else {
              		this.lightDistance.visible = true;
              	this.lightDistance.scale.set( d, d, d );
              	}
              */
            }
          }]);
        }(Mesh);
        var _vector$1 = /*@__PURE__*/new Vector3();
        var _color1 = /*@__PURE__*/new Color();
        var _color2 = /*@__PURE__*/new Color();
        var HemisphereLightHelper = /*#__PURE__*/function (_Object3D15) {
          function HemisphereLightHelper(light, size, color) {
            var _this133;
            _classCallCheck2(this, HemisphereLightHelper);
            _this133 = _callSuper(this, HemisphereLightHelper);
            _this133.light = light;
            _this133.matrix = light.matrixWorld;
            _this133.matrixAutoUpdate = false;
            _this133.color = color;
            _this133.type = 'HemisphereLightHelper';
            var geometry = new OctahedronGeometry(size);
            geometry.rotateY(Math.PI * 0.5);
            _this133.material = new MeshBasicMaterial({
              wireframe: true,
              fog: false,
              toneMapped: false
            });
            if (_this133.color === undefined) _this133.material.vertexColors = true;
            var position = geometry.getAttribute('position');
            var colors = new Float32Array(position.count * 3);
            geometry.setAttribute('color', new BufferAttribute(colors, 3));
            _this133.add(new Mesh(geometry, _this133.material));
            _this133.update();
            return _this133;
          }
          _inherits(HemisphereLightHelper, _Object3D15);
          return _createClass(HemisphereLightHelper, [{
            key: "dispose",
            value: function dispose() {
              this.children[0].geometry.dispose();
              this.children[0].material.dispose();
            }
          }, {
            key: "update",
            value: function update() {
              var mesh = this.children[0];
              if (this.color !== undefined) {
                this.material.color.set(this.color);
              } else {
                var colors = mesh.geometry.getAttribute('color');
                _color1.copy(this.light.color);
                _color2.copy(this.light.groundColor);
                for (var i = 0, l = colors.count; i < l; i++) {
                  var color = i < l / 2 ? _color1 : _color2;
                  colors.setXYZ(i, color.r, color.g, color.b);
                }
                colors.needsUpdate = true;
              }
              this.light.updateWorldMatrix(true, false);
              mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
            }
          }]);
        }(Object3D);
        var GridHelper = /*#__PURE__*/function (_LineSegments2) {
          function GridHelper() {
            var _this134;
            var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
            var divisions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
            var color1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0x444444;
            var color2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0x888888;
            _classCallCheck2(this, GridHelper);
            color1 = new Color(color1);
            color2 = new Color(color2);
            var center = divisions / 2;
            var step = size / divisions;
            var halfSize = size / 2;
            var vertices = [],
              colors = [];
            for (var i = 0, j = 0, _k11 = -halfSize; i <= divisions; i++, _k11 += step) {
              vertices.push(-halfSize, 0, _k11, halfSize, 0, _k11);
              vertices.push(_k11, 0, -halfSize, _k11, 0, halfSize);
              var color = i === center ? color1 : color2;
              color.toArray(colors, j);
              j += 3;
              color.toArray(colors, j);
              j += 3;
              color.toArray(colors, j);
              j += 3;
              color.toArray(colors, j);
              j += 3;
            }
            var geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            var material = new LineBasicMaterial({
              vertexColors: true,
              toneMapped: false
            });
            _this134 = _callSuper(this, GridHelper, [geometry, material]);
            _this134.type = 'GridHelper';
            return _this134;
          }
          _inherits(GridHelper, _LineSegments2);
          return _createClass(GridHelper, [{
            key: "dispose",
            value: function dispose() {
              this.geometry.dispose();
              this.material.dispose();
            }
          }]);
        }(LineSegments);
        var PolarGridHelper = /*#__PURE__*/function (_LineSegments3) {
          function PolarGridHelper() {
            var _this135;
            var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
            var sectors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;
            var rings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;
            var divisions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 64;
            var color1 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0x444444;
            var color2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0x888888;
            _classCallCheck2(this, PolarGridHelper);
            color1 = new Color(color1);
            color2 = new Color(color2);
            var vertices = [];
            var colors = [];

            // create the sectors

            if (sectors > 1) {
              for (var i = 0; i < sectors; i++) {
                var v = i / sectors * (Math.PI * 2);
                var x = Math.sin(v) * radius;
                var z = Math.cos(v) * radius;
                vertices.push(0, 0, 0);
                vertices.push(x, 0, z);
                var color = i & 1 ? color1 : color2;
                colors.push(color.r, color.g, color.b);
                colors.push(color.r, color.g, color.b);
              }
            }

            // create the rings

            for (var _i106 = 0; _i106 < rings; _i106++) {
              var _color3 = _i106 & 1 ? color1 : color2;
              var r = radius - radius / rings * _i106;
              for (var j = 0; j < divisions; j++) {
                // first vertex

                var _v = j / divisions * (Math.PI * 2);
                var _x20 = Math.sin(_v) * r;
                var _z3 = Math.cos(_v) * r;
                vertices.push(_x20, 0, _z3);
                colors.push(_color3.r, _color3.g, _color3.b);

                // second vertex

                _v = (j + 1) / divisions * (Math.PI * 2);
                _x20 = Math.sin(_v) * r;
                _z3 = Math.cos(_v) * r;
                vertices.push(_x20, 0, _z3);
                colors.push(_color3.r, _color3.g, _color3.b);
              }
            }
            var geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            var material = new LineBasicMaterial({
              vertexColors: true,
              toneMapped: false
            });
            _this135 = _callSuper(this, PolarGridHelper, [geometry, material]);
            _this135.type = 'PolarGridHelper';
            return _this135;
          }
          _inherits(PolarGridHelper, _LineSegments3);
          return _createClass(PolarGridHelper, [{
            key: "dispose",
            value: function dispose() {
              this.geometry.dispose();
              this.material.dispose();
            }
          }]);
        }(LineSegments);
        var _v1 = /*@__PURE__*/new Vector3();
        var _v2 = /*@__PURE__*/new Vector3();
        var _v3 = /*@__PURE__*/new Vector3();
        var DirectionalLightHelper = /*#__PURE__*/function (_Object3D16) {
          function DirectionalLightHelper(light, size, color) {
            var _this136;
            _classCallCheck2(this, DirectionalLightHelper);
            _this136 = _callSuper(this, DirectionalLightHelper);
            _this136.light = light;
            _this136.matrix = light.matrixWorld;
            _this136.matrixAutoUpdate = false;
            _this136.color = color;
            _this136.type = 'DirectionalLightHelper';
            if (size === undefined) size = 1;
            var geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
            var material = new LineBasicMaterial({
              fog: false,
              toneMapped: false
            });
            _this136.lightPlane = new Line(geometry, material);
            _this136.add(_this136.lightPlane);
            geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
            _this136.targetLine = new Line(geometry, material);
            _this136.add(_this136.targetLine);
            _this136.update();
            return _this136;
          }
          _inherits(DirectionalLightHelper, _Object3D16);
          return _createClass(DirectionalLightHelper, [{
            key: "dispose",
            value: function dispose() {
              this.lightPlane.geometry.dispose();
              this.lightPlane.material.dispose();
              this.targetLine.geometry.dispose();
              this.targetLine.material.dispose();
            }
          }, {
            key: "update",
            value: function update() {
              this.light.updateWorldMatrix(true, false);
              this.light.target.updateWorldMatrix(true, false);
              _v1.setFromMatrixPosition(this.light.matrixWorld);
              _v2.setFromMatrixPosition(this.light.target.matrixWorld);
              _v3.subVectors(_v2, _v1);
              this.lightPlane.lookAt(_v2);
              if (this.color !== undefined) {
                this.lightPlane.material.color.set(this.color);
                this.targetLine.material.color.set(this.color);
              } else {
                this.lightPlane.material.color.copy(this.light.color);
                this.targetLine.material.color.copy(this.light.color);
              }
              this.targetLine.lookAt(_v2);
              this.targetLine.scale.z = _v3.length();
            }
          }]);
        }(Object3D);
        var _vector = /*@__PURE__*/new Vector3();
        var _camera = /*@__PURE__*/new Camera();

        /**
         *	- shows frustum, line of sight and up of the camera
         *	- suitable for fast updates
         * 	- based on frustum visualization in lightgl.js shadowmap example
         *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
         */
        var CameraHelper = /*#__PURE__*/function (_LineSegments4) {
          function CameraHelper(camera) {
            var _this137;
            _classCallCheck2(this, CameraHelper);
            var geometry = new BufferGeometry();
            var material = new LineBasicMaterial({
              color: 0xffffff,
              vertexColors: true,
              toneMapped: false
            });
            var vertices = [];
            var colors = [];
            var pointMap = {};

            // near

            addLine('n1', 'n2');
            addLine('n2', 'n4');
            addLine('n4', 'n3');
            addLine('n3', 'n1');

            // far

            addLine('f1', 'f2');
            addLine('f2', 'f4');
            addLine('f4', 'f3');
            addLine('f3', 'f1');

            // sides

            addLine('n1', 'f1');
            addLine('n2', 'f2');
            addLine('n3', 'f3');
            addLine('n4', 'f4');

            // cone

            addLine('p', 'n1');
            addLine('p', 'n2');
            addLine('p', 'n3');
            addLine('p', 'n4');

            // up

            addLine('u1', 'u2');
            addLine('u2', 'u3');
            addLine('u3', 'u1');

            // target

            addLine('c', 't');
            addLine('p', 'c');

            // cross

            addLine('cn1', 'cn2');
            addLine('cn3', 'cn4');
            addLine('cf1', 'cf2');
            addLine('cf3', 'cf4');
            function addLine(a, b) {
              addPoint(a);
              addPoint(b);
            }
            function addPoint(id) {
              vertices.push(0, 0, 0);
              colors.push(0, 0, 0);
              if (pointMap[id] === undefined) {
                pointMap[id] = [];
              }
              pointMap[id].push(vertices.length / 3 - 1);
            }
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            _this137 = _callSuper(this, CameraHelper, [geometry, material]);
            _this137.type = 'CameraHelper';
            _this137.camera = camera;
            if (_this137.camera.updateProjectionMatrix) _this137.camera.updateProjectionMatrix();
            _this137.matrix = camera.matrixWorld;
            _this137.matrixAutoUpdate = false;
            _this137.pointMap = pointMap;
            _this137.update();

            // colors

            var colorFrustum = new Color(0xffaa00);
            var colorCone = new Color(0xff0000);
            var colorUp = new Color(0x00aaff);
            var colorTarget = new Color(0xffffff);
            var colorCross = new Color(0x333333);
            _this137.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross);
            return _this137;
          }
          _inherits(CameraHelper, _LineSegments4);
          return _createClass(CameraHelper, [{
            key: "setColors",
            value: function setColors(frustum, cone, up, target, cross) {
              var geometry = this.geometry;
              var colorAttribute = geometry.getAttribute('color');

              // near

              colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b);
              colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b); // n1, n2
              colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b);
              colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b); // n2, n4
              colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b);
              colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b); // n4, n3
              colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b);
              colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b); // n3, n1

              // far

              colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b);
              colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b); // f1, f2
              colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b);
              colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b); // f2, f4
              colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b);
              colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b); // f4, f3
              colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b);
              colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b); // f3, f1

              // sides

              colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b);
              colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b); // n1, f1
              colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b);
              colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b); // n2, f2
              colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b);
              colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b); // n3, f3
              colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b);
              colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b); // n4, f4

              // cone

              colorAttribute.setXYZ(24, cone.r, cone.g, cone.b);
              colorAttribute.setXYZ(25, cone.r, cone.g, cone.b); // p, n1
              colorAttribute.setXYZ(26, cone.r, cone.g, cone.b);
              colorAttribute.setXYZ(27, cone.r, cone.g, cone.b); // p, n2
              colorAttribute.setXYZ(28, cone.r, cone.g, cone.b);
              colorAttribute.setXYZ(29, cone.r, cone.g, cone.b); // p, n3
              colorAttribute.setXYZ(30, cone.r, cone.g, cone.b);
              colorAttribute.setXYZ(31, cone.r, cone.g, cone.b); // p, n4

              // up

              colorAttribute.setXYZ(32, up.r, up.g, up.b);
              colorAttribute.setXYZ(33, up.r, up.g, up.b); // u1, u2
              colorAttribute.setXYZ(34, up.r, up.g, up.b);
              colorAttribute.setXYZ(35, up.r, up.g, up.b); // u2, u3
              colorAttribute.setXYZ(36, up.r, up.g, up.b);
              colorAttribute.setXYZ(37, up.r, up.g, up.b); // u3, u1

              // target

              colorAttribute.setXYZ(38, target.r, target.g, target.b);
              colorAttribute.setXYZ(39, target.r, target.g, target.b); // c, t
              colorAttribute.setXYZ(40, cross.r, cross.g, cross.b);
              colorAttribute.setXYZ(41, cross.r, cross.g, cross.b); // p, c

              // cross

              colorAttribute.setXYZ(42, cross.r, cross.g, cross.b);
              colorAttribute.setXYZ(43, cross.r, cross.g, cross.b); // cn1, cn2
              colorAttribute.setXYZ(44, cross.r, cross.g, cross.b);
              colorAttribute.setXYZ(45, cross.r, cross.g, cross.b); // cn3, cn4

              colorAttribute.setXYZ(46, cross.r, cross.g, cross.b);
              colorAttribute.setXYZ(47, cross.r, cross.g, cross.b); // cf1, cf2
              colorAttribute.setXYZ(48, cross.r, cross.g, cross.b);
              colorAttribute.setXYZ(49, cross.r, cross.g, cross.b); // cf3, cf4

              colorAttribute.needsUpdate = true;
            }
          }, {
            key: "update",
            value: function update() {
              var geometry = this.geometry;
              var pointMap = this.pointMap;
              var w = 1,
                h = 1;

              // we need just camera projection matrix inverse
              // world matrix must be identity

              _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);

              // center / target

              setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
              setPoint('t', pointMap, geometry, _camera, 0, 0, 1);

              // near

              setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
              setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
              setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
              setPoint('n4', pointMap, geometry, _camera, w, h, -1);

              // far

              setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
              setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
              setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
              setPoint('f4', pointMap, geometry, _camera, w, h, 1);

              // up

              setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
              setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
              setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1);

              // cross

              setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
              setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
              setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
              setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
              setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
              setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
              setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
              setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
              geometry.getAttribute('position').needsUpdate = true;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.geometry.dispose();
              this.material.dispose();
            }
          }]);
        }(LineSegments);
        function setPoint(point, pointMap, geometry, camera, x, y, z) {
          _vector.set(x, y, z).unproject(camera);
          var points = pointMap[point];
          if (points !== undefined) {
            var position = geometry.getAttribute('position');
            for (var i = 0, l = points.length; i < l; i++) {
              position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
            }
          }
        }
        var _box = /*@__PURE__*/new Box3();
        var BoxHelper = /*#__PURE__*/function (_LineSegments5) {
          function BoxHelper(object) {
            var _this138;
            var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0xffff00;
            _classCallCheck2(this, BoxHelper);
            var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
            var positions = new Float32Array(8 * 3);
            var geometry = new BufferGeometry();
            geometry.setIndex(new BufferAttribute(indices, 1));
            geometry.setAttribute('position', new BufferAttribute(positions, 3));
            _this138 = _callSuper(this, BoxHelper, [geometry, new LineBasicMaterial({
              color: color,
              toneMapped: false
            })]);
            _this138.object = object;
            _this138.type = 'BoxHelper';
            _this138.matrixAutoUpdate = false;
            _this138.update();
            return _this138;
          }
          _inherits(BoxHelper, _LineSegments5);
          return _createClass(BoxHelper, [{
            key: "update",
            value: function update(object) {
              if (object !== undefined) {
                console.warn('THREE.BoxHelper: .update() has no longer arguments.');
              }
              if (this.object !== undefined) {
                _box.setFromObject(this.object);
              }
              if (_box.isEmpty()) return;
              var min = _box.min;
              var max = _box.max;

              /*
              	5____4
              1/___0/|
              | 6__|_7
              2/___3/
              	0: max.x, max.y, max.z
              1: min.x, max.y, max.z
              2: min.x, min.y, max.z
              3: max.x, min.y, max.z
              4: max.x, max.y, min.z
              5: min.x, max.y, min.z
              6: min.x, min.y, min.z
              7: max.x, min.y, min.z
              */

              var position = this.geometry.attributes.position;
              var array = position.array;
              array[0] = max.x;
              array[1] = max.y;
              array[2] = max.z;
              array[3] = min.x;
              array[4] = max.y;
              array[5] = max.z;
              array[6] = min.x;
              array[7] = min.y;
              array[8] = max.z;
              array[9] = max.x;
              array[10] = min.y;
              array[11] = max.z;
              array[12] = max.x;
              array[13] = max.y;
              array[14] = min.z;
              array[15] = min.x;
              array[16] = max.y;
              array[17] = min.z;
              array[18] = min.x;
              array[19] = min.y;
              array[20] = min.z;
              array[21] = max.x;
              array[22] = min.y;
              array[23] = min.z;
              position.needsUpdate = true;
              this.geometry.computeBoundingSphere();
            }
          }, {
            key: "setFromObject",
            value: function setFromObject(object) {
              this.object = object;
              this.update();
              return this;
            }
          }, {
            key: "copy",
            value: function copy(source, recursive) {
              _superPropGet(BoxHelper, "copy", this, 3)([source, recursive]);
              this.object = source.object;
              return this;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.geometry.dispose();
              this.material.dispose();
            }
          }]);
        }(LineSegments);
        var Box3Helper = /*#__PURE__*/function (_LineSegments6) {
          function Box3Helper(box) {
            var _this139;
            var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0xffff00;
            _classCallCheck2(this, Box3Helper);
            var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
            var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
            var geometry = new BufferGeometry();
            geometry.setIndex(new BufferAttribute(indices, 1));
            geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
            _this139 = _callSuper(this, Box3Helper, [geometry, new LineBasicMaterial({
              color: color,
              toneMapped: false
            })]);
            _this139.box = box;
            _this139.type = 'Box3Helper';
            _this139.geometry.computeBoundingSphere();
            return _this139;
          }
          _inherits(Box3Helper, _LineSegments6);
          return _createClass(Box3Helper, [{
            key: "updateMatrixWorld",
            value: function updateMatrixWorld(force) {
              var box = this.box;
              if (box.isEmpty()) return;
              box.getCenter(this.position);
              box.getSize(this.scale);
              this.scale.multiplyScalar(0.5);
              _superPropGet(Box3Helper, "updateMatrixWorld", this, 3)([force]);
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.geometry.dispose();
              this.material.dispose();
            }
          }]);
        }(LineSegments);
        var PlaneHelper = /*#__PURE__*/function (_Line3) {
          function PlaneHelper(plane) {
            var _this140;
            var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var hex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0xffff00;
            _classCallCheck2(this, PlaneHelper);
            var color = hex;
            var positions = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
            var geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
            geometry.computeBoundingSphere();
            _this140 = _callSuper(this, PlaneHelper, [geometry, new LineBasicMaterial({
              color: color,
              toneMapped: false
            })]);
            _this140.type = 'PlaneHelper';
            _this140.plane = plane;
            _this140.size = size;
            var positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
            var geometry2 = new BufferGeometry();
            geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
            geometry2.computeBoundingSphere();
            _this140.add(new Mesh(geometry2, new MeshBasicMaterial({
              color: color,
              opacity: 0.2,
              transparent: true,
              depthWrite: false,
              toneMapped: false
            })));
            return _this140;
          }
          _inherits(PlaneHelper, _Line3);
          return _createClass(PlaneHelper, [{
            key: "updateMatrixWorld",
            value: function updateMatrixWorld(force) {
              this.position.set(0, 0, 0);
              this.scale.set(0.5 * this.size, 0.5 * this.size, 1);
              this.lookAt(this.plane.normal);
              this.translateZ(-this.plane.constant);
              _superPropGet(PlaneHelper, "updateMatrixWorld", this, 3)([force]);
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.geometry.dispose();
              this.material.dispose();
              this.children[0].geometry.dispose();
              this.children[0].material.dispose();
            }
          }]);
        }(Line);
        var _axis = /*@__PURE__*/new Vector3();
        var _lineGeometry, _coneGeometry;
        var ArrowHelper = /*#__PURE__*/function (_Object3D17) {
          // dir is assumed to be normalized

          function ArrowHelper() {
            var _this141;
            var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(0, 0, 1);
            var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(0, 0, 0);
            var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0xffff00;
            var headLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : length * 0.2;
            var headWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : headLength * 0.2;
            _classCallCheck2(this, ArrowHelper);
            _this141 = _callSuper(this, ArrowHelper);
            _this141.type = 'ArrowHelper';
            if (_lineGeometry === undefined) {
              _lineGeometry = new BufferGeometry();
              _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
              _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
              _coneGeometry.translate(0, -0.5, 0);
            }
            _this141.position.copy(origin);
            _this141.line = new Line(_lineGeometry, new LineBasicMaterial({
              color: color,
              toneMapped: false
            }));
            _this141.line.matrixAutoUpdate = false;
            _this141.add(_this141.line);
            _this141.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
              color: color,
              toneMapped: false
            }));
            _this141.cone.matrixAutoUpdate = false;
            _this141.add(_this141.cone);
            _this141.setDirection(dir);
            _this141.setLength(length, headLength, headWidth);
            return _this141;
          }
          _inherits(ArrowHelper, _Object3D17);
          return _createClass(ArrowHelper, [{
            key: "setDirection",
            value: function setDirection(dir) {
              // dir is assumed to be normalized

              if (dir.y > 0.99999) {
                this.quaternion.set(0, 0, 0, 1);
              } else if (dir.y < -0.99999) {
                this.quaternion.set(1, 0, 0, 0);
              } else {
                _axis.set(dir.z, 0, -dir.x).normalize();
                var radians = Math.acos(dir.y);
                this.quaternion.setFromAxisAngle(_axis, radians);
              }
            }
          }, {
            key: "setLength",
            value: function setLength(length) {
              var headLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : length * 0.2;
              var headWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : headLength * 0.2;
              this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
              this.line.updateMatrix();
              this.cone.scale.set(headWidth, headLength, headWidth);
              this.cone.position.y = length;
              this.cone.updateMatrix();
            }
          }, {
            key: "setColor",
            value: function setColor(color) {
              this.line.material.color.set(color);
              this.cone.material.color.set(color);
            }
          }, {
            key: "copy",
            value: function copy(source) {
              _superPropGet(ArrowHelper, "copy", this, 3)([source, false]);
              this.line.copy(source.line);
              this.cone.copy(source.cone);
              return this;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.line.geometry.dispose();
              this.line.material.dispose();
              this.cone.geometry.dispose();
              this.cone.material.dispose();
            }
          }]);
        }(Object3D);
        var AxesHelper = /*#__PURE__*/function (_LineSegments7) {
          function AxesHelper() {
            var _this142;
            var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            _classCallCheck2(this, AxesHelper);
            var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
            var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
            var geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            var material = new LineBasicMaterial({
              vertexColors: true,
              toneMapped: false
            });
            _this142 = _callSuper(this, AxesHelper, [geometry, material]);
            _this142.type = 'AxesHelper';
            return _this142;
          }
          _inherits(AxesHelper, _LineSegments7);
          return _createClass(AxesHelper, [{
            key: "setColors",
            value: function setColors(xAxisColor, yAxisColor, zAxisColor) {
              var color = new Color();
              var array = this.geometry.attributes.color.array;
              color.set(xAxisColor);
              color.toArray(array, 0);
              color.toArray(array, 3);
              color.set(yAxisColor);
              color.toArray(array, 6);
              color.toArray(array, 9);
              color.set(zAxisColor);
              color.toArray(array, 12);
              color.toArray(array, 15);
              this.geometry.attributes.color.needsUpdate = true;
              return this;
            }
          }, {
            key: "dispose",
            value: function dispose() {
              this.geometry.dispose();
              this.material.dispose();
            }
          }]);
        }(LineSegments);
        var ShapePath = /*#__PURE__*/function () {
          function ShapePath() {
            _classCallCheck2(this, ShapePath);
            this.type = 'ShapePath';
            this.color = new Color();
            this.subPaths = [];
            this.currentPath = null;
          }
          return _createClass(ShapePath, [{
            key: "moveTo",
            value: function moveTo(x, y) {
              this.currentPath = new Path();
              this.subPaths.push(this.currentPath);
              this.currentPath.moveTo(x, y);
              return this;
            }
          }, {
            key: "lineTo",
            value: function lineTo(x, y) {
              this.currentPath.lineTo(x, y);
              return this;
            }
          }, {
            key: "quadraticCurveTo",
            value: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
              this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
              return this;
            }
          }, {
            key: "bezierCurveTo",
            value: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
              this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
              return this;
            }
          }, {
            key: "splineThru",
            value: function splineThru(pts) {
              this.currentPath.splineThru(pts);
              return this;
            }
          }, {
            key: "toShapes",
            value: function toShapes(isCCW) {
              function toShapesNoHoles(inSubpaths) {
                var shapes = [];
                for (var i = 0, l = inSubpaths.length; i < l; i++) {
                  var _tmpPath = inSubpaths[i];
                  var _tmpShape = new Shape();
                  _tmpShape.curves = _tmpPath.curves;
                  shapes.push(_tmpShape);
                }
                return shapes;
              }
              function isPointInsidePolygon(inPt, inPolygon) {
                var polyLen = inPolygon.length;

                // inPt on polygon contour => immediate success    or
                // toggling of inside/outside at every single! intersection point of an edge
                //  with the horizontal line through inPt, left of inPt
                //  not counting lowerY endpoints of edges and whole edges on that line
                var inside = false;
                for (var _p8 = polyLen - 1, q = 0; q < polyLen; _p8 = q++) {
                  var edgeLowPt = inPolygon[_p8];
                  var edgeHighPt = inPolygon[q];
                  var edgeDx = edgeHighPt.x - edgeLowPt.x;
                  var edgeDy = edgeHighPt.y - edgeLowPt.y;
                  if (Math.abs(edgeDy) > Number.EPSILON) {
                    // not parallel
                    if (edgeDy < 0) {
                      edgeLowPt = inPolygon[q];
                      edgeDx = -edgeDx;
                      edgeHighPt = inPolygon[_p8];
                      edgeDy = -edgeDy;
                    }
                    if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                    if (inPt.y === edgeLowPt.y) {
                      if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
                      // continue;				// no intersection or edgeLowPt => doesn't count !!!
                    } else {
                      var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                      if (perpEdge === 0) return true; // inPt is on contour ?
                      if (perpEdge < 0) continue;
                      inside = !inside; // true intersection left of inPt
                    }
                  } else {
                    // parallel or collinear
                    if (inPt.y !== edgeLowPt.y) continue; // parallel
                    // edge lies on the same horizontal line as inPt
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
                    // continue;
                  }
                }
                return inside;
              }
              var isClockWise = ShapeUtils.isClockWise;
              var subPaths = this.subPaths;
              if (subPaths.length === 0) return [];
              var solid, tmpPath, tmpShape;
              var shapes = [];
              if (subPaths.length === 1) {
                tmpPath = subPaths[0];
                tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
                return shapes;
              }
              var holesFirst = !isClockWise(subPaths[0].getPoints());
              holesFirst = isCCW ? !holesFirst : holesFirst;

              // console.log("Holes first", holesFirst);

              var betterShapeHoles = [];
              var newShapes = [];
              var newShapeHoles = [];
              var mainIdx = 0;
              var tmpPoints;
              newShapes[mainIdx] = undefined;
              newShapeHoles[mainIdx] = [];
              for (var i = 0, l = subPaths.length; i < l; i++) {
                tmpPath = subPaths[i];
                tmpPoints = tmpPath.getPoints();
                solid = isClockWise(tmpPoints);
                solid = isCCW ? !solid : solid;
                if (solid) {
                  if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                  newShapes[mainIdx] = {
                    s: new Shape(),
                    p: tmpPoints
                  };
                  newShapes[mainIdx].s.curves = tmpPath.curves;
                  if (holesFirst) mainIdx++;
                  newShapeHoles[mainIdx] = [];

                  //console.log('cw', i);
                } else {
                  newShapeHoles[mainIdx].push({
                    h: tmpPath,
                    p: tmpPoints[0]
                  });

                  //console.log('ccw', i);
                }
              }

              // only Holes? -> probably all Shapes with wrong orientation
              if (!newShapes[0]) return toShapesNoHoles(subPaths);
              if (newShapes.length > 1) {
                var ambiguous = false;
                var toChange = 0;
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                  betterShapeHoles[sIdx] = [];
                }
                for (var _sIdx = 0, _sLen = newShapes.length; _sIdx < _sLen; _sIdx++) {
                  var sho = newShapeHoles[_sIdx];
                  for (var hIdx = 0; hIdx < sho.length; hIdx++) {
                    var ho = sho[hIdx];
                    var hole_unassigned = true;
                    for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                      if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                        if (_sIdx !== s2Idx) toChange++;
                        if (hole_unassigned) {
                          hole_unassigned = false;
                          betterShapeHoles[s2Idx].push(ho);
                        } else {
                          ambiguous = true;
                        }
                      }
                    }
                    if (hole_unassigned) {
                      betterShapeHoles[_sIdx].push(ho);
                    }
                  }
                }
                if (toChange > 0 && ambiguous === false) {
                  newShapeHoles = betterShapeHoles;
                }
              }
              var tmpHoles;
              for (var _i107 = 0, il = newShapes.length; _i107 < il; _i107++) {
                tmpShape = newShapes[_i107].s;
                shapes.push(tmpShape);
                tmpHoles = newShapeHoles[_i107];
                for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
                  tmpShape.holes.push(tmpHoles[j].h);
                }
              }

              //console.log("shape", shapes);

              return shapes;
            }
          }]);
        }();
        var WebGLMultipleRenderTargets = /*#__PURE__*/function (_WebGLRenderTarget4) {
          // @deprecated, r162

          function WebGLMultipleRenderTargets() {
            var _this143;
            var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
            _classCallCheck2(this, WebGLMultipleRenderTargets);
            console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.');
            _this143 = _callSuper(this, WebGLMultipleRenderTargets, [width, height, _objectSpread(_objectSpread({}, options), {}, {
              count: count
            })]);
            _this143.isWebGLMultipleRenderTargets = true;
            return _this143;
          }
          _inherits(WebGLMultipleRenderTargets, _WebGLRenderTarget4);
          return _createClass(WebGLMultipleRenderTargets, [{
            key: "texture",
            get: function get() {
              return this.textures;
            }
          }]);
        }(WebGLRenderTarget);
        if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
            detail: {
              revision: REVISION
            }
          }));
        }
        if (typeof window !== 'undefined') {
          if (window.__THREE__) {
            console.warn('WARNING: Multiple instances of Three.js being imported.');
          } else {
            window.__THREE__ = REVISION;
          }
        }
        var THREE = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          ACESFilmicToneMapping: ACESFilmicToneMapping,
          AddEquation: AddEquation,
          AddOperation: AddOperation,
          AdditiveAnimationBlendMode: AdditiveAnimationBlendMode,
          AdditiveBlending: AdditiveBlending,
          AgXToneMapping: AgXToneMapping,
          AlphaFormat: AlphaFormat,
          AlwaysCompare: AlwaysCompare,
          AlwaysDepth: AlwaysDepth,
          AlwaysStencilFunc: AlwaysStencilFunc,
          AmbientLight: AmbientLight,
          AnimationAction: AnimationAction,
          AnimationClip: AnimationClip,
          AnimationLoader: AnimationLoader,
          AnimationMixer: AnimationMixer,
          AnimationObjectGroup: AnimationObjectGroup,
          AnimationUtils: AnimationUtils,
          ArcCurve: ArcCurve,
          ArrayCamera: ArrayCamera,
          ArrowHelper: ArrowHelper,
          AttachedBindMode: AttachedBindMode,
          Audio: Audio$1,
          AudioAnalyser: AudioAnalyser,
          AudioContext: AudioContext,
          AudioListener: AudioListener,
          AudioLoader: AudioLoader,
          AxesHelper: AxesHelper,
          BackSide: BackSide,
          BasicDepthPacking: BasicDepthPacking,
          BasicShadowMap: BasicShadowMap,
          BatchedMesh: BatchedMesh,
          Bone: Bone,
          BooleanKeyframeTrack: BooleanKeyframeTrack,
          Box2: Box2,
          Box3: Box3,
          Box3Helper: Box3Helper,
          BoxGeometry: BoxGeometry,
          BoxHelper: BoxHelper,
          BufferAttribute: BufferAttribute,
          BufferGeometry: BufferGeometry,
          BufferGeometryLoader: BufferGeometryLoader,
          ByteType: ByteType,
          Cache: Cache,
          Camera: Camera,
          CameraHelper: CameraHelper,
          CanvasTexture: CanvasTexture,
          CapsuleGeometry: CapsuleGeometry,
          CatmullRomCurve3: CatmullRomCurve3,
          CineonToneMapping: CineonToneMapping,
          CircleGeometry: CircleGeometry,
          ClampToEdgeWrapping: ClampToEdgeWrapping,
          Clock: Clock,
          Color: Color,
          ColorKeyframeTrack: ColorKeyframeTrack,
          ColorManagement: ColorManagement,
          CompressedArrayTexture: CompressedArrayTexture,
          CompressedCubeTexture: CompressedCubeTexture,
          CompressedTexture: CompressedTexture,
          CompressedTextureLoader: CompressedTextureLoader,
          ConeGeometry: ConeGeometry,
          ConstantAlphaFactor: ConstantAlphaFactor,
          ConstantColorFactor: ConstantColorFactor,
          CubeCamera: CubeCamera,
          CubeReflectionMapping: CubeReflectionMapping,
          CubeRefractionMapping: CubeRefractionMapping,
          CubeTexture: CubeTexture,
          CubeTextureLoader: CubeTextureLoader,
          CubeUVReflectionMapping: CubeUVReflectionMapping,
          CubicBezierCurve: CubicBezierCurve,
          CubicBezierCurve3: CubicBezierCurve3,
          CubicInterpolant: CubicInterpolant,
          CullFaceBack: CullFaceBack,
          CullFaceFront: CullFaceFront,
          CullFaceFrontBack: CullFaceFrontBack,
          CullFaceNone: CullFaceNone,
          Curve: Curve,
          CurvePath: CurvePath,
          CustomBlending: CustomBlending,
          CustomToneMapping: CustomToneMapping,
          CylinderGeometry: CylinderGeometry,
          Cylindrical: Cylindrical,
          Data3DTexture: Data3DTexture,
          DataArrayTexture: DataArrayTexture,
          DataTexture: DataTexture,
          DataTextureLoader: DataTextureLoader,
          DataUtils: DataUtils,
          DecrementStencilOp: DecrementStencilOp,
          DecrementWrapStencilOp: DecrementWrapStencilOp,
          DefaultLoadingManager: DefaultLoadingManager,
          DepthFormat: DepthFormat,
          DepthStencilFormat: DepthStencilFormat,
          DepthTexture: DepthTexture,
          DetachedBindMode: DetachedBindMode,
          DirectionalLight: DirectionalLight,
          DirectionalLightHelper: DirectionalLightHelper,
          DiscreteInterpolant: DiscreteInterpolant,
          DisplayP3ColorSpace: DisplayP3ColorSpace,
          DodecahedronGeometry: DodecahedronGeometry,
          DoubleSide: DoubleSide,
          DstAlphaFactor: DstAlphaFactor,
          DstColorFactor: DstColorFactor,
          DynamicCopyUsage: DynamicCopyUsage,
          DynamicDrawUsage: DynamicDrawUsage,
          DynamicReadUsage: DynamicReadUsage,
          EdgesGeometry: EdgesGeometry,
          EllipseCurve: EllipseCurve,
          EqualCompare: EqualCompare,
          EqualDepth: EqualDepth,
          EqualStencilFunc: EqualStencilFunc,
          EquirectangularReflectionMapping: EquirectangularReflectionMapping,
          EquirectangularRefractionMapping: EquirectangularRefractionMapping,
          Euler: Euler,
          EventDispatcher: EventDispatcher,
          ExtrudeGeometry: ExtrudeGeometry,
          FileLoader: FileLoader,
          Float16BufferAttribute: Float16BufferAttribute,
          Float32BufferAttribute: Float32BufferAttribute,
          FloatType: FloatType,
          Fog: Fog,
          FogExp2: FogExp2,
          FramebufferTexture: FramebufferTexture,
          FrontSide: FrontSide,
          Frustum: Frustum,
          GLBufferAttribute: GLBufferAttribute,
          GLSL1: GLSL1,
          GLSL3: GLSL3,
          GreaterCompare: GreaterCompare,
          GreaterDepth: GreaterDepth,
          GreaterEqualCompare: GreaterEqualCompare,
          GreaterEqualDepth: GreaterEqualDepth,
          GreaterEqualStencilFunc: GreaterEqualStencilFunc,
          GreaterStencilFunc: GreaterStencilFunc,
          GridHelper: GridHelper,
          Group: Group,
          HalfFloatType: HalfFloatType,
          HemisphereLight: HemisphereLight,
          HemisphereLightHelper: HemisphereLightHelper,
          IcosahedronGeometry: IcosahedronGeometry,
          ImageBitmapLoader: ImageBitmapLoader,
          ImageLoader: ImageLoader,
          ImageUtils: ImageUtils,
          IncrementStencilOp: IncrementStencilOp,
          IncrementWrapStencilOp: IncrementWrapStencilOp,
          InstancedBufferAttribute: InstancedBufferAttribute,
          InstancedBufferGeometry: InstancedBufferGeometry,
          InstancedInterleavedBuffer: InstancedInterleavedBuffer,
          InstancedMesh: InstancedMesh,
          Int16BufferAttribute: Int16BufferAttribute,
          Int32BufferAttribute: Int32BufferAttribute,
          Int8BufferAttribute: Int8BufferAttribute,
          IntType: IntType,
          InterleavedBuffer: InterleavedBuffer,
          InterleavedBufferAttribute: InterleavedBufferAttribute,
          Interpolant: Interpolant,
          InterpolateDiscrete: InterpolateDiscrete,
          InterpolateLinear: InterpolateLinear,
          InterpolateSmooth: InterpolateSmooth,
          InvertStencilOp: InvertStencilOp,
          KeepStencilOp: KeepStencilOp,
          KeyframeTrack: KeyframeTrack,
          LOD: LOD,
          LatheGeometry: LatheGeometry,
          Layers: Layers,
          LessCompare: LessCompare,
          LessDepth: LessDepth,
          LessEqualCompare: LessEqualCompare,
          LessEqualDepth: LessEqualDepth,
          LessEqualStencilFunc: LessEqualStencilFunc,
          LessStencilFunc: LessStencilFunc,
          Light: Light,
          LightProbe: LightProbe,
          Line: Line,
          Line3: Line3,
          LineBasicMaterial: LineBasicMaterial,
          LineCurve: LineCurve,
          LineCurve3: LineCurve3,
          LineDashedMaterial: LineDashedMaterial,
          LineLoop: LineLoop,
          LineSegments: LineSegments,
          LinearDisplayP3ColorSpace: LinearDisplayP3ColorSpace,
          LinearFilter: LinearFilter,
          LinearInterpolant: LinearInterpolant,
          LinearMipMapLinearFilter: LinearMipMapLinearFilter,
          LinearMipMapNearestFilter: LinearMipMapNearestFilter,
          LinearMipmapLinearFilter: LinearMipmapLinearFilter,
          LinearMipmapNearestFilter: LinearMipmapNearestFilter,
          LinearSRGBColorSpace: LinearSRGBColorSpace,
          LinearToneMapping: LinearToneMapping,
          LinearTransfer: LinearTransfer,
          Loader: Loader,
          LoaderUtils: LoaderUtils,
          LoadingManager: LoadingManager,
          LoopOnce: LoopOnce,
          LoopPingPong: LoopPingPong,
          LoopRepeat: LoopRepeat,
          LuminanceAlphaFormat: LuminanceAlphaFormat,
          LuminanceFormat: LuminanceFormat,
          MOUSE: MOUSE,
          Material: Material,
          MaterialLoader: MaterialLoader,
          MathUtils: MathUtils,
          Matrix3: Matrix3,
          Matrix4: Matrix4,
          MaxEquation: MaxEquation,
          Mesh: Mesh,
          MeshBasicMaterial: MeshBasicMaterial,
          MeshDepthMaterial: MeshDepthMaterial,
          MeshDistanceMaterial: MeshDistanceMaterial,
          MeshLambertMaterial: MeshLambertMaterial,
          MeshMatcapMaterial: MeshMatcapMaterial,
          MeshNormalMaterial: MeshNormalMaterial,
          MeshPhongMaterial: MeshPhongMaterial,
          MeshPhysicalMaterial: MeshPhysicalMaterial,
          MeshStandardMaterial: MeshStandardMaterial,
          MeshToonMaterial: MeshToonMaterial,
          MinEquation: MinEquation,
          MirroredRepeatWrapping: MirroredRepeatWrapping,
          MixOperation: MixOperation,
          MultiplyBlending: MultiplyBlending,
          MultiplyOperation: MultiplyOperation,
          NearestFilter: NearestFilter,
          NearestMipMapLinearFilter: NearestMipMapLinearFilter,
          NearestMipMapNearestFilter: NearestMipMapNearestFilter,
          NearestMipmapLinearFilter: NearestMipmapLinearFilter,
          NearestMipmapNearestFilter: NearestMipmapNearestFilter,
          NeutralToneMapping: NeutralToneMapping,
          NeverCompare: NeverCompare,
          NeverDepth: NeverDepth,
          NeverStencilFunc: NeverStencilFunc,
          NoBlending: NoBlending,
          NoColorSpace: NoColorSpace,
          NoToneMapping: NoToneMapping,
          NormalAnimationBlendMode: NormalAnimationBlendMode,
          NormalBlending: NormalBlending,
          NotEqualCompare: NotEqualCompare,
          NotEqualDepth: NotEqualDepth,
          NotEqualStencilFunc: NotEqualStencilFunc,
          NumberKeyframeTrack: NumberKeyframeTrack,
          Object3D: Object3D,
          ObjectLoader: ObjectLoader,
          ObjectSpaceNormalMap: ObjectSpaceNormalMap,
          OctahedronGeometry: OctahedronGeometry,
          OneFactor: OneFactor,
          OneMinusConstantAlphaFactor: OneMinusConstantAlphaFactor,
          OneMinusConstantColorFactor: OneMinusConstantColorFactor,
          OneMinusDstAlphaFactor: OneMinusDstAlphaFactor,
          OneMinusDstColorFactor: OneMinusDstColorFactor,
          OneMinusSrcAlphaFactor: OneMinusSrcAlphaFactor,
          OneMinusSrcColorFactor: OneMinusSrcColorFactor,
          OrthographicCamera: OrthographicCamera,
          P3Primaries: P3Primaries,
          PCFShadowMap: PCFShadowMap,
          PCFSoftShadowMap: PCFSoftShadowMap,
          PMREMGenerator: PMREMGenerator,
          Path: Path,
          PerspectiveCamera: PerspectiveCamera,
          Plane: Plane,
          PlaneGeometry: PlaneGeometry,
          PlaneHelper: PlaneHelper,
          PointLight: PointLight,
          PointLightHelper: PointLightHelper,
          Points: Points,
          PointsMaterial: PointsMaterial,
          PolarGridHelper: PolarGridHelper,
          PolyhedronGeometry: PolyhedronGeometry,
          PositionalAudio: PositionalAudio,
          PropertyBinding: PropertyBinding,
          PropertyMixer: PropertyMixer,
          QuadraticBezierCurve: QuadraticBezierCurve,
          QuadraticBezierCurve3: QuadraticBezierCurve3,
          Quaternion: Quaternion,
          QuaternionKeyframeTrack: QuaternionKeyframeTrack,
          QuaternionLinearInterpolant: QuaternionLinearInterpolant,
          RED_GREEN_RGTC2_Format: RED_GREEN_RGTC2_Format,
          RED_RGTC1_Format: RED_RGTC1_Format,
          REVISION: REVISION,
          RGBADepthPacking: RGBADepthPacking,
          RGBAFormat: RGBAFormat,
          RGBAIntegerFormat: RGBAIntegerFormat,
          RGBA_ASTC_10x10_Format: RGBA_ASTC_10x10_Format,
          RGBA_ASTC_10x5_Format: RGBA_ASTC_10x5_Format,
          RGBA_ASTC_10x6_Format: RGBA_ASTC_10x6_Format,
          RGBA_ASTC_10x8_Format: RGBA_ASTC_10x8_Format,
          RGBA_ASTC_12x10_Format: RGBA_ASTC_12x10_Format,
          RGBA_ASTC_12x12_Format: RGBA_ASTC_12x12_Format,
          RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,
          RGBA_ASTC_5x4_Format: RGBA_ASTC_5x4_Format,
          RGBA_ASTC_5x5_Format: RGBA_ASTC_5x5_Format,
          RGBA_ASTC_6x5_Format: RGBA_ASTC_6x5_Format,
          RGBA_ASTC_6x6_Format: RGBA_ASTC_6x6_Format,
          RGBA_ASTC_8x5_Format: RGBA_ASTC_8x5_Format,
          RGBA_ASTC_8x6_Format: RGBA_ASTC_8x6_Format,
          RGBA_ASTC_8x8_Format: RGBA_ASTC_8x8_Format,
          RGBA_BPTC_Format: RGBA_BPTC_Format,
          RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,
          RGBA_PVRTC_2BPPV1_Format: RGBA_PVRTC_2BPPV1_Format,
          RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,
          RGBA_S3TC_DXT1_Format: RGBA_S3TC_DXT1_Format,
          RGBA_S3TC_DXT3_Format: RGBA_S3TC_DXT3_Format,
          RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,
          RGBFormat: RGBFormat,
          RGBIntegerFormat: RGBIntegerFormat,
          RGB_BPTC_SIGNED_Format: RGB_BPTC_SIGNED_Format,
          RGB_BPTC_UNSIGNED_Format: RGB_BPTC_UNSIGNED_Format,
          RGB_ETC1_Format: RGB_ETC1_Format,
          RGB_ETC2_Format: RGB_ETC2_Format,
          RGB_PVRTC_2BPPV1_Format: RGB_PVRTC_2BPPV1_Format,
          RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,
          RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,
          RGFormat: RGFormat,
          RGIntegerFormat: RGIntegerFormat,
          RawShaderMaterial: RawShaderMaterial,
          Ray: Ray,
          Raycaster: Raycaster,
          Rec709Primaries: Rec709Primaries,
          RectAreaLight: RectAreaLight,
          RedFormat: RedFormat,
          RedIntegerFormat: RedIntegerFormat,
          ReinhardToneMapping: ReinhardToneMapping,
          RenderTarget: RenderTarget,
          RepeatWrapping: RepeatWrapping,
          ReplaceStencilOp: ReplaceStencilOp,
          ReverseSubtractEquation: ReverseSubtractEquation,
          RingGeometry: RingGeometry,
          SIGNED_RED_GREEN_RGTC2_Format: SIGNED_RED_GREEN_RGTC2_Format,
          SIGNED_RED_RGTC1_Format: SIGNED_RED_RGTC1_Format,
          SRGBColorSpace: SRGBColorSpace,
          SRGBTransfer: SRGBTransfer,
          Scene: Scene,
          ShaderChunk: ShaderChunk,
          ShaderLib: ShaderLib,
          ShaderMaterial: ShaderMaterial,
          ShadowMaterial: ShadowMaterial,
          Shape: Shape,
          ShapeGeometry: ShapeGeometry,
          ShapePath: ShapePath,
          ShapeUtils: ShapeUtils,
          ShortType: ShortType,
          Skeleton: Skeleton,
          SkeletonHelper: SkeletonHelper,
          SkinnedMesh: SkinnedMesh,
          Source: Source,
          Sphere: Sphere,
          SphereGeometry: SphereGeometry,
          Spherical: Spherical,
          SphericalHarmonics3: SphericalHarmonics3,
          SplineCurve: SplineCurve,
          SpotLight: SpotLight,
          SpotLightHelper: SpotLightHelper,
          Sprite: Sprite,
          SpriteMaterial: SpriteMaterial,
          SrcAlphaFactor: SrcAlphaFactor,
          SrcAlphaSaturateFactor: SrcAlphaSaturateFactor,
          SrcColorFactor: SrcColorFactor,
          StaticCopyUsage: StaticCopyUsage,
          StaticDrawUsage: StaticDrawUsage,
          StaticReadUsage: StaticReadUsage,
          StereoCamera: StereoCamera,
          StreamCopyUsage: StreamCopyUsage,
          StreamDrawUsage: StreamDrawUsage,
          StreamReadUsage: StreamReadUsage,
          StringKeyframeTrack: StringKeyframeTrack,
          SubtractEquation: SubtractEquation,
          SubtractiveBlending: SubtractiveBlending,
          TOUCH: TOUCH,
          TangentSpaceNormalMap: TangentSpaceNormalMap,
          TetrahedronGeometry: TetrahedronGeometry,
          Texture: Texture,
          TextureLoader: TextureLoader,
          TextureUtils: TextureUtils,
          TorusGeometry: TorusGeometry,
          TorusKnotGeometry: TorusKnotGeometry,
          Triangle: Triangle,
          TriangleFanDrawMode: TriangleFanDrawMode,
          TriangleStripDrawMode: TriangleStripDrawMode,
          TrianglesDrawMode: TrianglesDrawMode,
          TubeGeometry: TubeGeometry,
          UVMapping: UVMapping,
          Uint16BufferAttribute: Uint16BufferAttribute,
          Uint32BufferAttribute: Uint32BufferAttribute,
          Uint8BufferAttribute: Uint8BufferAttribute,
          Uint8ClampedBufferAttribute: Uint8ClampedBufferAttribute,
          Uniform: Uniform,
          UniformsGroup: UniformsGroup,
          UniformsLib: UniformsLib,
          UniformsUtils: UniformsUtils,
          UnsignedByteType: UnsignedByteType,
          UnsignedInt248Type: UnsignedInt248Type,
          UnsignedInt5999Type: UnsignedInt5999Type,
          UnsignedIntType: UnsignedIntType,
          UnsignedShort4444Type: UnsignedShort4444Type,
          UnsignedShort5551Type: UnsignedShort5551Type,
          UnsignedShortType: UnsignedShortType,
          VSMShadowMap: VSMShadowMap,
          Vector2: Vector2,
          Vector3: Vector3,
          Vector4: Vector4,
          VectorKeyframeTrack: VectorKeyframeTrack,
          VideoTexture: VideoTexture,
          WebGL3DRenderTarget: WebGL3DRenderTarget,
          WebGLArrayRenderTarget: WebGLArrayRenderTarget,
          WebGLCoordinateSystem: WebGLCoordinateSystem,
          WebGLCubeRenderTarget: WebGLCubeRenderTarget,
          WebGLMultipleRenderTargets: WebGLMultipleRenderTargets,
          WebGLRenderTarget: WebGLRenderTarget,
          WebGLRenderer: WebGLRenderer,
          WebGLUtils: WebGLUtils,
          WebGPUCoordinateSystem: WebGPUCoordinateSystem,
          WireframeGeometry: WireframeGeometry,
          WrapAroundEnding: WrapAroundEnding,
          ZeroCurvatureEnding: ZeroCurvatureEnding,
          ZeroFactor: ZeroFactor,
          ZeroSlopeEnding: ZeroSlopeEnding,
          ZeroStencilOp: ZeroStencilOp,
          createCanvasElement: createCanvasElement
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        var CSS3DObject = /*#__PURE__*/function (_Object3D18) {
          /**
           * @param element Target Sprite DOM Element
           */
          function CSS3DObject(element) {
            var _this144;
            _classCallCheck2(this, CSS3DObject);
            _this144 = _callSuper(this, CSS3DObject);
            _this144.element = element;
            _this144.element.style.position = 'absolute';
            _this144.element.style.pointerEvents = 'auto';
            _this144.addEventListener('removed', function () {
              _this144.traverse(function (object) {
                if (object instanceof CSS3DObject && object.element instanceof Element && object.element.parentNode !== null) {
                  object.element.parentNode.removeChild(object.element);
                }
              });
            });
            return _this144;
          }
          /**
           * Copy content from another CSS3DObject.
           * @param source Source CSS3DObject
           * @param recursive
           * @returns CSS3DObject
           */
          _inherits(CSS3DObject, _Object3D18);
          return _createClass(CSS3DObject, [{
            key: "copy",
            value: function copy(source, recursive) {
              Object3D.prototype.copy.call(this, source, recursive);
              this.element = source.element.cloneNode(true);
              return this;
            }
          }]);
        }(Object3D);
        var CSS3DSprite = /*#__PURE__*/function (_CSS3DObject) {
          /**
           * @param element Target Sprite DOM Element
           * @param spriteRatio The ratio for sprite rotation compensation, 1 for full sprite, 0 for normal 3D object.
           */
          function CSS3DSprite(element) {
            var _this145;
            var spriteRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            _classCallCheck2(this, CSS3DSprite);
            _this145 = _callSuper(this, CSS3DSprite, [element]);
            _this145.spriteRatio = spriteRatio;
            _this145.spriteMatrixWorld = new Matrix4().copy(_this145.matrixWorld);
            return _this145;
          }
          _inherits(CSS3DSprite, _CSS3DObject);
          return _createClass(CSS3DSprite);
        }(CSS3DObject);
        var CSS3DRenderer = /*#__PURE__*/function (_EventDispatcher9) {
          function CSS3DRenderer() {
            var _this146;
            _classCallCheck2(this, CSS3DRenderer);
            _this146 = _callSuper(this, CSS3DRenderer);
            _this146._width = 0;
            _this146._height = 0;
            _this146._widthHalf = 0;
            _this146._heightHalf = 0;
            _this146.matrix = new Matrix4();
            _this146._spriteQuat = new Quaternion();
            _this146._objectQuat = new Quaternion();
            _this146.cache = {
              camera: {
                fov: 0,
                style: ''
              },
              objects: new WeakMap()
            };
            _this146.epsilon = function (value) {
              return Math.abs(value) < 1e-10 ? 0 : value;
            };
            _this146.getDistanceToSquared = function () {
              var a = new Vector3();
              var b = new Vector3();
              return function (object1, object2) {
                a.setFromMatrixPosition(object1.matrixWorld);
                b.setFromMatrixPosition(object2.matrixWorld);
                return a.distanceToSquared(b);
              };
            }();
            _this146.getCameraCSSMatrix = function (martrix, camera, fov) {
              var _this147 = _this146,
                epsilon = _this147.epsilon;
              var elements = martrix.elements;
              // prettier-ignore
              var matrixCSS = "matrix3d(".concat(epsilon(elements[0]), ",").concat(epsilon(-elements[1]), ",").concat(epsilon(elements[2]), ",").concat(epsilon(elements[3]), ",").concat(epsilon(elements[4]), ",").concat(epsilon(-elements[5]), ",").concat(epsilon(elements[6]), ",").concat(epsilon(elements[7]), ",").concat(epsilon(elements[8]), ",").concat(epsilon(-elements[9]), ",").concat(epsilon(elements[10]), ",").concat(epsilon(elements[11]), ",").concat(epsilon(elements[12]), ",").concat(epsilon(-elements[13]), ",").concat(epsilon(elements[14]), ",").concat(epsilon(elements[15]), ")");
              if (camera instanceof OrthographicCamera) {
                var tx = -(camera.right + camera.left) / 2;
                var ty = (camera.top + camera.bottom) / 2;
                return "scale(".concat(fov, ")translate(").concat(epsilon(tx), "px,").concat(epsilon(ty), "px)").concat(matrixCSS);
              }
              return "translateZ(".concat(fov, "px)").concat(matrixCSS);
            };
            _this146.getObjectCSSMatrix = function (matrix, cameraCSSMatrix) {
              var _this148 = _this146,
                epsilon = _this148.epsilon;
              var elements = matrix.elements;
              // prettier-ignore
              var matrix3d = "matrix3d(".concat(epsilon(elements[0]), ",").concat(epsilon(elements[1]), ",").concat(epsilon(elements[2]), ",").concat(epsilon(elements[3]), ",").concat(epsilon(-elements[4]), ",").concat(epsilon(-elements[5]), ",").concat(epsilon(-elements[6]), ",").concat(epsilon(-elements[7]), ",").concat(epsilon(elements[8]), ",").concat(epsilon(elements[9]), ",").concat(epsilon(elements[10]), ",").concat(epsilon(elements[11]), ",").concat(epsilon(elements[12]), ",").concat(epsilon(elements[13]), ",").concat(epsilon(elements[14]), ",").concat(epsilon(elements[15]), ")");
              // prettier-ignore
              if (_this146.isIE) {
                return "translate(-50%,-50%)translate(".concat(_this146._widthHalf, "px,").concat(_this146._heightHalf, "px)").concat(cameraCSSMatrix).concat(matrix3d);
              }
              return "translate(-50%,-50%)".concat(matrix3d);
            };
            _this146.renderObject = function (object, scene, camera, cameraCSSMatrix) {
              var _this149 = _this146,
                matrix = _this149.matrix,
                getObjectCSSMatrix = _this149.getObjectCSSMatrix,
                cache = _this149.cache,
                cameraElement = _this149.cameraElement,
                renderObject = _this149.renderObject,
                isIE = _this149.isIE,
                getDistanceToSquared = _this149.getDistanceToSquared;
              if (object instanceof CSS3DObject) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                object.onBeforeRender(_this146, scene, camera);
                var style;
                if (object instanceof CSS3DSprite) {
                  // http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/
                  matrix.copy(camera.matrixWorldInverse);
                  // Get the inverse transforms
                  matrix.transpose();
                  // NOTE: The euler interp is probably cause Gimbal lock
                  // Convert the rotation part to euler to merge by ratio
                  // this._spriteEuler.setFromRotationMatrix(matrix); // camera inverse part
                  // this._objectEuler.setFromRotationMatrix(object.matrixWorld); // object rotation part
                  // this._spriteEuler.x = this._spriteEuler.x * object.spriteRatio + this._objectEuler.x * (1 - object.spriteRatio);
                  // this._spriteEuler.y = this._spriteEuler.y * object.spriteRatio + this._objectEuler.y * (1 - object.spriteRatio);
                  // this._spriteEuler.z = this._spriteEuler.z * object.spriteRatio + this._objectEuler.z * (1 - object.spriteRatio);
                  // matrix.makeRotationFromEuler(this._spriteEuler);
                  _this146._spriteQuat.setFromRotationMatrix(matrix);
                  _this146._objectQuat.setFromRotationMatrix(object.matrixWorld);
                  _this146._objectQuat.slerp(_this146._spriteQuat, object.spriteRatio);
                  matrix.makeRotationFromQuaternion(_this146._objectQuat);
                  matrix.copyPosition(object.matrixWorld);
                  matrix.scale(object.scale);
                  matrix.elements[3] = 0;
                  matrix.elements[7] = 0;
                  matrix.elements[11] = 0;
                  matrix.elements[15] = 1;
                  // save current computed sprite matrix
                  object.spriteMatrixWorld.copy(matrix);
                  style = getObjectCSSMatrix(matrix, cameraCSSMatrix);
                } else {
                  style = getObjectCSSMatrix(object.matrixWorld, cameraCSSMatrix);
                }
                var element = object.element;
                var cachedObject = cache.objects.get(object);
                if (cachedObject === undefined || cachedObject.style !== style) {
                  element.style.transform = style;
                  var objectData = {
                    style: style
                  };
                  cache.objects.set(object, objectData);
                  if (isIE) {
                    objectData.distanceToCameraSquared = getDistanceToSquared(camera, object);
                  }
                }
                element.style.display = object.visible ? '' : 'none';
                if (element.parentNode !== cameraElement) {
                  cameraElement.appendChild(element);
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                object.onAfterRender(_this146, scene, camera);
              }
              for (var i = 0, l = object.children.length; i < l; i++) {
                renderObject(object.children[i], scene, camera, cameraCSSMatrix);
              }
            };
            var domElement = document.createElement('div');
            _this146.domElement = domElement;
            domElement.style.overflow = 'hidden';
            var cameraElement = document.createElement('div');
            _this146.cameraElement = cameraElement;
            cameraElement.style.transformStyle = 'preserve-3d';
            domElement.appendChild(cameraElement);
            _this146.isIE = /Trident/i.test(navigator.userAgent);
            return _this146;
          }
          _inherits(CSS3DRenderer, _EventDispatcher9);
          return _createClass(CSS3DRenderer, [{
            key: "zOrder",
            value: function zOrder(scene) {
              var cache = this.cache;
              var items = [];
              scene.traverse(function (obj) {
                var object = obj;
                if (cache.objects.has(object)) {
                  items.push({
                    object: object,
                    data: cache.objects.get(object)
                  });
                }
              });
              var order = items.sort(function (a, b) {
                return (
                  // Only for IE, property is guaranteed to exist
                  a.data.distanceToCameraSquared - b.data.distanceToCameraSquared
                );
              });
              var zMax = order.length;
              order.forEach(function (info, index) {
                var object = info.object;
                object.element.style.zIndex = "".concat(zMax - index);
              });
            }
          }, {
            key: "setClearColor",
            value: function setClearColor() {
              /* noop */
            }
            /**
             * Get the size of container element.
             * @returns
             */
          }, {
            key: "getSize",
            value: function getSize() {
              return {
                width: this._width,
                height: this._height
              };
            }
            /**
             * Set the size of container element.
             * @param width The width of element
             * @param height The height of element
             */
          }, {
            key: "setSize",
            value: function setSize(width, height) {
              this._width = width;
              this._height = height;
              this._widthHalf = this._width / 2;
              this._heightHalf = this._height / 2;
              this.domElement.style.width = "".concat(width, "px");
              this.domElement.style.height = "".concat(height, "px");
              this.cameraElement.style.width = "".concat(width, "px");
              this.cameraElement.style.height = "".concat(height, "px");
            }
            /**
             * Update CSS3D scene.
             * @param scene Three.js scene
             * @param camera Three.js camera
             */
          }, {
            key: "render",
            value: function render(scene, camera) {
              var _heightHalf = this._heightHalf,
                _widthHalf = this._widthHalf,
                isIE = this.isIE,
                cameraElement = this.cameraElement,
                cache = this.cache,
                domElement = this.domElement,
                getCameraCSSMatrix = this.getCameraCSSMatrix,
                zOrder = this.zOrder,
                renderObject = this.renderObject;
              var fov = camera.projectionMatrix.elements[5] * _heightHalf;
              if (cache.camera.fov !== fov) {
                domElement.style.perspective = "".concat(fov, "px");
                cache.camera.fov = fov;
              }
              // compatible for old version of three.js
              if (scene.matrixAutoUpdate && scene.matrixAutoUpdate === true ||
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              scene.autoUpdate === true) {
                scene.updateMatrixWorld();
              }
              if (camera.parent === null) camera.updateMatrixWorld();
              var cameraCSSMatrix = getCameraCSSMatrix(camera.matrixWorldInverse, camera, fov);
              var style = "".concat(cameraCSSMatrix, "translate(").concat(_widthHalf, "px,").concat(_heightHalf, "px)");
              if (cache.camera.style !== style && !isIE) {
                cameraElement.style.transform = style;
                cache.camera.style = style;
              }
              renderObject(scene, scene, camera, cameraCSSMatrix);
              if (isIE) {
                // IE10 and 11 does not support 'preserve-3d'.
                // Thus, z-order in 3D will not work.
                // We have to calc z-order manually and set CSS z-index for IE.
                // FYI: z-index can't handle object intersection
                zOrder(scene);
              }
            }
          }]);
        }(EventDispatcher);
        var _changeEvent = {
          type: 'change'
        };
        var _startEvent = {
          type: 'start'
        };
        var _endEvent = {
          type: 'end'
        };
        var TrackballControls = /*#__PURE__*/function (_EventDispatcher10) {
          function TrackballControls(object, domElement) {
            var _this150;
            _classCallCheck2(this, TrackballControls);
            _this150 = _callSuper(this, TrackballControls);
            var scope = _this150;
            var STATE = {
              NONE: -1,
              ROTATE: 0,
              ZOOM: 1,
              PAN: 2,
              TOUCH_ROTATE: 3,
              TOUCH_ZOOM_PAN: 4
            };
            _this150.object = object;
            _this150.domElement = domElement;
            _this150.domElement.style.touchAction = 'none'; // disable touch scroll

            // API

            _this150.enabled = true;
            _this150.screen = {
              left: 0,
              top: 0,
              width: 0,
              height: 0
            };
            _this150.rotateSpeed = 1.0;
            _this150.zoomSpeed = 1.2;
            _this150.panSpeed = 0.3;
            _this150.noRotate = false;
            _this150.noZoom = false;
            _this150.noPan = false;
            _this150.staticMoving = false;
            _this150.dynamicDampingFactor = 0.2;
            _this150.minDistance = 0;
            _this150.maxDistance = Infinity;
            _this150.minZoom = 0;
            _this150.maxZoom = Infinity;
            _this150.keys = ['KeyA' /*A*/, 'KeyS' /*S*/, 'KeyD' /*D*/];
            _this150.mouseButtons = {
              LEFT: MOUSE.ROTATE,
              MIDDLE: MOUSE.DOLLY,
              RIGHT: MOUSE.PAN
            };

            // internals

            _this150.target = new Vector3();
            var EPS = 0.000001;
            var lastPosition = new Vector3();
            var lastZoom = 1;
            var _state = STATE.NONE,
              _keyState = STATE.NONE,
              _touchZoomDistanceStart = 0,
              _touchZoomDistanceEnd = 0,
              _lastAngle = 0;
            var _eye = new Vector3(),
              _movePrev = new Vector2(),
              _moveCurr = new Vector2(),
              _lastAxis = new Vector3(),
              _zoomStart = new Vector2(),
              _zoomEnd = new Vector2(),
              _panStart = new Vector2(),
              _panEnd = new Vector2(),
              _pointers = [],
              _pointerPositions = {};

            // for reset

            _this150.target0 = _this150.target.clone();
            _this150.position0 = _this150.object.position.clone();
            _this150.up0 = _this150.object.up.clone();
            _this150.zoom0 = _this150.object.zoom;

            // methods

            _this150.handleResize = function () {
              var box = scope.domElement.getBoundingClientRect();
              // adjustments come from similar code in the jquery offset() function
              var d = scope.domElement.ownerDocument.documentElement;
              scope.screen.left = box.left + window.pageXOffset - d.clientLeft;
              scope.screen.top = box.top + window.pageYOffset - d.clientTop;
              scope.screen.width = box.width;
              scope.screen.height = box.height;
            };
            var getMouseOnScreen = function () {
              var vector = new Vector2();
              return function getMouseOnScreen(pageX, pageY) {
                vector.set((pageX - scope.screen.left) / scope.screen.width, (pageY - scope.screen.top) / scope.screen.height);
                return vector;
              };
            }();
            var getMouseOnCircle = function () {
              var vector = new Vector2();
              return function getMouseOnCircle(pageX, pageY) {
                vector.set((pageX - scope.screen.width * 0.5 - scope.screen.left) / (scope.screen.width * 0.5), (scope.screen.height + 2 * (scope.screen.top - pageY)) / scope.screen.width // screen.width intentional
                );
                return vector;
              };
            }();
            _this150.rotateCamera = function () {
              var axis = new Vector3(),
                quaternion = new Quaternion(),
                eyeDirection = new Vector3(),
                objectUpDirection = new Vector3(),
                objectSidewaysDirection = new Vector3(),
                moveDirection = new Vector3();
              return function rotateCamera() {
                moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);
                var angle = moveDirection.length();
                if (angle) {
                  _eye.copy(scope.object.position).sub(scope.target);
                  eyeDirection.copy(_eye).normalize();
                  objectUpDirection.copy(scope.object.up).normalize();
                  objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();
                  objectUpDirection.setLength(_moveCurr.y - _movePrev.y);
                  objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);
                  moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));
                  axis.crossVectors(moveDirection, _eye).normalize();
                  angle *= scope.rotateSpeed;
                  quaternion.setFromAxisAngle(axis, angle);
                  _eye.applyQuaternion(quaternion);
                  scope.object.up.applyQuaternion(quaternion);
                  _lastAxis.copy(axis);
                  _lastAngle = angle;
                } else if (!scope.staticMoving && _lastAngle) {
                  _lastAngle *= Math.sqrt(1.0 - scope.dynamicDampingFactor);
                  _eye.copy(scope.object.position).sub(scope.target);
                  quaternion.setFromAxisAngle(_lastAxis, _lastAngle);
                  _eye.applyQuaternion(quaternion);
                  scope.object.up.applyQuaternion(quaternion);
                }
                _movePrev.copy(_moveCurr);
              };
            }();
            _this150.zoomCamera = function () {
              var factor;
              if (_state === STATE.TOUCH_ZOOM_PAN) {
                factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
                _touchZoomDistanceStart = _touchZoomDistanceEnd;
                if (scope.object.isPerspectiveCamera) {
                  _eye.multiplyScalar(factor);
                } else if (scope.object.isOrthographicCamera) {
                  scope.object.zoom = MathUtils.clamp(scope.object.zoom / factor, scope.minZoom, scope.maxZoom);
                  if (lastZoom !== scope.object.zoom) {
                    scope.object.updateProjectionMatrix();
                  }
                } else {
                  console.warn('THREE.TrackballControls: Unsupported camera type');
                }
              } else {
                factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * scope.zoomSpeed;
                if (factor !== 1.0 && factor > 0.0) {
                  if (scope.object.isPerspectiveCamera) {
                    _eye.multiplyScalar(factor);
                  } else if (scope.object.isOrthographicCamera) {
                    scope.object.zoom = MathUtils.clamp(scope.object.zoom / factor, scope.minZoom, scope.maxZoom);
                    if (lastZoom !== scope.object.zoom) {
                      scope.object.updateProjectionMatrix();
                    }
                  } else {
                    console.warn('THREE.TrackballControls: Unsupported camera type');
                  }
                }
                if (scope.staticMoving) {
                  _zoomStart.copy(_zoomEnd);
                } else {
                  _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
                }
              }
            };
            _this150.panCamera = function () {
              var mouseChange = new Vector2(),
                objectUp = new Vector3(),
                pan = new Vector3();
              return function panCamera() {
                mouseChange.copy(_panEnd).sub(_panStart);
                if (mouseChange.lengthSq()) {
                  if (scope.object.isOrthographicCamera) {
                    var scale_x = (scope.object.right - scope.object.left) / scope.object.zoom / scope.domElement.clientWidth;
                    var scale_y = (scope.object.top - scope.object.bottom) / scope.object.zoom / scope.domElement.clientWidth;
                    mouseChange.x *= scale_x;
                    mouseChange.y *= scale_y;
                  }
                  mouseChange.multiplyScalar(_eye.length() * scope.panSpeed);
                  pan.copy(_eye).cross(scope.object.up).setLength(mouseChange.x);
                  pan.add(objectUp.copy(scope.object.up).setLength(mouseChange.y));
                  scope.object.position.add(pan);
                  scope.target.add(pan);
                  if (scope.staticMoving) {
                    _panStart.copy(_panEnd);
                  } else {
                    _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(scope.dynamicDampingFactor));
                  }
                }
              };
            }();
            _this150.checkDistances = function () {
              if (!scope.noZoom || !scope.noPan) {
                if (_eye.lengthSq() > scope.maxDistance * scope.maxDistance) {
                  scope.object.position.addVectors(scope.target, _eye.setLength(scope.maxDistance));
                  _zoomStart.copy(_zoomEnd);
                }
                if (_eye.lengthSq() < scope.minDistance * scope.minDistance) {
                  scope.object.position.addVectors(scope.target, _eye.setLength(scope.minDistance));
                  _zoomStart.copy(_zoomEnd);
                }
              }
            };
            _this150.update = function () {
              _eye.subVectors(scope.object.position, scope.target);
              if (!scope.noRotate) {
                scope.rotateCamera();
              }
              if (!scope.noZoom) {
                scope.zoomCamera();
              }
              if (!scope.noPan) {
                scope.panCamera();
              }
              scope.object.position.addVectors(scope.target, _eye);
              if (scope.object.isPerspectiveCamera) {
                scope.checkDistances();
                scope.object.lookAt(scope.target);
                if (lastPosition.distanceToSquared(scope.object.position) > EPS) {
                  scope.dispatchEvent(_changeEvent);
                  lastPosition.copy(scope.object.position);
                }
              } else if (scope.object.isOrthographicCamera) {
                scope.object.lookAt(scope.target);
                if (lastPosition.distanceToSquared(scope.object.position) > EPS || lastZoom !== scope.object.zoom) {
                  scope.dispatchEvent(_changeEvent);
                  lastPosition.copy(scope.object.position);
                  lastZoom = scope.object.zoom;
                }
              } else {
                console.warn('THREE.TrackballControls: Unsupported camera type');
              }
            };
            _this150.reset = function () {
              _state = STATE.NONE;
              _keyState = STATE.NONE;
              scope.target.copy(scope.target0);
              scope.object.position.copy(scope.position0);
              scope.object.up.copy(scope.up0);
              scope.object.zoom = scope.zoom0;
              scope.object.updateProjectionMatrix();
              _eye.subVectors(scope.object.position, scope.target);
              scope.object.lookAt(scope.target);
              scope.dispatchEvent(_changeEvent);
              lastPosition.copy(scope.object.position);
              lastZoom = scope.object.zoom;
            };

            // listeners

            function onPointerDown(event) {
              if (scope.enabled === false) return;
              if (_pointers.length === 0) {
                scope.domElement.setPointerCapture(event.pointerId);
                scope.domElement.addEventListener('pointermove', onPointerMove);
                scope.domElement.addEventListener('pointerup', onPointerUp);
              }

              //

              addPointer(event);
              if (event.pointerType === 'touch') {
                onTouchStart(event);
              } else {
                onMouseDown(event);
              }
            }
            function onPointerMove(event) {
              if (scope.enabled === false) return;
              if (event.pointerType === 'touch') {
                onTouchMove(event);
              } else {
                onMouseMove(event);
              }
            }
            function onPointerUp(event) {
              if (scope.enabled === false) return;
              if (event.pointerType === 'touch') {
                onTouchEnd(event);
              } else {
                onMouseUp();
              }

              //

              removePointer(event);
              if (_pointers.length === 0) {
                scope.domElement.releasePointerCapture(event.pointerId);
                scope.domElement.removeEventListener('pointermove', onPointerMove);
                scope.domElement.removeEventListener('pointerup', onPointerUp);
              }
            }
            function onPointerCancel(event) {
              removePointer(event);
            }
            function keydown(event) {
              if (scope.enabled === false) return;
              window.removeEventListener('keydown', keydown);
              if (_keyState !== STATE.NONE) {
                return;
              } else if (event.code === scope.keys[STATE.ROTATE] && !scope.noRotate) {
                _keyState = STATE.ROTATE;
              } else if (event.code === scope.keys[STATE.ZOOM] && !scope.noZoom) {
                _keyState = STATE.ZOOM;
              } else if (event.code === scope.keys[STATE.PAN] && !scope.noPan) {
                _keyState = STATE.PAN;
              }
            }
            function keyup() {
              if (scope.enabled === false) return;
              _keyState = STATE.NONE;
              window.addEventListener('keydown', keydown);
            }
            function onMouseDown(event) {
              if (_state === STATE.NONE) {
                switch (event.button) {
                  case scope.mouseButtons.LEFT:
                    _state = STATE.ROTATE;
                    break;
                  case scope.mouseButtons.MIDDLE:
                    _state = STATE.ZOOM;
                    break;
                  case scope.mouseButtons.RIGHT:
                    _state = STATE.PAN;
                    break;
                }
              }
              var state = _keyState !== STATE.NONE ? _keyState : _state;
              if (state === STATE.ROTATE && !scope.noRotate) {
                _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
                _movePrev.copy(_moveCurr);
              } else if (state === STATE.ZOOM && !scope.noZoom) {
                _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
                _zoomEnd.copy(_zoomStart);
              } else if (state === STATE.PAN && !scope.noPan) {
                _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
                _panEnd.copy(_panStart);
              }
              scope.dispatchEvent(_startEvent);
            }
            function onMouseMove(event) {
              var state = _keyState !== STATE.NONE ? _keyState : _state;
              if (state === STATE.ROTATE && !scope.noRotate) {
                _movePrev.copy(_moveCurr);
                _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
              } else if (state === STATE.ZOOM && !scope.noZoom) {
                _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
              } else if (state === STATE.PAN && !scope.noPan) {
                _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
              }
            }
            function onMouseUp() {
              _state = STATE.NONE;
              scope.dispatchEvent(_endEvent);
            }
            function onMouseWheel(event) {
              if (scope.enabled === false) return;
              if (scope.noZoom === true) return;
              event.preventDefault();
              switch (event.deltaMode) {
                case 2:
                  // Zoom in pages
                  _zoomStart.y -= event.deltaY * 0.025;
                  break;
                case 1:
                  // Zoom in lines
                  _zoomStart.y -= event.deltaY * 0.01;
                  break;
                default:
                  // undefined, 0, assume pixels
                  _zoomStart.y -= event.deltaY * 0.00025;
                  break;
              }
              scope.dispatchEvent(_startEvent);
              scope.dispatchEvent(_endEvent);
            }
            function onTouchStart(event) {
              trackPointer(event);
              switch (_pointers.length) {
                case 1:
                  _state = STATE.TOUCH_ROTATE;
                  _moveCurr.copy(getMouseOnCircle(_pointers[0].pageX, _pointers[0].pageY));
                  _movePrev.copy(_moveCurr);
                  break;
                default:
                  // 2 or more
                  _state = STATE.TOUCH_ZOOM_PAN;
                  var dx = _pointers[0].pageX - _pointers[1].pageX;
                  var dy = _pointers[0].pageY - _pointers[1].pageY;
                  _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
                  var x = (_pointers[0].pageX + _pointers[1].pageX) / 2;
                  var y = (_pointers[0].pageY + _pointers[1].pageY) / 2;
                  _panStart.copy(getMouseOnScreen(x, y));
                  _panEnd.copy(_panStart);
                  break;
              }
              scope.dispatchEvent(_startEvent);
            }
            function onTouchMove(event) {
              trackPointer(event);
              switch (_pointers.length) {
                case 1:
                  _movePrev.copy(_moveCurr);
                  _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
                  break;
                default:
                  // 2 or more

                  var position = getSecondPointerPosition(event);
                  var dx = event.pageX - position.x;
                  var dy = event.pageY - position.y;
                  _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
                  var x = (event.pageX + position.x) / 2;
                  var y = (event.pageY + position.y) / 2;
                  _panEnd.copy(getMouseOnScreen(x, y));
                  break;
              }
            }
            function onTouchEnd(event) {
              switch (_pointers.length) {
                case 0:
                  _state = STATE.NONE;
                  break;
                case 1:
                  _state = STATE.TOUCH_ROTATE;
                  _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
                  _movePrev.copy(_moveCurr);
                  break;
                case 2:
                  _state = STATE.TOUCH_ZOOM_PAN;
                  for (var i = 0; i < _pointers.length; i++) {
                    if (_pointers[i].pointerId !== event.pointerId) {
                      var position = _pointerPositions[_pointers[i].pointerId];
                      _moveCurr.copy(getMouseOnCircle(position.x, position.y));
                      _movePrev.copy(_moveCurr);
                      break;
                    }
                  }
                  break;
              }
              scope.dispatchEvent(_endEvent);
            }
            function contextmenu(event) {
              if (scope.enabled === false) return;
              event.preventDefault();
            }
            function addPointer(event) {
              _pointers.push(event);
            }
            function removePointer(event) {
              delete _pointerPositions[event.pointerId];
              for (var i = 0; i < _pointers.length; i++) {
                if (_pointers[i].pointerId == event.pointerId) {
                  _pointers.splice(i, 1);
                  return;
                }
              }
            }
            function trackPointer(event) {
              var position = _pointerPositions[event.pointerId];
              if (position === undefined) {
                position = new Vector2();
                _pointerPositions[event.pointerId] = position;
              }
              position.set(event.pageX, event.pageY);
            }
            function getSecondPointerPosition(event) {
              var pointer = event.pointerId === _pointers[0].pointerId ? _pointers[1] : _pointers[0];
              return _pointerPositions[pointer.pointerId];
            }
            _this150.dispose = function () {
              scope.domElement.removeEventListener('contextmenu', contextmenu);
              scope.domElement.removeEventListener('pointerdown', onPointerDown);
              scope.domElement.removeEventListener('pointercancel', onPointerCancel);
              scope.domElement.removeEventListener('wheel', onMouseWheel);
              scope.domElement.removeEventListener('pointermove', onPointerMove);
              scope.domElement.removeEventListener('pointerup', onPointerUp);
              window.removeEventListener('keydown', keydown);
              window.removeEventListener('keyup', keyup);
            };
            _this150.domElement.addEventListener('contextmenu', contextmenu);
            _this150.domElement.addEventListener('pointerdown', onPointerDown);
            _this150.domElement.addEventListener('pointercancel', onPointerCancel);
            _this150.domElement.addEventListener('wheel', onMouseWheel, {
              passive: false
            });
            window.addEventListener('keydown', keydown);
            window.addEventListener('keyup', keyup);
            _this150.handleResize();

            // force an update at start
            _this150.update();
            return _this150;
          }
          _inherits(TrackballControls, _EventDispatcher10);
          return _createClass(TrackballControls);
        }(EventDispatcher);
        /*!
          * vue-router v4.5.0
          * (c) 2024 Eduardo San Martin Morote
          * @license MIT
          */
        var isBrowser = typeof document !== "undefined";
        function isRouteComponent(component) {
          return _typeof2(component) === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
        }
        function isESModule(obj) {
          return obj.__esModule || obj[Symbol.toStringTag] === "Module" ||
          // support CF with dynamic imports that do not
          // add the Module string tag
          obj.default && isRouteComponent(obj.default);
        }
        var assign = Object.assign;
        function applyToParams(fn, params) {
          var newParams = {};
          for (var key in params) {
            var value = params[key];
            newParams[key] = isArray(value) ? value.map(fn) : fn(value);
          }
          return newParams;
        }
        var noop = function noop() {};
        var isArray = Array.isArray;
        var HASH_RE = /#/g;
        var AMPERSAND_RE = /&/g;
        var SLASH_RE = /\//g;
        var EQUAL_RE = /=/g;
        var IM_RE = /\?/g;
        var PLUS_RE = /\+/g;
        var ENC_BRACKET_OPEN_RE = /%5B/g;
        var ENC_BRACKET_CLOSE_RE = /%5D/g;
        var ENC_CARET_RE = /%5E/g;
        var ENC_BACKTICK_RE = /%60/g;
        var ENC_CURLY_OPEN_RE = /%7B/g;
        var ENC_PIPE_RE = /%7C/g;
        var ENC_CURLY_CLOSE_RE = /%7D/g;
        var ENC_SPACE_RE = /%20/g;
        function commonEncode(text) {
          return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
        }
        function encodeHash(text) {
          return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
        }
        function encodeQueryValue(text) {
          return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
        }
        function encodeQueryKey(text) {
          return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
        }
        function encodePath(text) {
          return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
        }
        function encodeParam(text) {
          return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
        }
        function decode(text) {
          try {
            return decodeURIComponent("" + text);
          } catch (err) {}
          return "" + text;
        }
        var TRAILING_SLASH_RE = /\/$/;
        var removeTrailingSlash = function removeTrailingSlash(path) {
          return path.replace(TRAILING_SLASH_RE, "");
        };
        function parseURL(parseQuery2, location2) {
          var currentLocation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "/";
          var path,
            query = {},
            searchString = "",
            hash = "";
          var hashPos = location2.indexOf("#");
          var searchPos = location2.indexOf("?");
          if (hashPos < searchPos && hashPos >= 0) {
            searchPos = -1;
          }
          if (searchPos > -1) {
            path = location2.slice(0, searchPos);
            searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
            query = parseQuery2(searchString);
          }
          if (hashPos > -1) {
            path = path || location2.slice(0, hashPos);
            hash = location2.slice(hashPos, location2.length);
          }
          path = resolveRelativePath(path != null ? path : location2, currentLocation);
          return {
            fullPath: path + (searchString && "?") + searchString + hash,
            path: path,
            query: query,
            hash: decode(hash)
          };
        }
        function stringifyURL(stringifyQuery2, location2) {
          var query = location2.query ? stringifyQuery2(location2.query) : "";
          return location2.path + (query && "?") + query + (location2.hash || "");
        }
        function stripBase(pathname, base) {
          if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase())) return pathname;
          return pathname.slice(base.length) || "/";
        }
        function isSameRouteLocation(stringifyQuery2, a, b) {
          var aLastIndex = a.matched.length - 1;
          var bLastIndex = b.matched.length - 1;
          return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
        }
        function isSameRouteRecord(a, b) {
          return (a.aliasOf || a) === (b.aliasOf || b);
        }
        function isSameRouteLocationParams(a, b) {
          if (Object.keys(a).length !== Object.keys(b).length) return false;
          for (var key in a) {
            if (!isSameRouteLocationParamsValue(a[key], b[key])) return false;
          }
          return true;
        }
        function isSameRouteLocationParamsValue(a, b) {
          return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;
        }
        function isEquivalentArray(a, b) {
          return isArray(b) ? a.length === b.length && a.every(function (value, i) {
            return value === b[i];
          }) : a.length === 1 && a[0] === b;
        }
        function resolveRelativePath(to, from) {
          if (to.startsWith("/")) return to;
          if (!to) return from;
          var fromSegments = from.split("/");
          var toSegments = to.split("/");
          var lastToSegment = toSegments[toSegments.length - 1];
          if (lastToSegment === ".." || lastToSegment === ".") {
            toSegments.push("");
          }
          var position = fromSegments.length - 1;
          var toPosition;
          var segment;
          for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
            segment = toSegments[toPosition];
            if (segment === ".") continue;
            if (segment === "..") {
              if (position > 1) position--;
            } else break;
          }
          return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition).join("/");
        }
        var START_LOCATION_NORMALIZED = {
          path: "/",
          // TODO: could we use a symbol in the future?
          name: void 0,
          params: {},
          query: {},
          hash: "",
          fullPath: "/",
          matched: [],
          meta: {},
          redirectedFrom: void 0
        };
        var NavigationType;
        (function (NavigationType2) {
          NavigationType2["pop"] = "pop";
          NavigationType2["push"] = "push";
        })(NavigationType || (NavigationType = {}));
        var NavigationDirection;
        (function (NavigationDirection2) {
          NavigationDirection2["back"] = "back";
          NavigationDirection2["forward"] = "forward";
          NavigationDirection2["unknown"] = "";
        })(NavigationDirection || (NavigationDirection = {}));
        function normalizeBase(base) {
          if (!base) {
            if (isBrowser) {
              var baseEl = document.querySelector("base");
              base = baseEl && baseEl.getAttribute("href") || "/";
              base = base.replace(/^\w+:\/\/[^\/]+/, "");
            } else {
              base = "/";
            }
          }
          if (base[0] !== "/" && base[0] !== "#") base = "/" + base;
          return removeTrailingSlash(base);
        }
        var BEFORE_HASH_RE = /^[^#]+#/;
        function createHref(base, location2) {
          return base.replace(BEFORE_HASH_RE, "#") + location2;
        }
        function getElementPosition(el, offset) {
          var docRect = document.documentElement.getBoundingClientRect();
          var elRect = el.getBoundingClientRect();
          return {
            behavior: offset.behavior,
            left: elRect.left - docRect.left - (offset.left || 0),
            top: elRect.top - docRect.top - (offset.top || 0)
          };
        }
        var computeScrollPosition = function computeScrollPosition() {
          return {
            left: window.scrollX,
            top: window.scrollY
          };
        };
        function scrollToPosition(position) {
          var scrollToOptions;
          if ("el" in position) {
            var positionEl = position.el;
            var isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
            var el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
            if (!el) {
              return;
            }
            scrollToOptions = getElementPosition(el, position);
          } else {
            scrollToOptions = position;
          }
          if ("scrollBehavior" in document.documentElement.style) window.scrollTo(scrollToOptions);else {
            window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
          }
        }
        function getScrollKey(path, delta) {
          var position = history.state ? history.state.position - delta : -1;
          return position + path;
        }
        var scrollPositions = /* @__PURE__ */new Map();
        function saveScrollPosition(key, scrollPosition) {
          scrollPositions.set(key, scrollPosition);
        }
        function getSavedScrollPosition(key) {
          var scroll = scrollPositions.get(key);
          scrollPositions.delete(key);
          return scroll;
        }
        var createBaseLocation = function createBaseLocation() {
          return location.protocol + "//" + location.host;
        };
        function createCurrentLocation(base, location2) {
          var pathname = location2.pathname,
            search = location2.search,
            hash = location2.hash;
          var hashPos = base.indexOf("#");
          if (hashPos > -1) {
            var slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
            var pathFromHash = hash.slice(slicePos);
            if (pathFromHash[0] !== "/") pathFromHash = "/" + pathFromHash;
            return stripBase(pathFromHash, "");
          }
          var path = stripBase(pathname, base);
          return path + search + hash;
        }
        function useHistoryListeners(base, historyState, currentLocation, replace) {
          var listeners = [];
          var teardowns = [];
          var pauseState = null;
          var popStateHandler = function popStateHandler(_ref71) {
            var state = _ref71.state;
            var to = createCurrentLocation(base, location);
            var from = currentLocation.value;
            var fromState = historyState.value;
            var delta = 0;
            if (state) {
              currentLocation.value = to;
              historyState.value = state;
              if (pauseState && pauseState === from) {
                pauseState = null;
                return;
              }
              delta = fromState ? state.position - fromState.position : 0;
            } else {
              replace(to);
            }
            listeners.forEach(function (listener) {
              listener(currentLocation.value, from, {
                delta: delta,
                type: NavigationType.pop,
                direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
              });
            });
          };
          function pauseListeners() {
            pauseState = currentLocation.value;
          }
          function listen(callback) {
            listeners.push(callback);
            var teardown = function teardown() {
              var index = listeners.indexOf(callback);
              if (index > -1) listeners.splice(index, 1);
            };
            teardowns.push(teardown);
            return teardown;
          }
          function beforeUnloadListener() {
            var _window2 = window,
              history2 = _window2.history;
            if (!history2.state) return;
            history2.replaceState(assign({}, history2.state, {
              scroll: computeScrollPosition()
            }), "");
          }
          function destroy() {
            var _iterator27 = _createForOfIteratorHelper(teardowns),
              _step27;
            try {
              for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
                var teardown = _step27.value;
                teardown();
              }
            } catch (err) {
              _iterator27.e(err);
            } finally {
              _iterator27.f();
            }
            teardowns = [];
            window.removeEventListener("popstate", popStateHandler);
            window.removeEventListener("beforeunload", beforeUnloadListener);
          }
          window.addEventListener("popstate", popStateHandler);
          window.addEventListener("beforeunload", beforeUnloadListener, {
            passive: true
          });
          return {
            pauseListeners: pauseListeners,
            listen: listen,
            destroy: destroy
          };
        }
        function buildState(back, current, forward) {
          var replaced = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var computeScroll = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          return {
            back: back,
            current: current,
            forward: forward,
            replaced: replaced,
            position: window.history.length,
            scroll: computeScroll ? computeScrollPosition() : null
          };
        }
        function useHistoryStateNavigation(base) {
          var _window3 = window,
            history2 = _window3.history,
            location2 = _window3.location;
          var currentLocation = {
            value: createCurrentLocation(base, location2)
          };
          var historyState = {
            value: history2.state
          };
          if (!historyState.value) {
            changeLocation(currentLocation.value, {
              back: null,
              current: currentLocation.value,
              forward: null,
              // the length is off by one, we need to decrease it
              position: history2.length - 1,
              replaced: true,
              // don't add a scroll as the user may have an anchor, and we want
              // scrollBehavior to be triggered without a saved position
              scroll: null
            }, true);
          }
          function changeLocation(to, state, replace2) {
            var hashIndex = base.indexOf("#");
            var url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
            try {
              history2[replace2 ? "replaceState" : "pushState"](state, "", url);
              historyState.value = state;
            } catch (err) {
              {
                console.error(err);
              }
              location2[replace2 ? "replace" : "assign"](url);
            }
          }
          function replace(to, data) {
            var state = assign({}, history2.state, buildState(historyState.value.back,
            // keep back and forward entries but override current position
            to, historyState.value.forward, true), data, {
              position: historyState.value.position
            });
            changeLocation(to, state, true);
            currentLocation.value = to;
          }
          function push(to, data) {
            var currentState = assign({},
            // use current history state to gracefully handle a wrong call to
            // history.replaceState
            // https://github.com/vuejs/router/issues/366
            historyState.value, history2.state, {
              forward: to,
              scroll: computeScrollPosition()
            });
            changeLocation(currentState.current, currentState, true);
            var state = assign({}, buildState(currentLocation.value, to, null), {
              position: currentState.position + 1
            }, data);
            changeLocation(to, state, false);
            currentLocation.value = to;
          }
          return {
            location: currentLocation,
            state: historyState,
            push: push,
            replace: replace
          };
        }
        function createWebHistory(base) {
          base = normalizeBase(base);
          var historyNavigation = useHistoryStateNavigation(base);
          var historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
          function go(delta) {
            var triggerListeners = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            if (!triggerListeners) historyListeners.pauseListeners();
            history.go(delta);
          }
          var routerHistory = assign({
            // it's overridden right after
            location: "",
            base: base,
            go: go,
            createHref: createHref.bind(null, base)
          }, historyNavigation, historyListeners);
          Object.defineProperty(routerHistory, "location", {
            enumerable: true,
            get: function get() {
              return historyNavigation.location.value;
            }
          });
          Object.defineProperty(routerHistory, "state", {
            enumerable: true,
            get: function get() {
              return historyNavigation.state.value;
            }
          });
          return routerHistory;
        }
        function createWebHashHistory(base) {
          base = location.host ? base || location.pathname + location.search : "";
          if (!base.includes("#")) base += "#";
          return createWebHistory(base);
        }
        function isRouteLocation(route) {
          return typeof route === "string" || route && _typeof2(route) === "object";
        }
        function isRouteName(name) {
          return typeof name === "string" || _typeof2(name) === "symbol";
        }
        var NavigationFailureSymbol = Symbol("");
        var NavigationFailureType;
        (function (NavigationFailureType2) {
          NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
          NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
          NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
        })(NavigationFailureType || (NavigationFailureType = {}));
        function createRouterError(type, params) {
          {
            return assign(new Error(), _defineProperty2({
              type: type
            }, NavigationFailureSymbol, true), params);
          }
        }
        function isNavigationFailure(error, type) {
          return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
        }
        var BASE_PARAM_PATTERN = "[^/]+?";
        var BASE_PATH_PARSER_OPTIONS = {
          sensitive: false,
          strict: false,
          start: true,
          end: true
        };
        var REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
        function tokensToParser(segments, extraOptions) {
          var options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
          var score = [];
          var pattern = options.start ? "^" : "";
          var keys = [];
          var _iterator28 = _createForOfIteratorHelper(segments),
            _step28;
          try {
            for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
              var segment = _step28.value;
              var segmentScores = segment.length ? [] : [90
              /* PathScore.Root */];
              if (options.strict && !segment.length) pattern += "/";
              for (var tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
                var token = segment[tokenIndex];
                var subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
                if (token.type === 0) {
                  if (!tokenIndex) pattern += "/";
                  pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
                  subSegmentScore += 40;
                } else if (token.type === 1) {
                  var value = token.value,
                    repeatable = token.repeatable,
                    optional = token.optional,
                    regexp = token.regexp;
                  keys.push({
                    name: value,
                    repeatable: repeatable,
                    optional: optional
                  });
                  var re2 = regexp ? regexp : BASE_PARAM_PATTERN;
                  if (re2 !== BASE_PARAM_PATTERN) {
                    subSegmentScore += 10;
                    try {
                      new RegExp("(".concat(re2, ")"));
                    } catch (err) {
                      throw new Error("Invalid custom RegExp for param \"".concat(value, "\" (").concat(re2, "): ") + err.message);
                    }
                  }
                  var subPattern = repeatable ? "((?:".concat(re2, ")(?:/(?:").concat(re2, "))*)") : "(".concat(re2, ")");
                  if (!tokenIndex) subPattern =
                  // avoid an optional / if there are more segments e.g. /:p?-static
                  // or /:p?-:p2
                  optional && segment.length < 2 ? "(?:/".concat(subPattern, ")") : "/" + subPattern;
                  if (optional) subPattern += "?";
                  pattern += subPattern;
                  subSegmentScore += 20;
                  if (optional) subSegmentScore += -8;
                  if (repeatable) subSegmentScore += -20;
                  if (re2 === ".*") subSegmentScore += -50;
                }
                segmentScores.push(subSegmentScore);
              }
              score.push(segmentScores);
            }
          } catch (err) {
            _iterator28.e(err);
          } finally {
            _iterator28.f();
          }
          if (options.strict && options.end) {
            var i = score.length - 1;
            score[i][score[i].length - 1] += 0.7000000000000001;
          }
          if (!options.strict) pattern += "/?";
          if (options.end) pattern += "$";else if (options.strict && !pattern.endsWith("/")) pattern += "(?:/|$)";
          var re = new RegExp(pattern, options.sensitive ? "" : "i");
          function parse(path) {
            var match = path.match(re);
            var params = {};
            if (!match) return null;
            for (var _i108 = 1; _i108 < match.length; _i108++) {
              var value = match[_i108] || "";
              var key = keys[_i108 - 1];
              params[key.name] = value && key.repeatable ? value.split("/") : value;
            }
            return params;
          }
          function stringify(params) {
            var path = "";
            var avoidDuplicatedSlash = false;
            var _iterator29 = _createForOfIteratorHelper(segments),
              _step29;
            try {
              for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
                var segment = _step29.value;
                if (!avoidDuplicatedSlash || !path.endsWith("/")) path += "/";
                avoidDuplicatedSlash = false;
                var _iterator30 = _createForOfIteratorHelper(segment),
                  _step30;
                try {
                  for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
                    var token = _step30.value;
                    if (token.type === 0) {
                      path += token.value;
                    } else if (token.type === 1) {
                      var value = token.value,
                        repeatable = token.repeatable,
                        optional = token.optional;
                      var param = value in params ? params[value] : "";
                      if (isArray(param) && !repeatable) {
                        throw new Error("Provided param \"".concat(value, "\" is an array but it is not repeatable (* or + modifiers)"));
                      }
                      var _text = isArray(param) ? param.join("/") : param;
                      if (!_text) {
                        if (optional) {
                          if (segment.length < 2) {
                            if (path.endsWith("/")) path = path.slice(0, -1);else avoidDuplicatedSlash = true;
                          }
                        } else throw new Error("Missing required param \"".concat(value, "\""));
                      }
                      path += _text;
                    }
                  }
                } catch (err) {
                  _iterator30.e(err);
                } finally {
                  _iterator30.f();
                }
              }
            } catch (err) {
              _iterator29.e(err);
            } finally {
              _iterator29.f();
            }
            return path || "/";
          }
          return {
            re: re,
            score: score,
            keys: keys,
            parse: parse,
            stringify: stringify
          };
        }
        function compareScoreArray(a, b) {
          var i = 0;
          while (i < a.length && i < b.length) {
            var diff = b[i] - a[i];
            if (diff) return diff;
            i++;
          }
          if (a.length < b.length) {
            return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
          } else if (a.length > b.length) {
            return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
          }
          return 0;
        }
        function comparePathParserScore(a, b) {
          var i = 0;
          var aScore = a.score;
          var bScore = b.score;
          while (i < aScore.length && i < bScore.length) {
            var comp = compareScoreArray(aScore[i], bScore[i]);
            if (comp) return comp;
            i++;
          }
          if (Math.abs(bScore.length - aScore.length) === 1) {
            if (isLastScoreNegative(aScore)) return 1;
            if (isLastScoreNegative(bScore)) return -1;
          }
          return bScore.length - aScore.length;
        }
        function isLastScoreNegative(score) {
          var last = score[score.length - 1];
          return score.length > 0 && last[last.length - 1] < 0;
        }
        var ROOT_TOKEN = {
          type: 0,
          value: ""
        };
        var VALID_PARAM_RE = /[a-zA-Z0-9_]/;
        function tokenizePath(path) {
          if (!path) return [[]];
          if (path === "/") return [[ROOT_TOKEN]];
          if (!path.startsWith("/")) {
            throw new Error("Invalid path \"".concat(path, "\""));
          }
          function crash(message) {
            throw new Error("ERR (".concat(state, ")/\"").concat(buffer, "\": ").concat(message));
          }
          var state = 0;
          var previousState = state;
          var tokens = [];
          var segment;
          function finalizeSegment() {
            if (segment) tokens.push(segment);
            segment = [];
          }
          var i = 0;
          var char;
          var buffer = "";
          var customRe = "";
          function consumeBuffer() {
            if (!buffer) return;
            if (state === 0) {
              segment.push({
                type: 0,
                value: buffer
              });
            } else if (state === 1 || state === 2 || state === 3) {
              if (segment.length > 1 && (char === "*" || char === "+")) crash("A repeatable param (".concat(buffer, ") must be alone in its segment. eg: '/:ids+."));
              segment.push({
                type: 1,
                value: buffer,
                regexp: customRe,
                repeatable: char === "*" || char === "+",
                optional: char === "*" || char === "?"
              });
            } else {
              crash("Invalid state to consume buffer");
            }
            buffer = "";
          }
          function addCharToBuffer() {
            buffer += char;
          }
          while (i < path.length) {
            char = path[i++];
            if (char === "\\" && state !== 2) {
              previousState = state;
              state = 4;
              continue;
            }
            switch (state) {
              case 0:
                if (char === "/") {
                  if (buffer) {
                    consumeBuffer();
                  }
                  finalizeSegment();
                } else if (char === ":") {
                  consumeBuffer();
                  state = 1;
                } else {
                  addCharToBuffer();
                }
                break;
              case 4:
                addCharToBuffer();
                state = previousState;
                break;
              case 1:
                if (char === "(") {
                  state = 2;
                } else if (VALID_PARAM_RE.test(char)) {
                  addCharToBuffer();
                } else {
                  consumeBuffer();
                  state = 0;
                  if (char !== "*" && char !== "?" && char !== "+") i--;
                }
                break;
              case 2:
                if (char === ")") {
                  if (customRe[customRe.length - 1] == "\\") customRe = customRe.slice(0, -1) + char;else state = 3;
                } else {
                  customRe += char;
                }
                break;
              case 3:
                consumeBuffer();
                state = 0;
                if (char !== "*" && char !== "?" && char !== "+") i--;
                customRe = "";
                break;
              default:
                crash("Unknown state");
                break;
            }
          }
          if (state === 2) crash("Unfinished custom RegExp for param \"".concat(buffer, "\""));
          consumeBuffer();
          finalizeSegment();
          return tokens;
        }
        function createRouteRecordMatcher(record, parent, options) {
          var parser = tokensToParser(tokenizePath(record.path), options);
          var matcher = assign(parser, {
            record: record,
            parent: parent,
            // these needs to be populated by the parent
            children: [],
            alias: []
          });
          if (parent) {
            if (!matcher.record.aliasOf === !parent.record.aliasOf) parent.children.push(matcher);
          }
          return matcher;
        }
        function createRouterMatcher(routes, globalOptions) {
          var matchers = [];
          var matcherMap = /* @__PURE__ */new Map();
          globalOptions = mergeOptions({
            strict: false,
            end: true,
            sensitive: false
          }, globalOptions);
          function getRecordMatcher(name) {
            return matcherMap.get(name);
          }
          function addRoute(record, parent, originalRecord) {
            var isRootAdd = !originalRecord;
            var mainNormalizedRecord = normalizeRouteRecord(record);
            mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
            var options = mergeOptions(globalOptions, record);
            var normalizedRecords = [mainNormalizedRecord];
            if ("alias" in record) {
              var aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
              var _iterator31 = _createForOfIteratorHelper(aliases),
                _step31;
              try {
                for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
                  var alias = _step31.value;
                  normalizedRecords.push(
                  // we need to normalize again to ensure the `mods` property
                  // being non enumerable
                  normalizeRouteRecord(assign({}, mainNormalizedRecord, {
                    // this allows us to hold a copy of the `components` option
                    // so that async components cache is hold on the original record
                    components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
                    path: alias,
                    // we might be the child of an alias
                    aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
                    // the aliases are always of the same kind as the original since they
                    // are defined on the same record
                  })));
                }
              } catch (err) {
                _iterator31.e(err);
              } finally {
                _iterator31.f();
              }
            }
            var matcher;
            var originalMatcher;
            for (var _i109 = 0, _normalizedRecords = normalizedRecords; _i109 < _normalizedRecords.length; _i109++) {
              var normalizedRecord = _normalizedRecords[_i109];
              var path = normalizedRecord.path;
              if (parent && path[0] !== "/") {
                var parentPath = parent.record.path;
                var connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
                normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
              }
              matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
              if (originalRecord) {
                originalRecord.alias.push(matcher);
              } else {
                originalMatcher = originalMatcher || matcher;
                if (originalMatcher !== matcher) originalMatcher.alias.push(matcher);
                if (isRootAdd && record.name && !isAliasRecord(matcher)) {
                  removeRoute(record.name);
                }
              }
              if (isMatchable(matcher)) {
                insertMatcher(matcher);
              }
              if (mainNormalizedRecord.children) {
                var children = mainNormalizedRecord.children;
                for (var i = 0; i < children.length; i++) {
                  addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
                }
              }
              originalRecord = originalRecord || matcher;
            }
            return originalMatcher ? function () {
              removeRoute(originalMatcher);
            } : noop;
          }
          function removeRoute(matcherRef) {
            if (isRouteName(matcherRef)) {
              var matcher = matcherMap.get(matcherRef);
              if (matcher) {
                matcherMap.delete(matcherRef);
                matchers.splice(matchers.indexOf(matcher), 1);
                matcher.children.forEach(removeRoute);
                matcher.alias.forEach(removeRoute);
              }
            } else {
              var _index18 = matchers.indexOf(matcherRef);
              if (_index18 > -1) {
                matchers.splice(_index18, 1);
                if (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);
                matcherRef.children.forEach(removeRoute);
                matcherRef.alias.forEach(removeRoute);
              }
            }
          }
          function getRoutes() {
            return matchers;
          }
          function insertMatcher(matcher) {
            var index = findInsertionIndex(matcher, matchers);
            matchers.splice(index, 0, matcher);
            if (matcher.record.name && !isAliasRecord(matcher)) matcherMap.set(matcher.record.name, matcher);
          }
          function resolve(location2, currentLocation) {
            var matcher;
            var params = {};
            var path;
            var name;
            if ("name" in location2 && location2.name) {
              matcher = matcherMap.get(location2.name);
              if (!matcher) throw createRouterError(1, {
                location: location2
              });
              name = matcher.record.name;
              params = assign(
              // paramsFromLocation is a new object
              paramsFromLocation(currentLocation.params,
              // only keep params that exist in the resolved location
              // only keep optional params coming from a parent record
              matcher.keys.filter(function (k) {
                return !k.optional;
              }).concat(matcher.parent ? matcher.parent.keys.filter(function (k) {
                return k.optional;
              }) : []).map(function (k) {
                return k.name;
              })),
              // discard any existing params in the current location that do not exist here
              // #1497 this ensures better active/exact matching
              location2.params && paramsFromLocation(location2.params, matcher.keys.map(function (k) {
                return k.name;
              })));
              path = matcher.stringify(params);
            } else if (location2.path != null) {
              path = location2.path;
              matcher = matchers.find(function (m) {
                return m.re.test(path);
              });
              if (matcher) {
                params = matcher.parse(path);
                name = matcher.record.name;
              }
            } else {
              matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find(function (m) {
                return m.re.test(currentLocation.path);
              });
              if (!matcher) throw createRouterError(1, {
                location: location2,
                currentLocation: currentLocation
              });
              name = matcher.record.name;
              params = assign({}, currentLocation.params, location2.params);
              path = matcher.stringify(params);
            }
            var matched = [];
            var parentMatcher = matcher;
            while (parentMatcher) {
              matched.unshift(parentMatcher.record);
              parentMatcher = parentMatcher.parent;
            }
            return {
              name: name,
              path: path,
              params: params,
              matched: matched,
              meta: mergeMetaFields(matched)
            };
          }
          routes.forEach(function (route) {
            return addRoute(route);
          });
          function clearRoutes() {
            matchers.length = 0;
            matcherMap.clear();
          }
          return {
            addRoute: addRoute,
            resolve: resolve,
            removeRoute: removeRoute,
            clearRoutes: clearRoutes,
            getRoutes: getRoutes,
            getRecordMatcher: getRecordMatcher
          };
        }
        function paramsFromLocation(params, keys) {
          var newParams = {};
          var _iterator32 = _createForOfIteratorHelper(keys),
            _step32;
          try {
            for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
              var key = _step32.value;
              if (key in params) newParams[key] = params[key];
            }
          } catch (err) {
            _iterator32.e(err);
          } finally {
            _iterator32.f();
          }
          return newParams;
        }
        function normalizeRouteRecord(record) {
          var normalized = {
            path: record.path,
            redirect: record.redirect,
            name: record.name,
            meta: record.meta || {},
            aliasOf: record.aliasOf,
            beforeEnter: record.beforeEnter,
            props: normalizeRecordProps(record),
            children: record.children || [],
            instances: {},
            leaveGuards: /* @__PURE__ */new Set(),
            updateGuards: /* @__PURE__ */new Set(),
            enterCallbacks: {},
            // must be declared afterwards
            // mods: {},
            components: "components" in record ? record.components || null : record.component && {
              default: record.component
            }
          };
          Object.defineProperty(normalized, "mods", {
            value: {}
          });
          return normalized;
        }
        function normalizeRecordProps(record) {
          var propsObject = {};
          var props = record.props || false;
          if ("component" in record) {
            propsObject.default = props;
          } else {
            for (var name in record.components) propsObject[name] = _typeof2(props) === "object" ? props[name] : props;
          }
          return propsObject;
        }
        function isAliasRecord(record) {
          while (record) {
            if (record.record.aliasOf) return true;
            record = record.parent;
          }
          return false;
        }
        function mergeMetaFields(matched) {
          return matched.reduce(function (meta, record) {
            return assign(meta, record.meta);
          }, {});
        }
        function mergeOptions(defaults, partialOptions) {
          var options = {};
          for (var key in defaults) {
            options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
          }
          return options;
        }
        function findInsertionIndex(matcher, matchers) {
          var lower = 0;
          var upper = matchers.length;
          while (lower !== upper) {
            var mid = lower + upper >> 1;
            var sortOrder = comparePathParserScore(matcher, matchers[mid]);
            if (sortOrder < 0) {
              upper = mid;
            } else {
              lower = mid + 1;
            }
          }
          var insertionAncestor = getInsertionAncestor(matcher);
          if (insertionAncestor) {
            upper = matchers.lastIndexOf(insertionAncestor, upper - 1);
          }
          return upper;
        }
        function getInsertionAncestor(matcher) {
          var ancestor = matcher;
          while (ancestor = ancestor.parent) {
            if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) {
              return ancestor;
            }
          }
          return;
        }
        function isMatchable(_ref72) {
          var record = _ref72.record;
          return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);
        }
        function parseQuery(search) {
          var query = {};
          if (search === "" || search === "?") return query;
          var hasLeadingIM = search[0] === "?";
          var searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
          for (var i = 0; i < searchParams.length; ++i) {
            var searchParam = searchParams[i].replace(PLUS_RE, " ");
            var eqPos = searchParam.indexOf("=");
            var key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
            var value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
            if (key in query) {
              var currentValue = query[key];
              if (!isArray(currentValue)) {
                currentValue = query[key] = [currentValue];
              }
              currentValue.push(value);
            } else {
              query[key] = value;
            }
          }
          return query;
        }
        function stringifyQuery(query) {
          var search = "";
          var _loop11 = function _loop11(key) {
            var value = query[key];
            key = encodeQueryKey(key);
            if (value == null) {
              if (value !== void 0) {
                search += (search.length ? "&" : "") + key;
              }
              return 1; // continue
            }
            var values = isArray(value) ? value.map(function (v) {
              return v && encodeQueryValue(v);
            }) : [value && encodeQueryValue(value)];
            values.forEach(function (value2) {
              if (value2 !== void 0) {
                search += (search.length ? "&" : "") + key;
                if (value2 != null) search += "=" + value2;
              }
            });
          };
          for (var key in query) {
            if (_loop11(key)) continue;
          }
          return search;
        }
        function normalizeQuery(query) {
          var normalizedQuery = {};
          for (var key in query) {
            var value = query[key];
            if (value !== void 0) {
              normalizedQuery[key] = isArray(value) ? value.map(function (v) {
                return v == null ? null : "" + v;
              }) : value == null ? value : "" + value;
            }
          }
          return normalizedQuery;
        }
        var matchedRouteKey = Symbol("");
        var viewDepthKey = Symbol("");
        var routerKey = Symbol("");
        var routeLocationKey = Symbol("");
        var routerViewLocationKey = Symbol("");
        function useCallbacks() {
          var handlers = [];
          function add(handler) {
            handlers.push(handler);
            return function () {
              var i = handlers.indexOf(handler);
              if (i > -1) handlers.splice(i, 1);
            };
          }
          function reset() {
            handlers = [];
          }
          return {
            add: add,
            list: function list() {
              return handlers.slice();
            },
            reset: reset
          };
        }
        function guardToPromiseFn(guard, to, from, record, name) {
          var runWithContext = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (fn) {
            return fn();
          };
          var enterCallbackArray = record && (
          // name is defined if record is because of the function overload
          record.enterCallbacks[name] = record.enterCallbacks[name] || []);
          return function () {
            return new Promise(function (resolve, reject) {
              var next = function next(valid) {
                if (valid === false) {
                  reject(createRouterError(4, {
                    from: from,
                    to: to
                  }));
                } else if (valid instanceof Error) {
                  reject(valid);
                } else if (isRouteLocation(valid)) {
                  reject(createRouterError(2, {
                    from: to,
                    to: valid
                  }));
                } else {
                  if (enterCallbackArray &&
                  // since enterCallbackArray is truthy, both record and name also are
                  record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
                    enterCallbackArray.push(valid);
                  }
                  resolve();
                }
              };
              var guardReturn = runWithContext(function () {
                return guard.call(record && record.instances[name], to, from, next);
              });
              var guardCall = Promise.resolve(guardReturn);
              if (guard.length < 3) guardCall = guardCall.then(next);
              guardCall.catch(function (err) {
                return reject(err);
              });
            });
          };
        }
        function extractComponentsGuards(matched, guardType, to, from) {
          var runWithContext = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (fn) {
            return fn();
          };
          var guards = [];
          var _iterator33 = _createForOfIteratorHelper(matched),
            _step33;
          try {
            var _loop12 = function _loop12() {
              var record = _step33.value;
              var _loop13 = function _loop13(name) {
                var rawComponent = record.components[name];
                if (guardType !== "beforeRouteEnter" && !record.instances[name]) return 1; // continue
                if (isRouteComponent(rawComponent)) {
                  var options = rawComponent.__vccOpts || rawComponent;
                  var guard = options[guardType];
                  guard && guards.push(guardToPromiseFn(guard, to, from, record, name, runWithContext));
                } else {
                  var componentPromise = rawComponent();
                  guards.push(function () {
                    return componentPromise.then(function (resolved) {
                      if (!resolved) throw new Error("Couldn't resolve component \"".concat(name, "\" at \"").concat(record.path, "\""));
                      var resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
                      record.mods[name] = resolved;
                      record.components[name] = resolvedComponent;
                      var options = resolvedComponent.__vccOpts || resolvedComponent;
                      var guard = options[guardType];
                      return guard && guardToPromiseFn(guard, to, from, record, name, runWithContext)();
                    });
                  });
                }
              };
              for (var name in record.components) {
                if (_loop13(name)) continue;
              }
            };
            for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
              _loop12();
            }
          } catch (err) {
            _iterator33.e(err);
          } finally {
            _iterator33.f();
          }
          return guards;
        }
        function useLink(props) {
          var router = inject(routerKey);
          var currentRoute = inject(routeLocationKey);
          var route = computed(function () {
            var to = unref(props.to);
            return router.resolve(to);
          });
          var activeRecordIndex = computed(function () {
            var matched = route.value.matched;
            var length = matched.length;
            var routeMatched = matched[length - 1];
            var currentMatched = currentRoute.matched;
            if (!routeMatched || !currentMatched.length) return -1;
            var index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
            if (index > -1) return index;
            var parentRecordPath = getOriginalPath(matched[length - 2]);
            return (
              // we are dealing with nested routes
              length > 1 &&
              // if the parent and matched route have the same path, this link is
              // referring to the empty child. Or we currently are on a different
              // child of the same parent
              getOriginalPath(routeMatched) === parentRecordPath &&
              // avoid comparing the child with its parent
              currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index
            );
          });
          var isActive = computed(function () {
            return activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params);
          });
          var isExactActive = computed(function () {
            return activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params);
          });
          function navigate() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            if (guardEvent(e)) {
              var _p9 = router[unref(props.replace) ? "replace" : "push"](unref(props.to)
              // avoid uncaught errors are they are logged anyway
              ).catch(noop);
              if (props.viewTransition && typeof document !== "undefined" && "startViewTransition" in document) {
                document.startViewTransition(function () {
                  return _p9;
                });
              }
              return _p9;
            }
            return Promise.resolve();
          }
          return {
            route: route,
            href: computed(function () {
              return route.value.href;
            }),
            isActive: isActive,
            isExactActive: isExactActive,
            navigate: navigate
          };
        }
        function preferSingleVNode(vnodes) {
          return vnodes.length === 1 ? vnodes[0] : vnodes;
        }
        var RouterLinkImpl = /* @__PURE__ */defineComponent({
          name: "RouterLink",
          compatConfig: {
            MODE: 3
          },
          props: {
            to: {
              type: [String, Object],
              required: true
            },
            replace: Boolean,
            activeClass: String,
            // inactiveClass: String,
            exactActiveClass: String,
            custom: Boolean,
            ariaCurrentValue: {
              type: String,
              default: "page"
            }
          },
          useLink: useLink,
          setup: function setup(props, _ref73) {
            var slots = _ref73.slots;
            var link = reactive(useLink(props));
            var _inject = inject(routerKey),
              options = _inject.options;
            var elClass = computed(function () {
              return _defineProperty2(_defineProperty2({}, getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active"), link.isActive), getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active"), link.isExactActive);
            });
            return function () {
              var children = slots.default && preferSingleVNode(slots.default(link));
              return props.custom ? children : h("a", {
                "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
                href: link.href,
                // this would override user added attrs but Vue will still add
                // the listener, so we end up triggering both
                onClick: link.navigate,
                class: elClass.value
              }, children);
            };
          }
        });
        var RouterLink = RouterLinkImpl;
        function guardEvent(e) {
          if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;
          if (e.defaultPrevented) return;
          if (e.button !== void 0 && e.button !== 0) return;
          if (e.currentTarget && e.currentTarget.getAttribute) {
            var _target4 = e.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(_target4)) return;
          }
          if (e.preventDefault) e.preventDefault();
          return true;
        }
        function includesParams(outer, inner) {
          var _loop14 = function _loop14() {
              var innerValue = inner[key];
              var outerValue = outer[key];
              if (typeof innerValue === "string") {
                if (innerValue !== outerValue) return {
                  v: false
                };
              } else {
                if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some(function (value, i) {
                  return value !== outerValue[i];
                })) return {
                  v: false
                };
              }
            },
            _ret3;
          for (var key in inner) {
            _ret3 = _loop14();
            if (_ret3) return _ret3.v;
          }
          return true;
        }
        function getOriginalPath(record) {
          return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
        }
        var getLinkClass = function getLinkClass(propClass, globalClass, defaultClass) {
          return propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
        };
        var RouterViewImpl = /* @__PURE__ */defineComponent({
          name: "RouterView",
          // #674 we manually inherit them
          inheritAttrs: false,
          props: {
            name: {
              type: String,
              default: "default"
            },
            route: Object
          },
          // Better compat for @vue/compat users
          // https://github.com/vuejs/router/issues/1315
          compatConfig: {
            MODE: 3
          },
          setup: function setup(props, _ref75) {
            var attrs = _ref75.attrs,
              slots = _ref75.slots;
            var injectedRoute = inject(routerViewLocationKey);
            var routeToDisplay = computed(function () {
              return props.route || injectedRoute.value;
            });
            var injectedDepth = inject(viewDepthKey, 0);
            var depth = computed(function () {
              var initialDepth = unref(injectedDepth);
              var matched = routeToDisplay.value.matched;
              var matchedRoute;
              while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
                initialDepth++;
              }
              return initialDepth;
            });
            var matchedRouteRef = computed(function () {
              return routeToDisplay.value.matched[depth.value];
            });
            provide(viewDepthKey, computed(function () {
              return depth.value + 1;
            }));
            provide(matchedRouteKey, matchedRouteRef);
            provide(routerViewLocationKey, routeToDisplay);
            var viewRef = ref();
            watch(function () {
              return [viewRef.value, matchedRouteRef.value, props.name];
            }, function (_ref76, _ref77) {
              var _ref78 = _slicedToArray(_ref76, 3),
                instance = _ref78[0],
                to = _ref78[1],
                name = _ref78[2];
              var _ref79 = _slicedToArray(_ref77, 3),
                oldInstance = _ref79[0],
                from = _ref79[1],
                oldName = _ref79[2];
              if (to) {
                to.instances[name] = instance;
                if (from && from !== to && instance && instance === oldInstance) {
                  if (!to.leaveGuards.size) {
                    to.leaveGuards = from.leaveGuards;
                  }
                  if (!to.updateGuards.size) {
                    to.updateGuards = from.updateGuards;
                  }
                }
              }
              if (instance && to && (
              // if there is no instance but to and from are the same this might be
              // the first visit
              !from || !isSameRouteRecord(to, from) || !oldInstance)) {
                (to.enterCallbacks[name] || []).forEach(function (callback) {
                  return callback(instance);
                });
              }
            }, {
              flush: "post"
            });
            return function () {
              var route = routeToDisplay.value;
              var currentName = props.name;
              var matchedRoute = matchedRouteRef.value;
              var ViewComponent = matchedRoute && matchedRoute.components[currentName];
              if (!ViewComponent) {
                return normalizeSlot(slots.default, {
                  Component: ViewComponent,
                  route: route
                });
              }
              var routePropsOption = matchedRoute.props[currentName];
              var routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
              var onVnodeUnmounted = function onVnodeUnmounted(vnode) {
                if (vnode.component.isUnmounted) {
                  matchedRoute.instances[currentName] = null;
                }
              };
              var component = h(ViewComponent, assign({}, routeProps, attrs, {
                onVnodeUnmounted: onVnodeUnmounted,
                ref: viewRef
              }));
              return (
                // pass the vnode to the slot as a prop.
                // h and <component :is="..."> both accept vnodes
                normalizeSlot(slots.default, {
                  Component: component,
                  route: route
                }) || component
              );
            };
          }
        });
        function normalizeSlot(slot, data) {
          if (!slot) return null;
          var slotContent = slot(data);
          return slotContent.length === 1 ? slotContent[0] : slotContent;
        }
        var RouterView = RouterViewImpl;
        function createRouter(options) {
          var matcher = createRouterMatcher(options.routes, options);
          var parseQuery$1 = options.parseQuery || parseQuery;
          var stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
          var routerHistory = options.history;
          var beforeGuards = useCallbacks();
          var beforeResolveGuards = useCallbacks();
          var afterGuards = useCallbacks();
          var currentRoute = shallowRef(START_LOCATION_NORMALIZED);
          var pendingLocation = START_LOCATION_NORMALIZED;
          if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
            history.scrollRestoration = "manual";
          }
          var normalizeParams = applyToParams.bind(null, function (paramValue) {
            return "" + paramValue;
          });
          var encodeParams = applyToParams.bind(null, encodeParam);
          var decodeParams =
          // @ts-expect-error: intentionally avoid the type check
          applyToParams.bind(null, decode);
          function addRoute(parentOrRoute, route) {
            var parent;
            var record;
            if (isRouteName(parentOrRoute)) {
              parent = matcher.getRecordMatcher(parentOrRoute);
              record = route;
            } else {
              record = parentOrRoute;
            }
            return matcher.addRoute(record, parent);
          }
          function removeRoute(name) {
            var recordMatcher = matcher.getRecordMatcher(name);
            if (recordMatcher) {
              matcher.removeRoute(recordMatcher);
            }
          }
          function getRoutes() {
            return matcher.getRoutes().map(function (routeMatcher) {
              return routeMatcher.record;
            });
          }
          function hasRoute(name) {
            return !!matcher.getRecordMatcher(name);
          }
          function resolve(rawLocation, currentLocation) {
            currentLocation = assign({}, currentLocation || currentRoute.value);
            if (typeof rawLocation === "string") {
              var locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
              var matchedRoute2 = matcher.resolve({
                path: locationNormalized.path
              }, currentLocation);
              var href2 = routerHistory.createHref(locationNormalized.fullPath);
              return assign(locationNormalized, matchedRoute2, {
                params: decodeParams(matchedRoute2.params),
                hash: decode(locationNormalized.hash),
                redirectedFrom: void 0,
                href: href2
              });
            }
            var matcherLocation;
            if (rawLocation.path != null) {
              matcherLocation = assign({}, rawLocation, {
                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
              });
            } else {
              var targetParams = assign({}, rawLocation.params);
              for (var key in targetParams) {
                if (targetParams[key] == null) {
                  delete targetParams[key];
                }
              }
              matcherLocation = assign({}, rawLocation, {
                params: encodeParams(targetParams)
              });
              currentLocation.params = encodeParams(currentLocation.params);
            }
            var matchedRoute = matcher.resolve(matcherLocation, currentLocation);
            var hash = rawLocation.hash || "";
            matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
            var fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
              hash: encodeHash(hash),
              path: matchedRoute.path
            }));
            var href = routerHistory.createHref(fullPath);
            return assign({
              fullPath: fullPath,
              // keep the hash encoded so fullPath is effectively path + encodedQuery +
              // hash
              hash: hash,
              query:
              // if the user is using a custom query lib like qs, we might have
              // nested objects, so we keep the query as is, meaning it can contain
              // numbers at `$route.query`, but at the point, the user will have to
              // use their own type anyway.
              // https://github.com/vuejs/router/issues/328#issuecomment-649481567
              stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
            }, matchedRoute, {
              redirectedFrom: void 0,
              href: href
            });
          }
          function locationAsObject(to) {
            return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
          }
          function checkCanceledNavigation(to, from) {
            if (pendingLocation !== to) {
              return createRouterError(8, {
                from: from,
                to: to
              });
            }
          }
          function push(to) {
            return pushWithRedirect(to);
          }
          function replace(to) {
            return push(assign(locationAsObject(to), {
              replace: true
            }));
          }
          function handleRedirectRecord(to) {
            var lastMatched = to.matched[to.matched.length - 1];
            if (lastMatched && lastMatched.redirect) {
              var redirect = lastMatched.redirect;
              var newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
              if (typeof newTargetLocation === "string") {
                newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) :
                // force empty params
                {
                  path: newTargetLocation
                };
                newTargetLocation.params = {};
              }
              return assign({
                query: to.query,
                hash: to.hash,
                // avoid transferring params if the redirect has a path
                params: newTargetLocation.path != null ? {} : to.params
              }, newTargetLocation);
            }
          }
          function pushWithRedirect(to, redirectedFrom) {
            var targetLocation = pendingLocation = resolve(to);
            var from = currentRoute.value;
            var data = to.state;
            var force = to.force;
            var replace2 = to.replace === true;
            var shouldRedirect = handleRedirectRecord(targetLocation);
            if (shouldRedirect) return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
              state: _typeof2(shouldRedirect) === "object" ? assign({}, data, shouldRedirect.state) : data,
              force: force,
              replace: replace2
            }),
            // keep original redirectedFrom if it exists
            redirectedFrom || targetLocation);
            var toLocation = targetLocation;
            toLocation.redirectedFrom = redirectedFrom;
            var failure;
            if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
              failure = createRouterError(16, {
                to: toLocation,
                from: from
              });
              handleScroll(from, from,
              // this is a push, the only way for it to be triggered from a
              // history.listen is with a redirect, which makes it become a push
              true,
              // This cannot be the first navigation because the initial location
              // cannot be manually navigated to
              false);
            }
            return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch(function (error) {
              return isNavigationFailure(error) ?
              // navigation redirects still mark the router as ready
              isNavigationFailure(error, 2
              /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */) ? error : markAsReady(error) :
              // reject any unknown error
              triggerError(error, toLocation, from);
            }).then(function (failure2) {
              if (failure2) {
                if (isNavigationFailure(failure2, 2
                /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)) {
                  return pushWithRedirect(
                  // keep options
                  assign({
                    // preserve an existing replacement but allow the redirect to override it
                    replace: replace2
                  }, locationAsObject(failure2.to), {
                    state: _typeof2(failure2.to) === "object" ? assign({}, data, failure2.to.state) : data,
                    force: force
                  }),
                  // preserve the original redirectedFrom if any
                  redirectedFrom || toLocation);
                }
              } else {
                failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
              }
              triggerAfterEach(toLocation, from, failure2);
              return failure2;
            });
          }
          function checkCanceledNavigationAndReject(to, from) {
            var error = checkCanceledNavigation(to, from);
            return error ? Promise.reject(error) : Promise.resolve();
          }
          function runWithContext(fn) {
            var app = installedApps.values().next().value;
            return app && typeof app.runWithContext === "function" ? app.runWithContext(fn) : fn();
          }
          function navigate(to, from) {
            var guards;
            var _extractChangingRecor = extractChangingRecords(to, from),
              _extractChangingRecor2 = _slicedToArray(_extractChangingRecor, 3),
              leavingRecords = _extractChangingRecor2[0],
              updatingRecords = _extractChangingRecor2[1],
              enteringRecords = _extractChangingRecor2[2];
            guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
            var _iterator34 = _createForOfIteratorHelper(leavingRecords),
              _step34;
            try {
              for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
                var record = _step34.value;
                record.leaveGuards.forEach(function (guard) {
                  guards.push(guardToPromiseFn(guard, to, from));
                });
              }
            } catch (err) {
              _iterator34.e(err);
            } finally {
              _iterator34.f();
            }
            var canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards).then(function () {
              guards = [];
              var _iterator35 = _createForOfIteratorHelper(beforeGuards.list()),
                _step35;
              try {
                for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
                  var guard = _step35.value;
                  guards.push(guardToPromiseFn(guard, to, from));
                }
              } catch (err) {
                _iterator35.e(err);
              } finally {
                _iterator35.f();
              }
              guards.push(canceledNavigationCheck);
              return runGuardQueue(guards);
            }).then(function () {
              guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
              var _iterator36 = _createForOfIteratorHelper(updatingRecords),
                _step36;
              try {
                for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
                  var record = _step36.value;
                  record.updateGuards.forEach(function (guard) {
                    guards.push(guardToPromiseFn(guard, to, from));
                  });
                }
              } catch (err) {
                _iterator36.e(err);
              } finally {
                _iterator36.f();
              }
              guards.push(canceledNavigationCheck);
              return runGuardQueue(guards);
            }).then(function () {
              guards = [];
              var _iterator37 = _createForOfIteratorHelper(enteringRecords),
                _step37;
              try {
                for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {
                  var record = _step37.value;
                  if (record.beforeEnter) {
                    if (isArray(record.beforeEnter)) {
                      var _iterator38 = _createForOfIteratorHelper(record.beforeEnter),
                        _step38;
                      try {
                        for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
                          var beforeEnter = _step38.value;
                          guards.push(guardToPromiseFn(beforeEnter, to, from));
                        }
                      } catch (err) {
                        _iterator38.e(err);
                      } finally {
                        _iterator38.f();
                      }
                    } else {
                      guards.push(guardToPromiseFn(record.beforeEnter, to, from));
                    }
                  }
                }
              } catch (err) {
                _iterator37.e(err);
              } finally {
                _iterator37.f();
              }
              guards.push(canceledNavigationCheck);
              return runGuardQueue(guards);
            }).then(function () {
              to.matched.forEach(function (record) {
                return record.enterCallbacks = {};
              });
              guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from, runWithContext);
              guards.push(canceledNavigationCheck);
              return runGuardQueue(guards);
            }).then(function () {
              guards = [];
              var _iterator39 = _createForOfIteratorHelper(beforeResolveGuards.list()),
                _step39;
              try {
                for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
                  var guard = _step39.value;
                  guards.push(guardToPromiseFn(guard, to, from));
                }
              } catch (err) {
                _iterator39.e(err);
              } finally {
                _iterator39.f();
              }
              guards.push(canceledNavigationCheck);
              return runGuardQueue(guards);
            }).catch(function (err) {
              return isNavigationFailure(err, 8
              /* ErrorTypes.NAVIGATION_CANCELLED */) ? err : Promise.reject(err);
            });
          }
          function triggerAfterEach(to, from, failure) {
            afterGuards.list().forEach(function (guard) {
              return runWithContext(function () {
                return guard(to, from, failure);
              });
            });
          }
          function finalizeNavigation(toLocation, from, isPush, replace2, data) {
            var error = checkCanceledNavigation(toLocation, from);
            if (error) return error;
            var isFirstNavigation = from === START_LOCATION_NORMALIZED;
            var state = !isBrowser ? {} : history.state;
            if (isPush) {
              if (replace2 || isFirstNavigation) routerHistory.replace(toLocation.fullPath, assign({
                scroll: isFirstNavigation && state && state.scroll
              }, data));else routerHistory.push(toLocation.fullPath, data);
            }
            currentRoute.value = toLocation;
            handleScroll(toLocation, from, isPush, isFirstNavigation);
            markAsReady();
          }
          var removeHistoryListener;
          function setupListeners() {
            if (removeHistoryListener) return;
            removeHistoryListener = routerHistory.listen(function (to, _from, info) {
              if (!router.listening) return;
              var toLocation = resolve(to);
              var shouldRedirect = handleRedirectRecord(toLocation);
              if (shouldRedirect) {
                pushWithRedirect(assign(shouldRedirect, {
                  replace: true,
                  force: true
                }), toLocation).catch(noop);
                return;
              }
              pendingLocation = toLocation;
              var from = currentRoute.value;
              if (isBrowser) {
                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
              }
              navigate(toLocation, from).catch(function (error) {
                if (isNavigationFailure(error, 4 | 8
                /* ErrorTypes.NAVIGATION_CANCELLED */)) {
                  return error;
                }
                if (isNavigationFailure(error, 2
                /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)) {
                  pushWithRedirect(assign(locationAsObject(error.to), {
                    force: true
                  }), toLocation
                  // avoid an uncaught rejection, let push call triggerError
                  ).then(function (failure) {
                    if (isNavigationFailure(failure, 4 | 16
                    /* ErrorTypes.NAVIGATION_DUPLICATED */) && !info.delta && info.type === NavigationType.pop) {
                      routerHistory.go(-1, false);
                    }
                  }).catch(noop);
                  return Promise.reject();
                }
                if (info.delta) {
                  routerHistory.go(-info.delta, false);
                }
                return triggerError(error, toLocation, from);
              }).then(function (failure) {
                failure = failure || finalizeNavigation(
                // after navigation, all matched components are resolved
                toLocation, from, false);
                if (failure) {
                  if (info.delta &&
                  // a new navigation has been triggered, so we do not want to revert, that will change the current history
                  // entry while a different route is displayed
                  !isNavigationFailure(failure, 8
                  /* ErrorTypes.NAVIGATION_CANCELLED */)) {
                    routerHistory.go(-info.delta, false);
                  } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16
                  /* ErrorTypes.NAVIGATION_DUPLICATED */)) {
                    routerHistory.go(-1, false);
                  }
                }
                triggerAfterEach(toLocation, from, failure);
              }).catch(noop);
            });
          }
          var readyHandlers = useCallbacks();
          var errorListeners = useCallbacks();
          var ready;
          function triggerError(error, to, from) {
            markAsReady(error);
            var list = errorListeners.list();
            if (list.length) {
              list.forEach(function (handler) {
                return handler(error, to, from);
              });
            } else {
              console.error(error);
            }
            return Promise.reject(error);
          }
          function isReady() {
            if (ready && currentRoute.value !== START_LOCATION_NORMALIZED) return Promise.resolve();
            return new Promise(function (resolve2, reject) {
              readyHandlers.add([resolve2, reject]);
            });
          }
          function markAsReady(err) {
            if (!ready) {
              ready = !err;
              setupListeners();
              readyHandlers.list().forEach(function (_ref80) {
                var _ref81 = _slicedToArray(_ref80, 2),
                  resolve2 = _ref81[0],
                  reject = _ref81[1];
                return err ? reject(err) : resolve2();
              });
              readyHandlers.reset();
            }
            return err;
          }
          function handleScroll(to, from, isPush, isFirstNavigation) {
            var scrollBehavior = options.scrollBehavior;
            if (!isBrowser || !scrollBehavior) return Promise.resolve();
            var scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
            return nextTick().then(function () {
              return scrollBehavior(to, from, scrollPosition);
            }).then(function (position) {
              return position && scrollToPosition(position);
            }).catch(function (err) {
              return triggerError(err, to, from);
            });
          }
          var go = function go(delta) {
            return routerHistory.go(delta);
          };
          var started;
          var installedApps = /* @__PURE__ */new Set();
          var router = {
            currentRoute: currentRoute,
            listening: true,
            addRoute: addRoute,
            removeRoute: removeRoute,
            clearRoutes: matcher.clearRoutes,
            hasRoute: hasRoute,
            getRoutes: getRoutes,
            resolve: resolve,
            options: options,
            push: push,
            replace: replace,
            go: go,
            back: function back() {
              return go(-1);
            },
            forward: function forward() {
              return go(1);
            },
            beforeEach: beforeGuards.add,
            beforeResolve: beforeResolveGuards.add,
            afterEach: afterGuards.add,
            onError: errorListeners.add,
            isReady: isReady,
            install: function install(app) {
              var router2 = this;
              app.component("RouterLink", RouterLink);
              app.component("RouterView", RouterView);
              app.config.globalProperties.$router = router2;
              Object.defineProperty(app.config.globalProperties, "$route", {
                enumerable: true,
                get: function get() {
                  return unref(currentRoute);
                }
              });
              if (isBrowser &&
              // used for the initial navigation client side to avoid pushing
              // multiple times when the router is used in multiple apps
              !started && currentRoute.value === START_LOCATION_NORMALIZED) {
                started = true;
                push(routerHistory.location).catch(function (err) {});
              }
              var reactiveRoute = {};
              var _loop15 = function _loop15(key) {
                Object.defineProperty(reactiveRoute, key, {
                  get: function get() {
                    return currentRoute.value[key];
                  },
                  enumerable: true
                });
              };
              for (var key in START_LOCATION_NORMALIZED) {
                _loop15(key);
              }
              app.provide(routerKey, router2);
              app.provide(routeLocationKey, shallowReactive(reactiveRoute));
              app.provide(routerViewLocationKey, currentRoute);
              var unmountApp = app.unmount;
              installedApps.add(app);
              app.unmount = function () {
                installedApps.delete(app);
                if (installedApps.size < 1) {
                  pendingLocation = START_LOCATION_NORMALIZED;
                  removeHistoryListener && removeHistoryListener();
                  removeHistoryListener = null;
                  currentRoute.value = START_LOCATION_NORMALIZED;
                  started = false;
                  ready = false;
                }
                unmountApp();
              };
            }
          };
          function runGuardQueue(guards) {
            return guards.reduce(function (promise, guard) {
              return promise.then(function () {
                return runWithContext(guard);
              });
            }, Promise.resolve());
          }
          return router;
        }
        function extractChangingRecords(to, from) {
          var leavingRecords = [];
          var updatingRecords = [];
          var enteringRecords = [];
          var len = Math.max(from.matched.length, to.matched.length);
          var _loop16 = function _loop16() {
            var recordFrom = from.matched[i];
            if (recordFrom) {
              if (to.matched.find(function (record) {
                return isSameRouteRecord(record, recordFrom);
              })) updatingRecords.push(recordFrom);else leavingRecords.push(recordFrom);
            }
            var recordTo = to.matched[i];
            if (recordTo) {
              if (!from.matched.find(function (record) {
                return isSameRouteRecord(record, recordTo);
              })) {
                enteringRecords.push(recordTo);
              }
            }
          };
          for (var i = 0; i < len; i++) {
            _loop16();
          }
          return [leavingRecords, updatingRecords, enteringRecords];
        }
        function useRouter() {
          return inject(routerKey);
        }
        function useRoute(_name) {
          return inject(routeLocationKey);
        }
        var dist = {
          exports: {}
        };
        var require$$0 = /*@__PURE__*/getAugmentedNamespace(vue_runtime_esmBundler);
        (function (module, exports) {
          (function webpackUniversalModuleDefinition(root, factory) {
            module.exports = factory(require$$0);
          })(commonjsGlobal, function (__WEBPACK_EXTERNAL_MODULE__976__) {
            return /******/function () {
              // webpackBootstrap
              /******/
              var __webpack_modules__ = {
                /***/772: (/***/function _(__unused_webpack_module, exports) {
                  Object.defineProperty(exports, "__esModule", {
                    value: true
                  });
                  // runtime helper for setting properties on components
                  // in a tree-shakable way
                  exports["default"] = function (sfc, props) {
                    var target = sfc.__vccOpts || sfc;
                    var _iterator40 = _createForOfIteratorHelper(props),
                      _step40;
                    try {
                      for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
                        var _step40$value = _slicedToArray(_step40.value, 2),
                          key = _step40$value[0],
                          val = _step40$value[1];
                        target[key] = val;
                      }
                    } catch (err) {
                      _iterator40.e(err);
                    } finally {
                      _iterator40.f();
                    }
                    return target;
                  };

                  /***/
                }),
                /***/976: (/***/function _(module) {
                  module.exports = __WEBPACK_EXTERNAL_MODULE__976__;

                  /***/
                })

                /******/
              };
              /************************************************************************/
              /******/ // The module cache
              /******/
              var __webpack_module_cache__ = {};
              /******/
              /******/ // The require function
              /******/
              function __webpack_require__(moduleId) {
                /******/ // Check if module is in cache
                /******/var cachedModule = __webpack_module_cache__[moduleId];
                /******/
                if (cachedModule !== undefined) {
                  /******/return cachedModule.exports;
                  /******/
                }
                /******/ // Create a new module (and put it into the cache)
                /******/
                var module = __webpack_module_cache__[moduleId] = {
                  /******/ // no module.id needed
                  /******/ // no module.loaded needed
                  /******/exports: {}
                  /******/
                };
                /******/
                /******/ // Execute the module function
                /******/
                __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
                /******/
                /******/ // Return the exports of the module
                /******/
                return module.exports;
                /******/
              }
              /******/
              /************************************************************************/
              /******/ /* webpack/runtime/define property getters */
              /******/
              (function () {
                /******/ // define getter functions for harmony exports
                /******/__webpack_require__.d = function (exports, definition) {
                  /******/for (var key in definition) {
                    /******/if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                      /******/Object.defineProperty(exports, key, {
                        enumerable: true,
                        get: definition[key]
                      });
                      /******/
                    }
                    /******/
                  }
                  /******/
                };
                /******/
              })();
              /******/
              /******/ /* webpack/runtime/hasOwnProperty shorthand */
              /******/
              (function () {
                /******/__webpack_require__.o = function (obj, prop) {
                  return Object.prototype.hasOwnProperty.call(obj, prop);
                };
                /******/
              })();
              /******/
              /******/ /* webpack/runtime/make namespace object */
              /******/
              (function () {
                /******/ // define __esModule on exports
                /******/__webpack_require__.r = function (exports) {
                  /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                    /******/Object.defineProperty(exports, Symbol.toStringTag, {
                      value: 'Module'
                    });
                    /******/
                  }
                  /******/
                  Object.defineProperty(exports, '__esModule', {
                    value: true
                  });
                  /******/
                };
                /******/
              })();
              /******/
              /************************************************************************/
              var __webpack_exports__ = {};
              // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
              (function () {
                // ESM COMPAT FLAG
                __webpack_require__.r(__webpack_exports__);

                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                  ToastComponent: function ToastComponent() {
                    return /* reexport */Component;
                  },
                  ToastPlugin: function ToastPlugin() {
                    return /* binding */_ToastPlugin;
                  },
                  ToastPositions: function ToastPositions() {
                    return /* reexport */positions;
                  },
                  "default": function _default() {
                    return /* binding */src;
                  },
                  useToast: function useToast() {
                    return /* reexport */_useToast;
                  }
                });

                // EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","amd":"vue","root":"Vue"}
                var external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_ = __webpack_require__(976);
                var _hoisted_1 = /*#__PURE__*/(0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createElementVNode)("div", {
                  class: "v-toast__icon"
                }, null, -1);
                var _hoisted_2 = ["innerHTML"];
                function render(_ctx, _cache, $props, $setup, $data, $options) {
                  return (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createBlock)(external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Transition, {
                    "enter-active-class": _ctx.transition.enter,
                    "leave-active-class": _ctx.transition.leave
                  }, {
                    default: (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withCtx)(function () {
                      return [(0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createElementVNode)("div", {
                        ref: "root",
                        role: "alert",
                        class: (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.normalizeClass)(["v-toast__item", ["v-toast__item--".concat(_ctx.type), "v-toast__item--".concat(_ctx.position)]]),
                        onMouseover: _cache[0] || (_cache[0] = function ($event) {
                          return _ctx.toggleTimer(true);
                        }),
                        onMouseleave: _cache[1] || (_cache[1] = function ($event) {
                          return _ctx.toggleTimer(false);
                        }),
                        onClick: _cache[2] || (_cache[2] = function () {
                          return _ctx.whenClicked && _ctx.whenClicked.apply(_ctx, arguments);
                        })
                      }, [_hoisted_1, (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createElementVNode)("p", {
                        class: "v-toast__text",
                        innerHTML: _ctx.message
                      }, null, 8, _hoisted_2)], 34), [[external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.vShow, _ctx.isActive]])];
                    }),
                    _: 1
                  }, 8, ["enter-active-class", "leave-active-class"]);
                }
                function removeElement(el) {
                  if (typeof el.remove !== 'undefined') {
                    el.remove();
                  } else {
                    var _el$parentNode;
                    (_el$parentNode = el.parentNode) === null || _el$parentNode === void 0 || _el$parentNode.removeChild(el);
                  }
                }
                function createComponent(component, props, parentContainer) {
                  var slots = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
                  var vNode = (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.h)(component, props, slots);
                  var container = document.createElement('div');
                  container.classList.add('v-toast--pending');
                  parentContainer.appendChild(container);
                  (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.render)(vNode, container);
                  return vNode.component;
                }
                // https://stackoverflow.com/a/3969760
                var Timer = /*#__PURE__*/function () {
                  function Timer(callback, delay) {
                    _classCallCheck2(this, Timer);
                    this.startedAt = Date.now();
                    this.callback = callback;
                    this.delay = delay;
                    this.timer = setTimeout(callback, delay);
                  }
                  return _createClass(Timer, [{
                    key: "pause",
                    value: function pause() {
                      this.stop();
                      this.delay -= Date.now() - this.startedAt;
                    }
                  }, {
                    key: "resume",
                    value: function resume() {
                      this.stop();
                      this.startedAt = Date.now();
                      this.timer = setTimeout(this.callback, this.delay);
                    }
                  }, {
                    key: "stop",
                    value: function stop() {
                      clearTimeout(this.timer);
                    }
                  }]);
                }();
                /* harmony default export */
                var positions = Object.freeze({
                  TOP_RIGHT: 'top-right',
                  TOP: 'top',
                  TOP_LEFT: 'top-left',
                  BOTTOM_RIGHT: 'bottom-right',
                  BOTTOM: 'bottom',
                  BOTTOM_LEFT: 'bottom-left'
                });
                /* harmony default export */
                function mitt(n) {
                  return {
                    all: n = n || new Map(),
                    on: function on(t, e) {
                      var i = n.get(t);
                      i ? i.push(e) : n.set(t, [e]);
                    },
                    off: function off(t, e) {
                      var i = n.get(t);
                      i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
                    },
                    emit: function emit(t, e) {
                      var i = n.get(t);
                      i && i.slice().map(function (n) {
                        n(e);
                      }), (i = n.get("*")) && i.slice().map(function (n) {
                        n(t, e);
                      });
                    }
                  };
                }
                var eventBus = mitt();
                /* harmony default export */
                var bus = eventBus;

                /* harmony default export */
                var Componentvue_type_script_lang_js = (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.defineComponent)({
                  name: 'Toast',
                  props: {
                    message: {
                      type: String,
                      required: true
                    },
                    type: {
                      type: String,
                      default: 'success'
                    },
                    position: {
                      type: String,
                      default: positions.BOTTOM_RIGHT,
                      validator: function validator(value) {
                        return Object.values(positions).includes(value);
                      }
                    },
                    duration: {
                      type: Number,
                      default: 3000
                    },
                    dismissible: {
                      type: Boolean,
                      default: true
                    },
                    onDismiss: {
                      type: Function,
                      default: function _default() {}
                    },
                    onClick: {
                      type: Function,
                      default: function _default() {}
                    },
                    queue: Boolean,
                    pauseOnHover: {
                      type: Boolean,
                      default: true
                    }
                  },
                  data: function data() {
                    return {
                      isActive: false,
                      parentTop: null,
                      parentBottom: null,
                      isHovered: false
                    };
                  },
                  beforeMount: function beforeMount() {
                    this.setupContainer();
                  },
                  mounted: function mounted() {
                    this.showNotice();
                    bus.on('toast-clear', this.dismiss);
                  },
                  methods: {
                    setupContainer: function setupContainer() {
                      this.parentTop = document.querySelector('.v-toast.v-toast--top');
                      this.parentBottom = document.querySelector('.v-toast.v-toast--bottom');
                      // No need to create them, they already exists
                      if (this.parentTop && this.parentBottom) return;
                      if (!this.parentTop) {
                        this.parentTop = document.createElement('div');
                        this.parentTop.className = 'v-toast v-toast--top';
                      }
                      if (!this.parentBottom) {
                        this.parentBottom = document.createElement('div');
                        this.parentBottom.className = 'v-toast v-toast--bottom';
                      }
                      var container = document.body;
                      container.appendChild(this.parentTop);
                      container.appendChild(this.parentBottom);
                    },
                    shouldQueue: function shouldQueue() {
                      if (!this.queue) return false;
                      return this.parentTop.childElementCount > 0 || this.parentBottom.childElementCount > 0;
                    },
                    dismiss: function dismiss() {
                      var _arguments2 = arguments,
                        _this151 = this;
                      if (this.timer) this.timer.stop();
                      clearTimeout(this.queueTimer);
                      this.isActive = false;

                      // Timeout for the animation complete before destroying
                      setTimeout(function () {
                        _this151.onDismiss.apply(null, _arguments2);
                        var wrapper = _this151.$refs.root;
                        // unmount the component
                        (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.render)(null, wrapper);
                        removeElement(wrapper);
                      }, 150);
                    },
                    showNotice: function showNotice() {
                      if (this.shouldQueue()) {
                        // Call recursively if it should queue
                        this.queueTimer = setTimeout(this.showNotice, 250);
                        return;
                      }
                      var wrapper = this.$refs.root.parentElement;
                      this.correctParent.insertAdjacentElement('afterbegin', this.$refs.root);
                      removeElement(wrapper);
                      this.isActive = true;
                      if (this.duration) {
                        this.timer = new Timer(this.dismiss, this.duration);
                      }
                    },
                    whenClicked: function whenClicked() {
                      if (!this.dismissible) return;
                      this.onClick.apply(null, arguments);
                      this.dismiss();
                    },
                    toggleTimer: function toggleTimer(newVal) {
                      if (!this.pauseOnHover || !this.timer) return;
                      newVal ? this.timer.pause() : this.timer.resume();
                    }
                  },
                  computed: {
                    correctParent: function correctParent() {
                      switch (this.position) {
                        case positions.TOP:
                        case positions.TOP_RIGHT:
                        case positions.TOP_LEFT:
                          return this.parentTop;
                        case positions.BOTTOM:
                        case positions.BOTTOM_RIGHT:
                        case positions.BOTTOM_LEFT:
                          return this.parentBottom;
                      }
                    },
                    transition: function transition() {
                      switch (this.position) {
                        case positions.TOP:
                        case positions.TOP_RIGHT:
                        case positions.TOP_LEFT:
                          return {
                            enter: 'v-toast--fade-in-down',
                            leave: 'v-toast--fade-out'
                          };
                        case positions.BOTTOM:
                        case positions.BOTTOM_RIGHT:
                        case positions.BOTTOM_LEFT:
                          return {
                            enter: 'v-toast--fade-in-up',
                            leave: 'v-toast--fade-out'
                          };
                      }
                    }
                  },
                  beforeUnmount: function beforeUnmount() {
                    bus.off('toast-clear', this.dismiss);
                  }
                });

                // EXTERNAL MODULE: ./node_modules/.pnpm/vue-loader@17.1.1_@vue+compiler-sfc@3.3.4_vue@3.3.4_webpack@5.84.1/node_modules/vue-loader/dist/exportHelper.js
                var exportHelper = __webpack_require__(772);
                var __exports__ = /*#__PURE__*/(0, exportHelper["default"])(Componentvue_type_script_lang_js, [['render', render]]);

                /* harmony default export */
                var Component = __exports__;
                var _useToast = function _useToast() {
                  var globalProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                  return {
                    open: function open(options) {
                      var message = null;
                      if (typeof options === 'string') message = options;
                      var defaultProps = {
                        message: message
                      };
                      var propsData = Object.assign({}, defaultProps, globalProps, options);
                      var instance = createComponent(Component, propsData, document.body);
                      return {
                        dismiss: instance.ctx.dismiss
                      };
                    },
                    clear: function clear() {
                      bus.emit('toast-clear');
                    },
                    success: function success(message) {
                      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                      return this.open(Object.assign({}, {
                        message: message,
                        type: 'success'
                      }, options));
                    },
                    error: function error(message) {
                      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                      return this.open(Object.assign({}, {
                        message: message,
                        type: 'error'
                      }, options));
                    },
                    info: function info(message) {
                      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                      return this.open(Object.assign({}, {
                        message: message,
                        type: 'info'
                      }, options));
                    },
                    warning: function warning(message) {
                      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                      return this.open(Object.assign({}, {
                        message: message,
                        type: 'warning'
                      }, options));
                    },
                    default: function _default(message) {
                      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                      return this.open(Object.assign({}, {
                        message: message,
                        type: 'default'
                      }, options));
                    }
                  };
                };
                var _ToastPlugin = {
                  install: function install(app) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    var instance = _useToast(options);
                    app.config.globalProperties.$toast = instance;
                    app.provide('$toast', instance);
                  }
                };
                /* harmony default export */
                var src = _ToastPlugin;
              })();

              /******/
              return __webpack_exports__;
              /******/
            }();
          });
        })(dist);
        var distExports = dist.exports;
        var defaultPrizeImage = "" + new URL('../png/-DLt8cyCz.png', module.meta.url).href + "";
        var _hoisted_1$5 = ["src"];
        var _sfc_main$5 = exports("a7", /* @__PURE__ */defineComponent({
          __name: "index",
          props: {
            imgItem: {
              type: Object,
              default: function _default() {
                return {};
              }
            }
          },
          setup: function setup(__props) {
            var props = __props;
            var imageDbStore = localforage.createInstance({
              name: "imgStore"
            });
            var imgUrl = ref("");
            function getImageStoreItem(_x21) {
              return _getImageStoreItem2.apply(this, arguments);
            }
            function _getImageStoreItem2() {
              _getImageStoreItem2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(item) {
                var image, key;
                return _regeneratorRuntime().wrap(function _callee13$(_context21) {
                  while (1) switch (_context21.prev = _context21.next) {
                    case 0:
                      image = "";
                      if (!(item.url === "Storage")) {
                        _context21.next = 8;
                        break;
                      }
                      key = item.id;
                      _context21.next = 5;
                      return imageDbStore.getItem(key);
                    case 5:
                      image = _context21.sent;
                      _context21.next = 9;
                      break;
                    case 8:
                      image = item.url;
                    case 9:
                      return _context21.abrupt("return", image);
                    case 10:
                    case "end":
                      return _context21.stop();
                  }
                }, _callee13);
              }));
              return _getImageStoreItem2.apply(this, arguments);
            }
            onMounted(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
              var image;
              return _regeneratorRuntime().wrap(function _callee12$(_context20) {
                while (1) switch (_context20.prev = _context20.next) {
                  case 0:
                    _context20.next = 2;
                    return getImageStoreItem(props.imgItem);
                  case 2:
                    image = _context20.sent;
                    imgUrl.value = image;
                  case 4:
                  case "end":
                    return _context20.stop();
                }
              }, _callee12);
            })));
            return function (_ctx, _cache) {
              return openBlock(), createElementBlock("img", {
                src: imgUrl.value,
                alt: "Image",
                class: "object-cover h-full rounded-xl"
              }, null, 8, _hoisted_1$5);
            };
          }
        }));
        var _hoisted_1$4 = {
          class: "overflow-hidden modal-box"
        };
        var _hoisted_2$4 = {
          class: "pb-6 text-lg font-bold"
        };
        var _hoisted_3$4 = {
          class: "pb-8"
        };
        var _hoisted_4$4 = {
          class: "flex justify-between px-3 text-center separated-number"
        };
        var _hoisted_5$4 = ["data-tip", "onClick"];
        var _hoisted_6$4 = {
          class: "modal-action"
        };
        var _hoisted_7$3 = {
          method: "dialog"
        };
        var _sfc_main$4 = exports("E", /* @__PURE__ */defineComponent({
          __name: "EditSeparateDialog",
          props: {
            totalNumber: {
              type: Number,
              default: 0
            },
            separatedNumber: {
              type: Array,
              default: []
            }
          },
          emits: ["submitData"],
          setup: function setup(__props, _ref83) {
            var __emit = _ref83.emit;
            var props = __props;
            var emits = __emit;
            var _useI18n = useI18n(),
              t = _useI18n.t;
            var separatedNumberRef = ref();
            var _toRefs = toRefs(props),
              separatedNumber = _toRefs.separatedNumber,
              totalNumber = _toRefs.totalNumber;
            var scaleList = ref([]);
            function editScale(item) {
              if (item === totalNumber.value) {
                return;
              }
              if (scaleList.value.includes(item)) {
                var _index19 = scaleList.value.indexOf(item);
                scaleList.value.splice(_index19, 1);
                separatedNumber.value.splice(_index19, 1);
              } else {
                scaleList.value.push(item);
                scaleList.value.sort(function (a, b) {
                  return a - b;
                });
              }
            }
            function clearData() {
              emits("submitData", separatedNumber.value);
              separatedNumberRef.value.close();
            }
            watch(scaleList, function (val) {
              separatedNumber.value.length = 0;
              for (var i = 1; i < scaleList.value.length; i++) {
                separatedNumber.value[i - 1] = {
                  id: i.toString(),
                  count: val[i] - val[i - 1],
                  isUsedCount: 0
                };
              }
            }, {
              deep: true
            });
            watch(totalNumber, function (val) {
              if (val <= 0) {
                return;
              }
              separatedNumberRef.value.showModal();
              scaleList.value = Array.from({
                length: separatedNumber.value.length + 1
              }).fill(totalNumber.value);
              for (var i = separatedNumber.value.length - 1; i >= 0; i--) {
                scaleList.value[i] = scaleList.value[i + 1] - separatedNumber.value[i].count;
              }
              if (scaleList.value[0] !== 0) {
                scaleList.value.unshift(0);
              }
            });
            onMounted(function () {
              document.addEventListener("keydown", function (e) {
                if (e.key === "Escape") {
                  e.preventDefault();
                }
              });
            });
            return function (_ctx, _cache) {
              return openBlock(), createElementBlock("dialog", {
                id: "my_modal_1",
                ref_key: "separatedNumberRef",
                ref: separatedNumberRef,
                class: "z-50 overflow-hidden border-none modal"
              }, [createBaseVNode("div", _hoisted_1$4, [createBaseVNode("h3", _hoisted_2$4, toDisplayString$1(unref(t)("dialog.titleTip")), 1), createBaseVNode("p", _hoisted_3$4, toDisplayString$1(unref(t)("dialog.dialogSingleDrawLimit")), 1), createBaseVNode("div", _hoisted_4$4, [(openBlock(true), createElementBlock(Fragment, null, renderList(props.totalNumber, function (item) {
                return openBlock(), createElementBlock("div", {
                  key: item,
                  class: "relative flex flex-col items-center cursor-pointer"
                }, [createBaseVNode("div", {
                  class: "absolute mb-12 text-center tooltip -top-5 hover:text-lg",
                  "data-tip": unref(t)("tooltip.leftClick"),
                  onClick: withModifiers(function ($event) {
                    return editScale(item);
                  }, ["left"])
                }, [createBaseVNode("span", null, toDisplayString$1(item), 1)], 8, _hoisted_5$4), createBaseVNode("div", {
                  class: normalizeClass(["text-center", scaleList.value.includes(item) ? "text-red-500 font-extrabold" : ""])
                }, " | ", 2)]);
              }), 128))]), createBaseVNode("div", _hoisted_6$4, [createBaseVNode("form", _hoisted_7$3, [createBaseVNode("button", {
                class: "btn",
                onClick: clearData
              }, toDisplayString$1(unref(t)("button.close")), 1)])])])], 512);
            };
          }
        }));
        var _hoisted_1$3 = {
          class: "flex items-center"
        };
        var _hoisted_2$3 = {
          class: "modal-box"
        };
        var _hoisted_3$3 = {
          class: "text-lg font-bold"
        };
        var _hoisted_4$3 = {
          class: "flex flex-col gap-3"
        };
        var _hoisted_5$3 = {
          class: "flex w-full max-w-xs"
        };
        var _hoisted_6$3 = {
          class: "label"
        };
        var _hoisted_7$2 = {
          class: "label-text"
        };
        var _hoisted_8 = ["placeholder"];
        var _hoisted_9 = {
          class: "flex w-full max-w-xs"
        };
        var _hoisted_10 = {
          class: "label"
        };
        var _hoisted_11 = {
          class: "label-text"
        };
        var _hoisted_12 = ["checked"];
        var _hoisted_13 = {
          class: "flex w-full max-w-xs"
        };
        var _hoisted_14 = {
          class: "label"
        };
        var _hoisted_15 = {
          class: "label-text"
        };
        var _hoisted_16 = ["placeholder"];
        var _hoisted_17 = {
          class: "flex w-full max-w-xs"
        };
        var _hoisted_18 = {
          class: "label"
        };
        var _hoisted_19 = {
          class: "label-text"
        };
        var _hoisted_20 = ["placeholder"];
        var _hoisted_21 = {
          key: 0,
          class: "flex w-full max-w-xs"
        };
        var _hoisted_22 = {
          class: "label"
        };
        var _hoisted_23 = {
          class: "label-text"
        };
        var _hoisted_24 = {
          key: 0,
          class: "flex flex-wrap w-full h-full gap-1 p-0 pt-1 m-0 cursor-pointer"
        };
        var _hoisted_25 = ["data-tip"];
        var _hoisted_26 = {
          key: 1,
          class: "btn btn-secondary btn-xs"
        };
        var _hoisted_27 = {
          class: "flex w-full max-w-xs"
        };
        var _hoisted_28 = {
          class: "label"
        };
        var _hoisted_29 = {
          class: "label-text"
        };
        var _hoisted_30 = {
          key: 0,
          value: {
            id: "",
            name: "",
            url: ""
          }
        };
        var _hoisted_31 = {
          disabled: "",
          selected: ""
        };
        var _hoisted_32 = ["value"];
        var _hoisted_33 = {
          class: "modal-action"
        };
        var _hoisted_34 = {
          method: "dialog",
          class: "flex gap-3"
        };
        var _hoisted_35 = {
          class: "btn btn-sm"
        };
        var _hoisted_36 = {
          class: "relative flex flex-row items-center justify-between w-full h-full shadow-xl card bg-base-100"
        };
        var _hoisted_37 = {
          key: 0,
          class: "absolute z-50 w-full h-full bg-gray-800/70 item-mask rounded-xl"
        };
        var _hoisted_38 = {
          class: "w-10 h-10 rounded-xl"
        };
        var _hoisted_39 = ["src"];
        var _hoisted_40 = {
          class: "items-center p-0 text-center card-body"
        };
        var _hoisted_41 = ["data-tip"];
        var _hoisted_42 = {
          class: "p-0 m-0 overflow-hidden w-28 card-title whitespace-nowrap text-ellipsis"
        };
        var _hoisted_43 = {
          class: "absolute z-40 p-0 m-0 text-gray-300/80 mt-9"
        };
        var _hoisted_44 = ["value", "max"];
        var _hoisted_45 = {
          class: "flex flex-col gap-1 mr-2"
        };
        var _hoisted_46 = ["data-tip"];
        var _hoisted_47 = ["data-tip"];
        var _hoisted_48 = {
          key: 0,
          class: "flex items-center"
        };
        var _hoisted_49 = {
          key: 0,
          class: "relative flex flex-row items-center justify-between w-64 h-20 shadow-xl card bg-base-100"
        };
        var _hoisted_50 = {
          key: 0,
          class: "absolute z-50 w-full h-full bg-gray-800/70 item-mask rounded-xl"
        };
        var _hoisted_51 = {
          class: "w-10 h-10 rounded-xl"
        };
        var _hoisted_52 = ["src"];
        var _hoisted_53 = {
          class: "items-center p-0 text-center card-body"
        };
        var _hoisted_54 = ["data-tip"];
        var _hoisted_55 = {
          class: "w-24 p-0 m-0 overflow-hidden text-center card-title whitespace-nowrap text-ellipsis"
        };
        var _hoisted_56 = {
          class: "absolute z-40 p-0 m-0 text-gray-300/80 mt-9"
        };
        var _hoisted_57 = ["value", "max"];
        var _hoisted_58 = {
          class: "flex flex-col gap-3"
        };
        var _hoisted_59 = ["data-tip"];
        var _hoisted_60 = ["data-tip"];
        var _hoisted_61 = ["data-tip"];
        var _sfc_main$3 = /* @__PURE__ */defineComponent({
          __name: "PrizeList",
          setup: function setup(__props) {
            var _useI18n2 = useI18n(),
              t = _useI18n2.t;
            var prizeConfig = useStore().prizeConfig;
            var globalConfig = useStore().globalConfig;
            var system = useStore().system;
            var _storeToRefs = storeToRefs(prizeConfig),
              localPrizeList = _storeToRefs.getPrizeConfig,
              currentPrize = _storeToRefs.getCurrentPrize,
              temporaryPrize = _storeToRefs.getTemporaryPrize;
            var _storeToRefs2 = storeToRefs(globalConfig),
              isShowPrizeList = _storeToRefs2.getIsShowPrizeList,
              localImageList = _storeToRefs2.getImageList;
            var _storeToRefs3 = storeToRefs(system),
              isMobile = _storeToRefs3.getIsMobile;
            var prizeListRef = ref();
            var prizeListContainerRef = ref();
            var temporaryPrizeRef = ref();
            var selectedPrize = ref();
            function getPrizeListHeight() {
              var height = 200;
              if (prizeListRef.value) {
                height = prizeListRef.value.offsetHeight;
              }
              return height;
            }
            var prizeShow = ref(structuredClone(isShowPrizeList.value));
            function addTemporaryPrize() {
              temporaryPrizeRef.value.showModal();
            }
            function deleteTemporaryPrize() {
              temporaryPrize.value.isShow = false;
              prizeConfig.setTemporaryPrize(temporaryPrize.value);
            }
            function submitTemporaryPrize() {
              if (!temporaryPrize.value.name || !temporaryPrize.value.count) {
                alert(i18n.global.t("error.completeInformation"));
                return;
              }
              temporaryPrize.value.isShow = true;
              temporaryPrize.value.id = (/* @__PURE__ */new Date()).getTime().toString();
              prizeConfig.setCurrentPrize(temporaryPrize.value);
            }
            function selectPrize(item) {
              selectedPrize.value = item;
              selectedPrize.value.isUsedCount = 0;
              selectedPrize.value.isUsed = false;
              if (selectedPrize.value.separateCount.countList.length > 1) {
                return;
              }
              selectedPrize.value.separateCount = {
                enable: true,
                countList: [{
                  id: "0",
                  count: item.count,
                  isUsedCount: 0
                }]
              };
            }
            function submitData(value) {
              selectedPrize.value.separateCount.countList = value;
              selectedPrize.value = null;
            }
            function changePersonCount() {
              temporaryPrize.value.separateCount.countList = [];
            }
            function setCurrentPrize() {
              for (var i = 0; i < localPrizeList.value.length; i++) {
                if (localPrizeList.value[i].isUsedCount < localPrizeList.value[i].count) {
                  prizeConfig.setCurrentPrize(localPrizeList.value[i]);
                  return;
                }
              }
            }
            onMounted(function () {
              prizeListContainerRef.value.style.height = "".concat(getPrizeListHeight(), "px");
              setCurrentPrize();
            });
            return function (_ctx, _cache) {
              var _selectedPrize$value, _selectedPrize$value2;
              var _component_svg_icon = __unplugin_components_0;
              return openBlock(), createElementBlock("div", _hoisted_1$3, [createBaseVNode("dialog", {
                id: "my_modal_1",
                ref_key: "temporaryPrizeRef",
                ref: temporaryPrizeRef,
                class: "border-none modal"
              }, [createBaseVNode("div", _hoisted_2$3, [createBaseVNode("h3", _hoisted_3$3, toDisplayString$1(unref(t)("dialog.titleTemporary")), 1), createBaseVNode("div", _hoisted_4$3, [createBaseVNode("label", _hoisted_5$3, [createBaseVNode("div", _hoisted_6$3, [createBaseVNode("span", _hoisted_7$2, toDisplayString$1(unref(t)("table.name")) + ":", 1)]), withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
                  return unref(temporaryPrize).name = $event;
                }),
                type: "text",
                placeholder: unref(t)("placeHolder.name"),
                class: "max-w-xs input-sm input input-bordered"
              }, null, 8, _hoisted_8), [[vModelText, unref(temporaryPrize).name]])]), createBaseVNode("label", _hoisted_9, [createBaseVNode("div", _hoisted_10, [createBaseVNode("span", _hoisted_11, toDisplayString$1(unref(t)("table.fullParticipation")), 1)]), createBaseVNode("input", {
                type: "checkbox",
                checked: unref(temporaryPrize).isAll,
                class: "mt-2 border-solid checkbox checkbox-secondary border-1",
                onChange: _cache[1] || (_cache[1] = function ($event) {
                  return unref(temporaryPrize).isAll = !unref(temporaryPrize).isAll;
                })
              }, null, 40, _hoisted_12)]), createBaseVNode("label", _hoisted_13, [createBaseVNode("div", _hoisted_14, [createBaseVNode("span", _hoisted_15, toDisplayString$1(unref(t)("table.setLuckyNumber")), 1)]), withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[2] || (_cache[2] = function ($event) {
                  return unref(temporaryPrize).count = $event;
                }),
                type: "number",
                placeholder: unref(t)("placeHolder.winnerCount"),
                class: "max-w-xs input-sm input input-bordered",
                onChange: changePersonCount
              }, null, 40, _hoisted_16), [[vModelText, unref(temporaryPrize).count]])]), createBaseVNode("label", _hoisted_17, [createBaseVNode("div", _hoisted_18, [createBaseVNode("span", _hoisted_19, toDisplayString$1(unref(t)("table.luckyPeopleNumber")), 1)]), withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[3] || (_cache[3] = function ($event) {
                  return unref(temporaryPrize).isUsedCount = $event;
                }),
                disabled: "",
                type: "number",
                placeholder: unref(t)("placeHolder.winnerCount"),
                class: "max-w-xs input-sm input input-bordered"
              }, null, 8, _hoisted_20), [[vModelText, unref(temporaryPrize).isUsedCount]])]), unref(temporaryPrize).separateCount ? (openBlock(), createElementBlock("label", _hoisted_21, [createBaseVNode("div", _hoisted_22, [createBaseVNode("span", _hoisted_23, toDisplayString$1(unref(t)("table.onceNumber")), 1)]), createBaseVNode("div", {
                class: "flex justify-start h-full",
                onClick: _cache[4] || (_cache[4] = function ($event) {
                  return selectPrize(unref(temporaryPrize));
                })
              }, [unref(temporaryPrize).separateCount.countList.length ? (openBlock(), createElementBlock("ul", _hoisted_24, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(temporaryPrize).separateCount.countList, function (se) {
                return openBlock(), createElementBlock("li", {
                  key: se.id,
                  class: "relative flex items-center justify-center w-8 h-8 bg-slate-600/60 separated"
                }, [createBaseVNode("div", {
                  class: "flex items-center justify-center w-full h-full tooltip",
                  "data-tip": "".concat(unref(t)("tooltip.doneCount") + se.isUsedCount, "/").concat(se.count)
                }, [createBaseVNode("div", {
                  class: "absolute left-0 z-50 h-full bg-blue-300/80",
                  style: normalizeStyle("width:".concat(se.isUsedCount * 100 / se.count, "%"))
                }, null, 4), createBaseVNode("span", null, toDisplayString$1(se.count), 1)], 8, _hoisted_25)]);
              }), 128))])) : (openBlock(), createElementBlock("button", _hoisted_26, toDisplayString$1(unref(t)("button.setting")), 1))])])) : createCommentVNode("", true), createBaseVNode("label", _hoisted_27, [createBaseVNode("div", _hoisted_28, [createBaseVNode("span", _hoisted_29, toDisplayString$1(unref(t)("table.image")), 1)]), withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[5] || (_cache[5] = function ($event) {
                  return unref(temporaryPrize).picture = $event;
                }),
                class: "flex-1 w-12 select select-warning select-sm"
              }, [unref(temporaryPrize).picture.id ? (openBlock(), createElementBlock("option", _hoisted_30, " ")) : createCommentVNode("", true), createBaseVNode("option", _hoisted_31, toDisplayString$1(unref(t)("table.selectPicture")), 1), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(localImageList), function (picItem) {
                return openBlock(), createElementBlock("option", {
                  key: picItem.id,
                  class: "w-auto",
                  value: picItem
                }, toDisplayString$1(picItem.name), 9, _hoisted_32);
              }), 128))], 512), [[vModelSelect, unref(temporaryPrize).picture]])])]), createBaseVNode("div", _hoisted_33, [createBaseVNode("form", _hoisted_34, [createBaseVNode("button", {
                class: "btn btn-sm",
                onClick: submitTemporaryPrize
              }, toDisplayString$1(unref(t)("button.confirm")), 1), createBaseVNode("button", _hoisted_35, toDisplayString$1(unref(t)("button.cancel")), 1)])])])], 512), createVNode(_sfc_main$4, {
                "total-number": (_selectedPrize$value = selectedPrize.value) === null || _selectedPrize$value === void 0 ? void 0 : _selectedPrize$value.count,
                "separated-number": (_selectedPrize$value2 = selectedPrize.value) === null || _selectedPrize$value2 === void 0 ? void 0 : _selectedPrize$value2.separateCount.countList,
                onSubmitData: submitData
              }, null, 8, ["total-number", "separated-number"]), createBaseVNode("div", {
                ref_key: "prizeListContainerRef",
                ref: prizeListContainerRef
              }, [unref(temporaryPrize).isShow ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["h-20 w-72", unref(temporaryPrize).isShow ? "current-prize" : ""])
              }, [createBaseVNode("div", _hoisted_36, [unref(temporaryPrize).isUsed ? (openBlock(), createElementBlock("div", _hoisted_37)) : createCommentVNode("", true), createBaseVNode("figure", _hoisted_38, [unref(temporaryPrize).picture.url ? (openBlock(), createBlock(_sfc_main$5, {
                key: 0,
                "img-item": unref(temporaryPrize).picture
              }, null, 8, ["img-item"])) : (openBlock(), createElementBlock("img", {
                key: 1,
                src: unref(defaultPrizeImage),
                alt: "Prize",
                class: "object-cover h-full rounded-xl"
              }, null, 8, _hoisted_39))]), createBaseVNode("div", _hoisted_40, [createBaseVNode("div", {
                class: "tooltip tooltip-left",
                "data-tip": unref(temporaryPrize).name
              }, [createBaseVNode("h2", _hoisted_42, toDisplayString$1(unref(temporaryPrize).name), 1)], 8, _hoisted_41), createBaseVNode("p", _hoisted_43, toDisplayString$1(unref(temporaryPrize).isUsedCount) + "/" + toDisplayString$1(unref(temporaryPrize).count), 1), createBaseVNode("progress", {
                class: "w-3/4 h-6 progress progress-primary",
                value: unref(temporaryPrize).isUsedCount,
                max: unref(temporaryPrize).count
              }, null, 8, _hoisted_44)]), createBaseVNode("div", _hoisted_45, [createBaseVNode("div", {
                class: "tooltip tooltip-left",
                "data-tip": unref(t)("tooltip.edit")
              }, [createBaseVNode("div", {
                class: "cursor-pointer hover:text-blue-400",
                onClick: addTemporaryPrize
              }, [createVNode(_component_svg_icon, {
                name: "edit"
              })])], 8, _hoisted_46), createBaseVNode("div", {
                class: "tooltip tooltip-left",
                "data-tip": unref(t)("tooltip.delete")
              }, [createBaseVNode("div", {
                class: "cursor-pointer hover:text-blue-400",
                onClick: deleteTemporaryPrize
              }, [createVNode(_component_svg_icon, {
                name: "delete"
              })])], 8, _hoisted_47)])])], 2)) : createCommentVNode("", true), createVNode(Transition, {
                name: "prize-list",
                appear: true
              }, {
                default: withCtx(function () {
                  return [prizeShow.value && !unref(isMobile) && !unref(temporaryPrize).isShow ? (openBlock(), createElementBlock("div", _hoisted_48, [createBaseVNode("ul", {
                    ref_key: "prizeListRef",
                    ref: prizeListRef,
                    class: "flex flex-col gap-1 p-2 rounded-xl bg-slate-500/50"
                  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(localPrizeList), function (item) {
                    return openBlock(), createElementBlock("li", {
                      key: item.id,
                      class: normalizeClass(unref(currentPrize).id === item.id ? "current-prize" : "")
                    }, [item.isShow ? (openBlock(), createElementBlock("div", _hoisted_49, [item.isUsed ? (openBlock(), createElementBlock("div", _hoisted_50)) : createCommentVNode("", true), createBaseVNode("figure", _hoisted_51, [item.picture.url ? (openBlock(), createBlock(_sfc_main$5, {
                      key: 0,
                      "img-item": item.picture
                    }, null, 8, ["img-item"])) : (openBlock(), createElementBlock("img", {
                      key: 1,
                      src: unref(defaultPrizeImage),
                      alt: "Prize",
                      class: "object-cover h-full rounded-xl"
                    }, null, 8, _hoisted_52))]), createBaseVNode("div", _hoisted_53, [createBaseVNode("div", {
                      class: "tooltip tooltip-left",
                      "data-tip": item.name
                    }, [createBaseVNode("h2", _hoisted_55, toDisplayString$1(item.name), 1)], 8, _hoisted_54), createBaseVNode("p", _hoisted_56, toDisplayString$1(item.isUsedCount) + "/" + toDisplayString$1(item.count), 1), createBaseVNode("progress", {
                      class: "w-3/4 h-6 progress progress-primary",
                      value: item.isUsedCount,
                      max: item.count
                    }, null, 8, _hoisted_57)])])) : createCommentVNode("", true)], 2);
                  }), 128))], 512), createBaseVNode("div", _hoisted_58, [createBaseVNode("div", {
                    class: "tooltip tooltip-right",
                    "data-tip": unref(t)("tooltip.prizeList")
                  }, [createBaseVNode("div", {
                    class: "flex items-center w-6 h-8 rounded-r-lg cursor-pointer prize-option bg-slate-500/50",
                    onClick: _cache[6] || (_cache[6] = function ($event) {
                      return prizeShow.value = !prizeShow.value;
                    })
                  }, [createVNode(_component_svg_icon, {
                    name: "arrow_left",
                    class: "w-full h-full"
                  })])], 8, _hoisted_59), createBaseVNode("div", {
                    class: "tooltip tooltip-right",
                    "data-tip": unref(t)("tooltip.addActivity")
                  }, [createBaseVNode("div", {
                    class: "flex items-center w-6 h-8 rounded-r-lg cursor-pointer prize-option bg-slate-500/50",
                    onClick: addTemporaryPrize
                  }, [createVNode(_component_svg_icon, {
                    name: "add",
                    class: "w-full h-full"
                  })])], 8, _hoisted_60)])])) : createCommentVNode("", true)];
                }),
                _: 1
              })], 512), createVNode(Transition, {
                name: "prize-operate",
                appear: true
              }, {
                default: withCtx(function () {
                  return [withDirectives(createBaseVNode("div", {
                    class: "tooltip tooltip-right",
                    "data-tip": unref(t)("tooltip.prizeList")
                  }, [createBaseVNode("div", {
                    class: "flex items-center w-6 h-8 rounded-r-lg cursor-pointer prize-option bg-slate-500/50",
                    onClick: _cache[7] || (_cache[7] = function ($event) {
                      return prizeShow.value = !prizeShow.value;
                    })
                  }, [createVNode(_component_svg_icon, {
                    name: "arrow_right",
                    class: "w-full h-full"
                  })])], 8, _hoisted_61), [[vShow, !prizeShow.value]])];
                }),
                _: 1
              })]);
            };
          }
        });

        /* unplugin-vue-components disabled */

        var PrizeList = /* @__PURE__ */_export_sfc(_sfc_main$3, [["__scopeId", "data-v-055549ac"]]);
        var _hoisted_1$2 = {
          class: "absolute z-10 flex flex-col items-center justify-center -translate-x-1/2 left-1/2"
        };
        var _hoisted_2$2 = {
          class: "flex gap-3"
        };
        var _hoisted_3$2 = {
          id: "menu"
        };
        var _hoisted_4$2 = {
          key: 1,
          class: "start"
        };
        var _hoisted_5$2 = {
          key: 3,
          class: "flex justify-center gap-6 enStop"
        };
        var _hoisted_6$2 = {
          class: "start"
        };
        var _hoisted_7$1 = {
          class: "start"
        };
        var _sfc_main$2 = /* @__PURE__ */defineComponent({
          __name: "index",
          setup: function setup(__props) {
            var _useI18n3 = useI18n(),
              t = _useI18n3.t;
            var toast = distExports.useToast();
            var router = useRouter();
            var personConfig = useStore().personConfig;
            var globalConfig = useStore().globalConfig;
            var prizeConfig = useStore().prizeConfig;
            var _storeToRefs4 = storeToRefs(personConfig),
              allPersonList = _storeToRefs4.getAllPersonList,
              notPersonList = _storeToRefs4.getNotPersonList,
              notThisPrizePersonList = _storeToRefs4.getNotThisPrizePersonList;
            var _storeToRefs5 = storeToRefs(prizeConfig),
              currentPrize = _storeToRefs5.getCurrentPrize;
            var _storeToRefs6 = storeToRefs(globalConfig),
              topTitle = _storeToRefs6.getTopTitle,
              cardColor = _storeToRefs6.getCardColor,
              patternColor = _storeToRefs6.getPatterColor,
              patternList = _storeToRefs6.getPatternList,
              textColor = _storeToRefs6.getTextColor,
              luckyColor = _storeToRefs6.getLuckyColor,
              cardSize = _storeToRefs6.getCardSize,
              textSize = _storeToRefs6.getTextSize,
              rowCount = _storeToRefs6.getRowCount,
              homeBackground = _storeToRefs6.getBackground,
              isShowAvatar = _storeToRefs6.getIsShowAvatar;
            var tableData = ref([]);
            var currentStatus = ref(0);
            var ballRotationY = ref(0);
            var containerRef = ref();
            var canOperate = ref(true);
            var cameraZ = ref(3e3);
            var animationFrameId = ref(null);
            var scene = ref();
            var camera = ref();
            var renderer = ref();
            var controls = ref();
            var objects = ref([]);
            var targets = {
              grid: [],
              helix: [],
              table: [],
              sphere: []
            };
            var luckyTargets = ref([]);
            var luckyCardList = ref([]);
            var luckyCount = ref(10);
            var personPool = ref([]);
            var intervalTimer = ref(null);
            function initTableData() {
              if (allPersonList.value.length <= 0) {
                return;
              }
              var totalCount = rowCount.value * 7;
              var originPersonData = JSON.parse(JSON.stringify(allPersonList.value));
              var originPersonLength = originPersonData.length;
              if (originPersonLength < totalCount) {
                var repeatCount = Math.ceil(totalCount / originPersonLength);
                for (var i = 0; i < repeatCount; i++) {
                  tableData.value = tableData.value.concat(JSON.parse(JSON.stringify(originPersonData)));
                }
              } else {
                tableData.value = originPersonData.slice(0, totalCount);
              }
              tableData.value = filterData(tableData.value.slice(0, totalCount), rowCount.value);
            }
            function init() {
              var felidView = 40;
              var width = window.innerWidth;
              var height = window.innerHeight;
              var aspect = width / height;
              var nearPlane = 1;
              var farPlane = 1e4;
              var WebGLoutput = containerRef.value;
              scene.value = new Scene();
              camera.value = new PerspectiveCamera(felidView, aspect, nearPlane, farPlane);
              camera.value.position.z = cameraZ.value;
              renderer.value = new CSS3DRenderer();
              renderer.value.setSize(width, height * 0.9);
              renderer.value.domElement.style.position = "absolute";
              renderer.value.domElement.style.paddingTop = "50px";
              renderer.value.domElement.style.top = "50%";
              renderer.value.domElement.style.left = "50%";
              renderer.value.domElement.style.transform = "translate(-50%, -50%)";
              WebGLoutput.appendChild(renderer.value.domElement);
              controls.value = new TrackballControls(camera.value, renderer.value.domElement);
              controls.value.rotateSpeed = 1;
              controls.value.staticMoving = true;
              controls.value.minDistance = 500;
              controls.value.maxDistance = 6e3;
              controls.value.addEventListener("change", render);
              var tableLen = tableData.value.length;
              for (var i = 0; i < tableLen; i++) {
                var element = document.createElement("div");
                element.className = "element-card";
                var _number = document.createElement("div");
                _number.className = "card-id";
                _number.textContent = tableData.value[i].uid;
                if (isShowAvatar.value) _number.style.display = "none";
                element.appendChild(_number);
                var symbol = document.createElement("div");
                symbol.className = "card-name";
                symbol.textContent = tableData.value[i].name;
                if (isShowAvatar.value) symbol.className = "card-name card-avatar-name";
                element.appendChild(symbol);
                var detail = document.createElement("div");
                detail.className = "card-detail";
                detail.textContent = "";
                if (tableData.value[i].department) {
                  detail.append(document.createTextNode(tableData.value[i].department));
                }
                if (tableData.value[i].department && tableData.value[i].identity) {
                  detail.append(document.createElement("br"));
                }
                if (tableData.value[i].identity) {
                  detail.append(document.createTextNode(tableData.value[i].identity));
                }
                if (isShowAvatar.value) detail.style.display = "none";
                element.appendChild(detail);
                var avatar = document.createElement("img");
                avatar.className = "card-avatar";
                avatar.src = tableData.value[i].avatar;
                avatar.alt = "avatar";
                avatar.style.width = "140px";
                avatar.style.height = "140px";
                if (!isShowAvatar.value) avatar.style.display = "none";
                element.appendChild(avatar);
                element = useElementStyle(element, tableData.value[i], i, patternList.value, patternColor.value, cardColor.value, cardSize.value, textSize.value);
                var object = new CSS3DObject(element);
                object.position.x = Math.random() * 4e3 - 2e3;
                object.position.y = Math.random() * 4e3 - 2e3;
                object.position.z = Math.random() * 4e3 - 2e3;
                scene.value.add(object);
                objects.value.push(object);
              }
              createTableVertices();
              createSphereVertices();
              createHelixVertices();
              function createTableVertices() {
                var tableLen2 = tableData.value.length;
                for (var _i110 = 0; _i110 < tableLen2; _i110++) {
                  var _object2 = new Object3D();
                  _object2.position.x = tableData.value[_i110].x * (cardSize.value.width + 40) - rowCount.value * 90;
                  _object2.position.y = -tableData.value[_i110].y * (cardSize.value.height + 20) + 1e3;
                  _object2.position.z = 0;
                  targets.table.push(_object2);
                }
              }
              function createSphereVertices() {
                var i = 0;
                var objLength = objects.value.length;
                var vector = new Vector3();
                for (; i < objLength; ++i) {
                  var phi = Math.acos(-1 + 2 * i / objLength);
                  var theta = Math.sqrt(objLength * Math.PI) * phi;
                  var _object3 = new Object3D();
                  _object3.position.x = 800 * Math.cos(theta) * Math.sin(phi);
                  _object3.position.y = 800 * Math.sin(theta) * Math.sin(phi);
                  _object3.position.z = -800 * Math.cos(phi);
                  vector.copy(_object3.position).multiplyScalar(2);
                  _object3.lookAt(vector);
                  targets.sphere.push(_object3);
                }
              }
              function createHelixVertices() {
                var i = 0;
                var vector = new Vector3();
                var objLength = objects.value.length;
                for (; i < objLength; ++i) {
                  var phi = i * 0.213 + Math.PI;
                  var _object4 = new Object3D();
                  _object4.position.x = 800 * Math.sin(phi);
                  _object4.position.y = -(i * 8) + 450;
                  _object4.position.z = 800 * Math.cos(phi + Math.PI);
                  _object4.scale.set(1.1, 1.1, 1.1);
                  vector.x = _object4.position.x * 2;
                  vector.y = _object4.position.y;
                  vector.z = _object4.position.z * 2;
                  _object4.lookAt(vector);
                  targets.helix.push(_object4);
                }
              }
              window.addEventListener("resize", onWindowResize, false);
              transform(targets.table, 1e3);
              render();
            }
            function transform(targets2, duration) {
              removeAll();
              if (intervalTimer.value) {
                clearInterval(intervalTimer.value);
                intervalTimer.value = null;
                randomBallData("sphere");
              }
              return new Promise(function (resolve) {
                var objLength = objects.value.length;
                var _loop17 = function _loop17(i) {
                  var object = objects.value[i];
                  var target = targets2[i];
                  new Tween(object.position).to({
                    x: target.position.x,
                    y: target.position.y,
                    z: target.position.z
                  }, Math.random() * duration + duration).easing(Easing.Exponential.InOut).start();
                  new Tween(object.rotation).to({
                    x: target.rotation.x,
                    y: target.rotation.y,
                    z: target.rotation.z
                  }, Math.random() * duration + duration).easing(Easing.Exponential.InOut).start().onComplete(function () {
                    if (luckyCardList.value.length) {
                      luckyCardList.value.forEach(function (cardIndex) {
                        var item = objects.value[cardIndex];
                        useElementStyle(item.element, {}, i, patternList.value, patternColor.value, cardColor.value, cardSize.value, textSize.value, "sphere");
                      });
                    }
                    luckyTargets.value = [];
                    luckyCardList.value = [];
                    canOperate.value = true;
                  });
                };
                for (var i = 0; i < objLength; ++i) {
                  _loop17(i);
                }
                new Tween({}).to({}, duration * 2).onUpdate(render).start().onComplete(function () {
                  canOperate.value = true;
                  resolve("");
                });
              });
            }
            function onWindowResize() {
              camera.value.aspect = window.innerWidth / window.innerHeight;
              camera.value.updateProjectionMatrix();
              renderer.value.setSize(window.innerWidth, window.innerHeight);
              render();
            }
            function animation() {
              update();
              if (controls.value) {
                controls.value.update();
              }
              animationFrameId.value = requestAnimationFrame(animation);
            }
            function rollBall(rotateY, duration) {
              removeAll();
              return new Promise(function (resolve) {
                scene.value.rotation.y = 0;
                ballRotationY.value = Math.PI * rotateY * 1e3;
                var rotateObj = new Tween(scene.value.rotation);
                rotateObj.to({
                  // x: Math.PI * rotateX * 1000,
                  x: 0,
                  y: ballRotationY.value,
                  // z: Math.PI * rotateZ * 1000
                  z: 0
                }, duration * 1e3).onUpdate(render).start().onStop(function () {
                  resolve("");
                }).onComplete(function () {
                  resolve("");
                });
              });
            }
            function resetCamera() {
              new Tween(camera.value.position).to({
                x: 0,
                y: 0,
                z: 3e3
              }, 1e3).onUpdate(render).start().onComplete(function () {
                new Tween(camera.value.rotation).to({
                  x: 0,
                  y: 0,
                  z: 0
                }, 1e3).onUpdate(render).start().onComplete(function () {
                  canOperate.value = true;
                  camera.value.position.y = 0;
                  camera.value.position.x = 0;
                  camera.value.position.z = 3e3;
                  camera.value.rotation.x = 0;
                  camera.value.rotation.y = 0;
                  camera.value.rotation.z = -0;
                  controls.value.reset();
                });
              });
            }
            function render() {
              if (renderer.value) {
                renderer.value.render(scene.value, camera.value);
              }
            }
            function enterLottery() {
              return _enterLottery.apply(this, arguments);
            }
            function _enterLottery() {
              _enterLottery = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
                var i;
                return _regeneratorRuntime().wrap(function _callee14$(_context22) {
                  while (1) switch (_context22.prev = _context22.next) {
                    case 0:
                      if (canOperate.value) {
                        _context22.next = 2;
                        break;
                      }
                      return _context22.abrupt("return");
                    case 2:
                      if (!intervalTimer.value) {
                        randomBallData();
                      }
                      if (patternList.value.length) {
                        for (i = 0; i < patternList.value.length; i++) {
                          if (i < rowCount.value * 7) {
                            objects.value[patternList.value[i] - 1].element.style.backgroundColor = rgba(cardColor.value, Math.random() * 0.5 + 0.25);
                          }
                        }
                      }
                      canOperate.value = false;
                      _context22.next = 7;
                      return transform(targets.sphere, 1e3);
                    case 7:
                      currentStatus.value = 1;
                      rollBall(0.1, 2e3);
                    case 9:
                    case "end":
                      return _context22.stop();
                  }
                }, _callee14);
              }));
              return _enterLottery.apply(this, arguments);
            }
            function startLottery() {
              if (!canOperate.value) {
                return;
              }
              if (currentPrize.value.isUsed || !currentPrize.value) {
                toast.open({
                  message: i18n.global.t("error.personIsAllDone"),
                  type: "warning",
                  position: "top-right",
                  duration: 1e4
                });
                return;
              }
              personPool.value = currentPrize.value.isAll ? notThisPrizePersonList.value : notPersonList.value;
              if (personPool.value.length < currentPrize.value.count - currentPrize.value.isUsedCount) {
                toast.open({
                  message: i18n.global.t("error.personNotEnough"),
                  type: "warning",
                  position: "top-right",
                  duration: 1e4
                });
                return;
              }
              luckyCount.value = 10;
              var leftover = currentPrize.value.count - currentPrize.value.isUsedCount;
              var customCount = currentPrize.value.separateCount;
              if (customCount && customCount.enable && customCount.countList.length > 0) {
                for (var i = 0; i < customCount.countList.length; i++) {
                  if (customCount.countList[i].isUsedCount < customCount.countList[i].count) {
                    leftover = customCount.countList[i].count - customCount.countList[i].isUsedCount;
                    break;
                  }
                }
              }
              luckyCount.value = leftover < luckyCount.value ? leftover : luckyCount.value;
              for (var _i111 = 0; _i111 < luckyCount.value; _i111++) {
                if (personPool.value.length > 0) {
                  var randomIndex = Math.floor(Math.random() * personPool.value.length);
                  luckyTargets.value.push(personPool.value[randomIndex]);
                  personPool.value.splice(randomIndex, 1);
                }
              }
              toast.open({
                // message: `${currentPrize.value.name} ${leftover}`,
                message: i18n.global.t("error.startDraw", {
                  count: currentPrize.value.name,
                  leftover: leftover
                }),
                type: "default",
                position: "top-right",
                duration: 8e3
              });
              currentStatus.value = 2;
              rollBall(10, 3e3);
            }
            function stopLottery() {
              return _stopLottery.apply(this, arguments);
            }
            function _stopLottery() {
              _stopLottery = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
                var windowSize;
                return _regeneratorRuntime().wrap(function _callee15$(_context23) {
                  while (1) switch (_context23.prev = _context23.next) {
                    case 0:
                      if (canOperate.value) {
                        _context23.next = 2;
                        break;
                      }
                      return _context23.abrupt("return");
                    case 2:
                      canOperate.value = false;
                      rollBall(0, 1);
                      windowSize = {
                        width: window.innerWidth,
                        height: window.innerHeight
                      };
                      luckyTargets.value.forEach(function (person, index) {
                        var cardIndex = selectCard(luckyCardList.value, tableData.value.length, person.id);
                        luckyCardList.value.push(cardIndex);
                        var totalLuckyCount = luckyTargets.value.length;
                        var item = objects.value[cardIndex];
                        var _useElementPosition = useElementPosition(item, rowCount.value, totalLuckyCount, {
                            width: cardSize.value.width * 2,
                            height: cardSize.value.height * 2
                          }, windowSize, index),
                          xTable = _useElementPosition.xTable,
                          yTable = _useElementPosition.yTable;
                        new Tween(item.position).to({
                          x: xTable,
                          y: yTable,
                          z: 1e3
                        }, 1200).easing(Easing.Exponential.InOut).onStart(function () {
                          item.element = useElementStyle(item.element, person, cardIndex, patternList.value, patternColor.value, luckyColor.value, {
                            width: cardSize.value.width * 2,
                            height: cardSize.value.height * 2
                          }, textSize.value * 2, "lucky");
                        }).start().onComplete(function () {
                          canOperate.value = true;
                          currentStatus.value = 3;
                        });
                        new Tween(item.rotation).to({
                          x: 0,
                          y: 0,
                          z: 0
                        }, 900).easing(Easing.Exponential.InOut).start().onComplete(function () {
                          confettiFire();
                          resetCamera();
                        });
                      });
                    case 6:
                    case "end":
                      return _context23.stop();
                  }
                }, _callee15);
              }));
              return _stopLottery.apply(this, arguments);
            }
            function continueLottery() {
              return _continueLottery.apply(this, arguments);
            }
            function _continueLottery() {
              _continueLottery = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
                var customCount, i;
                return _regeneratorRuntime().wrap(function _callee16$(_context24) {
                  while (1) switch (_context24.prev = _context24.next) {
                    case 0:
                      if (canOperate.value) {
                        _context24.next = 2;
                        break;
                      }
                      return _context24.abrupt("return");
                    case 2:
                      customCount = currentPrize.value.separateCount;
                      if (!(customCount && customCount.enable && customCount.countList.length > 0)) {
                        _context24.next = 12;
                        break;
                      }
                      i = 0;
                    case 5:
                      if (!(i < customCount.countList.length)) {
                        _context24.next = 12;
                        break;
                      }
                      if (!(customCount.countList[i].isUsedCount < customCount.countList[i].count)) {
                        _context24.next = 9;
                        break;
                      }
                      customCount.countList[i].isUsedCount += luckyCount.value;
                      return _context24.abrupt("break", 12);
                    case 9:
                      i++;
                      _context24.next = 5;
                      break;
                    case 12:
                      currentPrize.value.isUsedCount += luckyCount.value;
                      luckyCount.value = 0;
                      if (currentPrize.value.isUsedCount >= currentPrize.value.count) {
                        currentPrize.value.isUsed = true;
                        currentPrize.value.isUsedCount = currentPrize.value.count;
                      }
                      personConfig.addAlreadyPersonList(luckyTargets.value, currentPrize.value);
                      prizeConfig.updatePrizeConfig(currentPrize.value);
                      _context24.next = 19;
                      return enterLottery();
                    case 19:
                    case "end":
                      return _context24.stop();
                  }
                }, _callee16);
              }));
              return _continueLottery.apply(this, arguments);
            }
            function quitLottery() {
              enterLottery();
              currentStatus.value = 0;
            }
            function confettiFire() {
              var duration = 3 * 1e3;
              var end = Date.now() + duration;
              (function frame() {
                confetti({
                  particleCount: 2,
                  angle: 60,
                  spread: 55,
                  origin: {
                    x: 0
                  }
                });
                confetti({
                  particleCount: 2,
                  angle: 120,
                  spread: 55,
                  origin: {
                    x: 1
                  }
                });
                if (Date.now() < end) {
                  requestAnimationFrame(frame);
                }
              })();
              centerFire(0.25, {
                spread: 26,
                startVelocity: 55
              });
              centerFire(0.2, {
                spread: 60
              });
              centerFire(0.35, {
                spread: 100,
                decay: 0.91,
                scalar: 0.8
              });
              centerFire(0.1, {
                spread: 120,
                startVelocity: 25,
                decay: 0.92,
                scalar: 1.2
              });
              centerFire(0.1, {
                spread: 120,
                startVelocity: 45
              });
            }
            function centerFire(particleRatio, opts) {
              var count = 200;
              confetti(_objectSpread(_objectSpread({
                origin: {
                  y: 0.7
                }
              }, opts), {}, {
                particleCount: Math.floor(count * particleRatio)
              }));
            }
            function setDefaultPersonList() {
              personConfig.setDefaultPersonList();
              window.location.reload();
            }
            function randomBallData() {
              var mod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "default";
              intervalTimer.value = setInterval(function () {
                var indexLength = 4;
                var cardRandomIndexArr = [];
                var personRandomIndexArr = [];
                for (var i = 0; i < indexLength; i++) {
                  var randomCardIndex = Math.floor(Math.random() * tableData.value.length);
                  var randomPersonIndex = Math.floor(Math.random() * allPersonList.value.length);
                  if (luckyCardList.value.includes(randomCardIndex)) {
                    continue;
                  }
                  cardRandomIndexArr.push(randomCardIndex);
                  personRandomIndexArr.push(randomPersonIndex);
                }
                for (var _i112 = 0; _i112 < cardRandomIndexArr.length; _i112++) {
                  if (!objects.value[cardRandomIndexArr[_i112]]) {
                    continue;
                  }
                  objects.value[cardRandomIndexArr[_i112]].element = useElementStyle(objects.value[cardRandomIndexArr[_i112]].element, allPersonList.value[personRandomIndexArr[_i112]], cardRandomIndexArr[_i112], patternList.value, patternColor.value, cardColor.value, {
                    width: cardSize.value.width,
                    height: cardSize.value.height
                  }, textSize.value, mod, "change");
                }
              }, 200);
            }
            function listenKeyboard(e) {
              if (e.keyCode !== 32 && e.keyCode !== 27 && !canOperate.value) {
                return;
              }
              if (e.keyCode === 27 && currentStatus.value === 3) {
                quitLottery();
              }
              if (e.keyCode !== 32) {
                return;
              }
              switch (currentStatus.value) {
                case 0:
                  enterLottery();
                  break;
                case 1:
                  startLottery();
                  break;
                case 2:
                  stopLottery();
                  break;
                case 3:
                  continueLottery();
                  break;
              }
            }
            function cleanup() {
              removeAll();
              if (window.cancelAnimationFrame) {
                window.cancelAnimationFrame(animationFrameId.value);
              }
              clearInterval(intervalTimer.value);
              intervalTimer.value = null;
              if (scene.value) {
                scene.value.traverse(function (object) {
                  if (object.material) {
                    if (Array.isArray(object.material)) {
                      object.material.forEach(function (material) {
                        material.dispose();
                      });
                    } else {
                      object.material.dispose();
                    }
                  }
                  if (object.geometry) {
                    object.geometry.dispose();
                  }
                  if (object.texture) {
                    object.texture.dispose();
                  }
                });
                scene.value.clear();
              }
              if (objects.value) {
                objects.value.forEach(function (object) {
                  if (object.element) {
                    object.element.remove();
                  }
                });
                objects.value = [];
              }
              if (controls.value) {
                controls.value.removeEventListener("change");
                controls.value.dispose();
              }
              window.removeEventListener("resize", onWindowResize);
              scene.value = null;
              camera.value = null;
              renderer.value = null;
              controls.value = null;
            }
            onMounted(function () {
              initTableData();
              init();
              animation();
              containerRef.value.style.color = "".concat(textColor);
              randomBallData();
              window.addEventListener("keydown", listenKeyboard);
            });
            onUnmounted(function () {
              nextTick(function () {
                cleanup();
              });
              clearInterval(intervalTimer.value);
              intervalTimer.value = null;
              window.removeEventListener("keydown", listenKeyboard);
            });
            return function (_ctx, _cache) {
              return openBlock(), createElementBlock(Fragment, null, [createBaseVNode("div", _hoisted_1$2, [createBaseVNode("h2", {
                class: "pt-12 m-0 mb-12 font-mono tracking-wide text-center leading-12 header-title",
                style: normalizeStyle({
                  fontSize: "".concat(unref(textSize) * 1.5, "px"),
                  color: unref(textColor)
                })
              }, toDisplayString$1(unref(topTitle)), 5), createBaseVNode("div", _hoisted_2$2, [tableData.value.length <= 0 ? (openBlock(), createElementBlock("button", {
                key: 0,
                class: "cursor-pointer btn btn-outline btn-secondary btn-lg",
                onClick: _cache[0] || (_cache[0] = function ($event) {
                  return unref(router).push("config");
                })
              }, toDisplayString$1(unref(t)("button.noInfoAndImport")), 1)) : createCommentVNode("", true), tableData.value.length <= 0 ? (openBlock(), createElementBlock("button", {
                key: 1,
                class: "cursor-pointer btn btn-outline btn-secondary btn-lg",
                onClick: setDefaultPersonList
              }, toDisplayString$1(unref(t)("button.useDefault")), 1)) : createCommentVNode("", true)])]), createBaseVNode("div", {
                id: "container",
                ref_key: "containerRef",
                ref: containerRef,
                class: "3dContainer"
              }, [createBaseVNode("div", _hoisted_3$2, [currentStatus.value === 0 && tableData.value.length > 0 ? (openBlock(), createElementBlock("button", {
                key: 0,
                class: "btn-end",
                onClick: enterLottery
              }, toDisplayString$1(unref(t)("button.enterLottery")), 1)) : createCommentVNode("", true), currentStatus.value === 1 ? (openBlock(), createElementBlock("div", _hoisted_4$2, [createBaseVNode("button", {
                class: "btn-start",
                onClick: startLottery
              }, [createBaseVNode("strong", null, toDisplayString$1(unref(t)("button.start")), 1), _cache[1] || (_cache[1] = createStaticVNode('<div id="container-stars" data-v-29bbe6aa><div id="stars" data-v-29bbe6aa></div></div><div id="glow" data-v-29bbe6aa><div class="circle" data-v-29bbe6aa></div><div class="circle" data-v-29bbe6aa></div></div>', 2))])])) : createCommentVNode("", true), currentStatus.value === 2 ? (openBlock(), createElementBlock("button", {
                key: 2,
                class: "btn-end btn glass btn-lg",
                onClick: stopLottery
              }, toDisplayString$1(unref(t)("button.selectLucky")), 1)) : createCommentVNode("", true), currentStatus.value === 3 ? (openBlock(), createElementBlock("div", _hoisted_5$2, [createBaseVNode("div", _hoisted_6$2, [createBaseVNode("button", {
                class: "btn-start",
                onClick: continueLottery
              }, [createBaseVNode("strong", null, toDisplayString$1(unref(t)("button.continue")), 1), _cache[2] || (_cache[2] = createStaticVNode('<div id="container-stars" data-v-29bbe6aa><div id="stars" data-v-29bbe6aa></div></div><div id="glow" data-v-29bbe6aa><div class="circle" data-v-29bbe6aa></div><div class="circle" data-v-29bbe6aa></div></div>', 2))])]), createBaseVNode("div", _hoisted_7$1, [createBaseVNode("button", {
                class: "btn-cancel",
                onClick: quitLottery
              }, [createBaseVNode("strong", null, toDisplayString$1(unref(t)("button.cancel")), 1), _cache[3] || (_cache[3] = createStaticVNode('<div id="container-stars" data-v-29bbe6aa><div id="stars" data-v-29bbe6aa></div></div><div id="glow" data-v-29bbe6aa><div class="circle" data-v-29bbe6aa></div><div class="circle" data-v-29bbe6aa></div></div>', 2))])])])) : createCommentVNode("", true)])], 512), createVNode(_sfc_main$6, {
                "home-background": unref(homeBackground)
              }, null, 8, ["home-background"]), createVNode(PrizeList, {
                class: "absolute left-0 top-32"
              })], 64);
            };
          }
        });

        /* unplugin-vue-components disabled */

        var Home = /* @__PURE__ */_export_sfc(_sfc_main$2, [["__scopeId", "data-v-29bbe6aa"]]);
        var configRoutes = exports("h", {
          path: "/log-lottery/config",
          name: "Config",
          component: function component() {
            return __vitePreload(function () {
              return module.import('./index-legacy-CpM7OCCM.js');
            }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
          },
          children: [{
            path: "",
            redirect: "/log-lottery/config/person"
          }, {
            path: "/log-lottery/config/person",
            name: "PersonConfig",
            component: function component() {
              return __vitePreload(function () {
                return module.import('./PersonConfig-legacy-BkVeYo9G.js');
              }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
            },
            meta: {
              title: i18n.global.t("sidebar.personConfiguration"),
              icon: "person"
            },
            children: [{
              path: "",
              redirect: "/log-lottery/config/person/all"
            }, {
              path: "/log-lottery/config/person/all",
              name: "AllPersonConfig",
              component: function component() {
                return __vitePreload(function () {
                  return module.import('./PersonAll-legacy-B-JiJ4pG.js');
                }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
              },
              meta: {
                title: i18n.global.t("sidebar.personList"),
                icon: "all"
              }
            }, {
              path: "/log-lottery/config/person/already",
              name: "AlreadyPerson",
              component: function component() {
                return __vitePreload(function () {
                  return module.import('./PersonAlready-legacy-CoFV62cu.js');
                }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
              },
              meta: {
                title: i18n.global.t("sidebar.winnerList"),
                icon: "already"
              }
            }
            // {
            //     path:'other',
            //     name:'OtherPersonConfig',
            //     component:()=>import('@/views/Config/Person/OtherPersonConfig.vue'),
            //     meta:{
            //         title:'',
            //         icon:'other'
            //     }
            // }
            ]
          }, {
            path: "/log-lottery/config/prize",
            name: "PrizeConfig",
            component: function component() {
              return __vitePreload(function () {
                return module.import('./PrizeConfig-legacy-C7Thfn0R.js');
              }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
            },
            meta: {
              title: i18n.global.t("sidebar.prizeConfiguration"),
              icon: "prize"
            }
          }, {
            path: "/log-lottery/config/global",
            name: "GlobalConfig",
            redirect: "/log-lottery/config/global/all",
            meta: {
              title: i18n.global.t("sidebar.globalSetting"),
              icon: "global"
            },
            children: [{
              path: "/log-lottery/config/global/face",
              name: "FaceConfig",
              component: function component() {
                return __vitePreload(function () {
                  return module.import('./FaceConfig-legacy-fQKbQVgO.js');
                }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
              },
              meta: {
                title: i18n.global.t("sidebar.viewSetting"),
                icon: "face"
              }
            }, {
              path: "/log-lottery/config/global/image",
              name: "ImageConfig",
              component: function component() {
                return __vitePreload(function () {
                  return module.import('./ImageConfig-legacy-CPakbzWJ.js');
                }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
              },
              meta: {
                title: i18n.global.t("sidebar.imagesManagement"),
                icon: "image"
              }
            }, {
              path: "/log-lottery/config/global/music",
              name: "MusicConfig",
              component: function component() {
                return __vitePreload(function () {
                  return module.import('./MusicConfig-legacy-Bj1uTblg.js');
                }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
              },
              meta: {
                title: i18n.global.t("sidebar.musicManagement"),
                icon: "music"
              }
            }]
          }, {
            path: "/log-lottery/config/readme",
            name: "Readme",
            component: function component() {
              return __vitePreload(function () {
                return module.import('./index-legacy-B1qv1nYs.js');
              }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
            },
            meta: {
              title: i18n.global.t("sidebar.operatingInstructions"),
              icon: "readme"
            }
          }]
        });
        var fileModeRoutes = [{
          path: "/",
          component: _sfc_main$7,
          redirect: "/home",
          children: [{
            path: "/home",
            name: "Home",
            component: Home
          }, {
            path: "/demo",
            name: "Demo",
            component: function component() {
              return __vitePreload(function () {
                return module.import('./index-legacy-CAqC27bW.js');
              }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
            }
          }, {
            path: "/config",
            name: "Config",
            component: function component() {
              return __vitePreload(function () {
                return module.import('./index-legacy-CpM7OCCM.js');
              }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
            },
            children: [{
              path: "",
              redirect: "/config/person"
            }, {
              path: "/config/person",
              name: "PersonConfig",
              component: function component() {
                return __vitePreload(function () {
                  return module.import('./PersonConfig-legacy-BkVeYo9G.js');
                }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
              },
              meta: {
                title: i18n.global.t("sidebar.personConfiguration"),
                icon: "person"
              },
              children: [{
                path: "",
                redirect: "/config/person/all"
              }, {
                path: "/config/person/all",
                name: "AllPersonConfig",
                component: function component() {
                  return __vitePreload(function () {
                    return module.import('./PersonAll-legacy-B-JiJ4pG.js');
                  }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
                },
                meta: {
                  title: i18n.global.t("sidebar.personList"),
                  icon: "all"
                }
              }, {
                path: "/config/person/already",
                name: "AlreadyPerson",
                component: function component() {
                  return __vitePreload(function () {
                    return module.import('./PersonAlready-legacy-CoFV62cu.js');
                  }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
                },
                meta: {
                  title: i18n.global.t("sidebar.winnerList"),
                  icon: "already"
                }
              }]
            }, {
              path: "/config/prize",
              name: "PrizeConfig",
              component: function component() {
                return __vitePreload(function () {
                  return module.import('./PrizeConfig-legacy-C7Thfn0R.js');
                }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
              },
              meta: {
                title: i18n.global.t("sidebar.prizeConfiguration"),
                icon: "prize"
              }
            }, {
              path: "/config/global",
              name: "GlobalConfig",
              redirect: "/config/global/all",
              meta: {
                title: i18n.global.t("sidebar.globalSetting"),
                icon: "global"
              },
              children: [{
                path: "/config/global/face",
                name: "FaceConfig",
                component: function component() {
                  return __vitePreload(function () {
                    return module.import('./FaceConfig-legacy-fQKbQVgO.js');
                  }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
                },
                meta: {
                  title: i18n.global.t("sidebar.viewSetting"),
                  icon: "face"
                }
              }, {
                path: "/config/global/image",
                name: "ImageConfig",
                component: function component() {
                  return __vitePreload(function () {
                    return module.import('./ImageConfig-legacy-CPakbzWJ.js');
                  }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
                },
                meta: {
                  title: i18n.global.t("sidebar.imagesManagement"),
                  icon: "image"
                }
              }, {
                path: "/config/global/music",
                name: "MusicConfig",
                component: function component() {
                  return __vitePreload(function () {
                    return module.import('./MusicConfig-legacy-Bj1uTblg.js');
                  }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
                },
                meta: {
                  title: i18n.global.t("sidebar.musicManagement"),
                  icon: "music"
                }
              }]
            }, {
              path: "/config/readme",
              name: "Readme",
              component: function component() {
                return __vitePreload(function () {
                  return module.import('./index-legacy-B1qv1nYs.js');
                }, false ? __VITE_PRELOAD__ : void 0, module.meta.url);
              },
              meta: {
                title: i18n.global.t("sidebar.operatingInstructions"),
                icon: "readme"
              }
            }]
          }]
        }];
        var router = createRouter({
          // 
          history: createWebHashHistory(),
          routes: fileModeRoutes
        });
        var updateStorage = function updateStorage(strategy, store) {
          var storage = strategy.storage || sessionStorage;
          var storeKey = strategy.key || store.$id;
          if (strategy.paths) {
            var partialState = strategy.paths.reduce(function (finalObj, key) {
              finalObj[key] = store.$state[key];
              return finalObj;
            }, {});
            storage.setItem(storeKey, JSON.stringify(partialState));
          } else {
            storage.setItem(storeKey, JSON.stringify(store.$state));
          }
        };
        var index = function index(_ref84) {
          var options = _ref84.options,
            store = _ref84.store;
          var _a, _b, _c, _d;
          if ((_a = options.persist) == null ? void 0 : _a.enabled) {
            var defaultStrat = [{
              key: store.$id,
              storage: sessionStorage
            }];
            var strategies = ((_c = (_b = options.persist) == null ? void 0 : _b.strategies) == null ? void 0 : _c.length) ? (_d = options.persist) == null ? void 0 : _d.strategies : defaultStrat;
            strategies.forEach(function (strategy) {
              var storage = strategy.storage || sessionStorage;
              var storeKey = strategy.key || store.$id;
              var storageResult = storage.getItem(storeKey);
              if (storageResult) {
                store.$patch(JSON.parse(storageResult));
                updateStorage(strategy, store);
              }
            });
            store.$subscribe(function () {
              strategies.forEach(function (strategy) {
                updateStorage(strategy, store);
              });
            });
          }
        };

        /*! @license DOMPurify 3.2.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.1/LICENSE */

        var entries = Object.entries,
          setPrototypeOf = Object.setPrototypeOf,
          isFrozen = Object.isFrozen,
          getPrototypeOf = Object.getPrototypeOf,
          getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var freeze = Object.freeze,
          seal = Object.seal,
          create = Object.create; // eslint-disable-line import/no-mutable-exports
        var _ref85 = typeof Reflect !== 'undefined' && Reflect,
          apply = _ref85.apply,
          construct = _ref85.construct;
        if (!freeze) {
          freeze = function freeze(x) {
            return x;
          };
        }
        if (!seal) {
          seal = function seal(x) {
            return x;
          };
        }
        if (!apply) {
          apply = function apply(fun, thisValue, args) {
            return fun.apply(thisValue, args);
          };
        }
        if (!construct) {
          construct = function construct(Func, args) {
            return _construct(Func, _toConsumableArray(args));
          };
        }
        var arrayForEach = unapply(Array.prototype.forEach);
        var arrayPop = unapply(Array.prototype.pop);
        var arrayPush = unapply(Array.prototype.push);
        var stringToLowerCase = unapply(String.prototype.toLowerCase);
        var stringToString = unapply(String.prototype.toString);
        var stringMatch = unapply(String.prototype.match);
        var stringReplace = unapply(String.prototype.replace);
        var stringIndexOf = unapply(String.prototype.indexOf);
        var stringTrim = unapply(String.prototype.trim);
        var objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
        var regExpTest = unapply(RegExp.prototype.test);
        var typeErrorCreate = unconstruct(TypeError);
        /**
         * Creates a new function that calls the given function with a specified thisArg and arguments.
         *
         * @param func - The function to be wrapped and called.
         * @returns A new function that calls the given function with a specified thisArg and arguments.
         */
        function unapply(func) {
          return function (thisArg) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return apply(func, thisArg, args);
          };
        }
        /**
         * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
         *
         * @param func - The constructor function to be wrapped and called.
         * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
         */
        function unconstruct(func) {
          return function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            return construct(func, args);
          };
        }
        /**
         * Add properties to a lookup table
         *
         * @param set - The set to which elements will be added.
         * @param array - The array containing elements to be added to the set.
         * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
         * @returns The modified set with added elements.
         */
        function addToSet(set, array) {
          var transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
          if (setPrototypeOf) {
            // Make 'in' and truthy checks like Boolean(set.constructor)
            // independent of any properties defined on Object.prototype.
            // Prevent prototype setters from intercepting set as a this value.
            setPrototypeOf(set, null);
          }
          var l = array.length;
          while (l--) {
            var element = array[l];
            if (typeof element === 'string') {
              var lcElement = transformCaseFunc(element);
              if (lcElement !== element) {
                // Config presets (e.g. tags.js, attrs.js) are immutable.
                if (!isFrozen(array)) {
                  array[l] = lcElement;
                }
                element = lcElement;
              }
            }
            set[element] = true;
          }
          return set;
        }
        /**
         * Clean up an array to harden against CSPP
         *
         * @param array - The array to be cleaned.
         * @returns The cleaned version of the array
         */
        function cleanArray(array) {
          for (var _index20 = 0; _index20 < array.length; _index20++) {
            var isPropertyExist = objectHasOwnProperty(array, _index20);
            if (!isPropertyExist) {
              array[_index20] = null;
            }
          }
          return array;
        }
        /**
         * Shallow clone an object
         *
         * @param object - The object to be cloned.
         * @returns A new object that copies the original.
         */
        function clone(object) {
          var newObject = create(null);
          var _iterator41 = _createForOfIteratorHelper(entries(object)),
            _step41;
          try {
            for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
              var _step41$value = _slicedToArray(_step41.value, 2),
                property = _step41$value[0],
                value = _step41$value[1];
              var isPropertyExist = objectHasOwnProperty(object, property);
              if (isPropertyExist) {
                if (Array.isArray(value)) {
                  newObject[property] = cleanArray(value);
                } else if (value && _typeof2(value) === 'object' && value.constructor === Object) {
                  newObject[property] = clone(value);
                } else {
                  newObject[property] = value;
                }
              }
            }
          } catch (err) {
            _iterator41.e(err);
          } finally {
            _iterator41.f();
          }
          return newObject;
        }
        /**
         * This method automatically checks if the prop is function or getter and behaves accordingly.
         *
         * @param object - The object to look up the getter function in its prototype chain.
         * @param prop - The property name for which to find the getter function.
         * @returns The getter function found in the prototype chain or a fallback function.
         */
        function lookupGetter(object, prop) {
          while (object !== null) {
            var desc = getOwnPropertyDescriptor(object, prop);
            if (desc) {
              if (desc.get) {
                return unapply(desc.get);
              }
              if (typeof desc.value === 'function') {
                return unapply(desc.value);
              }
            }
            object = getPrototypeOf(object);
          }
          function fallbackValue() {
            return null;
          }
          return fallbackValue;
        }
        var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
        // SVG
        var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
        var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
        // List of SVG elements that are disallowed by default.
        // We still need to know them so that we can do namespace
        // checks properly in case one wants to add them to
        // allow-list.
        var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
        var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);
        // Similarly to SVG, we want to know all MathML elements,
        // even those that we disallow by default.
        var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
        var text = freeze(['#text']);
        var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);
        var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
        var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
        var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

        // eslint-disable-next-line unicorn/better-regex
        var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
        var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
        var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
        var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
        var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
        var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
        );
        var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
        var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
        );
        var DOCTYPE_NAME = seal(/^html$/i);
        var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
        var EXPRESSIONS = /*#__PURE__*/Object.freeze({
          __proto__: null,
          ARIA_ATTR: ARIA_ATTR,
          ATTR_WHITESPACE: ATTR_WHITESPACE,
          CUSTOM_ELEMENT: CUSTOM_ELEMENT,
          DATA_ATTR: DATA_ATTR,
          DOCTYPE_NAME: DOCTYPE_NAME,
          ERB_EXPR: ERB_EXPR,
          IS_ALLOWED_URI: IS_ALLOWED_URI,
          IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
          MUSTACHE_EXPR: MUSTACHE_EXPR,
          TMPLIT_EXPR: TMPLIT_EXPR
        });

        /* eslint-disable @typescript-eslint/indent */
        // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
        var NODE_TYPE = {
          element: 1,
          attribute: 2,
          text: 3,
          cdataSection: 4,
          entityReference: 5,
          // Deprecated
          entityNode: 6,
          // Deprecated
          progressingInstruction: 7,
          comment: 8,
          document: 9,
          documentType: 10,
          documentFragment: 11,
          notation: 12 // Deprecated
        };
        var getGlobal = function getGlobal() {
          return typeof window === 'undefined' ? null : window;
        };
        /**
         * Creates a no-op policy for internal use only.
         * Don't export this function outside this module!
         * @param trustedTypes The policy factory.
         * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
         * @return The policy created (or null, if Trusted Types
         * are not supported or creating the policy failed).
         */
        var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
          if (_typeof2(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
            return null;
          }
          // Allow the callers to control the unique policy name
          // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
          // Policy creation with duplicate names throws in Trusted Types.
          var suffix = null;
          var ATTR_NAME = 'data-tt-policy-suffix';
          if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
            suffix = purifyHostElement.getAttribute(ATTR_NAME);
          }
          var policyName = 'dompurify' + (suffix ? '#' + suffix : '');
          try {
            return trustedTypes.createPolicy(policyName, {
              createHTML: function createHTML(html) {
                return html;
              },
              createScriptURL: function createScriptURL(scriptUrl) {
                return scriptUrl;
              }
            });
          } catch (_) {
            // Policy creation failed (most likely another DOMPurify script has
            // already run). Skip creating the policy, as this will only cause errors
            // if TT are enforced.
            console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
            return null;
          }
        };
        function createDOMPurify() {
          var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
          var DOMPurify = function DOMPurify(root) {
            return createDOMPurify(root);
          };
          DOMPurify.version = '3.2.1';
          DOMPurify.removed = [];
          if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document) {
            // Not running in a browser, provide a factory function
            // so that you can pass your own Window
            DOMPurify.isSupported = false;
            return DOMPurify;
          }
          var document = window.document;
          var originalDocument = document;
          var currentScript = originalDocument.currentScript;
          var DocumentFragment = window.DocumentFragment,
            HTMLTemplateElement = window.HTMLTemplateElement,
            Node = window.Node,
            Element = window.Element,
            NodeFilter = window.NodeFilter,
            _window$NamedNodeMap = window.NamedNodeMap,
            NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
            HTMLFormElement = window.HTMLFormElement,
            DOMParser = window.DOMParser,
            trustedTypes = window.trustedTypes;
          var ElementPrototype = Element.prototype;
          var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
          var remove = lookupGetter(ElementPrototype, 'remove');
          var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
          var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
          var getParentNode = lookupGetter(ElementPrototype, 'parentNode');
          // As per issue #47, the web-components registry is inherited by a
          // new document created via createHTMLDocument. As per the spec
          // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
          // a new empty registry is used when creating a template contents owner
          // document, so we use that as our parent document to ensure nothing
          // is inherited.
          if (typeof HTMLTemplateElement === 'function') {
            var template = document.createElement('template');
            if (template.content && template.content.ownerDocument) {
              document = template.content.ownerDocument;
            }
          }
          var trustedTypesPolicy;
          var emptyHTML = '';
          var _document = document,
            implementation = _document.implementation,
            createNodeIterator = _document.createNodeIterator,
            createDocumentFragment = _document.createDocumentFragment,
            getElementsByTagName = _document.getElementsByTagName;
          var importNode = originalDocument.importNode;
          var hooks = {};
          /**
           * Expose whether this browser supports running the full DOMPurify.
           */
          DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
          var MUSTACHE_EXPR = EXPRESSIONS.MUSTACHE_EXPR,
            ERB_EXPR = EXPRESSIONS.ERB_EXPR,
            TMPLIT_EXPR = EXPRESSIONS.TMPLIT_EXPR,
            DATA_ATTR = EXPRESSIONS.DATA_ATTR,
            ARIA_ATTR = EXPRESSIONS.ARIA_ATTR,
            IS_SCRIPT_OR_DATA = EXPRESSIONS.IS_SCRIPT_OR_DATA,
            ATTR_WHITESPACE = EXPRESSIONS.ATTR_WHITESPACE,
            CUSTOM_ELEMENT = EXPRESSIONS.CUSTOM_ELEMENT;
          var IS_ALLOWED_URI$1 = EXPRESSIONS.IS_ALLOWED_URI;
          /**
           * We consider the elements and attributes below to be safe. Ideally
           * don't add any new ones but feel free to remove unwanted ones.
           */
          /* allowed element names */
          var ALLOWED_TAGS = null;
          var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
          /* Allowed attribute names */
          var ALLOWED_ATTR = null;
          var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
          /*
           * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
           * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
           * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
           * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
           */
          var CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
            tagNameCheck: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: null
            },
            attributeNameCheck: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: null
            },
            allowCustomizedBuiltInElements: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: false
            }
          }));
          /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
          var FORBID_TAGS = null;
          /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
          var FORBID_ATTR = null;
          /* Decide if ARIA attributes are okay */
          var ALLOW_ARIA_ATTR = true;
          /* Decide if custom data attributes are okay */
          var ALLOW_DATA_ATTR = true;
          /* Decide if unknown protocols are okay */
          var ALLOW_UNKNOWN_PROTOCOLS = false;
          /* Decide if self-closing tags in attributes are allowed.
           * Usually removed due to a mXSS issue in jQuery 3.0 */
          var ALLOW_SELF_CLOSE_IN_ATTR = true;
          /* Output should be safe for common template engines.
           * This means, DOMPurify removes data attributes, mustaches and ERB
           */
          var SAFE_FOR_TEMPLATES = false;
          /* Output should be safe even for XML used within HTML and alike.
           * This means, DOMPurify removes comments when containing risky content.
           */
          var SAFE_FOR_XML = true;
          /* Decide if document with <html>... should be returned */
          var WHOLE_DOCUMENT = false;
          /* Track whether config is already set on this instance of DOMPurify. */
          var SET_CONFIG = false;
          /* Decide if all elements (e.g. style, script) must be children of
           * document.body. By default, browsers might move them to document.head */
          var FORCE_BODY = false;
          /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
           * string (or a TrustedHTML object if Trusted Types are supported).
           * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
           */
          var RETURN_DOM = false;
          /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
           * string  (or a TrustedHTML object if Trusted Types are supported) */
          var RETURN_DOM_FRAGMENT = false;
          /* Try to return a Trusted Type object instead of a string, return a string in
           * case Trusted Types are not supported  */
          var RETURN_TRUSTED_TYPE = false;
          /* Output should be free from DOM clobbering attacks?
           * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
           */
          var SANITIZE_DOM = true;
          /* Achieve full DOM Clobbering protection by isolating the namespace of named
           * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
           *
           * HTML/DOM spec rules that enable DOM Clobbering:
           *   - Named Access on Window (7.3.3)
           *   - DOM Tree Accessors (3.1.5)
           *   - Form Element Parent-Child Relations (4.10.3)
           *   - Iframe srcdoc / Nested WindowProxies (4.8.5)
           *   - HTMLCollection (4.2.10.2)
           *
           * Namespace isolation is implemented by prefixing `id` and `name` attributes
           * with a constant string, i.e., `user-content-`
           */
          var SANITIZE_NAMED_PROPS = false;
          var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
          /* Keep element content when removing element? */
          var KEEP_CONTENT = true;
          /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
           * of importing it into a new Document and returning a sanitized copy */
          var IN_PLACE = false;
          /* Allow usage of profiles like html, svg and mathMl */
          var USE_PROFILES = {};
          /* Tags to ignore content of when KEEP_CONTENT is true */
          var FORBID_CONTENTS = null;
          var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
          /* Tags that are safe for data: URIs */
          var DATA_URI_TAGS = null;
          var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
          /* Attributes safe for values like "javascript:" */
          var URI_SAFE_ATTRIBUTES = null;
          var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
          var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
          var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
          var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
          /* Document namespace */
          var NAMESPACE = HTML_NAMESPACE;
          var IS_EMPTY_INPUT = false;
          /* Allowed XHTML+XML namespaces */
          var ALLOWED_NAMESPACES = null;
          var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
          var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
          var HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);
          // Certain elements are allowed in both SVG and HTML
          // namespace. We need to specify them explicitly
          // so that they don't get erroneously deleted from
          // HTML namespace.
          var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
          /* Parsing of strict XHTML documents */
          var PARSER_MEDIA_TYPE = null;
          var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
          var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
          var transformCaseFunc = null;
          /* Keep a reference to config to pass to hooks */
          var CONFIG = null;
          /* Ideally, do not touch anything below this line */
          /* ______________________________________________ */
          var formElement = document.createElement('form');
          var isRegexOrFunction = function isRegexOrFunction(testValue) {
            return testValue instanceof RegExp || testValue instanceof Function;
          };
          /**
           * _parseConfig
           *
           * @param cfg optional config literal
           */
          // eslint-disable-next-line complexity
          var _parseConfig = function _parseConfig() {
            var cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            if (CONFIG && CONFIG === cfg) {
              return;
            }
            /* Shield configuration object from tampering */
            if (!cfg || _typeof2(cfg) !== 'object') {
              cfg = {};
            }
            /* Shield configuration object from prototype pollution */
            cfg = clone(cfg);
            PARSER_MEDIA_TYPE =
            // eslint-disable-next-line unicorn/prefer-includes
            SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
            // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
            transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
            /* Set configuration parameters */
            ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
            ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
            ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
            URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
            DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
            FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
            FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
            FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
            USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
            ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
            ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
            ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
            ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
            SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
            SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
            WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
            RETURN_DOM = cfg.RETURN_DOM || false; // Default false
            RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
            RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
            FORCE_BODY = cfg.FORCE_BODY || false; // Default false
            SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
            SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
            KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
            IN_PLACE = cfg.IN_PLACE || false; // Default false
            IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
            NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
            MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
            HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
            CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
              CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
            }
            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
              CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
            }
            if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
              CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
            }
            if (SAFE_FOR_TEMPLATES) {
              ALLOW_DATA_ATTR = false;
            }
            if (RETURN_DOM_FRAGMENT) {
              RETURN_DOM = true;
            }
            /* Parse profile info */
            if (USE_PROFILES) {
              ALLOWED_TAGS = addToSet({}, text);
              ALLOWED_ATTR = [];
              if (USE_PROFILES.html === true) {
                addToSet(ALLOWED_TAGS, html$1);
                addToSet(ALLOWED_ATTR, html);
              }
              if (USE_PROFILES.svg === true) {
                addToSet(ALLOWED_TAGS, svg$1);
                addToSet(ALLOWED_ATTR, svg);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.svgFilters === true) {
                addToSet(ALLOWED_TAGS, svgFilters);
                addToSet(ALLOWED_ATTR, svg);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.mathMl === true) {
                addToSet(ALLOWED_TAGS, mathMl$1);
                addToSet(ALLOWED_ATTR, mathMl);
                addToSet(ALLOWED_ATTR, xml);
              }
            }
            /* Merge configuration parameters */
            if (cfg.ADD_TAGS) {
              if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
                ALLOWED_TAGS = clone(ALLOWED_TAGS);
              }
              addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
            }
            if (cfg.ADD_ATTR) {
              if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
                ALLOWED_ATTR = clone(ALLOWED_ATTR);
              }
              addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
            }
            if (cfg.ADD_URI_SAFE_ATTR) {
              addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
            }
            if (cfg.FORBID_CONTENTS) {
              if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
                FORBID_CONTENTS = clone(FORBID_CONTENTS);
              }
              addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
            }
            /* Add #text in case KEEP_CONTENT is set to true */
            if (KEEP_CONTENT) {
              ALLOWED_TAGS['#text'] = true;
            }
            /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
            if (WHOLE_DOCUMENT) {
              addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
            }
            /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
            if (ALLOWED_TAGS.table) {
              addToSet(ALLOWED_TAGS, ['tbody']);
              delete FORBID_TAGS.tbody;
            }
            if (cfg.TRUSTED_TYPES_POLICY) {
              if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
              }
              if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
              }
              // Overwrite existing TrustedTypes policy.
              trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
              // Sign local variables required by `sanitize`.
              emptyHTML = trustedTypesPolicy.createHTML('');
            } else {
              // Uninitialized policy, attempt to initialize the internal dompurify policy.
              if (trustedTypesPolicy === undefined) {
                trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
              }
              // If creating the internal policy succeeded sign internal variables.
              if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
                emptyHTML = trustedTypesPolicy.createHTML('');
              }
            }
            // Prevent further manipulation of configuration.
            // Not available in IE8, Safari 5, etc.
            if (freeze) {
              freeze(cfg);
            }
            CONFIG = cfg;
          };
          /* Keep track of all possible SVG and MathML tags
           * so that we can perform the namespace checks
           * correctly. */
          var ALL_SVG_TAGS = addToSet({}, [].concat(_toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(svgDisallowed)));
          var ALL_MATHML_TAGS = addToSet({}, [].concat(_toConsumableArray(mathMl$1), _toConsumableArray(mathMlDisallowed)));
          /**
           * @param element a DOM element whose namespace is being checked
           * @returns Return false if the element has a
           *  namespace that a spec-compliant parser would never
           *  return. Return true otherwise.
           */
          var _checkValidNamespace = function _checkValidNamespace(element) {
            var parent = getParentNode(element);
            // In JSDOM, if we're inside shadow DOM, then parentNode
            // can be null. We just simulate parent in this case.
            if (!parent || !parent.tagName) {
              parent = {
                namespaceURI: NAMESPACE,
                tagName: 'template'
              };
            }
            var tagName = stringToLowerCase(element.tagName);
            var parentTagName = stringToLowerCase(parent.tagName);
            if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
              return false;
            }
            if (element.namespaceURI === SVG_NAMESPACE) {
              // The only way to switch from HTML namespace to SVG
              // is via <svg>. If it happens via any other tag, then
              // it should be killed.
              if (parent.namespaceURI === HTML_NAMESPACE) {
                return tagName === 'svg';
              }
              // The only way to switch from MathML to SVG is via`
              // svg if parent is either <annotation-xml> or MathML
              // text integration points.
              if (parent.namespaceURI === MATHML_NAMESPACE) {
                return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
              }
              // We only allow elements that are defined in SVG
              // spec. All others are disallowed in SVG namespace.
              return Boolean(ALL_SVG_TAGS[tagName]);
            }
            if (element.namespaceURI === MATHML_NAMESPACE) {
              // The only way to switch from HTML namespace to MathML
              // is via <math>. If it happens via any other tag, then
              // it should be killed.
              if (parent.namespaceURI === HTML_NAMESPACE) {
                return tagName === 'math';
              }
              // The only way to switch from SVG to MathML is via
              // <math> and HTML integration points
              if (parent.namespaceURI === SVG_NAMESPACE) {
                return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
              }
              // We only allow elements that are defined in MathML
              // spec. All others are disallowed in MathML namespace.
              return Boolean(ALL_MATHML_TAGS[tagName]);
            }
            if (element.namespaceURI === HTML_NAMESPACE) {
              // The only way to switch from SVG to HTML is via
              // HTML integration points, and from MathML to HTML
              // is via MathML text integration points
              if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              // We disallow tags that are specific for MathML
              // or SVG and should never appear in HTML namespace
              return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
            }
            // For XHTML and XML documents that support custom namespaces
            if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
              return true;
            }
            // The code should never reach this place (this means
            // that the element somehow got namespace that is not
            // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
            // Return false just in case.
            return false;
          };
          /**
           * _forceRemove
           *
           * @param node a DOM node
           */
          var _forceRemove = function _forceRemove(node) {
            arrayPush(DOMPurify.removed, {
              element: node
            });
            try {
              // eslint-disable-next-line unicorn/prefer-dom-node-remove
              getParentNode(node).removeChild(node);
            } catch (_) {
              remove(node);
            }
          };
          /**
           * _removeAttribute
           *
           * @param name an Attribute name
           * @param element a DOM node
           */
          var _removeAttribute = function _removeAttribute(name, element) {
            try {
              arrayPush(DOMPurify.removed, {
                attribute: element.getAttributeNode(name),
                from: element
              });
            } catch (_) {
              arrayPush(DOMPurify.removed, {
                attribute: null,
                from: element
              });
            }
            element.removeAttribute(name);
            // We void attribute values for unremovable "is"" attributes
            if (name === 'is' && !ALLOWED_ATTR[name]) {
              if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
                try {
                  _forceRemove(element);
                } catch (_) {}
              } else {
                try {
                  element.setAttribute(name, '');
                } catch (_) {}
              }
            }
          };
          /**
           * _initDocument
           *
           * @param dirty - a string of dirty markup
           * @return a DOM, filled with the dirty markup
           */
          var _initDocument = function _initDocument(dirty) {
            /* Create a HTML document */
            var doc = null;
            var leadingWhitespace = null;
            if (FORCE_BODY) {
              dirty = '<remove></remove>' + dirty;
            } else {
              /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
              var _matches2 = stringMatch(dirty, /^[\r\n\t ]+/);
              leadingWhitespace = _matches2 && _matches2[0];
            }
            if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
              // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
              dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
            }
            var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
            /*
             * Use the DOMParser API by default, fallback later if needs be
             * DOMParser not work for svg when has multiple root element.
             */
            if (NAMESPACE === HTML_NAMESPACE) {
              try {
                doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
              } catch (_) {}
            }
            /* Use createHTMLDocument in case DOMParser is not available */
            if (!doc || !doc.documentElement) {
              doc = implementation.createDocument(NAMESPACE, 'template', null);
              try {
                doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
              } catch (_) {
                // Syntax error if dirtyPayload is invalid xml
              }
            }
            var body = doc.body || doc.documentElement;
            if (dirty && leadingWhitespace) {
              body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
            }
            /* Work on whole document or just its body */
            if (NAMESPACE === HTML_NAMESPACE) {
              return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
            }
            return WHOLE_DOCUMENT ? doc.documentElement : body;
          };
          /**
           * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
           *
           * @param root The root element or node to start traversing on.
           * @return The created NodeIterator
           */
          var _createNodeIterator = function _createNodeIterator(root) {
            return createNodeIterator.call(root.ownerDocument || root, root,
            // eslint-disable-next-line no-bitwise
            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
          };
          /**
           * _isClobbered
           *
           * @param element element to check for clobbering attacks
           * @return true if clobbered, false if safe
           */
          var _isClobbered = function _isClobbered(element) {
            return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');
          };
          /**
           * Checks whether the given object is a DOM node.
           *
           * @param value object to check whether it's a DOM node
           * @return true is object is a DOM node
           */
          var _isNode = function _isNode(value) {
            return typeof Node === 'function' && value instanceof Node;
          };
          function _executeHook(entryPoint, currentNode, data) {
            if (!hooks[entryPoint]) {
              return;
            }
            arrayForEach(hooks[entryPoint], function (hook) {
              hook.call(DOMPurify, currentNode, data, CONFIG);
            });
          }
          /**
           * _sanitizeElements
           *
           * @protect nodeName
           * @protect textContent
           * @protect removeChild
           * @param currentNode to check for permission to exist
           * @return true if node was killed, false if left alive
           */
          var _sanitizeElements = function _sanitizeElements(currentNode) {
            var content = null;
            /* Execute a hook if present */
            _executeHook('beforeSanitizeElements', currentNode, null);
            /* Check if element is clobbered or can clobber */
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            /* Now let's check the element's type and name */
            var tagName = transformCaseFunc(currentNode.nodeName);
            /* Execute a hook if present */
            _executeHook('uponSanitizeElement', currentNode, {
              tagName: tagName,
              allowedTags: ALLOWED_TAGS
            });
            /* Detect mXSS attempts abusing namespace confusion */
            if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
              _forceRemove(currentNode);
              return true;
            }
            /* Remove any occurrence of processing instructions */
            if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
              _forceRemove(currentNode);
              return true;
            }
            /* Remove any kind of possibly harmful comments */
            if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
              _forceRemove(currentNode);
              return true;
            }
            /* Remove element if anything forbids its presence */
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              /* Check if we have a custom element to handle */
              if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
                  return false;
                }
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
                  return false;
                }
              }
              /* Keep content except for bad-listed elements */
              if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
                var parentNode = getParentNode(currentNode) || currentNode.parentNode;
                var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
                if (childNodes && parentNode) {
                  var childCount = childNodes.length;
                  for (var i = childCount - 1; i >= 0; --i) {
                    var childClone = cloneNode(childNodes[i], true);
                    childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
                    parentNode.insertBefore(childClone, getNextSibling(currentNode));
                  }
                }
              }
              _forceRemove(currentNode);
              return true;
            }
            /* Check whether element has a valid namespace */
            if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            /* Make sure that older browsers don't get fallback-tag mXSS */
            if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
              _forceRemove(currentNode);
              return true;
            }
            /* Sanitize element content to be template-safe */
            if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
              /* Get the element's text content */
              content = currentNode.textContent;
              arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], function (expr) {
                content = stringReplace(content, expr, ' ');
              });
              if (currentNode.textContent !== content) {
                arrayPush(DOMPurify.removed, {
                  element: currentNode.cloneNode()
                });
                currentNode.textContent = content;
              }
            }
            /* Execute a hook if present */
            _executeHook('afterSanitizeElements', currentNode, null);
            return false;
          };
          /**
           * _isValidAttribute
           *
           * @param lcTag Lowercase tag name of containing element.
           * @param lcName Lowercase attribute name.
           * @param value Attribute value.
           * @return Returns true if `value` is valid, otherwise false.
           */
          // eslint-disable-next-line complexity
          var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
            /* Make sure attribute cannot clobber */
            if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
              return false;
            }
            /* Allow valid data-* attributes: At least one character after "-"
                (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
                XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
                We don't need to check the value; it's always URI safe. */
            if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
              if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
              // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;else {
                return false;
              }
              /* Check value is safe. First, is attr inert? If so, is safe */
            } else if (URI_SAFE_ATTRIBUTES[lcName]) ;else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ;else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ;else if (value) {
              return false;
            } else ;
            return true;
          };
          /**
           * _isBasicCustomElement
           * checks if at least one dash is included in tagName, and it's not the first char
           * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
           *
           * @param tagName name of the tag of the node to sanitize
           * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
           */
          var _isBasicCustomElement = function _isBasicCustomElement(tagName) {
            return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
          };
          /**
           * _sanitizeAttributes
           *
           * @protect attributes
           * @protect nodeName
           * @protect removeAttribute
           * @protect setAttribute
           *
           * @param currentNode to sanitize
           */
          var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
            /* Execute a hook if present */
            _executeHook('beforeSanitizeAttributes', currentNode, null);
            var attributes = currentNode.attributes;
            /* Check if we have attributes; if not we might have a text node */
            if (!attributes) {
              return;
            }
            var hookEvent = {
              attrName: '',
              attrValue: '',
              keepAttr: true,
              allowedAttributes: ALLOWED_ATTR,
              forceKeepAttr: undefined
            };
            var l = attributes.length;
            /* Go backwards over all attributes; safely remove bad ones */
            var _loop18 = function _loop18() {
                var attr = attributes[l];
                var name = attr.name,
                  namespaceURI = attr.namespaceURI,
                  attrValue = attr.value;
                var lcName = transformCaseFunc(name);
                var value = name === 'value' ? attrValue : stringTrim(attrValue);
                /* Execute a hook if present */
                hookEvent.attrName = lcName;
                hookEvent.attrValue = value;
                hookEvent.keepAttr = true;
                hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
                _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
                value = hookEvent.attrValue;
                /* Full DOM Clobbering protection via namespace isolation,
                 * Prefix id and name attributes with `user-content-`
                 */
                if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
                  // Remove the attribute with this value
                  _removeAttribute(name, currentNode);
                  // Prefix the value and later re-create the attribute with the sanitized value
                  value = SANITIZE_NAMED_PROPS_PREFIX + value;
                }
                /* Work around a security issue with comments inside attributes */
                if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
                  _removeAttribute(name, currentNode);
                  return 0; // continue
                }
                /* Did the hooks approve of the attribute? */
                if (hookEvent.forceKeepAttr) {
                  return 0; // continue
                }
                /* Remove attribute */
                _removeAttribute(name, currentNode);
                /* Did the hooks approve of the attribute? */
                if (!hookEvent.keepAttr) {
                  return 0; // continue
                }
                /* Work around a security issue in jQuery 3.0 */
                if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
                  _removeAttribute(name, currentNode);
                  return 0; // continue
                }
                /* Sanitize attribute content to be template-safe */
                if (SAFE_FOR_TEMPLATES) {
                  arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], function (expr) {
                    value = stringReplace(value, expr, ' ');
                  });
                }
                /* Is `value` valid for this attribute? */
                var lcTag = transformCaseFunc(currentNode.nodeName);
                if (!_isValidAttribute(lcTag, lcName, value)) {
                  return 0; // continue
                }
                /* Handle attributes that require Trusted Types */
                if (trustedTypesPolicy && _typeof2(trustedTypes) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
                  if (namespaceURI) ;else {
                    switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                      case 'TrustedHTML':
                        {
                          value = trustedTypesPolicy.createHTML(value);
                          break;
                        }
                      case 'TrustedScriptURL':
                        {
                          value = trustedTypesPolicy.createScriptURL(value);
                          break;
                        }
                    }
                  }
                }
                /* Handle invalid data-* attribute set by try-catching it */
                try {
                  if (namespaceURI) {
                    currentNode.setAttributeNS(namespaceURI, name, value);
                  } else {
                    /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
                    currentNode.setAttribute(name, value);
                  }
                  if (_isClobbered(currentNode)) {
                    _forceRemove(currentNode);
                  } else {
                    arrayPop(DOMPurify.removed);
                  }
                } catch (_) {}
              },
              _ret4;
            while (l--) {
              _ret4 = _loop18();
              if (_ret4 === 0) continue;
            }
            /* Execute a hook if present */
            _executeHook('afterSanitizeAttributes', currentNode, null);
          };
          /**
           * _sanitizeShadowDOM
           *
           * @param fragment to iterate over recursively
           */
          var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
            var shadowNode = null;
            var shadowIterator = _createNodeIterator(fragment);
            /* Execute a hook if present */
            _executeHook('beforeSanitizeShadowDOM', fragment, null);
            while (shadowNode = shadowIterator.nextNode()) {
              /* Execute a hook if present */
              _executeHook('uponSanitizeShadowNode', shadowNode, null);
              /* Sanitize tags and elements */
              if (_sanitizeElements(shadowNode)) {
                continue;
              }
              /* Deep shadow DOM detected */
              if (shadowNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(shadowNode.content);
              }
              /* Check attributes, sanitize if necessary */
              _sanitizeAttributes(shadowNode);
            }
            /* Execute a hook if present */
            _executeHook('afterSanitizeShadowDOM', fragment, null);
          };
          // eslint-disable-next-line complexity
          DOMPurify.sanitize = function (dirty) {
            var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var body = null;
            var importedNode = null;
            var currentNode = null;
            var returnNode = null;
            /* Make sure we have a string to sanitize.
              DO NOT return early, as this will return the wrong type if
              the user has requested a DOM object rather than a string */
            IS_EMPTY_INPUT = !dirty;
            if (IS_EMPTY_INPUT) {
              dirty = '<!-->';
            }
            /* Stringify, in case dirty is an object */
            if (typeof dirty !== 'string' && !_isNode(dirty)) {
              if (typeof dirty.toString === 'function') {
                dirty = dirty.toString();
                if (typeof dirty !== 'string') {
                  throw typeErrorCreate('dirty is not a string, aborting');
                }
              } else {
                throw typeErrorCreate('toString is not a function');
              }
            }
            /* Return dirty HTML if DOMPurify cannot run */
            if (!DOMPurify.isSupported) {
              return dirty;
            }
            /* Assign config vars */
            if (!SET_CONFIG) {
              _parseConfig(cfg);
            }
            /* Clean up removed elements */
            DOMPurify.removed = [];
            /* Check if dirty is correctly typed for IN_PLACE */
            if (typeof dirty === 'string') {
              IN_PLACE = false;
            }
            if (IN_PLACE) {
              /* Do some early pre-sanitization to avoid unsafe root nodes */
              if (dirty.nodeName) {
                var tagName = transformCaseFunc(dirty.nodeName);
                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                  throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
                }
              }
            } else if (dirty instanceof Node) {
              /* If dirty is a DOM element, append to an empty document to avoid
                 elements being stripped by the parser */
              body = _initDocument('<!---->');
              importedNode = body.ownerDocument.importNode(dirty, true);
              if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
                /* Node is already a body, use as is */
                body = importedNode;
              } else if (importedNode.nodeName === 'HTML') {
                body = importedNode;
              } else {
                // eslint-disable-next-line unicorn/prefer-dom-node-append
                body.appendChild(importedNode);
              }
            } else {
              /* Exit directly if we have nothing to do */
              if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
              // eslint-disable-next-line unicorn/prefer-includes
              dirty.indexOf('<') === -1) {
                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
              }
              /* Initialize the document to work on */
              body = _initDocument(dirty);
              /* Check we have a DOM node from the data */
              if (!body) {
                return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
              }
            }
            /* Remove first element node (ours) if FORCE_BODY is set */
            if (body && FORCE_BODY) {
              _forceRemove(body.firstChild);
            }
            /* Get node iterator */
            var nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
            /* Now start iterating over the created document */
            while (currentNode = nodeIterator.nextNode()) {
              /* Sanitize tags and elements */
              if (_sanitizeElements(currentNode)) {
                continue;
              }
              /* Shadow DOM detected, sanitize it */
              if (currentNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(currentNode.content);
              }
              /* Check attributes, sanitize if necessary */
              _sanitizeAttributes(currentNode);
            }
            /* If we sanitized `dirty` in-place, return it. */
            if (IN_PLACE) {
              return dirty;
            }
            /* Return sanitized string or DOM */
            if (RETURN_DOM) {
              if (RETURN_DOM_FRAGMENT) {
                returnNode = createDocumentFragment.call(body.ownerDocument);
                while (body.firstChild) {
                  // eslint-disable-next-line unicorn/prefer-dom-node-append
                  returnNode.appendChild(body.firstChild);
                }
              } else {
                returnNode = body;
              }
              if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
                /*
                  AdoptNode() is not used because internal state is not reset
                  (e.g. the past names map of a HTMLFormElement), this is safe
                  in theory but we would rather not risk another attack vector.
                  The state that is cloned by importNode() is explicitly defined
                  by the specs.
                */
                returnNode = importNode.call(originalDocument, returnNode, true);
              }
              return returnNode;
            }
            var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
            /* Serialize doctype if allowed */
            if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
              serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
            }
            /* Sanitize final string template-safe */
            if (SAFE_FOR_TEMPLATES) {
              arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], function (expr) {
                serializedHTML = stringReplace(serializedHTML, expr, ' ');
              });
            }
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
          };
          DOMPurify.setConfig = function () {
            var cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            _parseConfig(cfg);
            SET_CONFIG = true;
          };
          DOMPurify.clearConfig = function () {
            CONFIG = null;
            SET_CONFIG = false;
          };
          DOMPurify.isValidAttribute = function (tag, attr, value) {
            /* Initialize shared config vars if necessary. */
            if (!CONFIG) {
              _parseConfig({});
            }
            var lcTag = transformCaseFunc(tag);
            var lcName = transformCaseFunc(attr);
            return _isValidAttribute(lcTag, lcName, value);
          };
          DOMPurify.addHook = function (entryPoint, hookFunction) {
            if (typeof hookFunction !== 'function') {
              return;
            }
            hooks[entryPoint] = hooks[entryPoint] || [];
            arrayPush(hooks[entryPoint], hookFunction);
          };
          DOMPurify.removeHook = function (entryPoint) {
            if (hooks[entryPoint]) {
              return arrayPop(hooks[entryPoint]);
            }
          };
          DOMPurify.removeHooks = function (entryPoint) {
            if (hooks[entryPoint]) {
              hooks[entryPoint] = [];
            }
          };
          DOMPurify.removeAllHooks = function () {
            hooks = {};
          };
          return DOMPurify;
        }
        var purify = createDOMPurify();
        function m(t, e) {
          var _t$hooks;
          var o = (_t$hooks = t.hooks) !== null && _t$hooks !== void 0 ? _t$hooks : {};
          var n;
          for (n in o) {
            var u = o[n];
            u !== void 0 && e.addHook(n, u);
          }
        }
        function c() {
          return purify();
        }
        function p() {
          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : c;
          var o = e();
          m(t, o);
          var n = function n(u, i) {
            var _t$default;
            var r = i.value;
            if (i.oldValue === r) return;
            var a = "".concat(r),
              s = i.arg,
              d = t.namedConfigurations,
              f = (_t$default = t.default) !== null && _t$default !== void 0 ? _t$default : {};
            if (d && s !== void 0) {
              var _d$s;
              u.innerHTML = o.sanitize(a, (_d$s = d[s]) !== null && _d$s !== void 0 ? _d$s : f);
              return;
            }
            u.innerHTML = o.sanitize(a, f);
          };
          return {
            mounted: n,
            updated: n
          };
        }
        var k = {
          install: function install(t) {
            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : c;
            t.directive("dompurify-html", p(e, o));
          }
        };
        var _hoisted_1$1 = ["data-tip"];
        var _hoisted_2$1 = ["data-tip"];
        var _hoisted_3$1 = ["data-tip"];
        var _hoisted_4$1 = ["data-tip"];
        var _hoisted_5$1 = {
          key: 0,
          xmlns: "http://www.w3.org/2000/svg",
          class: "w-5 h-5",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        };
        var _hoisted_6$1 = {
          key: 1,
          xmlns: "http://www.w3.org/2000/svg",
          class: "w-5 h-5",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        };
        var _sfc_main$1 = /* @__PURE__ */defineComponent({
          __name: "index",
          setup: function setup(__props) {
            var _useI18n4 = useI18n(),
              t = _useI18n4.t;
            var router = useRouter();
            var route = useRoute();
            var audioDbStore = localforage.createInstance({
              name: "audioStore"
            });
            var audio = ref(new Audio());
            var settingRef = ref();
            var globalConfig = useStore().globalConfig;
            var _storeToRefs7 = storeToRefs(globalConfig),
              localMusicList = _storeToRefs7.getMusicList,
              currentMusic = _storeToRefs7.getCurrentMusic;
            function play(_x22) {
              return _play.apply(this, arguments);
            }
            function _play() {
              _play = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(item) {
                var audioUrl;
                return _regeneratorRuntime().wrap(function _callee17$(_context25) {
                  while (1) switch (_context25.prev = _context25.next) {
                    case 0:
                      if (item) {
                        _context25.next = 2;
                        break;
                      }
                      return _context25.abrupt("return");
                    case 2:
                      audioUrl = "";
                      if (item.url) {
                        _context25.next = 5;
                        break;
                      }
                      return _context25.abrupt("return");
                    case 5:
                      if (!(item.url === "Storage")) {
                        _context25.next = 11;
                        break;
                      }
                      _context25.next = 8;
                      return audioDbStore.getItem(item.name);
                    case 8:
                      audioUrl = _context25.sent;
                      _context25.next = 12;
                      break;
                    case 11:
                      audioUrl = item.url;
                    case 12:
                      audio.value.pause();
                      audio.value.src = audioUrl;
                      audio.value.play();
                    case 15:
                    case "end":
                      return _context25.stop();
                  }
                }, _callee17);
              }));
              return _play.apply(this, arguments);
            }
            function playMusic(item) {
              var skip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              if (!item) {
                return;
              }
              if (!currentMusic.value.paused && !skip) {
                globalConfig.setCurrentMusic(item, true);
                return;
              }
              globalConfig.setCurrentMusic(item, false);
            }
            function nextPlay() {
              if (localMusicList.value.length >= 1) {
                var _index21 = localMusicList.value.findIndex(function (item) {
                  return item.name === currentMusic.value.item.name;
                });
                _index21++;
                if (_index21 >= localMusicList.value.length) {
                  _index21 = 0;
                }
                globalConfig.setCurrentMusic(localMusicList.value[_index21], false);
              }
            }
            function onPlayEnd() {
              audio.value.addEventListener("ended", nextPlay);
            }
            function enterConfig() {
              router.push("/log-lottery/config");
            }
            function enterHome() {
              router.push("/log-lottery");
            }
            var isFullscreen = ref(false);
            function toggleFullscreen() {
              if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(function () {
                  isFullscreen.value = true;
                }).catch(function (err) {
                  console.error(":", err);
                });
              } else {
                document.exitFullscreen().then(function () {
                  isFullscreen.value = false;
                }).catch(function (err) {
                  console.error(":", err);
                });
              }
            }
            onMounted(function () {
              globalConfig.setCurrentMusic(localMusicList.value[0], true);
              onPlayEnd();
              document.addEventListener("fullscreenchange", handleFullscreenChange);
            });
            function handleFullscreenChange() {
              isFullscreen.value = !!document.fullscreenElement;
            }
            onUnmounted(function () {
              audio.value.removeEventListener("ended", nextPlay);
              document.removeEventListener("fullscreenchange", handleFullscreenChange);
            });
            watch(currentMusic, function (val) {
              if (!val.paused && audio.value) {
                play(val.item);
              } else {
                audio.value.pause();
              }
            }, {
              deep: true
            });
            return function (_ctx, _cache) {
              var _component_svg_icon = __unplugin_components_0;
              return openBlock(), createElementBlock("div", {
                ref_key: "settingRef",
                ref: settingRef,
                class: "flex flex-col gap-3"
              }, [unref(route).path.includes("/config") ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "tooltip tooltip-left",
                "data-tip": unref(t)("tooltip.toHome")
              }, [createBaseVNode("div", {
                class: "flex items-center justify-center w-10 h-10 p-0 m-0 cursor-pointer setting-container bg-slate-500/50 rounded-l-xl hover:bg-slate-500/80 hover:text-blue-400/90",
                onClick: enterHome
              }, [createVNode(_component_svg_icon, {
                name: "home"
              })])], 8, _hoisted_1$1)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: "tooltip tooltip-left",
                "data-tip": unref(t)("tooltip.settingConfiguration")
              }, [createBaseVNode("div", {
                class: "flex items-center justify-center w-10 h-10 p-0 m-0 cursor-pointer setting-container bg-slate-500/50 rounded-l-xl hover:bg-slate-500/80 hover:text-blue-400/90",
                onClick: enterConfig
              }, [createVNode(_component_svg_icon, {
                name: "setting"
              })])], 8, _hoisted_2$1)), createBaseVNode("div", {
                class: "tooltip tooltip-left",
                "data-tip": unref(currentMusic).item ? "".concat(unref(currentMusic).item.name, "\n\r ").concat(unref(t)("tooltip.nextSong")) : unref(t)("tooltip.noSongPlay")
              }, [createBaseVNode("div", {
                class: "flex items-center justify-center w-10 h-10 p-0 m-0 cursor-pointer setting-container bg-slate-500/50 rounded-l-xl hover:bg-slate-500/80 hover:text-blue-400/90",
                onClick: _cache[0] || (_cache[0] = function ($event) {
                  return playMusic(unref(currentMusic).item);
                }),
                onContextmenu: withModifiers(nextPlay, ["right", "prevent"])
              }, [createVNode(_component_svg_icon, {
                name: unref(currentMusic).paused ? "play" : "pause"
              }, null, 8, ["name"])], 32)], 8, _hoisted_3$1), createBaseVNode("div", {
                class: "tooltip tooltip-left",
                "data-tip": isFullscreen.value ? unref(t)("tooltip.exitFullscreen") : unref(t)("tooltip.fullscreen")
              }, [createBaseVNode("div", {
                class: "flex items-center justify-center w-10 h-10 p-0 m-0 cursor-pointer setting-container bg-slate-500/50 rounded-l-xl hover:bg-slate-500/80 hover:text-blue-400/90",
                onClick: toggleFullscreen
              }, [!isFullscreen.value ? (openBlock(), createElementBlock("svg", _hoisted_5$1, _cache[1] || (_cache[1] = [createBaseVNode("path", {
                d: "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"
              }, null, -1)]))) : (openBlock(), createElementBlock("svg", _hoisted_6$1, _cache[2] || (_cache[2] = [createBaseVNode("path", {
                d: "M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"
              }, null, -1)])))])], 8, _hoisted_4$1)], 512);
            };
          }
        });

        /* unplugin-vue-components disabled */

        var PlayMusic = /* @__PURE__ */_export_sfc(_sfc_main$1, [["__scopeId", "data-v-3a365d2a"]]);
        var _hoisted_1 = {
          class: "modal-box"
        };
        var _hoisted_2 = {
          class: "text-lg font-bold"
        };
        var _hoisted_3 = {
          key: 0,
          class: "py-4"
        };
        var _hoisted_4 = {
          key: 1,
          class: "py-4"
        };
        var _hoisted_5 = {
          class: "modal-action"
        };
        var _hoisted_6 = {
          method: "dialog",
          class: "flex justify-start w-full gap-3"
        };
        var _hoisted_7 = {
          class: "btn"
        };
        var _sfc_main = /* @__PURE__ */defineComponent({
          __name: "App",
          setup: function setup(__props) {
            var _useI18n5 = useI18n(),
              t = _useI18n5.t;
            var globalConfig = useStore().globalConfig;
            var prizeConfig = useStore().prizeConfig;
            var system = useStore().system;
            var _storeToRefs8 = storeToRefs(globalConfig),
              localTheme = _storeToRefs8.getTheme;
            var _storeToRefs9 = storeToRefs(prizeConfig),
              prizeList = _storeToRefs9.getPrizeConfig;
            var tipDialog = ref();
            function setCurrentPrize() {
              if (prizeList.value.length <= 0) {
                return;
              }
              for (var i = 0; i < prizeList.value.length; i++) {
                if (!prizeList.value[i].isUsed) {
                  prizeConfig.setCurrentPrize(prizeList.value[i]);
                  break;
                }
              }
            }
            function judgeMobile() {
              var ua = navigator.userAgent;
              var isAndroid = ua.includes("Android") || ua.includes("Adr");
              var isIOS = !!ua.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
              system.setIsMobile(isAndroid || isIOS);
              return isAndroid || isIOS;
            }
            function judgeChromeOrEdge() {
              var ua = navigator.userAgent;
              var isChrome = ua.includes("Chrome");
              var isEdge = ua.includes("Edg");
              system.setIsChrome(isChrome);
              return isChrome || isEdge;
            }
            onMounted(function () {
              themeChange(localTheme.value.name);
              setCurrentPrize();
              if (judgeMobile() || !judgeChromeOrEdge()) {
                tipDialog.value.showModal();
              }
            });
            return function (_ctx, _cache) {
              var _component_router_view = resolveComponent("router-view");
              return openBlock(), createElementBlock(Fragment, null, [createBaseVNode("dialog", {
                id: "my_modal_1",
                ref_key: "tipDialog",
                ref: tipDialog,
                class: "border-none modal"
              }, [createBaseVNode("div", _hoisted_1, [createBaseVNode("h3", _hoisted_2, toDisplayString$1(unref(t)("dialog.titleTip")), 1), judgeMobile() ? (openBlock(), createElementBlock("p", _hoisted_3, toDisplayString$1(unref(t)("dialog.dialogPCWeb")), 1)) : createCommentVNode("", true), !judgeChromeOrEdge() ? (openBlock(), createElementBlock("p", _hoisted_4, toDisplayString$1(unref(t)("dialog.dialogLatestBrowser")), 1)) : createCommentVNode("", true), createBaseVNode("div", _hoisted_5, [createBaseVNode("form", _hoisted_6, [createBaseVNode("button", _hoisted_7, toDisplayString$1(unref(t)("button.confirm")), 1)])])])], 512), createVNode(_component_router_view), createVNode(PlayMusic, {
                class: "absolute right-0 bottom-1/2"
              })], 64);
            };
          }
        });
        if (typeof window !== 'undefined') {
          function loadSvg() {
            var body = document.body;
            var svgDom = document.getElementById('__svg__icons__dom__');
            if (!svgDom) {
              svgDom = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
              svgDom.style.position = 'absolute';
              svgDom.style.width = '0';
              svgDom.style.height = '0';
              svgDom.id = '__svg__icons__dom__';
              svgDom.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
              svgDom.setAttribute('xmlns:link', 'http://www.w3.org/1999/xlink');
            }
            svgDom.innerHTML = "<symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-add\"><path d=\"M874.667 469.333h-320v-320c0-23.466-19.2-42.666-42.667-42.666s-42.667 19.2-42.667 42.666v320h-320c-23.466 0-42.666 19.2-42.666 42.667s19.2 42.667 42.666 42.667h320v320c0 23.466 19.2 42.666 42.667 42.666s42.667-19.2 42.667-42.666v-320h320c23.466 0 42.666-19.2 42.666-42.667s-19.2-42.667-42.666-42.667z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-arrow_left\"><path d=\"M503.467 490.667 678.4 665.6l-59.733 59.733L384 490.667 618.667 256l59.733 59.733-174.933 174.934z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-arrow_right\"><path d=\"M558.933 490.667 384 665.6l59.733 59.733L678.4 490.667 443.733 256 384 315.733l174.933 174.934z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-close\"><path d=\"m806.4 263.2-45.6-45.6L512 467.2 263.2 217.6l-45.6 45.6L467.2 512 217.6 760.8l45.6 45.6L512 557.6l248.8 248.8 45.6-45.6L557.6 512z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-delete\"><path d=\"M840 288H688v-56c0-40-32-72-72-72H408c-40 0-72 32-72 72v56H184c-12.8 0-24 11.2-24 24s11.2 24 24 24h656c12.8 0 24-11.2 24-24s-11.2-24-24-24zm-456 0v-56c0-12.8 11.2-24 24-24h208c12.8 0 24 11.2 24 24v56H384zm374.4 96c-12.8 0-24 11.2-24 24v363.2c0 24-19.2 44.8-44.8 44.8H332.8c-24 0-44.8-19.2-44.8-44.8V408c0-12.8-11.2-24-24-24s-24 11.2-24 24v363.2c0 51.2 41.6 92.8 92.8 92.8h358.4c51.2 0 92.8-41.6 92.8-92.8V408c-1.6-12.8-12.8-24-25.6-24z\" /><path d=\"M444.8 744V408c0-12.8-11.2-24-24-24s-24 11.2-24 24v336c0 12.8 11.2 24 24 24s24-11.2 24-24zm182.4 0V408c0-12.8-11.2-24-24-24s-24 11.2-24 24v336c0 12.8 11.2 24 24 24s24-11.2 24-24z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-down\"><path d=\"M512 128c212 0 384 172 384 384S724 896 512 896 128 724 128 512s172-384 384-384m0-64C264.8 64 64 264.8 64 512s200.8 448 448 448 448-200.8 448-448S759.2 64 512 64zm226.4 322.4L512 613.6 285.6 386.4 240 432l226.4 226.4L512 704l45.6-45.6L784 432l-45.6-45.6z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-edit\"><path d=\"M846.8 255 744.5 152.8c-33.1-33.1-87.9-33.1-122.5 0L149.6 625.3c-10.1 10.1-15.8 24.5-15.8 38.9L128 814v4.3c1.4 15.8 7.2 30.2 18.8 40.3 10.1 10.1 24.5 14.4 38.9 14.4h2.9l146.9-5.8c14.4 0 27.3-7.2 37.4-17.3l472.5-472.4c36-34.6 36-89.3 1.4-122.5zm-675 574.3 4.4-124.3 118.3 118.3-122.7 6zm181.1-34.5L204.7 646.7 597 254.4l148.2 148.2-392.3 392.2zm465.8-465.5-31.5 31.4-148.4-148.2 31.6-31.4c6-6 13.5-9 21-9s15 3 21 9l106.3 106.3c11.9 11.9 11.9 29.9 0 41.9zm89.2 490.5H457.4c-16.6 0-30 13.4-30 30s13.4 30 30 30h450.5c16.6 0 30-13.4 30-30s-13.4-30-30-30zm-410-50.2c0 16.6 13.4 30 30 30h380c16.6 0 30-13.4 30-30s-13.4-30-30-30h-380c-16.5 0-30 13.4-30 30z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-github\"><path d=\"M498.895 100.608c-211.825 0-409.483 189.042-409.483 422.193 0 186.567 127.313 344.784 295.066 400.603 21.13 3.916 32.04-9.177 32.04-20.308 0-10.1 1.176-43.343 1.019-78.596-117.45 25.565-141.395-49.835-141.395-49.835-19.226-48.805-46.503-61.793-46.503-61.793-38.293-26.234 3.139-25.611 3.139-25.611 42.361 2.933 64.779 43.443 64.779 43.443 37.67 64.575 98.842 45.866 122.912 35.094 3.816-27.263 14.765-45.918 26.824-56.43C353.497 698.7 254.97 662.466 254.97 500.692c0-46.07 16.499-83.747 43.45-113.332-4.38-10.666-18.806-53.544 4.076-111.732 0 0 35.461-11.337 116.163 43.296 33.654-9.33 69.783-14.023 105.654-14.175 35.87.153 72.047 4.844 105.754 14.175 80.607-54.632 116.008-43.296 116.008-43.296 22.936 58.188 8.56 101.12 4.18 111.732 27.052 29.585 43.444 67.261 43.444 113.332 0 162.138-98.798 197.85-192.8 208.263 15.152 13.088 28.652 38.805 28.652 78.18 0 56.484-.46 101.943-.46 115.854 0 11.236 7.574 24.381 29.016 20.254 167.647-55.913 275.715-214.135 275.715-400.543 0-233.155-224.126-422.193-434.927-422.193v.1z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-home\"><path d=\"M937.067 482.335 556.72 106.84c-1.892-2.251-6.124-6.173-11.998-10.049-9.889-6.522-21.093-10.486-33.388-10.486-13.137 0-24.61 3.984-34.246 10.59-5.827 3.997-9.844 8.077-12.118 11.117L85.644 482.381c-14.654 14.435-14.654 37.891 0 52.359 14.538 14.38 33.883 8.316 50.366-7.92l25.523-25.232 350.848-339.87 374.33 368.073c20.076 13.223 37.772 17.378 50.358 4.947 14.652-14.465 14.652-37.936-.002-52.403z\" /><path d=\"M793.007 462.046c-17.391 0-31.568 13.939-31.634 31.237V843.6c0 17.417-14.372 31.603-32.12 31.603h-84.13V683.037c0-49.818-40.802-90.11-91.144-90.11h-85.268c-50.326 0-91.144 40.3-91.144 90.11v192.167h-84.13c-17.75 0-32.12-14.186-32.12-31.603v-350.21c-.033-17.355-14.218-31.344-31.611-31.344-17.42 0-31.59 13.965-31.658 31.303v354.43c0 49.844 40.808 90.133 91.144 90.133h151.644V687.26c0-17.41 14.364-31.58 32.119-31.58h76.8c17.757 0 32.12 14.17 32.12 31.58v250.653H733.52c50.321 0 91.145-40.297 91.145-90.133V493.323c-.137-17.365-14.284-31.277-31.658-31.277z\" /></symbol><symbol  viewBox=\"0 0 256 256\" id=\"icon-instagram\"><g fill=\"none\"><rect width=\"256\" height=\"256\" fill=\"url(#icon-instagram_a)\" rx=\"60\" /><rect width=\"256\" height=\"256\" fill=\"url(#icon-instagram_b)\" rx=\"60\" /><path fill=\"#fff\" d=\"M128.009 28c-27.158 0-30.567.119-41.233.604-10.646.488-17.913 2.173-24.271 4.646-6.578 2.554-12.157 5.971-17.715 11.531-5.563 5.559-8.98 11.138-11.542 17.713-2.48 6.36-4.167 13.63-4.646 24.271-.477 10.667-.602 14.077-.602 41.236s.12 30.557.604 41.223c.49 10.646 2.175 17.913 4.646 24.271 2.556 6.578 5.973 12.157 11.533 17.715 5.557 5.563 11.136 8.988 17.709 11.542 6.363 2.473 13.631 4.158 24.275 4.646 10.667.485 14.073.604 41.23.604 27.161 0 30.559-.119 41.225-.604 10.646-.488 17.921-2.173 24.284-4.646 6.575-2.554 12.146-5.979 17.702-11.542 5.563-5.558 8.979-11.137 11.542-17.712 2.458-6.361 4.146-13.63 4.646-24.272.479-10.666.604-14.066.604-41.225s-.125-30.567-.604-41.234c-.5-10.646-2.188-17.912-4.646-24.27-2.563-6.578-5.979-12.157-11.542-17.716-5.562-5.562-11.125-8.979-17.708-11.53-6.375-2.474-13.646-4.16-24.292-4.647-10.667-.485-14.063-.604-41.23-.604zm-8.971 18.021c2.663-.004 5.634 0 8.971 0 26.701 0 29.865.096 40.409.575 9.75.446 15.042 2.075 18.567 3.444 4.667 1.812 7.994 3.979 11.492 7.48 3.5 3.5 5.666 6.833 7.483 11.5 1.369 3.52 3 8.812 3.444 18.562.479 10.542.583 13.708.583 40.396 0 26.688-.104 29.855-.583 40.396-.446 9.75-2.075 15.042-3.444 18.563-1.812 4.667-3.983 7.99-7.483 11.488-3.5 3.5-6.823 5.666-11.492 7.479-3.521 1.375-8.817 3-18.567 3.446-10.542.479-13.708.583-40.409.583-26.702 0-29.867-.104-40.408-.583-9.75-.45-15.042-2.079-18.57-3.448-4.666-1.813-8-3.979-11.5-7.479s-5.666-6.825-7.483-11.494c-1.369-3.521-3-8.813-3.444-18.563-.479-10.542-.575-13.708-.575-40.413 0-26.704.096-29.854.575-40.396.446-9.75 2.075-15.042 3.444-18.567 1.813-4.667 3.983-8 7.484-11.5 3.5-3.5 6.833-5.667 11.5-7.483 3.525-1.375 8.819-3 18.569-3.448 9.225-.417 12.8-.542 31.437-.563zm62.351 16.604c-6.625 0-12 5.37-12 11.996 0 6.625 5.375 12 12 12s12-5.375 12-12-5.375-12-12-12zm-53.38 14.021c-28.36 0-51.354 22.994-51.354 51.355 0 28.361 22.994 51.344 51.354 51.344 28.361 0 51.347-22.983 51.347-51.344 0-28.36-22.988-51.355-51.349-51.355zm0 18.021c18.409 0 33.334 14.923 33.334 33.334 0 18.409-14.925 33.334-33.334 33.334-18.41 0-33.333-14.925-33.333-33.334 0-18.411 14.923-33.334 33.333-33.334\" /><defs><radialGradient id=\"icon-instagram_a\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"matrix(0 -253.715 235.975 0 68 275.717)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#FD5\" /><stop offset=\".1\" stop-color=\"#FD5\" /><stop offset=\".5\" stop-color=\"#FF543E\" /><stop offset=\"1\" stop-color=\"#C837AB\" /></radialGradient><radialGradient id=\"icon-instagram_b\" cx=\"0\" cy=\"0\" r=\"1\" gradientTransform=\"matrix(22.25952 111.2061 -458.39518 91.75449 -42.881 18.441)\" gradientUnits=\"userSpaceOnUse\"><stop stop-color=\"#3771C8\" /><stop offset=\".128\" stop-color=\"#3771C8\" /><stop offset=\"1\" stop-color=\"#60F\" stop-opacity=\"0\" /></radialGradient></defs></g></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-iov-next\"><path d=\"M141.261 113.136a25.568 25.568 0 0 1 14.472 4.5l542.94 373.04a25.568 25.568 0 0 1 0 42.162L155.784 906.312a25.568 25.568 0 0 1-40.09-21.068v-746.54a25.568 25.568 0 0 1 25.567-25.568zM882.74 166.83a25.568 25.568 0 0 1 25.568 25.568v639.204a25.568 25.568 0 0 1-25.568 25.568h-51.137a25.568 25.568 0 0 1-25.568-25.568V192.398a25.568 25.568 0 0 1 25.568-25.568h51.137z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-menu\"><path d=\"M212 338c-24.852 0-45-20.148-45-45s20.148-45 45-45h600c24.852 0 45 20.148 45 45s-20.148 45-45 45H212zm0 220c-24.852 0-45-20.148-45-45s20.148-45 45-45h600c24.852 0 45 20.148 45 45s-20.148 45-45 45H212zm0 220c-24.852 0-45-20.148-45-45s20.148-45 45-45h600c24.852 0 45 20.148 45 45s-20.148 45-45 45H212z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-open\"><path d=\"M896 768c25.6 0 42.667 17.067 42.667 42.667S921.6 853.333 896 853.333H128c-25.6 0-42.667-17.066-42.667-42.666S102.4 768 128 768h768zm0-298.667c25.6 0 42.667 17.067 42.667 42.667S921.6 554.667 896 554.667H128c-25.6 0-42.667-17.067-42.667-42.667S102.4 469.333 128 469.333h768zm0-298.666c25.6 0 42.667 17.066 42.667 42.666S921.6 256 896 256H128c-25.6 0-42.667-17.067-42.667-42.667S102.4 170.667 128 170.667h768z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-pause\"><path d=\"M349.867 149.333h-14.934c-21.333 0-36.266 14.934-36.266 34.134V838.4c0 19.2 14.933 34.133 34.133 34.133h14.933c19.2 0 34.134-14.933 34.134-34.133V183.467c2.133-19.2-12.8-34.134-32-34.134zm341.333 0h-14.933c-21.334 0-36.267 14.934-36.267 34.134V838.4c0 19.2 14.933 34.133 34.133 34.133h14.934c19.2 0 34.133-14.933 34.133-34.133V183.467c2.133-19.2-12.8-34.134-32-34.134z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-play\"><path d=\"m780.8 475.733-494.933-307.2c-27.734-17.066-64 4.267-64 36.267v614.4c0 32 36.266 53.333 64 36.267l492.8-307.2c29.866-14.934 29.866-57.6 2.133-72.534z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-setting\"><path d=\"m924.8 625.7-65.5-56c3.1-19 4.7-38.4 4.7-57.8s-1.6-38.8-4.7-57.8l65.5-56c10.1-8.6 13.8-22.6 9.3-35.2l-.9-2.6c-18.1-50.5-44.9-96.9-79.7-137.9l-1.8-2.1c-8.6-10.1-22.5-13.9-35.1-9.5l-81.3 28.9c-30-24.6-63.5-44-99.7-57.6l-15.7-85c-2.4-13.1-12.7-23.3-25.8-25.7l-2.7-.5c-52.1-9.4-106.9-9.4-159 0l-2.7.5c-13.1 2.4-23.4 12.6-25.8 25.7l-15.8 85.4c-35.9 13.6-69.2 32.9-99 57.4l-81.9-29.1c-12.5-4.4-26.5-.7-35.1 9.5l-1.8 2.1c-34.8 41.1-61.6 87.5-79.7 137.9l-.9 2.6c-4.5 12.5-.8 26.5 9.3 35.2l66.3 56.6c-3.1 18.8-4.6 38-4.6 57.1 0 19.2 1.5 38.4 4.6 57.1L99 625.5c-10.1 8.6-13.8 22.6-9.3 35.2l.9 2.6c18.1 50.4 44.9 96.9 79.7 137.9l1.8 2.1c8.6 10.1 22.5 13.9 35.1 9.5l81.9-29.1c29.8 24.5 63.1 43.9 99 57.4l15.8 85.4c2.4 13.1 12.7 23.3 25.8 25.7l2.7.5c26.1 4.7 52.8 7.1 79.5 7.1 26.7 0 53.5-2.4 79.5-7.1l2.7-.5c13.1-2.4 23.4-12.6 25.8-25.7l15.7-85c36.2-13.6 69.7-32.9 99.7-57.6l81.3 28.9c12.5 4.4 26.5.7 35.1-9.5l1.8-2.1c34.8-41.1 61.6-87.5 79.7-137.9l.9-2.6c4.5-12.3.8-26.3-9.3-35zM788.3 465.9c2.5 15.1 3.8 30.6 3.8 46.1s-1.3 31-3.8 46.1l-6.6 40.1 74.7 63.9c-11.3 26.1-25.6 50.7-42.6 73.6L721 702.8l-31.4 25.8c-23.9 19.6-50.5 35-79.3 45.8l-38.1 14.3-17.9 97c-28.1 3.2-56.8 3.2-85 0l-17.9-97.2-37.8-14.5c-28.5-10.8-55-26.2-78.7-45.7l-31.4-25.9-93.4 33.2c-17-22.9-31.2-47.6-42.6-73.6l75.5-64.5-6.5-40c-2.4-14.9-3.7-30.3-3.7-45.5 0-15.3 1.2-30.6 3.7-45.5l6.5-40-75.5-64.5c11.3-26.1 25.6-50.7 42.6-73.6l93.4 33.2 31.4-25.9c23.7-19.5 50.2-34.9 78.7-45.7l37.9-14.3 17.9-97.2c28.1-3.2 56.8-3.2 85 0l17.9 97 38.1 14.3c28.7 10.8 55.4 26.2 79.3 45.8l31.4 25.8 92.8-32.9c17 22.9 31.2 47.6 42.6 73.6L781.8 426l6.5 39.9z\" /><path d=\"M512 326c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm79.2 255.2C570 602.3 541.9 614 512 614c-29.9 0-58-11.7-79.2-32.8C411.7 560 400 531.9 400 502c0-29.9 11.7-58 32.8-79.2C454 401.6 482.1 390 512 390c29.9 0 58 11.6 79.2 32.8C612.3 444 624 472.1 624 502c0 29.9-11.7 58-32.8 79.2z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-sort-down\"><path d=\"m64 320 448 448 448-448z\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-sort-up\"><path d=\"M960 704 512 256 64 704z\" /></symbol><symbol  viewBox=\"0 0 1024 1024\" id=\"icon-totop\"><path fill=\"currentColor\" d=\"M572.235 205.282v600.365a30.118 30.118 0 1 1-60.235 0V205.282L292.382 438.633a28.913 28.913 0 0 1-42.646 0 33.43 33.43 0 0 1 0-45.236l271.058-288.045a28.913 28.913 0 0 1 42.647 0L834.5 393.397a33.43 33.43 0 0 1 0 45.176 28.913 28.913 0 0 1-42.647 0l-219.618-233.23z\" /></symbol><symbol  viewBox=\"0 0 256 209\" id=\"icon-twitter\"><path fill=\"#55acee\" d=\"M256 25.45a105.04 105.04 0 0 1-30.166 8.27c10.845-6.5 19.172-16.793 23.093-29.057a105.183 105.183 0 0 1-33.351 12.745C205.995 7.201 192.346.822 177.239.822c-29.006 0-52.523 23.516-52.523 52.52 0 4.117.465 8.125 1.36 11.97-43.65-2.191-82.35-23.1-108.255-54.876-4.52 7.757-7.11 16.78-7.11 26.404 0 18.222 9.273 34.297 23.365 43.716a52.312 52.312 0 0 1-23.79-6.57c-.003.22-.003.44-.003.661 0 25.447 18.104 46.675 42.13 51.5a52.592 52.592 0 0 1-23.718.9c6.683 20.866 26.08 36.05 49.062 36.475-17.975 14.086-40.622 22.483-65.228 22.483-4.24 0-8.42-.249-12.529-.734 23.243 14.902 50.85 23.597 80.51 23.597 96.607 0 149.434-80.031 149.434-149.435 0-2.278-.05-4.543-.152-6.795A106.748 106.748 0 0 0 256 25.45\" /></symbol><symbol class=\"icon\" viewBox=\"0 0 1024 1024\"  id=\"icon-up\"><path d=\"M512 128c212 0 384 172 384 384S724 896 512 896 128 724 128 512s172-384 384-384m0-64C264.8 64 64 264.8 64 512s200.8 448 448 448 448-200.8 448-448S759.2 64 512 64zm272 530.4L557.6 368 512 322.4 466.4 368 240 594.4l45.6 45.6L512 413.6 738.4 640l45.6-45.6z\" /></symbol><symbol viewBox=\"0 0 1440 690\"  class=\"transition duration-300 ease-in-out delay-150\" id=\"icon-wave\"><style>@keyframes pathAnim-0{0%,to{d:path(\"M 0,700 L 0,131 C 90.40769230769229,160.85641025641027 180.81538461538457,190.71282051282054 261,188 C 341.1846153846154,185.28717948717946 411.1461538461539,150.0051282051282 486,144 C 560.8538461538461,137.9948717948718 640.5999999999999,161.26666666666668 709,157 C 777.4000000000001,152.73333333333332 834.4538461538461,120.92820512820514 927,101 C 1019.5461538461539,81.07179487179486 1147.5846153846153,73.02051282051282 1239,80 C 1330.4153846153847,86.97948717948718 1385.2076923076925,108.9897435897436 1440,131 L 1440,700 L 0,700 Z\")}25%{d:path(\"M 0,700 L 0,131 C 72.08205128205125,98.84102564102564 144.1641025641025,66.68205128205128 230,70 C 315.8358974358975,73.31794871794872 415.4256410256411,112.11282051282052 509,130 C 602.5743589743589,147.88717948717948 690.1333333333332,144.86666666666665 752,144 C 813.8666666666668,143.13333333333335 850.0410256410258,144.4205128205128 923,134 C 995.9589743589742,123.57948717948719 1105.702564102564,101.45128205128205 1198,99 C 1290.297435897436,96.54871794871795 1365.148717948718,113.77435897435898 1440,131 L 1440,700 L 0,700 Z\")}50%{d:path(\"M 0,700 L 0,131 C 82.97692307692304,91.78461538461539 165.9538461538461,52.56923076923077 236,74 C 306.0461538461539,95.43076923076923 363.16153846153856,177.5076923076923 436,196 C 508.83846153846144,214.4923076923077 597.3999999999999,169.4 683,146 C 768.6000000000001,122.6 851.2384615384616,120.8923076923077 928,113 C 1004.7615384615384,105.1076923076923 1075.6461538461538,91.03076923076922 1160,93 C 1244.3538461538462,94.96923076923078 1342.1769230769232,112.98461538461538 1440,131 L 1440,700 L 0,700 Z\")}75%{d:path(\"M 0,700 L 0,131 C 87.95128205128205,141.17435897435897 175.9025641025641,151.34871794871793 241,163 C 306.0974358974359,174.65128205128207 348.34102564102557,187.77948717948718 435,190 C 521.6589743589744,192.22051282051282 652.7333333333335,183.53333333333333 737,160 C 821.2666666666665,136.46666666666667 858.725641025641,98.08717948717948 921,104 C 983.274358974359,109.91282051282052 1070.3641025641025,160.11794871794874 1161,172 C 1251.6358974358975,183.88205128205126 1345.8179487179486,157.44102564102565 1440,131 L 1440,700 L 0,700 Z\")}}@keyframes pathAnim-1{0%,to{d:path(\"M 0,700 L 0,306 C 73.36923076923077,283.31794871794875 146.73846153846154,260.63589743589745 217,254 C 287.26153846153846,247.36410256410255 354.4153846153846,256.77435897435896 436,279 C 517.5846153846154,301.22564102564104 613.6,336.26666666666665 708,351 C 802.4,365.73333333333335 895.1846153846154,360.15897435897443 971,349 C 1046.8153846153846,337.84102564102557 1105.6615384615386,321.09743589743584 1181,313 C 1256.3384615384614,304.90256410256416 1348.1692307692306,305.4512820512821 1440,306 L 1440,700 L 0,700 Z\")}25%{d:path(\"M 0,700 L 0,306 C 72.90000000000003,299.77435897435896 145.80000000000007,293.548717948718 232,306 C 318.19999999999993,318.451282051282 417.69999999999993,349.5794871794872 489,343 C 560.3000000000001,336.4205128205128 603.4000000000001,292.1333333333333 683,289 C 762.5999999999999,285.8666666666667 878.7,323.88717948717954 971,325 C 1063.3,326.11282051282046 1131.8,290.3179487179487 1206,281 C 1280.2,271.6820512820513 1360.1,288.8410256410257 1440,306 L 1440,700 L 0,700 Z\")}50%{d:path(\"M 0,700 L 0,306 C 102.84615384615384,278.4230769230769 205.69230769230768,250.84615384615387 274,272 C 342.3076923076923,293.15384615384613 376.0769230769231,363.03846153846155 458,364 C 539.9230769230769,364.96153846153845 670.0000000000001,297 744,299 C 817.9999999999999,301 835.9230769230769,372.96153846153845 918,370 C 1000.0769230769231,367.03846153846155 1146.3076923076924,289.15384615384613 1244,266 C 1341.6923076923076,242.84615384615387 1390.8461538461538,274.4230769230769 1440,306 L 1440,700 L 0,700 Z\")}75%{d:path(\"M 0,700 L 0,306 C 101.82564102564103,310.93589743589746 203.65128205128207,315.87179487179486 277,326 C 350.34871794871793,336.12820512820514 395.2205128205129,351.448717948718 469,357 C 542.7794871794871,362.551282051282 645.4666666666666,358.3333333333333 735,341 C 824.5333333333334,323.6666666666667 900.9128205128204,293.21794871794873 972,284 C 1043.0871794871796,274.78205128205127 1108.8820512820512,286.79487179487177 1186,294 C 1263.1179487179488,301.20512820512823 1351.5589743589744,303.6025641025641 1440,306 L 1440,700 L 0,700 Z\")}}@keyframes pathAnim-2{0%,to{d:path(\"M 0,700 L 0,481 C 83.87692307692308,501.28205128205127 167.75384615384615,521.5641025641025 243,530 C 318.24615384615385,538.4358974358975 384.86153846153843,535.025641025641 459,514 C 533.1384615384616,492.974358974359 614.8,454.33333333333337 695,455 C 775.2,455.66666666666663 853.9384615384615,495.6410256410257 931,494 C 1008.0615384615385,492.3589743589743 1083.446153846154,449.1025641025641 1168,440 C 1252.553846153846,430.8974358974359 1346.2769230769231,455.94871794871796 1440,481 L 1440,700 L 0,700 Z\")}25%{d:path(\"M 0,700 L 0,481 C 100.42051282051281,464.76666666666665 200.84102564102562,448.53333333333336 276,458 C 351.1589743589744,467.46666666666664 401.05641025641023,502.6333333333333 459,510 C 516.9435897435898,517.3666666666667 582.9333333333334,496.93333333333334 679,472 C 775.0666666666666,447.06666666666666 901.2102564102565,417.6333333333333 991,420 C 1080.7897435897435,422.3666666666667 1134.225641025641,456.53333333333336 1203,472 C 1271.774358974359,487.46666666666664 1355.8871794871795,484.23333333333335 1440,481 L 1440,700 L 0,700 Z\")}50%{d:path(\"M 0,700 L 0,481 C 80.45897435897433,478.6948717948718 160.91794871794866,476.38974358974355 227,489 C 293.08205128205134,501.61025641025645 344.7871794871796,529.1358974358975 439,515 C 533.2128205128204,500.8641025641025 669.9333333333332,445.06666666666666 762,426 C 854.0666666666668,406.93333333333334 901.4794871794875,424.59743589743584 976,431 C 1050.5205128205125,437.40256410256416 1152.1487179487178,432.5435897435898 1234,439 C 1315.8512820512822,445.4564102564102 1377.9256410256412,463.2282051282051 1440,481 L 1440,700 L 0,700 Z\")}75%{d:path(\"M 0,700 L 0,481 C 91.47179487179488,453.0820512820512 182.94358974358977,425.1641025641025 260,429 C 337.05641025641023,432.8358974358975 399.69743589743587,468.4256410256411 485,497 C 570.3025641025641,525.5743589743589 678.2666666666668,547.1333333333333 750,532 C 821.7333333333332,516.8666666666667 857.2358974358974,465.04102564102567 933,442 C 1008.7641025641026,418.95897435897433 1124.7897435897435,424.7025641025641 1216,436 C 1307.2102564102565,447.2974358974359 1373.6051282051283,464.14871794871794 1440,481 L 1440,700 L 0,700 Z\")}}</style><defs><linearGradient id=\"icon-wave_gradient\" x1=\"0%\" y1=\"50%\" x2=\"100%\" y2=\"50%\"><stop offset=\"5%\" stop-color=\"#7bdcb5\" /><stop offset=\"95%\" stop-color=\"#8ED1FC\" /></linearGradient></defs><path d=\"M0 700V131c90.408 29.856 180.815 59.713 261 57 80.185-2.713 150.146-37.995 225-44 74.854-6.005 154.6 17.267 223 13 68.4-4.267 125.454-36.072 218-56 92.546-19.928 220.585-27.98 312-21 91.415 6.98 146.208 28.99 201 51v569H0Z\" stroke-width=\"0\" fill=\"url(#icon-wave_gradient)\" fill-opacity=\".4\" class=\"transition-all duration-300 ease-in-out delay-150\" transform=\"rotate(-180 720 350)\" style=\"animation:pathAnim-0 4s;animation-timing-function:linear;animation-iteration-count:infinite\" /><path d=\"M0 700V306c73.37-22.682 146.738-45.364 217-52 70.262-6.636 137.415 2.774 219 25 81.585 22.226 177.6 57.267 272 72 94.4 14.733 187.185 9.159 263-2s134.662-27.903 210-36c75.338-8.097 167.17-7.549 259-7v394H0Z\" stroke-width=\"0\" fill=\"url(#icon-wave_gradient)\" fill-opacity=\".53\" class=\"transition-all duration-300 ease-in-out delay-150\" transform=\"rotate(-180 720 350)\" style=\"animation:pathAnim-1 4s;animation-timing-function:linear;animation-iteration-count:infinite\" /><path d=\"M0 700V481c83.877 20.282 167.754 40.564 243 49 75.246 8.436 141.862 5.026 216-16s155.8-59.667 236-59c80.2.667 158.938 40.641 236 39 77.062-1.641 152.446-44.897 237-54 84.554-9.103 178.277 15.949 272 41v219H0Z\" stroke-width=\"0\" fill=\"url(#icon-wave_gradient)\" class=\"transition-all duration-300 ease-in-out delay-150\" transform=\"rotate(-180 720 350)\" style=\"animation:pathAnim-2 4s;animation-timing-function:linear;animation-iteration-count:infinite\" /></symbol>";
            body.insertBefore(svgDom, body.lastChild);
          }
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadSvg);
          } else {
            loadSvg();
          }
        }
        var app = createApp(_sfc_main);
        var pinia = createPinia();
        pinia.use(index);
        app.config.globalProperties.$THREE = THREE;
        app.component("svg-icon", __unplugin_components_0);
        app.use(router).use(k).use(pinia).use(i18n).mount("#app");
      }
    };
  });
})();
